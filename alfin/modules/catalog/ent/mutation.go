// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/samlet/petrel/alfin/modules/catalog/ent/contentassoctype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/contenttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/costcomponenttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/custommethod"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/custommethodtype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/enumeration"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/enumerationtype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/facilityassoctype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/facilitygroup"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/facilitygrouptype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/facilitytype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/goodidentificationtype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/inventoryitemdetail"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/inventoryitemtype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderadjustment"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/ordercontactmech"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderheader"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderitem"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderitemshipgroup"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderitemshipgroupassoc"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderitemshipgrpinvres"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderpaymentpreference"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderrole"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/orderstatus"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/predicate"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/prodcatalogcategorytype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/prodconfitemcontenttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/product"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productassoc"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productassoctype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productcategory"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productcategorycontenttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productcategorytype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productconfigitem"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productcontenttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productfeature"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productfeatureappltype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productfeaturecategory"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productfeatureiactntype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productfeaturetype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productmainttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productmetertype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productprice"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productpriceactiontype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productpricepurpose"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productpricetype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productreview"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productstore"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productstoregroup"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/producttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/quantitybreaktype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/rejectionreason"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/roletype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentcontactmechtype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentgatewayconfig"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentgatewayconfigtype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentgatewaydhl"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentgatewayfedex"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentgatewayups"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmentgatewayusps"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/shipmenttype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/statusitem"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/statustype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/statusvalidchange"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/subscriptiontype"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/supplierpreforder"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/variancereason"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeContentAssocType           = "ContentAssocType"
	TypeContentType                = "ContentType"
	TypeCostComponentType          = "CostComponentType"
	TypeCustomMethod               = "CustomMethod"
	TypeCustomMethodType           = "CustomMethodType"
	TypeEnumeration                = "Enumeration"
	TypeEnumerationType            = "EnumerationType"
	TypeFacilityAssocType          = "FacilityAssocType"
	TypeFacilityGroup              = "FacilityGroup"
	TypeFacilityGroupType          = "FacilityGroupType"
	TypeFacilityType               = "FacilityType"
	TypeGoodIdentificationType     = "GoodIdentificationType"
	TypeInventoryItemDetail        = "InventoryItemDetail"
	TypeInventoryItemType          = "InventoryItemType"
	TypeOrderAdjustment            = "OrderAdjustment"
	TypeOrderContactMech           = "OrderContactMech"
	TypeOrderHeader                = "OrderHeader"
	TypeOrderItem                  = "OrderItem"
	TypeOrderItemShipGroup         = "OrderItemShipGroup"
	TypeOrderItemShipGroupAssoc    = "OrderItemShipGroupAssoc"
	TypeOrderItemShipGrpInvRes     = "OrderItemShipGrpInvRes"
	TypeOrderPaymentPreference     = "OrderPaymentPreference"
	TypeOrderRole                  = "OrderRole"
	TypeOrderStatus                = "OrderStatus"
	TypeProdCatalogCategoryType    = "ProdCatalogCategoryType"
	TypeProdConfItemContentType    = "ProdConfItemContentType"
	TypeProduct                    = "Product"
	TypeProductAssoc               = "ProductAssoc"
	TypeProductAssocType           = "ProductAssocType"
	TypeProductCategory            = "ProductCategory"
	TypeProductCategoryContentType = "ProductCategoryContentType"
	TypeProductCategoryType        = "ProductCategoryType"
	TypeProductConfigItem          = "ProductConfigItem"
	TypeProductContentType         = "ProductContentType"
	TypeProductFeature             = "ProductFeature"
	TypeProductFeatureApplType     = "ProductFeatureApplType"
	TypeProductFeatureCategory     = "ProductFeatureCategory"
	TypeProductFeatureIactnType    = "ProductFeatureIactnType"
	TypeProductFeatureType         = "ProductFeatureType"
	TypeProductMaintType           = "ProductMaintType"
	TypeProductMeterType           = "ProductMeterType"
	TypeProductPrice               = "ProductPrice"
	TypeProductPriceActionType     = "ProductPriceActionType"
	TypeProductPricePurpose        = "ProductPricePurpose"
	TypeProductPriceType           = "ProductPriceType"
	TypeProductReview              = "ProductReview"
	TypeProductStore               = "ProductStore"
	TypeProductStoreGroup          = "ProductStoreGroup"
	TypeProductType                = "ProductType"
	TypeQuantityBreakType          = "QuantityBreakType"
	TypeRejectionReason            = "RejectionReason"
	TypeRoleType                   = "RoleType"
	TypeShipmentContactMechType    = "ShipmentContactMechType"
	TypeShipmentGatewayConfig      = "ShipmentGatewayConfig"
	TypeShipmentGatewayConfigType  = "ShipmentGatewayConfigType"
	TypeShipmentGatewayDhl         = "ShipmentGatewayDhl"
	TypeShipmentGatewayFedex       = "ShipmentGatewayFedex"
	TypeShipmentGatewayUps         = "ShipmentGatewayUps"
	TypeShipmentGatewayUsps        = "ShipmentGatewayUsps"
	TypeShipmentType               = "ShipmentType"
	TypeStatusItem                 = "StatusItem"
	TypeStatusType                 = "StatusType"
	TypeStatusValidChange          = "StatusValidChange"
	TypeSubscriptionType           = "SubscriptionType"
	TypeSupplierPrefOrder          = "SupplierPrefOrder"
	TypeVarianceReason             = "VarianceReason"
)

// ContentAssocTypeMutation represents an operation that mutates the ContentAssocType nodes in the graph.
type ContentAssocTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ContentAssocType, error)
	predicates    []predicate.ContentAssocType
}

var _ ent.Mutation = (*ContentAssocTypeMutation)(nil)

// contentassoctypeOption allows management of the mutation configuration using functional options.
type contentassoctypeOption func(*ContentAssocTypeMutation)

// newContentAssocTypeMutation creates new mutation for the ContentAssocType entity.
func newContentAssocTypeMutation(c config, op Op, opts ...contentassoctypeOption) *ContentAssocTypeMutation {
	m := &ContentAssocTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeContentAssocType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentAssocTypeID sets the ID field of the mutation.
func withContentAssocTypeID(id int) contentassoctypeOption {
	return func(m *ContentAssocTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ContentAssocType
		)
		m.oldValue = func(ctx context.Context) (*ContentAssocType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContentAssocType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContentAssocType sets the old ContentAssocType of the mutation.
func withContentAssocType(node *ContentAssocType) contentassoctypeOption {
	return func(m *ContentAssocTypeMutation) {
		m.oldValue = func(context.Context) (*ContentAssocType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentAssocTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentAssocTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentAssocTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ContentAssocTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ContentAssocTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ContentAssocType entity.
// If the ContentAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentAssocTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ContentAssocTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ContentAssocTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ContentAssocTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ContentAssocType entity.
// If the ContentAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentAssocTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ContentAssocTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ContentAssocTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ContentAssocTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ContentAssocType entity.
// If the ContentAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentAssocTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ContentAssocTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[contentassoctype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ContentAssocTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[contentassoctype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ContentAssocTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, contentassoctype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ContentAssocTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContentAssocTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ContentAssocType entity.
// If the ContentAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentAssocTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ContentAssocTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[contentassoctype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ContentAssocTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[contentassoctype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ContentAssocTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, contentassoctype.FieldDescription)
}

// Op returns the operation name.
func (m *ContentAssocTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ContentAssocType).
func (m *ContentAssocTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentAssocTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, contentassoctype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, contentassoctype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, contentassoctype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, contentassoctype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentAssocTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contentassoctype.FieldCreateTime:
		return m.CreateTime()
	case contentassoctype.FieldUpdateTime:
		return m.UpdateTime()
	case contentassoctype.FieldStringRef:
		return m.StringRef()
	case contentassoctype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentAssocTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contentassoctype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case contentassoctype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case contentassoctype.FieldStringRef:
		return m.OldStringRef(ctx)
	case contentassoctype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ContentAssocType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentAssocTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contentassoctype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case contentassoctype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case contentassoctype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case contentassoctype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ContentAssocType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentAssocTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentAssocTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentAssocTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContentAssocType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentAssocTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contentassoctype.FieldStringRef) {
		fields = append(fields, contentassoctype.FieldStringRef)
	}
	if m.FieldCleared(contentassoctype.FieldDescription) {
		fields = append(fields, contentassoctype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentAssocTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentAssocTypeMutation) ClearField(name string) error {
	switch name {
	case contentassoctype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case contentassoctype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ContentAssocType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentAssocTypeMutation) ResetField(name string) error {
	switch name {
	case contentassoctype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case contentassoctype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case contentassoctype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case contentassoctype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ContentAssocType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentAssocTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentAssocTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentAssocTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentAssocTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentAssocTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentAssocTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentAssocTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ContentAssocType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentAssocTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ContentAssocType edge %s", name)
}

// ContentTypeMutation represents an operation that mutates the ContentType nodes in the graph.
type ContentTypeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	string_ref                 *string
	has_table                  *contenttype.HasTable
	description                *string
	clearedFields              map[string]struct{}
	parent                     *int
	clearedparent              bool
	children                   map[int]struct{}
	removedchildren            map[int]struct{}
	clearedchildren            bool
	child_content_types        map[int]struct{}
	removedchild_content_types map[int]struct{}
	clearedchild_content_types bool
	done                       bool
	oldValue                   func(context.Context) (*ContentType, error)
	predicates                 []predicate.ContentType
}

var _ ent.Mutation = (*ContentTypeMutation)(nil)

// contenttypeOption allows management of the mutation configuration using functional options.
type contenttypeOption func(*ContentTypeMutation)

// newContentTypeMutation creates new mutation for the ContentType entity.
func newContentTypeMutation(c config, op Op, opts ...contenttypeOption) *ContentTypeMutation {
	m := &ContentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeContentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContentTypeID sets the ID field of the mutation.
func withContentTypeID(id int) contenttypeOption {
	return func(m *ContentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ContentType
		)
		m.oldValue = func(ctx context.Context) (*ContentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContentType sets the old ContentType of the mutation.
func withContentType(node *ContentType) contenttypeOption {
	return func(m *ContentTypeMutation) {
		m.oldValue = func(context.Context) (*ContentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ContentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ContentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ContentType entity.
// If the ContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ContentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ContentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ContentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ContentType entity.
// If the ContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ContentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ContentTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ContentTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ContentType entity.
// If the ContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ContentTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[contenttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ContentTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[contenttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ContentTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, contenttype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ContentTypeMutation) SetHasTable(ct contenttype.HasTable) {
	m.has_table = &ct
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ContentTypeMutation) HasTable() (r contenttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ContentType entity.
// If the ContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentTypeMutation) OldHasTable(ctx context.Context) (v contenttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ContentTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[contenttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ContentTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[contenttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ContentTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, contenttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ContentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ContentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ContentType entity.
// If the ContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ContentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[contenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ContentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[contenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ContentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, contenttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ContentType entity by id.
func (m *ContentTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ContentType entity.
func (m *ContentTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ContentType entity was cleared.
func (m *ContentTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ContentTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ContentTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ContentTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ContentType entity by ids.
func (m *ContentTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ContentType entity.
func (m *ContentTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ContentType entity was cleared.
func (m *ContentTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ContentType entity by IDs.
func (m *ContentTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ContentType entity.
func (m *ContentTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ContentTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ContentTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildContentTypeIDs adds the "child_content_types" edge to the ContentType entity by ids.
func (m *ContentTypeMutation) AddChildContentTypeIDs(ids ...int) {
	if m.child_content_types == nil {
		m.child_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_content_types[ids[i]] = struct{}{}
	}
}

// ClearChildContentTypes clears the "child_content_types" edge to the ContentType entity.
func (m *ContentTypeMutation) ClearChildContentTypes() {
	m.clearedchild_content_types = true
}

// ChildContentTypesCleared reports if the "child_content_types" edge to the ContentType entity was cleared.
func (m *ContentTypeMutation) ChildContentTypesCleared() bool {
	return m.clearedchild_content_types
}

// RemoveChildContentTypeIDs removes the "child_content_types" edge to the ContentType entity by IDs.
func (m *ContentTypeMutation) RemoveChildContentTypeIDs(ids ...int) {
	if m.removedchild_content_types == nil {
		m.removedchild_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_content_types[ids[i]] = struct{}{}
	}
}

// RemovedChildContentTypes returns the removed IDs of the "child_content_types" edge to the ContentType entity.
func (m *ContentTypeMutation) RemovedChildContentTypesIDs() (ids []int) {
	for id := range m.removedchild_content_types {
		ids = append(ids, id)
	}
	return
}

// ChildContentTypesIDs returns the "child_content_types" edge IDs in the mutation.
func (m *ContentTypeMutation) ChildContentTypesIDs() (ids []int) {
	for id := range m.child_content_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildContentTypes resets all changes to the "child_content_types" edge.
func (m *ContentTypeMutation) ResetChildContentTypes() {
	m.child_content_types = nil
	m.clearedchild_content_types = false
	m.removedchild_content_types = nil
}

// Op returns the operation name.
func (m *ContentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ContentType).
func (m *ContentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, contenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, contenttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, contenttype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, contenttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, contenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contenttype.FieldCreateTime:
		return m.CreateTime()
	case contenttype.FieldUpdateTime:
		return m.UpdateTime()
	case contenttype.FieldStringRef:
		return m.StringRef()
	case contenttype.FieldHasTable:
		return m.HasTable()
	case contenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case contenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case contenttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case contenttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case contenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ContentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case contenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case contenttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case contenttype.FieldHasTable:
		v, ok := value.(contenttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case contenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ContentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contenttype.FieldStringRef) {
		fields = append(fields, contenttype.FieldStringRef)
	}
	if m.FieldCleared(contenttype.FieldHasTable) {
		fields = append(fields, contenttype.FieldHasTable)
	}
	if m.FieldCleared(contenttype.FieldDescription) {
		fields = append(fields, contenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContentTypeMutation) ClearField(name string) error {
	switch name {
	case contenttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case contenttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case contenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ContentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContentTypeMutation) ResetField(name string) error {
	switch name {
	case contenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case contenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case contenttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case contenttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case contenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ContentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, contenttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, contenttype.EdgeChildren)
	}
	if m.child_content_types != nil {
		edges = append(edges, contenttype.EdgeChildContentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contenttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case contenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case contenttype.EdgeChildContentTypes:
		ids := make([]ent.Value, 0, len(m.child_content_types))
		for id := range m.child_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, contenttype.EdgeChildren)
	}
	if m.removedchild_content_types != nil {
		edges = append(edges, contenttype.EdgeChildContentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case contenttype.EdgeChildContentTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_content_types))
		for id := range m.removedchild_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, contenttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, contenttype.EdgeChildren)
	}
	if m.clearedchild_content_types {
		edges = append(edges, contenttype.EdgeChildContentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case contenttype.EdgeParent:
		return m.clearedparent
	case contenttype.EdgeChildren:
		return m.clearedchildren
	case contenttype.EdgeChildContentTypes:
		return m.clearedchild_content_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContentTypeMutation) ClearEdge(name string) error {
	switch name {
	case contenttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ContentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContentTypeMutation) ResetEdge(name string) error {
	switch name {
	case contenttype.EdgeParent:
		m.ResetParent()
		return nil
	case contenttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case contenttype.EdgeChildContentTypes:
		m.ResetChildContentTypes()
		return nil
	}
	return fmt.Errorf("unknown ContentType edge %s", name)
}

// CostComponentTypeMutation represents an operation that mutates the CostComponentType nodes in the graph.
type CostComponentTypeMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	create_time                       *time.Time
	update_time                       *time.Time
	string_ref                        *string
	has_table                         *costcomponenttype.HasTable
	description                       *string
	clearedFields                     map[string]struct{}
	parent                            *int
	clearedparent                     bool
	children                          map[int]struct{}
	removedchildren                   map[int]struct{}
	clearedchildren                   bool
	child_cost_component_types        map[int]struct{}
	removedchild_cost_component_types map[int]struct{}
	clearedchild_cost_component_types bool
	done                              bool
	oldValue                          func(context.Context) (*CostComponentType, error)
	predicates                        []predicate.CostComponentType
}

var _ ent.Mutation = (*CostComponentTypeMutation)(nil)

// costcomponenttypeOption allows management of the mutation configuration using functional options.
type costcomponenttypeOption func(*CostComponentTypeMutation)

// newCostComponentTypeMutation creates new mutation for the CostComponentType entity.
func newCostComponentTypeMutation(c config, op Op, opts ...costcomponenttypeOption) *CostComponentTypeMutation {
	m := &CostComponentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCostComponentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCostComponentTypeID sets the ID field of the mutation.
func withCostComponentTypeID(id int) costcomponenttypeOption {
	return func(m *CostComponentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CostComponentType
		)
		m.oldValue = func(ctx context.Context) (*CostComponentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CostComponentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCostComponentType sets the old CostComponentType of the mutation.
func withCostComponentType(node *CostComponentType) costcomponenttypeOption {
	return func(m *CostComponentTypeMutation) {
		m.oldValue = func(context.Context) (*CostComponentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CostComponentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CostComponentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CostComponentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CostComponentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CostComponentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CostComponentType entity.
// If the CostComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostComponentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CostComponentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CostComponentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CostComponentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CostComponentType entity.
// If the CostComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostComponentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CostComponentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *CostComponentTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *CostComponentTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the CostComponentType entity.
// If the CostComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostComponentTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *CostComponentTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[costcomponenttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *CostComponentTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[costcomponenttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *CostComponentTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, costcomponenttype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *CostComponentTypeMutation) SetHasTable(ct costcomponenttype.HasTable) {
	m.has_table = &ct
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *CostComponentTypeMutation) HasTable() (r costcomponenttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the CostComponentType entity.
// If the CostComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostComponentTypeMutation) OldHasTable(ctx context.Context) (v costcomponenttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *CostComponentTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[costcomponenttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *CostComponentTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[costcomponenttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *CostComponentTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, costcomponenttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *CostComponentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CostComponentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CostComponentType entity.
// If the CostComponentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CostComponentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CostComponentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[costcomponenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CostComponentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[costcomponenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CostComponentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, costcomponenttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the CostComponentType entity by id.
func (m *CostComponentTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the CostComponentType entity.
func (m *CostComponentTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the CostComponentType entity was cleared.
func (m *CostComponentTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CostComponentTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CostComponentTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CostComponentTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the CostComponentType entity by ids.
func (m *CostComponentTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the CostComponentType entity.
func (m *CostComponentTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the CostComponentType entity was cleared.
func (m *CostComponentTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the CostComponentType entity by IDs.
func (m *CostComponentTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the CostComponentType entity.
func (m *CostComponentTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CostComponentTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CostComponentTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildCostComponentTypeIDs adds the "child_cost_component_types" edge to the CostComponentType entity by ids.
func (m *CostComponentTypeMutation) AddChildCostComponentTypeIDs(ids ...int) {
	if m.child_cost_component_types == nil {
		m.child_cost_component_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_cost_component_types[ids[i]] = struct{}{}
	}
}

// ClearChildCostComponentTypes clears the "child_cost_component_types" edge to the CostComponentType entity.
func (m *CostComponentTypeMutation) ClearChildCostComponentTypes() {
	m.clearedchild_cost_component_types = true
}

// ChildCostComponentTypesCleared reports if the "child_cost_component_types" edge to the CostComponentType entity was cleared.
func (m *CostComponentTypeMutation) ChildCostComponentTypesCleared() bool {
	return m.clearedchild_cost_component_types
}

// RemoveChildCostComponentTypeIDs removes the "child_cost_component_types" edge to the CostComponentType entity by IDs.
func (m *CostComponentTypeMutation) RemoveChildCostComponentTypeIDs(ids ...int) {
	if m.removedchild_cost_component_types == nil {
		m.removedchild_cost_component_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_cost_component_types[ids[i]] = struct{}{}
	}
}

// RemovedChildCostComponentTypes returns the removed IDs of the "child_cost_component_types" edge to the CostComponentType entity.
func (m *CostComponentTypeMutation) RemovedChildCostComponentTypesIDs() (ids []int) {
	for id := range m.removedchild_cost_component_types {
		ids = append(ids, id)
	}
	return
}

// ChildCostComponentTypesIDs returns the "child_cost_component_types" edge IDs in the mutation.
func (m *CostComponentTypeMutation) ChildCostComponentTypesIDs() (ids []int) {
	for id := range m.child_cost_component_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildCostComponentTypes resets all changes to the "child_cost_component_types" edge.
func (m *CostComponentTypeMutation) ResetChildCostComponentTypes() {
	m.child_cost_component_types = nil
	m.clearedchild_cost_component_types = false
	m.removedchild_cost_component_types = nil
}

// Op returns the operation name.
func (m *CostComponentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CostComponentType).
func (m *CostComponentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CostComponentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, costcomponenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, costcomponenttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, costcomponenttype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, costcomponenttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, costcomponenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CostComponentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case costcomponenttype.FieldCreateTime:
		return m.CreateTime()
	case costcomponenttype.FieldUpdateTime:
		return m.UpdateTime()
	case costcomponenttype.FieldStringRef:
		return m.StringRef()
	case costcomponenttype.FieldHasTable:
		return m.HasTable()
	case costcomponenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CostComponentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case costcomponenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case costcomponenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case costcomponenttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case costcomponenttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case costcomponenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CostComponentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostComponentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case costcomponenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case costcomponenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case costcomponenttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case costcomponenttype.FieldHasTable:
		v, ok := value.(costcomponenttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case costcomponenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CostComponentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CostComponentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CostComponentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CostComponentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CostComponentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CostComponentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(costcomponenttype.FieldStringRef) {
		fields = append(fields, costcomponenttype.FieldStringRef)
	}
	if m.FieldCleared(costcomponenttype.FieldHasTable) {
		fields = append(fields, costcomponenttype.FieldHasTable)
	}
	if m.FieldCleared(costcomponenttype.FieldDescription) {
		fields = append(fields, costcomponenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CostComponentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CostComponentTypeMutation) ClearField(name string) error {
	switch name {
	case costcomponenttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case costcomponenttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case costcomponenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CostComponentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CostComponentTypeMutation) ResetField(name string) error {
	switch name {
	case costcomponenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case costcomponenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case costcomponenttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case costcomponenttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case costcomponenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CostComponentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CostComponentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, costcomponenttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, costcomponenttype.EdgeChildren)
	}
	if m.child_cost_component_types != nil {
		edges = append(edges, costcomponenttype.EdgeChildCostComponentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CostComponentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case costcomponenttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case costcomponenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case costcomponenttype.EdgeChildCostComponentTypes:
		ids := make([]ent.Value, 0, len(m.child_cost_component_types))
		for id := range m.child_cost_component_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CostComponentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, costcomponenttype.EdgeChildren)
	}
	if m.removedchild_cost_component_types != nil {
		edges = append(edges, costcomponenttype.EdgeChildCostComponentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CostComponentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case costcomponenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case costcomponenttype.EdgeChildCostComponentTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_cost_component_types))
		for id := range m.removedchild_cost_component_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CostComponentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, costcomponenttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, costcomponenttype.EdgeChildren)
	}
	if m.clearedchild_cost_component_types {
		edges = append(edges, costcomponenttype.EdgeChildCostComponentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CostComponentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case costcomponenttype.EdgeParent:
		return m.clearedparent
	case costcomponenttype.EdgeChildren:
		return m.clearedchildren
	case costcomponenttype.EdgeChildCostComponentTypes:
		return m.clearedchild_cost_component_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CostComponentTypeMutation) ClearEdge(name string) error {
	switch name {
	case costcomponenttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown CostComponentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CostComponentTypeMutation) ResetEdge(name string) error {
	switch name {
	case costcomponenttype.EdgeParent:
		m.ResetParent()
		return nil
	case costcomponenttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case costcomponenttype.EdgeChildCostComponentTypes:
		m.ResetChildCostComponentTypes()
		return nil
	}
	return fmt.Errorf("unknown CostComponentType edge %s", name)
}

// CustomMethodMutation represents an operation that mutates the CustomMethod nodes in the graph.
type CustomMethodMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	create_time               *time.Time
	update_time               *time.Time
	string_ref                *string
	custom_method_name        *string
	description               *string
	clearedFields             map[string]struct{}
	custom_method_type        *int
	clearedcustom_method_type bool
	product_assocs            map[int]struct{}
	removedproduct_assocs     map[int]struct{}
	clearedproduct_assocs     bool
	product_prices            map[int]struct{}
	removedproduct_prices     map[int]struct{}
	clearedproduct_prices     bool
	done                      bool
	oldValue                  func(context.Context) (*CustomMethod, error)
	predicates                []predicate.CustomMethod
}

var _ ent.Mutation = (*CustomMethodMutation)(nil)

// custommethodOption allows management of the mutation configuration using functional options.
type custommethodOption func(*CustomMethodMutation)

// newCustomMethodMutation creates new mutation for the CustomMethod entity.
func newCustomMethodMutation(c config, op Op, opts ...custommethodOption) *CustomMethodMutation {
	m := &CustomMethodMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomMethod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomMethodID sets the ID field of the mutation.
func withCustomMethodID(id int) custommethodOption {
	return func(m *CustomMethodMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomMethod
		)
		m.oldValue = func(ctx context.Context) (*CustomMethod, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomMethod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomMethod sets the old CustomMethod of the mutation.
func withCustomMethod(node *CustomMethod) custommethodOption {
	return func(m *CustomMethodMutation) {
		m.oldValue = func(context.Context) (*CustomMethod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomMethodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomMethodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomMethodMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CustomMethodMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CustomMethodMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CustomMethod entity.
// If the CustomMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CustomMethodMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CustomMethodMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CustomMethodMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CustomMethod entity.
// If the CustomMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CustomMethodMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *CustomMethodMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *CustomMethodMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the CustomMethod entity.
// If the CustomMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *CustomMethodMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[custommethod.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *CustomMethodMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[custommethod.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *CustomMethodMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, custommethod.FieldStringRef)
}

// SetCustomMethodName sets the "custom_method_name" field.
func (m *CustomMethodMutation) SetCustomMethodName(s string) {
	m.custom_method_name = &s
}

// CustomMethodName returns the value of the "custom_method_name" field in the mutation.
func (m *CustomMethodMutation) CustomMethodName() (r string, exists bool) {
	v := m.custom_method_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomMethodName returns the old "custom_method_name" field's value of the CustomMethod entity.
// If the CustomMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodMutation) OldCustomMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCustomMethodName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCustomMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomMethodName: %w", err)
	}
	return oldValue.CustomMethodName, nil
}

// ClearCustomMethodName clears the value of the "custom_method_name" field.
func (m *CustomMethodMutation) ClearCustomMethodName() {
	m.custom_method_name = nil
	m.clearedFields[custommethod.FieldCustomMethodName] = struct{}{}
}

// CustomMethodNameCleared returns if the "custom_method_name" field was cleared in this mutation.
func (m *CustomMethodMutation) CustomMethodNameCleared() bool {
	_, ok := m.clearedFields[custommethod.FieldCustomMethodName]
	return ok
}

// ResetCustomMethodName resets all changes to the "custom_method_name" field.
func (m *CustomMethodMutation) ResetCustomMethodName() {
	m.custom_method_name = nil
	delete(m.clearedFields, custommethod.FieldCustomMethodName)
}

// SetDescription sets the "description" field.
func (m *CustomMethodMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomMethodMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CustomMethod entity.
// If the CustomMethod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomMethodMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[custommethod.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomMethodMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[custommethod.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomMethodMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, custommethod.FieldDescription)
}

// SetCustomMethodTypeID sets the "custom_method_type" edge to the CustomMethodType entity by id.
func (m *CustomMethodMutation) SetCustomMethodTypeID(id int) {
	m.custom_method_type = &id
}

// ClearCustomMethodType clears the "custom_method_type" edge to the CustomMethodType entity.
func (m *CustomMethodMutation) ClearCustomMethodType() {
	m.clearedcustom_method_type = true
}

// CustomMethodTypeCleared reports if the "custom_method_type" edge to the CustomMethodType entity was cleared.
func (m *CustomMethodMutation) CustomMethodTypeCleared() bool {
	return m.clearedcustom_method_type
}

// CustomMethodTypeID returns the "custom_method_type" edge ID in the mutation.
func (m *CustomMethodMutation) CustomMethodTypeID() (id int, exists bool) {
	if m.custom_method_type != nil {
		return *m.custom_method_type, true
	}
	return
}

// CustomMethodTypeIDs returns the "custom_method_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomMethodTypeID instead. It exists only for internal usage by the builders.
func (m *CustomMethodMutation) CustomMethodTypeIDs() (ids []int) {
	if id := m.custom_method_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomMethodType resets all changes to the "custom_method_type" edge.
func (m *CustomMethodMutation) ResetCustomMethodType() {
	m.custom_method_type = nil
	m.clearedcustom_method_type = false
}

// AddProductAssocIDs adds the "product_assocs" edge to the ProductAssoc entity by ids.
func (m *CustomMethodMutation) AddProductAssocIDs(ids ...int) {
	if m.product_assocs == nil {
		m.product_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.product_assocs[ids[i]] = struct{}{}
	}
}

// ClearProductAssocs clears the "product_assocs" edge to the ProductAssoc entity.
func (m *CustomMethodMutation) ClearProductAssocs() {
	m.clearedproduct_assocs = true
}

// ProductAssocsCleared reports if the "product_assocs" edge to the ProductAssoc entity was cleared.
func (m *CustomMethodMutation) ProductAssocsCleared() bool {
	return m.clearedproduct_assocs
}

// RemoveProductAssocIDs removes the "product_assocs" edge to the ProductAssoc entity by IDs.
func (m *CustomMethodMutation) RemoveProductAssocIDs(ids ...int) {
	if m.removedproduct_assocs == nil {
		m.removedproduct_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_assocs[ids[i]] = struct{}{}
	}
}

// RemovedProductAssocs returns the removed IDs of the "product_assocs" edge to the ProductAssoc entity.
func (m *CustomMethodMutation) RemovedProductAssocsIDs() (ids []int) {
	for id := range m.removedproduct_assocs {
		ids = append(ids, id)
	}
	return
}

// ProductAssocsIDs returns the "product_assocs" edge IDs in the mutation.
func (m *CustomMethodMutation) ProductAssocsIDs() (ids []int) {
	for id := range m.product_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetProductAssocs resets all changes to the "product_assocs" edge.
func (m *CustomMethodMutation) ResetProductAssocs() {
	m.product_assocs = nil
	m.clearedproduct_assocs = false
	m.removedproduct_assocs = nil
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrice entity by ids.
func (m *CustomMethodMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrice entity.
func (m *CustomMethodMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrice entity was cleared.
func (m *CustomMethodMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrice entity by IDs.
func (m *CustomMethodMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrice entity.
func (m *CustomMethodMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *CustomMethodMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *CustomMethodMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// Op returns the operation name.
func (m *CustomMethodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CustomMethod).
func (m *CustomMethodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomMethodMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, custommethod.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, custommethod.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, custommethod.FieldStringRef)
	}
	if m.custom_method_name != nil {
		fields = append(fields, custommethod.FieldCustomMethodName)
	}
	if m.description != nil {
		fields = append(fields, custommethod.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomMethodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case custommethod.FieldCreateTime:
		return m.CreateTime()
	case custommethod.FieldUpdateTime:
		return m.UpdateTime()
	case custommethod.FieldStringRef:
		return m.StringRef()
	case custommethod.FieldCustomMethodName:
		return m.CustomMethodName()
	case custommethod.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomMethodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case custommethod.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case custommethod.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case custommethod.FieldStringRef:
		return m.OldStringRef(ctx)
	case custommethod.FieldCustomMethodName:
		return m.OldCustomMethodName(ctx)
	case custommethod.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CustomMethod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomMethodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case custommethod.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case custommethod.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case custommethod.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case custommethod.FieldCustomMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomMethodName(v)
		return nil
	case custommethod.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CustomMethod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomMethodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomMethodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomMethodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomMethod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomMethodMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(custommethod.FieldStringRef) {
		fields = append(fields, custommethod.FieldStringRef)
	}
	if m.FieldCleared(custommethod.FieldCustomMethodName) {
		fields = append(fields, custommethod.FieldCustomMethodName)
	}
	if m.FieldCleared(custommethod.FieldDescription) {
		fields = append(fields, custommethod.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomMethodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomMethodMutation) ClearField(name string) error {
	switch name {
	case custommethod.FieldStringRef:
		m.ClearStringRef()
		return nil
	case custommethod.FieldCustomMethodName:
		m.ClearCustomMethodName()
		return nil
	case custommethod.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CustomMethod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomMethodMutation) ResetField(name string) error {
	switch name {
	case custommethod.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case custommethod.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case custommethod.FieldStringRef:
		m.ResetStringRef()
		return nil
	case custommethod.FieldCustomMethodName:
		m.ResetCustomMethodName()
		return nil
	case custommethod.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CustomMethod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomMethodMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.custom_method_type != nil {
		edges = append(edges, custommethod.EdgeCustomMethodType)
	}
	if m.product_assocs != nil {
		edges = append(edges, custommethod.EdgeProductAssocs)
	}
	if m.product_prices != nil {
		edges = append(edges, custommethod.EdgeProductPrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomMethodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case custommethod.EdgeCustomMethodType:
		if id := m.custom_method_type; id != nil {
			return []ent.Value{*id}
		}
	case custommethod.EdgeProductAssocs:
		ids := make([]ent.Value, 0, len(m.product_assocs))
		for id := range m.product_assocs {
			ids = append(ids, id)
		}
		return ids
	case custommethod.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomMethodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproduct_assocs != nil {
		edges = append(edges, custommethod.EdgeProductAssocs)
	}
	if m.removedproduct_prices != nil {
		edges = append(edges, custommethod.EdgeProductPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomMethodMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case custommethod.EdgeProductAssocs:
		ids := make([]ent.Value, 0, len(m.removedproduct_assocs))
		for id := range m.removedproduct_assocs {
			ids = append(ids, id)
		}
		return ids
	case custommethod.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomMethodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcustom_method_type {
		edges = append(edges, custommethod.EdgeCustomMethodType)
	}
	if m.clearedproduct_assocs {
		edges = append(edges, custommethod.EdgeProductAssocs)
	}
	if m.clearedproduct_prices {
		edges = append(edges, custommethod.EdgeProductPrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomMethodMutation) EdgeCleared(name string) bool {
	switch name {
	case custommethod.EdgeCustomMethodType:
		return m.clearedcustom_method_type
	case custommethod.EdgeProductAssocs:
		return m.clearedproduct_assocs
	case custommethod.EdgeProductPrices:
		return m.clearedproduct_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomMethodMutation) ClearEdge(name string) error {
	switch name {
	case custommethod.EdgeCustomMethodType:
		m.ClearCustomMethodType()
		return nil
	}
	return fmt.Errorf("unknown CustomMethod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomMethodMutation) ResetEdge(name string) error {
	switch name {
	case custommethod.EdgeCustomMethodType:
		m.ResetCustomMethodType()
		return nil
	case custommethod.EdgeProductAssocs:
		m.ResetProductAssocs()
		return nil
	case custommethod.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	}
	return fmt.Errorf("unknown CustomMethod edge %s", name)
}

// CustomMethodTypeMutation represents an operation that mutates the CustomMethodType nodes in the graph.
type CustomMethodTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	create_time                      *time.Time
	update_time                      *time.Time
	string_ref                       *string
	has_table                        *custommethodtype.HasTable
	description                      *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	children                         map[int]struct{}
	removedchildren                  map[int]struct{}
	clearedchildren                  bool
	custom_methods                   map[int]struct{}
	removedcustom_methods            map[int]struct{}
	clearedcustom_methods            bool
	child_custom_method_types        map[int]struct{}
	removedchild_custom_method_types map[int]struct{}
	clearedchild_custom_method_types bool
	done                             bool
	oldValue                         func(context.Context) (*CustomMethodType, error)
	predicates                       []predicate.CustomMethodType
}

var _ ent.Mutation = (*CustomMethodTypeMutation)(nil)

// custommethodtypeOption allows management of the mutation configuration using functional options.
type custommethodtypeOption func(*CustomMethodTypeMutation)

// newCustomMethodTypeMutation creates new mutation for the CustomMethodType entity.
func newCustomMethodTypeMutation(c config, op Op, opts ...custommethodtypeOption) *CustomMethodTypeMutation {
	m := &CustomMethodTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomMethodType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomMethodTypeID sets the ID field of the mutation.
func withCustomMethodTypeID(id int) custommethodtypeOption {
	return func(m *CustomMethodTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomMethodType
		)
		m.oldValue = func(ctx context.Context) (*CustomMethodType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomMethodType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomMethodType sets the old CustomMethodType of the mutation.
func withCustomMethodType(node *CustomMethodType) custommethodtypeOption {
	return func(m *CustomMethodTypeMutation) {
		m.oldValue = func(context.Context) (*CustomMethodType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomMethodTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomMethodTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomMethodTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CustomMethodTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CustomMethodTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CustomMethodType entity.
// If the CustomMethodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CustomMethodTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CustomMethodTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CustomMethodTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CustomMethodType entity.
// If the CustomMethodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CustomMethodTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *CustomMethodTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *CustomMethodTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the CustomMethodType entity.
// If the CustomMethodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *CustomMethodTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[custommethodtype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *CustomMethodTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[custommethodtype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *CustomMethodTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, custommethodtype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *CustomMethodTypeMutation) SetHasTable(ct custommethodtype.HasTable) {
	m.has_table = &ct
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *CustomMethodTypeMutation) HasTable() (r custommethodtype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the CustomMethodType entity.
// If the CustomMethodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodTypeMutation) OldHasTable(ctx context.Context) (v custommethodtype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *CustomMethodTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[custommethodtype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *CustomMethodTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[custommethodtype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *CustomMethodTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, custommethodtype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *CustomMethodTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomMethodTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CustomMethodType entity.
// If the CustomMethodType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomMethodTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomMethodTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[custommethodtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomMethodTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[custommethodtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomMethodTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, custommethodtype.FieldDescription)
}

// SetParentID sets the "parent" edge to the CustomMethodType entity by id.
func (m *CustomMethodTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the CustomMethodType entity.
func (m *CustomMethodTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the CustomMethodType entity was cleared.
func (m *CustomMethodTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CustomMethodTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CustomMethodTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CustomMethodTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the CustomMethodType entity by ids.
func (m *CustomMethodTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the CustomMethodType entity.
func (m *CustomMethodTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the CustomMethodType entity was cleared.
func (m *CustomMethodTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the CustomMethodType entity by IDs.
func (m *CustomMethodTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the CustomMethodType entity.
func (m *CustomMethodTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CustomMethodTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CustomMethodTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddCustomMethodIDs adds the "custom_methods" edge to the CustomMethod entity by ids.
func (m *CustomMethodTypeMutation) AddCustomMethodIDs(ids ...int) {
	if m.custom_methods == nil {
		m.custom_methods = make(map[int]struct{})
	}
	for i := range ids {
		m.custom_methods[ids[i]] = struct{}{}
	}
}

// ClearCustomMethods clears the "custom_methods" edge to the CustomMethod entity.
func (m *CustomMethodTypeMutation) ClearCustomMethods() {
	m.clearedcustom_methods = true
}

// CustomMethodsCleared reports if the "custom_methods" edge to the CustomMethod entity was cleared.
func (m *CustomMethodTypeMutation) CustomMethodsCleared() bool {
	return m.clearedcustom_methods
}

// RemoveCustomMethodIDs removes the "custom_methods" edge to the CustomMethod entity by IDs.
func (m *CustomMethodTypeMutation) RemoveCustomMethodIDs(ids ...int) {
	if m.removedcustom_methods == nil {
		m.removedcustom_methods = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcustom_methods[ids[i]] = struct{}{}
	}
}

// RemovedCustomMethods returns the removed IDs of the "custom_methods" edge to the CustomMethod entity.
func (m *CustomMethodTypeMutation) RemovedCustomMethodsIDs() (ids []int) {
	for id := range m.removedcustom_methods {
		ids = append(ids, id)
	}
	return
}

// CustomMethodsIDs returns the "custom_methods" edge IDs in the mutation.
func (m *CustomMethodTypeMutation) CustomMethodsIDs() (ids []int) {
	for id := range m.custom_methods {
		ids = append(ids, id)
	}
	return
}

// ResetCustomMethods resets all changes to the "custom_methods" edge.
func (m *CustomMethodTypeMutation) ResetCustomMethods() {
	m.custom_methods = nil
	m.clearedcustom_methods = false
	m.removedcustom_methods = nil
}

// AddChildCustomMethodTypeIDs adds the "child_custom_method_types" edge to the CustomMethodType entity by ids.
func (m *CustomMethodTypeMutation) AddChildCustomMethodTypeIDs(ids ...int) {
	if m.child_custom_method_types == nil {
		m.child_custom_method_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_custom_method_types[ids[i]] = struct{}{}
	}
}

// ClearChildCustomMethodTypes clears the "child_custom_method_types" edge to the CustomMethodType entity.
func (m *CustomMethodTypeMutation) ClearChildCustomMethodTypes() {
	m.clearedchild_custom_method_types = true
}

// ChildCustomMethodTypesCleared reports if the "child_custom_method_types" edge to the CustomMethodType entity was cleared.
func (m *CustomMethodTypeMutation) ChildCustomMethodTypesCleared() bool {
	return m.clearedchild_custom_method_types
}

// RemoveChildCustomMethodTypeIDs removes the "child_custom_method_types" edge to the CustomMethodType entity by IDs.
func (m *CustomMethodTypeMutation) RemoveChildCustomMethodTypeIDs(ids ...int) {
	if m.removedchild_custom_method_types == nil {
		m.removedchild_custom_method_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_custom_method_types[ids[i]] = struct{}{}
	}
}

// RemovedChildCustomMethodTypes returns the removed IDs of the "child_custom_method_types" edge to the CustomMethodType entity.
func (m *CustomMethodTypeMutation) RemovedChildCustomMethodTypesIDs() (ids []int) {
	for id := range m.removedchild_custom_method_types {
		ids = append(ids, id)
	}
	return
}

// ChildCustomMethodTypesIDs returns the "child_custom_method_types" edge IDs in the mutation.
func (m *CustomMethodTypeMutation) ChildCustomMethodTypesIDs() (ids []int) {
	for id := range m.child_custom_method_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildCustomMethodTypes resets all changes to the "child_custom_method_types" edge.
func (m *CustomMethodTypeMutation) ResetChildCustomMethodTypes() {
	m.child_custom_method_types = nil
	m.clearedchild_custom_method_types = false
	m.removedchild_custom_method_types = nil
}

// Op returns the operation name.
func (m *CustomMethodTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CustomMethodType).
func (m *CustomMethodTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomMethodTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, custommethodtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, custommethodtype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, custommethodtype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, custommethodtype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, custommethodtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomMethodTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case custommethodtype.FieldCreateTime:
		return m.CreateTime()
	case custommethodtype.FieldUpdateTime:
		return m.UpdateTime()
	case custommethodtype.FieldStringRef:
		return m.StringRef()
	case custommethodtype.FieldHasTable:
		return m.HasTable()
	case custommethodtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomMethodTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case custommethodtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case custommethodtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case custommethodtype.FieldStringRef:
		return m.OldStringRef(ctx)
	case custommethodtype.FieldHasTable:
		return m.OldHasTable(ctx)
	case custommethodtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CustomMethodType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomMethodTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case custommethodtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case custommethodtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case custommethodtype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case custommethodtype.FieldHasTable:
		v, ok := value.(custommethodtype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case custommethodtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CustomMethodType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomMethodTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomMethodTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomMethodTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CustomMethodType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomMethodTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(custommethodtype.FieldStringRef) {
		fields = append(fields, custommethodtype.FieldStringRef)
	}
	if m.FieldCleared(custommethodtype.FieldHasTable) {
		fields = append(fields, custommethodtype.FieldHasTable)
	}
	if m.FieldCleared(custommethodtype.FieldDescription) {
		fields = append(fields, custommethodtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomMethodTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomMethodTypeMutation) ClearField(name string) error {
	switch name {
	case custommethodtype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case custommethodtype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case custommethodtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CustomMethodType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomMethodTypeMutation) ResetField(name string) error {
	switch name {
	case custommethodtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case custommethodtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case custommethodtype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case custommethodtype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case custommethodtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CustomMethodType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomMethodTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, custommethodtype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, custommethodtype.EdgeChildren)
	}
	if m.custom_methods != nil {
		edges = append(edges, custommethodtype.EdgeCustomMethods)
	}
	if m.child_custom_method_types != nil {
		edges = append(edges, custommethodtype.EdgeChildCustomMethodTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomMethodTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case custommethodtype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case custommethodtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case custommethodtype.EdgeCustomMethods:
		ids := make([]ent.Value, 0, len(m.custom_methods))
		for id := range m.custom_methods {
			ids = append(ids, id)
		}
		return ids
	case custommethodtype.EdgeChildCustomMethodTypes:
		ids := make([]ent.Value, 0, len(m.child_custom_method_types))
		for id := range m.child_custom_method_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomMethodTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, custommethodtype.EdgeChildren)
	}
	if m.removedcustom_methods != nil {
		edges = append(edges, custommethodtype.EdgeCustomMethods)
	}
	if m.removedchild_custom_method_types != nil {
		edges = append(edges, custommethodtype.EdgeChildCustomMethodTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomMethodTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case custommethodtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case custommethodtype.EdgeCustomMethods:
		ids := make([]ent.Value, 0, len(m.removedcustom_methods))
		for id := range m.removedcustom_methods {
			ids = append(ids, id)
		}
		return ids
	case custommethodtype.EdgeChildCustomMethodTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_custom_method_types))
		for id := range m.removedchild_custom_method_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomMethodTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, custommethodtype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, custommethodtype.EdgeChildren)
	}
	if m.clearedcustom_methods {
		edges = append(edges, custommethodtype.EdgeCustomMethods)
	}
	if m.clearedchild_custom_method_types {
		edges = append(edges, custommethodtype.EdgeChildCustomMethodTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomMethodTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case custommethodtype.EdgeParent:
		return m.clearedparent
	case custommethodtype.EdgeChildren:
		return m.clearedchildren
	case custommethodtype.EdgeCustomMethods:
		return m.clearedcustom_methods
	case custommethodtype.EdgeChildCustomMethodTypes:
		return m.clearedchild_custom_method_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomMethodTypeMutation) ClearEdge(name string) error {
	switch name {
	case custommethodtype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown CustomMethodType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomMethodTypeMutation) ResetEdge(name string) error {
	switch name {
	case custommethodtype.EdgeParent:
		m.ResetParent()
		return nil
	case custommethodtype.EdgeChildren:
		m.ResetChildren()
		return nil
	case custommethodtype.EdgeCustomMethods:
		m.ResetCustomMethods()
		return nil
	case custommethodtype.EdgeChildCustomMethodTypes:
		m.ResetChildCustomMethodTypes()
		return nil
	}
	return fmt.Errorf("unknown CustomMethodType edge %s", name)
}

// EnumerationMutation represents an operation that mutates the Enumeration nodes in the graph.
type EnumerationMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	create_time                                 *time.Time
	update_time                                 *time.Time
	string_ref                                  *string
	enum_code                                   *string
	sequence_id                                 *int
	addsequence_id                              *int
	description                                 *string
	clearedFields                               map[string]struct{}
	enumeration_type                            *int
	clearedenumeration_type                     bool
	reason_inventory_item_details               map[int]struct{}
	removedreason_inventory_item_details        map[int]struct{}
	clearedreason_inventory_item_details        bool
	sales_channel_order_headers                 map[int]struct{}
	removedsales_channel_order_headers          map[int]struct{}
	clearedsales_channel_order_headers          bool
	virtual_variant_method_products             map[int]struct{}
	removedvirtual_variant_method_products      map[int]struct{}
	clearedvirtual_variant_method_products      bool
	rating_products                             map[int]struct{}
	removedrating_products                      map[int]struct{}
	clearedrating_products                      bool
	requirement_method_products                 map[int]struct{}
	removedrequirement_method_products          map[int]struct{}
	clearedrequirement_method_products          bool
	reserve_order_product_stores                map[int]struct{}
	removedreserve_order_product_stores         map[int]struct{}
	clearedreserve_order_product_stores         bool
	requirement_method_product_stores           map[int]struct{}
	removedrequirement_method_product_stores    map[int]struct{}
	clearedrequirement_method_product_stores    bool
	default_sales_channel_product_stores        map[int]struct{}
	removeddefault_sales_channel_product_stores map[int]struct{}
	cleareddefault_sales_channel_product_stores bool
	store_credit_account_product_stores         map[int]struct{}
	removedstore_credit_account_product_stores  map[int]struct{}
	clearedstore_credit_account_product_stores  bool
	done                                        bool
	oldValue                                    func(context.Context) (*Enumeration, error)
	predicates                                  []predicate.Enumeration
}

var _ ent.Mutation = (*EnumerationMutation)(nil)

// enumerationOption allows management of the mutation configuration using functional options.
type enumerationOption func(*EnumerationMutation)

// newEnumerationMutation creates new mutation for the Enumeration entity.
func newEnumerationMutation(c config, op Op, opts ...enumerationOption) *EnumerationMutation {
	m := &EnumerationMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumeration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumerationID sets the ID field of the mutation.
func withEnumerationID(id int) enumerationOption {
	return func(m *EnumerationMutation) {
		var (
			err   error
			once  sync.Once
			value *Enumeration
		)
		m.oldValue = func(ctx context.Context) (*Enumeration, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Enumeration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumeration sets the old Enumeration of the mutation.
func withEnumeration(node *Enumeration) enumerationOption {
	return func(m *EnumerationMutation) {
		m.oldValue = func(context.Context) (*Enumeration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumerationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumerationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumerationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *EnumerationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnumerationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Enumeration entity.
// If the Enumeration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnumerationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EnumerationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EnumerationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Enumeration entity.
// If the Enumeration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EnumerationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *EnumerationMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *EnumerationMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the Enumeration entity.
// If the Enumeration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *EnumerationMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[enumeration.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *EnumerationMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[enumeration.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *EnumerationMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, enumeration.FieldStringRef)
}

// SetEnumCode sets the "enum_code" field.
func (m *EnumerationMutation) SetEnumCode(s string) {
	m.enum_code = &s
}

// EnumCode returns the value of the "enum_code" field in the mutation.
func (m *EnumerationMutation) EnumCode() (r string, exists bool) {
	v := m.enum_code
	if v == nil {
		return
	}
	return *v, true
}

// OldEnumCode returns the old "enum_code" field's value of the Enumeration entity.
// If the Enumeration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationMutation) OldEnumCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnumCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnumCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnumCode: %w", err)
	}
	return oldValue.EnumCode, nil
}

// ClearEnumCode clears the value of the "enum_code" field.
func (m *EnumerationMutation) ClearEnumCode() {
	m.enum_code = nil
	m.clearedFields[enumeration.FieldEnumCode] = struct{}{}
}

// EnumCodeCleared returns if the "enum_code" field was cleared in this mutation.
func (m *EnumerationMutation) EnumCodeCleared() bool {
	_, ok := m.clearedFields[enumeration.FieldEnumCode]
	return ok
}

// ResetEnumCode resets all changes to the "enum_code" field.
func (m *EnumerationMutation) ResetEnumCode() {
	m.enum_code = nil
	delete(m.clearedFields, enumeration.FieldEnumCode)
}

// SetSequenceID sets the "sequence_id" field.
func (m *EnumerationMutation) SetSequenceID(i int) {
	m.sequence_id = &i
	m.addsequence_id = nil
}

// SequenceID returns the value of the "sequence_id" field in the mutation.
func (m *EnumerationMutation) SequenceID() (r int, exists bool) {
	v := m.sequence_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "sequence_id" field's value of the Enumeration entity.
// If the Enumeration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationMutation) OldSequenceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// AddSequenceID adds i to the "sequence_id" field.
func (m *EnumerationMutation) AddSequenceID(i int) {
	if m.addsequence_id != nil {
		*m.addsequence_id += i
	} else {
		m.addsequence_id = &i
	}
}

// AddedSequenceID returns the value that was added to the "sequence_id" field in this mutation.
func (m *EnumerationMutation) AddedSequenceID() (r int, exists bool) {
	v := m.addsequence_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceID clears the value of the "sequence_id" field.
func (m *EnumerationMutation) ClearSequenceID() {
	m.sequence_id = nil
	m.addsequence_id = nil
	m.clearedFields[enumeration.FieldSequenceID] = struct{}{}
}

// SequenceIDCleared returns if the "sequence_id" field was cleared in this mutation.
func (m *EnumerationMutation) SequenceIDCleared() bool {
	_, ok := m.clearedFields[enumeration.FieldSequenceID]
	return ok
}

// ResetSequenceID resets all changes to the "sequence_id" field.
func (m *EnumerationMutation) ResetSequenceID() {
	m.sequence_id = nil
	m.addsequence_id = nil
	delete(m.clearedFields, enumeration.FieldSequenceID)
}

// SetDescription sets the "description" field.
func (m *EnumerationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnumerationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Enumeration entity.
// If the Enumeration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EnumerationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[enumeration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EnumerationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[enumeration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EnumerationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, enumeration.FieldDescription)
}

// SetEnumerationTypeID sets the "enumeration_type" edge to the EnumerationType entity by id.
func (m *EnumerationMutation) SetEnumerationTypeID(id int) {
	m.enumeration_type = &id
}

// ClearEnumerationType clears the "enumeration_type" edge to the EnumerationType entity.
func (m *EnumerationMutation) ClearEnumerationType() {
	m.clearedenumeration_type = true
}

// EnumerationTypeCleared reports if the "enumeration_type" edge to the EnumerationType entity was cleared.
func (m *EnumerationMutation) EnumerationTypeCleared() bool {
	return m.clearedenumeration_type
}

// EnumerationTypeID returns the "enumeration_type" edge ID in the mutation.
func (m *EnumerationMutation) EnumerationTypeID() (id int, exists bool) {
	if m.enumeration_type != nil {
		return *m.enumeration_type, true
	}
	return
}

// EnumerationTypeIDs returns the "enumeration_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnumerationTypeID instead. It exists only for internal usage by the builders.
func (m *EnumerationMutation) EnumerationTypeIDs() (ids []int) {
	if id := m.enumeration_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnumerationType resets all changes to the "enumeration_type" edge.
func (m *EnumerationMutation) ResetEnumerationType() {
	m.enumeration_type = nil
	m.clearedenumeration_type = false
}

// AddReasonInventoryItemDetailIDs adds the "reason_inventory_item_details" edge to the InventoryItemDetail entity by ids.
func (m *EnumerationMutation) AddReasonInventoryItemDetailIDs(ids ...int) {
	if m.reason_inventory_item_details == nil {
		m.reason_inventory_item_details = make(map[int]struct{})
	}
	for i := range ids {
		m.reason_inventory_item_details[ids[i]] = struct{}{}
	}
}

// ClearReasonInventoryItemDetails clears the "reason_inventory_item_details" edge to the InventoryItemDetail entity.
func (m *EnumerationMutation) ClearReasonInventoryItemDetails() {
	m.clearedreason_inventory_item_details = true
}

// ReasonInventoryItemDetailsCleared reports if the "reason_inventory_item_details" edge to the InventoryItemDetail entity was cleared.
func (m *EnumerationMutation) ReasonInventoryItemDetailsCleared() bool {
	return m.clearedreason_inventory_item_details
}

// RemoveReasonInventoryItemDetailIDs removes the "reason_inventory_item_details" edge to the InventoryItemDetail entity by IDs.
func (m *EnumerationMutation) RemoveReasonInventoryItemDetailIDs(ids ...int) {
	if m.removedreason_inventory_item_details == nil {
		m.removedreason_inventory_item_details = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreason_inventory_item_details[ids[i]] = struct{}{}
	}
}

// RemovedReasonInventoryItemDetails returns the removed IDs of the "reason_inventory_item_details" edge to the InventoryItemDetail entity.
func (m *EnumerationMutation) RemovedReasonInventoryItemDetailsIDs() (ids []int) {
	for id := range m.removedreason_inventory_item_details {
		ids = append(ids, id)
	}
	return
}

// ReasonInventoryItemDetailsIDs returns the "reason_inventory_item_details" edge IDs in the mutation.
func (m *EnumerationMutation) ReasonInventoryItemDetailsIDs() (ids []int) {
	for id := range m.reason_inventory_item_details {
		ids = append(ids, id)
	}
	return
}

// ResetReasonInventoryItemDetails resets all changes to the "reason_inventory_item_details" edge.
func (m *EnumerationMutation) ResetReasonInventoryItemDetails() {
	m.reason_inventory_item_details = nil
	m.clearedreason_inventory_item_details = false
	m.removedreason_inventory_item_details = nil
}

// AddSalesChannelOrderHeaderIDs adds the "sales_channel_order_headers" edge to the OrderHeader entity by ids.
func (m *EnumerationMutation) AddSalesChannelOrderHeaderIDs(ids ...int) {
	if m.sales_channel_order_headers == nil {
		m.sales_channel_order_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.sales_channel_order_headers[ids[i]] = struct{}{}
	}
}

// ClearSalesChannelOrderHeaders clears the "sales_channel_order_headers" edge to the OrderHeader entity.
func (m *EnumerationMutation) ClearSalesChannelOrderHeaders() {
	m.clearedsales_channel_order_headers = true
}

// SalesChannelOrderHeadersCleared reports if the "sales_channel_order_headers" edge to the OrderHeader entity was cleared.
func (m *EnumerationMutation) SalesChannelOrderHeadersCleared() bool {
	return m.clearedsales_channel_order_headers
}

// RemoveSalesChannelOrderHeaderIDs removes the "sales_channel_order_headers" edge to the OrderHeader entity by IDs.
func (m *EnumerationMutation) RemoveSalesChannelOrderHeaderIDs(ids ...int) {
	if m.removedsales_channel_order_headers == nil {
		m.removedsales_channel_order_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsales_channel_order_headers[ids[i]] = struct{}{}
	}
}

// RemovedSalesChannelOrderHeaders returns the removed IDs of the "sales_channel_order_headers" edge to the OrderHeader entity.
func (m *EnumerationMutation) RemovedSalesChannelOrderHeadersIDs() (ids []int) {
	for id := range m.removedsales_channel_order_headers {
		ids = append(ids, id)
	}
	return
}

// SalesChannelOrderHeadersIDs returns the "sales_channel_order_headers" edge IDs in the mutation.
func (m *EnumerationMutation) SalesChannelOrderHeadersIDs() (ids []int) {
	for id := range m.sales_channel_order_headers {
		ids = append(ids, id)
	}
	return
}

// ResetSalesChannelOrderHeaders resets all changes to the "sales_channel_order_headers" edge.
func (m *EnumerationMutation) ResetSalesChannelOrderHeaders() {
	m.sales_channel_order_headers = nil
	m.clearedsales_channel_order_headers = false
	m.removedsales_channel_order_headers = nil
}

// AddVirtualVariantMethodProductIDs adds the "virtual_variant_method_products" edge to the Product entity by ids.
func (m *EnumerationMutation) AddVirtualVariantMethodProductIDs(ids ...int) {
	if m.virtual_variant_method_products == nil {
		m.virtual_variant_method_products = make(map[int]struct{})
	}
	for i := range ids {
		m.virtual_variant_method_products[ids[i]] = struct{}{}
	}
}

// ClearVirtualVariantMethodProducts clears the "virtual_variant_method_products" edge to the Product entity.
func (m *EnumerationMutation) ClearVirtualVariantMethodProducts() {
	m.clearedvirtual_variant_method_products = true
}

// VirtualVariantMethodProductsCleared reports if the "virtual_variant_method_products" edge to the Product entity was cleared.
func (m *EnumerationMutation) VirtualVariantMethodProductsCleared() bool {
	return m.clearedvirtual_variant_method_products
}

// RemoveVirtualVariantMethodProductIDs removes the "virtual_variant_method_products" edge to the Product entity by IDs.
func (m *EnumerationMutation) RemoveVirtualVariantMethodProductIDs(ids ...int) {
	if m.removedvirtual_variant_method_products == nil {
		m.removedvirtual_variant_method_products = make(map[int]struct{})
	}
	for i := range ids {
		m.removedvirtual_variant_method_products[ids[i]] = struct{}{}
	}
}

// RemovedVirtualVariantMethodProducts returns the removed IDs of the "virtual_variant_method_products" edge to the Product entity.
func (m *EnumerationMutation) RemovedVirtualVariantMethodProductsIDs() (ids []int) {
	for id := range m.removedvirtual_variant_method_products {
		ids = append(ids, id)
	}
	return
}

// VirtualVariantMethodProductsIDs returns the "virtual_variant_method_products" edge IDs in the mutation.
func (m *EnumerationMutation) VirtualVariantMethodProductsIDs() (ids []int) {
	for id := range m.virtual_variant_method_products {
		ids = append(ids, id)
	}
	return
}

// ResetVirtualVariantMethodProducts resets all changes to the "virtual_variant_method_products" edge.
func (m *EnumerationMutation) ResetVirtualVariantMethodProducts() {
	m.virtual_variant_method_products = nil
	m.clearedvirtual_variant_method_products = false
	m.removedvirtual_variant_method_products = nil
}

// AddRatingProductIDs adds the "rating_products" edge to the Product entity by ids.
func (m *EnumerationMutation) AddRatingProductIDs(ids ...int) {
	if m.rating_products == nil {
		m.rating_products = make(map[int]struct{})
	}
	for i := range ids {
		m.rating_products[ids[i]] = struct{}{}
	}
}

// ClearRatingProducts clears the "rating_products" edge to the Product entity.
func (m *EnumerationMutation) ClearRatingProducts() {
	m.clearedrating_products = true
}

// RatingProductsCleared reports if the "rating_products" edge to the Product entity was cleared.
func (m *EnumerationMutation) RatingProductsCleared() bool {
	return m.clearedrating_products
}

// RemoveRatingProductIDs removes the "rating_products" edge to the Product entity by IDs.
func (m *EnumerationMutation) RemoveRatingProductIDs(ids ...int) {
	if m.removedrating_products == nil {
		m.removedrating_products = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrating_products[ids[i]] = struct{}{}
	}
}

// RemovedRatingProducts returns the removed IDs of the "rating_products" edge to the Product entity.
func (m *EnumerationMutation) RemovedRatingProductsIDs() (ids []int) {
	for id := range m.removedrating_products {
		ids = append(ids, id)
	}
	return
}

// RatingProductsIDs returns the "rating_products" edge IDs in the mutation.
func (m *EnumerationMutation) RatingProductsIDs() (ids []int) {
	for id := range m.rating_products {
		ids = append(ids, id)
	}
	return
}

// ResetRatingProducts resets all changes to the "rating_products" edge.
func (m *EnumerationMutation) ResetRatingProducts() {
	m.rating_products = nil
	m.clearedrating_products = false
	m.removedrating_products = nil
}

// AddRequirementMethodProductIDs adds the "requirement_method_products" edge to the Product entity by ids.
func (m *EnumerationMutation) AddRequirementMethodProductIDs(ids ...int) {
	if m.requirement_method_products == nil {
		m.requirement_method_products = make(map[int]struct{})
	}
	for i := range ids {
		m.requirement_method_products[ids[i]] = struct{}{}
	}
}

// ClearRequirementMethodProducts clears the "requirement_method_products" edge to the Product entity.
func (m *EnumerationMutation) ClearRequirementMethodProducts() {
	m.clearedrequirement_method_products = true
}

// RequirementMethodProductsCleared reports if the "requirement_method_products" edge to the Product entity was cleared.
func (m *EnumerationMutation) RequirementMethodProductsCleared() bool {
	return m.clearedrequirement_method_products
}

// RemoveRequirementMethodProductIDs removes the "requirement_method_products" edge to the Product entity by IDs.
func (m *EnumerationMutation) RemoveRequirementMethodProductIDs(ids ...int) {
	if m.removedrequirement_method_products == nil {
		m.removedrequirement_method_products = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrequirement_method_products[ids[i]] = struct{}{}
	}
}

// RemovedRequirementMethodProducts returns the removed IDs of the "requirement_method_products" edge to the Product entity.
func (m *EnumerationMutation) RemovedRequirementMethodProductsIDs() (ids []int) {
	for id := range m.removedrequirement_method_products {
		ids = append(ids, id)
	}
	return
}

// RequirementMethodProductsIDs returns the "requirement_method_products" edge IDs in the mutation.
func (m *EnumerationMutation) RequirementMethodProductsIDs() (ids []int) {
	for id := range m.requirement_method_products {
		ids = append(ids, id)
	}
	return
}

// ResetRequirementMethodProducts resets all changes to the "requirement_method_products" edge.
func (m *EnumerationMutation) ResetRequirementMethodProducts() {
	m.requirement_method_products = nil
	m.clearedrequirement_method_products = false
	m.removedrequirement_method_products = nil
}

// AddReserveOrderProductStoreIDs adds the "reserve_order_product_stores" edge to the ProductStore entity by ids.
func (m *EnumerationMutation) AddReserveOrderProductStoreIDs(ids ...int) {
	if m.reserve_order_product_stores == nil {
		m.reserve_order_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.reserve_order_product_stores[ids[i]] = struct{}{}
	}
}

// ClearReserveOrderProductStores clears the "reserve_order_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) ClearReserveOrderProductStores() {
	m.clearedreserve_order_product_stores = true
}

// ReserveOrderProductStoresCleared reports if the "reserve_order_product_stores" edge to the ProductStore entity was cleared.
func (m *EnumerationMutation) ReserveOrderProductStoresCleared() bool {
	return m.clearedreserve_order_product_stores
}

// RemoveReserveOrderProductStoreIDs removes the "reserve_order_product_stores" edge to the ProductStore entity by IDs.
func (m *EnumerationMutation) RemoveReserveOrderProductStoreIDs(ids ...int) {
	if m.removedreserve_order_product_stores == nil {
		m.removedreserve_order_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedreserve_order_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedReserveOrderProductStores returns the removed IDs of the "reserve_order_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) RemovedReserveOrderProductStoresIDs() (ids []int) {
	for id := range m.removedreserve_order_product_stores {
		ids = append(ids, id)
	}
	return
}

// ReserveOrderProductStoresIDs returns the "reserve_order_product_stores" edge IDs in the mutation.
func (m *EnumerationMutation) ReserveOrderProductStoresIDs() (ids []int) {
	for id := range m.reserve_order_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetReserveOrderProductStores resets all changes to the "reserve_order_product_stores" edge.
func (m *EnumerationMutation) ResetReserveOrderProductStores() {
	m.reserve_order_product_stores = nil
	m.clearedreserve_order_product_stores = false
	m.removedreserve_order_product_stores = nil
}

// AddRequirementMethodProductStoreIDs adds the "requirement_method_product_stores" edge to the ProductStore entity by ids.
func (m *EnumerationMutation) AddRequirementMethodProductStoreIDs(ids ...int) {
	if m.requirement_method_product_stores == nil {
		m.requirement_method_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.requirement_method_product_stores[ids[i]] = struct{}{}
	}
}

// ClearRequirementMethodProductStores clears the "requirement_method_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) ClearRequirementMethodProductStores() {
	m.clearedrequirement_method_product_stores = true
}

// RequirementMethodProductStoresCleared reports if the "requirement_method_product_stores" edge to the ProductStore entity was cleared.
func (m *EnumerationMutation) RequirementMethodProductStoresCleared() bool {
	return m.clearedrequirement_method_product_stores
}

// RemoveRequirementMethodProductStoreIDs removes the "requirement_method_product_stores" edge to the ProductStore entity by IDs.
func (m *EnumerationMutation) RemoveRequirementMethodProductStoreIDs(ids ...int) {
	if m.removedrequirement_method_product_stores == nil {
		m.removedrequirement_method_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrequirement_method_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedRequirementMethodProductStores returns the removed IDs of the "requirement_method_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) RemovedRequirementMethodProductStoresIDs() (ids []int) {
	for id := range m.removedrequirement_method_product_stores {
		ids = append(ids, id)
	}
	return
}

// RequirementMethodProductStoresIDs returns the "requirement_method_product_stores" edge IDs in the mutation.
func (m *EnumerationMutation) RequirementMethodProductStoresIDs() (ids []int) {
	for id := range m.requirement_method_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetRequirementMethodProductStores resets all changes to the "requirement_method_product_stores" edge.
func (m *EnumerationMutation) ResetRequirementMethodProductStores() {
	m.requirement_method_product_stores = nil
	m.clearedrequirement_method_product_stores = false
	m.removedrequirement_method_product_stores = nil
}

// AddDefaultSalesChannelProductStoreIDs adds the "default_sales_channel_product_stores" edge to the ProductStore entity by ids.
func (m *EnumerationMutation) AddDefaultSalesChannelProductStoreIDs(ids ...int) {
	if m.default_sales_channel_product_stores == nil {
		m.default_sales_channel_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.default_sales_channel_product_stores[ids[i]] = struct{}{}
	}
}

// ClearDefaultSalesChannelProductStores clears the "default_sales_channel_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) ClearDefaultSalesChannelProductStores() {
	m.cleareddefault_sales_channel_product_stores = true
}

// DefaultSalesChannelProductStoresCleared reports if the "default_sales_channel_product_stores" edge to the ProductStore entity was cleared.
func (m *EnumerationMutation) DefaultSalesChannelProductStoresCleared() bool {
	return m.cleareddefault_sales_channel_product_stores
}

// RemoveDefaultSalesChannelProductStoreIDs removes the "default_sales_channel_product_stores" edge to the ProductStore entity by IDs.
func (m *EnumerationMutation) RemoveDefaultSalesChannelProductStoreIDs(ids ...int) {
	if m.removeddefault_sales_channel_product_stores == nil {
		m.removeddefault_sales_channel_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddefault_sales_channel_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedDefaultSalesChannelProductStores returns the removed IDs of the "default_sales_channel_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) RemovedDefaultSalesChannelProductStoresIDs() (ids []int) {
	for id := range m.removeddefault_sales_channel_product_stores {
		ids = append(ids, id)
	}
	return
}

// DefaultSalesChannelProductStoresIDs returns the "default_sales_channel_product_stores" edge IDs in the mutation.
func (m *EnumerationMutation) DefaultSalesChannelProductStoresIDs() (ids []int) {
	for id := range m.default_sales_channel_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetDefaultSalesChannelProductStores resets all changes to the "default_sales_channel_product_stores" edge.
func (m *EnumerationMutation) ResetDefaultSalesChannelProductStores() {
	m.default_sales_channel_product_stores = nil
	m.cleareddefault_sales_channel_product_stores = false
	m.removeddefault_sales_channel_product_stores = nil
}

// AddStoreCreditAccountProductStoreIDs adds the "store_credit_account_product_stores" edge to the ProductStore entity by ids.
func (m *EnumerationMutation) AddStoreCreditAccountProductStoreIDs(ids ...int) {
	if m.store_credit_account_product_stores == nil {
		m.store_credit_account_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.store_credit_account_product_stores[ids[i]] = struct{}{}
	}
}

// ClearStoreCreditAccountProductStores clears the "store_credit_account_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) ClearStoreCreditAccountProductStores() {
	m.clearedstore_credit_account_product_stores = true
}

// StoreCreditAccountProductStoresCleared reports if the "store_credit_account_product_stores" edge to the ProductStore entity was cleared.
func (m *EnumerationMutation) StoreCreditAccountProductStoresCleared() bool {
	return m.clearedstore_credit_account_product_stores
}

// RemoveStoreCreditAccountProductStoreIDs removes the "store_credit_account_product_stores" edge to the ProductStore entity by IDs.
func (m *EnumerationMutation) RemoveStoreCreditAccountProductStoreIDs(ids ...int) {
	if m.removedstore_credit_account_product_stores == nil {
		m.removedstore_credit_account_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstore_credit_account_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedStoreCreditAccountProductStores returns the removed IDs of the "store_credit_account_product_stores" edge to the ProductStore entity.
func (m *EnumerationMutation) RemovedStoreCreditAccountProductStoresIDs() (ids []int) {
	for id := range m.removedstore_credit_account_product_stores {
		ids = append(ids, id)
	}
	return
}

// StoreCreditAccountProductStoresIDs returns the "store_credit_account_product_stores" edge IDs in the mutation.
func (m *EnumerationMutation) StoreCreditAccountProductStoresIDs() (ids []int) {
	for id := range m.store_credit_account_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetStoreCreditAccountProductStores resets all changes to the "store_credit_account_product_stores" edge.
func (m *EnumerationMutation) ResetStoreCreditAccountProductStores() {
	m.store_credit_account_product_stores = nil
	m.clearedstore_credit_account_product_stores = false
	m.removedstore_credit_account_product_stores = nil
}

// Op returns the operation name.
func (m *EnumerationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Enumeration).
func (m *EnumerationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumerationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, enumeration.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, enumeration.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, enumeration.FieldStringRef)
	}
	if m.enum_code != nil {
		fields = append(fields, enumeration.FieldEnumCode)
	}
	if m.sequence_id != nil {
		fields = append(fields, enumeration.FieldSequenceID)
	}
	if m.description != nil {
		fields = append(fields, enumeration.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumerationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enumeration.FieldCreateTime:
		return m.CreateTime()
	case enumeration.FieldUpdateTime:
		return m.UpdateTime()
	case enumeration.FieldStringRef:
		return m.StringRef()
	case enumeration.FieldEnumCode:
		return m.EnumCode()
	case enumeration.FieldSequenceID:
		return m.SequenceID()
	case enumeration.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumerationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enumeration.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case enumeration.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case enumeration.FieldStringRef:
		return m.OldStringRef(ctx)
	case enumeration.FieldEnumCode:
		return m.OldEnumCode(ctx)
	case enumeration.FieldSequenceID:
		return m.OldSequenceID(ctx)
	case enumeration.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Enumeration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumerationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enumeration.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case enumeration.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case enumeration.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case enumeration.FieldEnumCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnumCode(v)
		return nil
	case enumeration.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	case enumeration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Enumeration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumerationMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_id != nil {
		fields = append(fields, enumeration.FieldSequenceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumerationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enumeration.FieldSequenceID:
		return m.AddedSequenceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumerationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enumeration.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceID(v)
		return nil
	}
	return fmt.Errorf("unknown Enumeration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumerationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enumeration.FieldStringRef) {
		fields = append(fields, enumeration.FieldStringRef)
	}
	if m.FieldCleared(enumeration.FieldEnumCode) {
		fields = append(fields, enumeration.FieldEnumCode)
	}
	if m.FieldCleared(enumeration.FieldSequenceID) {
		fields = append(fields, enumeration.FieldSequenceID)
	}
	if m.FieldCleared(enumeration.FieldDescription) {
		fields = append(fields, enumeration.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumerationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumerationMutation) ClearField(name string) error {
	switch name {
	case enumeration.FieldStringRef:
		m.ClearStringRef()
		return nil
	case enumeration.FieldEnumCode:
		m.ClearEnumCode()
		return nil
	case enumeration.FieldSequenceID:
		m.ClearSequenceID()
		return nil
	case enumeration.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Enumeration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumerationMutation) ResetField(name string) error {
	switch name {
	case enumeration.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case enumeration.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case enumeration.FieldStringRef:
		m.ResetStringRef()
		return nil
	case enumeration.FieldEnumCode:
		m.ResetEnumCode()
		return nil
	case enumeration.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	case enumeration.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Enumeration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumerationMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.enumeration_type != nil {
		edges = append(edges, enumeration.EdgeEnumerationType)
	}
	if m.reason_inventory_item_details != nil {
		edges = append(edges, enumeration.EdgeReasonInventoryItemDetails)
	}
	if m.sales_channel_order_headers != nil {
		edges = append(edges, enumeration.EdgeSalesChannelOrderHeaders)
	}
	if m.virtual_variant_method_products != nil {
		edges = append(edges, enumeration.EdgeVirtualVariantMethodProducts)
	}
	if m.rating_products != nil {
		edges = append(edges, enumeration.EdgeRatingProducts)
	}
	if m.requirement_method_products != nil {
		edges = append(edges, enumeration.EdgeRequirementMethodProducts)
	}
	if m.reserve_order_product_stores != nil {
		edges = append(edges, enumeration.EdgeReserveOrderProductStores)
	}
	if m.requirement_method_product_stores != nil {
		edges = append(edges, enumeration.EdgeRequirementMethodProductStores)
	}
	if m.default_sales_channel_product_stores != nil {
		edges = append(edges, enumeration.EdgeDefaultSalesChannelProductStores)
	}
	if m.store_credit_account_product_stores != nil {
		edges = append(edges, enumeration.EdgeStoreCreditAccountProductStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumerationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enumeration.EdgeEnumerationType:
		if id := m.enumeration_type; id != nil {
			return []ent.Value{*id}
		}
	case enumeration.EdgeReasonInventoryItemDetails:
		ids := make([]ent.Value, 0, len(m.reason_inventory_item_details))
		for id := range m.reason_inventory_item_details {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeSalesChannelOrderHeaders:
		ids := make([]ent.Value, 0, len(m.sales_channel_order_headers))
		for id := range m.sales_channel_order_headers {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeVirtualVariantMethodProducts:
		ids := make([]ent.Value, 0, len(m.virtual_variant_method_products))
		for id := range m.virtual_variant_method_products {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeRatingProducts:
		ids := make([]ent.Value, 0, len(m.rating_products))
		for id := range m.rating_products {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeRequirementMethodProducts:
		ids := make([]ent.Value, 0, len(m.requirement_method_products))
		for id := range m.requirement_method_products {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeReserveOrderProductStores:
		ids := make([]ent.Value, 0, len(m.reserve_order_product_stores))
		for id := range m.reserve_order_product_stores {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeRequirementMethodProductStores:
		ids := make([]ent.Value, 0, len(m.requirement_method_product_stores))
		for id := range m.requirement_method_product_stores {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeDefaultSalesChannelProductStores:
		ids := make([]ent.Value, 0, len(m.default_sales_channel_product_stores))
		for id := range m.default_sales_channel_product_stores {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeStoreCreditAccountProductStores:
		ids := make([]ent.Value, 0, len(m.store_credit_account_product_stores))
		for id := range m.store_credit_account_product_stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumerationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedreason_inventory_item_details != nil {
		edges = append(edges, enumeration.EdgeReasonInventoryItemDetails)
	}
	if m.removedsales_channel_order_headers != nil {
		edges = append(edges, enumeration.EdgeSalesChannelOrderHeaders)
	}
	if m.removedvirtual_variant_method_products != nil {
		edges = append(edges, enumeration.EdgeVirtualVariantMethodProducts)
	}
	if m.removedrating_products != nil {
		edges = append(edges, enumeration.EdgeRatingProducts)
	}
	if m.removedrequirement_method_products != nil {
		edges = append(edges, enumeration.EdgeRequirementMethodProducts)
	}
	if m.removedreserve_order_product_stores != nil {
		edges = append(edges, enumeration.EdgeReserveOrderProductStores)
	}
	if m.removedrequirement_method_product_stores != nil {
		edges = append(edges, enumeration.EdgeRequirementMethodProductStores)
	}
	if m.removeddefault_sales_channel_product_stores != nil {
		edges = append(edges, enumeration.EdgeDefaultSalesChannelProductStores)
	}
	if m.removedstore_credit_account_product_stores != nil {
		edges = append(edges, enumeration.EdgeStoreCreditAccountProductStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumerationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enumeration.EdgeReasonInventoryItemDetails:
		ids := make([]ent.Value, 0, len(m.removedreason_inventory_item_details))
		for id := range m.removedreason_inventory_item_details {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeSalesChannelOrderHeaders:
		ids := make([]ent.Value, 0, len(m.removedsales_channel_order_headers))
		for id := range m.removedsales_channel_order_headers {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeVirtualVariantMethodProducts:
		ids := make([]ent.Value, 0, len(m.removedvirtual_variant_method_products))
		for id := range m.removedvirtual_variant_method_products {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeRatingProducts:
		ids := make([]ent.Value, 0, len(m.removedrating_products))
		for id := range m.removedrating_products {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeRequirementMethodProducts:
		ids := make([]ent.Value, 0, len(m.removedrequirement_method_products))
		for id := range m.removedrequirement_method_products {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeReserveOrderProductStores:
		ids := make([]ent.Value, 0, len(m.removedreserve_order_product_stores))
		for id := range m.removedreserve_order_product_stores {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeRequirementMethodProductStores:
		ids := make([]ent.Value, 0, len(m.removedrequirement_method_product_stores))
		for id := range m.removedrequirement_method_product_stores {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeDefaultSalesChannelProductStores:
		ids := make([]ent.Value, 0, len(m.removeddefault_sales_channel_product_stores))
		for id := range m.removeddefault_sales_channel_product_stores {
			ids = append(ids, id)
		}
		return ids
	case enumeration.EdgeStoreCreditAccountProductStores:
		ids := make([]ent.Value, 0, len(m.removedstore_credit_account_product_stores))
		for id := range m.removedstore_credit_account_product_stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumerationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedenumeration_type {
		edges = append(edges, enumeration.EdgeEnumerationType)
	}
	if m.clearedreason_inventory_item_details {
		edges = append(edges, enumeration.EdgeReasonInventoryItemDetails)
	}
	if m.clearedsales_channel_order_headers {
		edges = append(edges, enumeration.EdgeSalesChannelOrderHeaders)
	}
	if m.clearedvirtual_variant_method_products {
		edges = append(edges, enumeration.EdgeVirtualVariantMethodProducts)
	}
	if m.clearedrating_products {
		edges = append(edges, enumeration.EdgeRatingProducts)
	}
	if m.clearedrequirement_method_products {
		edges = append(edges, enumeration.EdgeRequirementMethodProducts)
	}
	if m.clearedreserve_order_product_stores {
		edges = append(edges, enumeration.EdgeReserveOrderProductStores)
	}
	if m.clearedrequirement_method_product_stores {
		edges = append(edges, enumeration.EdgeRequirementMethodProductStores)
	}
	if m.cleareddefault_sales_channel_product_stores {
		edges = append(edges, enumeration.EdgeDefaultSalesChannelProductStores)
	}
	if m.clearedstore_credit_account_product_stores {
		edges = append(edges, enumeration.EdgeStoreCreditAccountProductStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumerationMutation) EdgeCleared(name string) bool {
	switch name {
	case enumeration.EdgeEnumerationType:
		return m.clearedenumeration_type
	case enumeration.EdgeReasonInventoryItemDetails:
		return m.clearedreason_inventory_item_details
	case enumeration.EdgeSalesChannelOrderHeaders:
		return m.clearedsales_channel_order_headers
	case enumeration.EdgeVirtualVariantMethodProducts:
		return m.clearedvirtual_variant_method_products
	case enumeration.EdgeRatingProducts:
		return m.clearedrating_products
	case enumeration.EdgeRequirementMethodProducts:
		return m.clearedrequirement_method_products
	case enumeration.EdgeReserveOrderProductStores:
		return m.clearedreserve_order_product_stores
	case enumeration.EdgeRequirementMethodProductStores:
		return m.clearedrequirement_method_product_stores
	case enumeration.EdgeDefaultSalesChannelProductStores:
		return m.cleareddefault_sales_channel_product_stores
	case enumeration.EdgeStoreCreditAccountProductStores:
		return m.clearedstore_credit_account_product_stores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumerationMutation) ClearEdge(name string) error {
	switch name {
	case enumeration.EdgeEnumerationType:
		m.ClearEnumerationType()
		return nil
	}
	return fmt.Errorf("unknown Enumeration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumerationMutation) ResetEdge(name string) error {
	switch name {
	case enumeration.EdgeEnumerationType:
		m.ResetEnumerationType()
		return nil
	case enumeration.EdgeReasonInventoryItemDetails:
		m.ResetReasonInventoryItemDetails()
		return nil
	case enumeration.EdgeSalesChannelOrderHeaders:
		m.ResetSalesChannelOrderHeaders()
		return nil
	case enumeration.EdgeVirtualVariantMethodProducts:
		m.ResetVirtualVariantMethodProducts()
		return nil
	case enumeration.EdgeRatingProducts:
		m.ResetRatingProducts()
		return nil
	case enumeration.EdgeRequirementMethodProducts:
		m.ResetRequirementMethodProducts()
		return nil
	case enumeration.EdgeReserveOrderProductStores:
		m.ResetReserveOrderProductStores()
		return nil
	case enumeration.EdgeRequirementMethodProductStores:
		m.ResetRequirementMethodProductStores()
		return nil
	case enumeration.EdgeDefaultSalesChannelProductStores:
		m.ResetDefaultSalesChannelProductStores()
		return nil
	case enumeration.EdgeStoreCreditAccountProductStores:
		m.ResetStoreCreditAccountProductStores()
		return nil
	}
	return fmt.Errorf("unknown Enumeration edge %s", name)
}

// EnumerationTypeMutation represents an operation that mutates the EnumerationType nodes in the graph.
type EnumerationTypeMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	create_time                    *time.Time
	update_time                    *time.Time
	string_ref                     *string
	has_table                      *enumerationtype.HasTable
	description                    *string
	clearedFields                  map[string]struct{}
	parent                         *int
	clearedparent                  bool
	children                       map[int]struct{}
	removedchildren                map[int]struct{}
	clearedchildren                bool
	enumerations                   map[int]struct{}
	removedenumerations            map[int]struct{}
	clearedenumerations            bool
	child_enumeration_types        map[int]struct{}
	removedchild_enumeration_types map[int]struct{}
	clearedchild_enumeration_types bool
	done                           bool
	oldValue                       func(context.Context) (*EnumerationType, error)
	predicates                     []predicate.EnumerationType
}

var _ ent.Mutation = (*EnumerationTypeMutation)(nil)

// enumerationtypeOption allows management of the mutation configuration using functional options.
type enumerationtypeOption func(*EnumerationTypeMutation)

// newEnumerationTypeMutation creates new mutation for the EnumerationType entity.
func newEnumerationTypeMutation(c config, op Op, opts ...enumerationtypeOption) *EnumerationTypeMutation {
	m := &EnumerationTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEnumerationType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnumerationTypeID sets the ID field of the mutation.
func withEnumerationTypeID(id int) enumerationtypeOption {
	return func(m *EnumerationTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EnumerationType
		)
		m.oldValue = func(ctx context.Context) (*EnumerationType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnumerationType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnumerationType sets the old EnumerationType of the mutation.
func withEnumerationType(node *EnumerationType) enumerationtypeOption {
	return func(m *EnumerationTypeMutation) {
		m.oldValue = func(context.Context) (*EnumerationType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnumerationTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnumerationTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnumerationTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *EnumerationTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnumerationTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EnumerationType entity.
// If the EnumerationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnumerationTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EnumerationTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EnumerationTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the EnumerationType entity.
// If the EnumerationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EnumerationTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *EnumerationTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *EnumerationTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the EnumerationType entity.
// If the EnumerationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *EnumerationTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[enumerationtype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *EnumerationTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[enumerationtype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *EnumerationTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, enumerationtype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *EnumerationTypeMutation) SetHasTable(et enumerationtype.HasTable) {
	m.has_table = &et
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *EnumerationTypeMutation) HasTable() (r enumerationtype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the EnumerationType entity.
// If the EnumerationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationTypeMutation) OldHasTable(ctx context.Context) (v enumerationtype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *EnumerationTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[enumerationtype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *EnumerationTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[enumerationtype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *EnumerationTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, enumerationtype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *EnumerationTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnumerationTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EnumerationType entity.
// If the EnumerationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnumerationTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EnumerationTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[enumerationtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EnumerationTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[enumerationtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EnumerationTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, enumerationtype.FieldDescription)
}

// SetParentID sets the "parent" edge to the EnumerationType entity by id.
func (m *EnumerationTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the EnumerationType entity.
func (m *EnumerationTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the EnumerationType entity was cleared.
func (m *EnumerationTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *EnumerationTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *EnumerationTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *EnumerationTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the EnumerationType entity by ids.
func (m *EnumerationTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the EnumerationType entity.
func (m *EnumerationTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the EnumerationType entity was cleared.
func (m *EnumerationTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the EnumerationType entity by IDs.
func (m *EnumerationTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the EnumerationType entity.
func (m *EnumerationTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *EnumerationTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *EnumerationTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddEnumerationIDs adds the "enumerations" edge to the Enumeration entity by ids.
func (m *EnumerationTypeMutation) AddEnumerationIDs(ids ...int) {
	if m.enumerations == nil {
		m.enumerations = make(map[int]struct{})
	}
	for i := range ids {
		m.enumerations[ids[i]] = struct{}{}
	}
}

// ClearEnumerations clears the "enumerations" edge to the Enumeration entity.
func (m *EnumerationTypeMutation) ClearEnumerations() {
	m.clearedenumerations = true
}

// EnumerationsCleared reports if the "enumerations" edge to the Enumeration entity was cleared.
func (m *EnumerationTypeMutation) EnumerationsCleared() bool {
	return m.clearedenumerations
}

// RemoveEnumerationIDs removes the "enumerations" edge to the Enumeration entity by IDs.
func (m *EnumerationTypeMutation) RemoveEnumerationIDs(ids ...int) {
	if m.removedenumerations == nil {
		m.removedenumerations = make(map[int]struct{})
	}
	for i := range ids {
		m.removedenumerations[ids[i]] = struct{}{}
	}
}

// RemovedEnumerations returns the removed IDs of the "enumerations" edge to the Enumeration entity.
func (m *EnumerationTypeMutation) RemovedEnumerationsIDs() (ids []int) {
	for id := range m.removedenumerations {
		ids = append(ids, id)
	}
	return
}

// EnumerationsIDs returns the "enumerations" edge IDs in the mutation.
func (m *EnumerationTypeMutation) EnumerationsIDs() (ids []int) {
	for id := range m.enumerations {
		ids = append(ids, id)
	}
	return
}

// ResetEnumerations resets all changes to the "enumerations" edge.
func (m *EnumerationTypeMutation) ResetEnumerations() {
	m.enumerations = nil
	m.clearedenumerations = false
	m.removedenumerations = nil
}

// AddChildEnumerationTypeIDs adds the "child_enumeration_types" edge to the EnumerationType entity by ids.
func (m *EnumerationTypeMutation) AddChildEnumerationTypeIDs(ids ...int) {
	if m.child_enumeration_types == nil {
		m.child_enumeration_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_enumeration_types[ids[i]] = struct{}{}
	}
}

// ClearChildEnumerationTypes clears the "child_enumeration_types" edge to the EnumerationType entity.
func (m *EnumerationTypeMutation) ClearChildEnumerationTypes() {
	m.clearedchild_enumeration_types = true
}

// ChildEnumerationTypesCleared reports if the "child_enumeration_types" edge to the EnumerationType entity was cleared.
func (m *EnumerationTypeMutation) ChildEnumerationTypesCleared() bool {
	return m.clearedchild_enumeration_types
}

// RemoveChildEnumerationTypeIDs removes the "child_enumeration_types" edge to the EnumerationType entity by IDs.
func (m *EnumerationTypeMutation) RemoveChildEnumerationTypeIDs(ids ...int) {
	if m.removedchild_enumeration_types == nil {
		m.removedchild_enumeration_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_enumeration_types[ids[i]] = struct{}{}
	}
}

// RemovedChildEnumerationTypes returns the removed IDs of the "child_enumeration_types" edge to the EnumerationType entity.
func (m *EnumerationTypeMutation) RemovedChildEnumerationTypesIDs() (ids []int) {
	for id := range m.removedchild_enumeration_types {
		ids = append(ids, id)
	}
	return
}

// ChildEnumerationTypesIDs returns the "child_enumeration_types" edge IDs in the mutation.
func (m *EnumerationTypeMutation) ChildEnumerationTypesIDs() (ids []int) {
	for id := range m.child_enumeration_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildEnumerationTypes resets all changes to the "child_enumeration_types" edge.
func (m *EnumerationTypeMutation) ResetChildEnumerationTypes() {
	m.child_enumeration_types = nil
	m.clearedchild_enumeration_types = false
	m.removedchild_enumeration_types = nil
}

// Op returns the operation name.
func (m *EnumerationTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnumerationType).
func (m *EnumerationTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnumerationTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, enumerationtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, enumerationtype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, enumerationtype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, enumerationtype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, enumerationtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnumerationTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enumerationtype.FieldCreateTime:
		return m.CreateTime()
	case enumerationtype.FieldUpdateTime:
		return m.UpdateTime()
	case enumerationtype.FieldStringRef:
		return m.StringRef()
	case enumerationtype.FieldHasTable:
		return m.HasTable()
	case enumerationtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnumerationTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enumerationtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case enumerationtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case enumerationtype.FieldStringRef:
		return m.OldStringRef(ctx)
	case enumerationtype.FieldHasTable:
		return m.OldHasTable(ctx)
	case enumerationtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown EnumerationType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumerationTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enumerationtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case enumerationtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case enumerationtype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case enumerationtype.FieldHasTable:
		v, ok := value.(enumerationtype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case enumerationtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown EnumerationType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnumerationTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnumerationTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnumerationTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnumerationType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnumerationTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enumerationtype.FieldStringRef) {
		fields = append(fields, enumerationtype.FieldStringRef)
	}
	if m.FieldCleared(enumerationtype.FieldHasTable) {
		fields = append(fields, enumerationtype.FieldHasTable)
	}
	if m.FieldCleared(enumerationtype.FieldDescription) {
		fields = append(fields, enumerationtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnumerationTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnumerationTypeMutation) ClearField(name string) error {
	switch name {
	case enumerationtype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case enumerationtype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case enumerationtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown EnumerationType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnumerationTypeMutation) ResetField(name string) error {
	switch name {
	case enumerationtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case enumerationtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case enumerationtype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case enumerationtype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case enumerationtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown EnumerationType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnumerationTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, enumerationtype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, enumerationtype.EdgeChildren)
	}
	if m.enumerations != nil {
		edges = append(edges, enumerationtype.EdgeEnumerations)
	}
	if m.child_enumeration_types != nil {
		edges = append(edges, enumerationtype.EdgeChildEnumerationTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnumerationTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enumerationtype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case enumerationtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case enumerationtype.EdgeEnumerations:
		ids := make([]ent.Value, 0, len(m.enumerations))
		for id := range m.enumerations {
			ids = append(ids, id)
		}
		return ids
	case enumerationtype.EdgeChildEnumerationTypes:
		ids := make([]ent.Value, 0, len(m.child_enumeration_types))
		for id := range m.child_enumeration_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnumerationTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, enumerationtype.EdgeChildren)
	}
	if m.removedenumerations != nil {
		edges = append(edges, enumerationtype.EdgeEnumerations)
	}
	if m.removedchild_enumeration_types != nil {
		edges = append(edges, enumerationtype.EdgeChildEnumerationTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnumerationTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enumerationtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case enumerationtype.EdgeEnumerations:
		ids := make([]ent.Value, 0, len(m.removedenumerations))
		for id := range m.removedenumerations {
			ids = append(ids, id)
		}
		return ids
	case enumerationtype.EdgeChildEnumerationTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_enumeration_types))
		for id := range m.removedchild_enumeration_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnumerationTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, enumerationtype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, enumerationtype.EdgeChildren)
	}
	if m.clearedenumerations {
		edges = append(edges, enumerationtype.EdgeEnumerations)
	}
	if m.clearedchild_enumeration_types {
		edges = append(edges, enumerationtype.EdgeChildEnumerationTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnumerationTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case enumerationtype.EdgeParent:
		return m.clearedparent
	case enumerationtype.EdgeChildren:
		return m.clearedchildren
	case enumerationtype.EdgeEnumerations:
		return m.clearedenumerations
	case enumerationtype.EdgeChildEnumerationTypes:
		return m.clearedchild_enumeration_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnumerationTypeMutation) ClearEdge(name string) error {
	switch name {
	case enumerationtype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown EnumerationType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnumerationTypeMutation) ResetEdge(name string) error {
	switch name {
	case enumerationtype.EdgeParent:
		m.ResetParent()
		return nil
	case enumerationtype.EdgeChildren:
		m.ResetChildren()
		return nil
	case enumerationtype.EdgeEnumerations:
		m.ResetEnumerations()
		return nil
	case enumerationtype.EdgeChildEnumerationTypes:
		m.ResetChildEnumerationTypes()
		return nil
	}
	return fmt.Errorf("unknown EnumerationType edge %s", name)
}

// FacilityAssocTypeMutation represents an operation that mutates the FacilityAssocType nodes in the graph.
type FacilityAssocTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FacilityAssocType, error)
	predicates    []predicate.FacilityAssocType
}

var _ ent.Mutation = (*FacilityAssocTypeMutation)(nil)

// facilityassoctypeOption allows management of the mutation configuration using functional options.
type facilityassoctypeOption func(*FacilityAssocTypeMutation)

// newFacilityAssocTypeMutation creates new mutation for the FacilityAssocType entity.
func newFacilityAssocTypeMutation(c config, op Op, opts ...facilityassoctypeOption) *FacilityAssocTypeMutation {
	m := &FacilityAssocTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFacilityAssocType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityAssocTypeID sets the ID field of the mutation.
func withFacilityAssocTypeID(id int) facilityassoctypeOption {
	return func(m *FacilityAssocTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FacilityAssocType
		)
		m.oldValue = func(ctx context.Context) (*FacilityAssocType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FacilityAssocType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacilityAssocType sets the old FacilityAssocType of the mutation.
func withFacilityAssocType(node *FacilityAssocType) facilityassoctypeOption {
	return func(m *FacilityAssocTypeMutation) {
		m.oldValue = func(context.Context) (*FacilityAssocType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityAssocTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityAssocTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityAssocTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *FacilityAssocTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FacilityAssocTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FacilityAssocType entity.
// If the FacilityAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityAssocTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FacilityAssocTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FacilityAssocTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FacilityAssocTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FacilityAssocType entity.
// If the FacilityAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityAssocTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FacilityAssocTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *FacilityAssocTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *FacilityAssocTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the FacilityAssocType entity.
// If the FacilityAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityAssocTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *FacilityAssocTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[facilityassoctype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *FacilityAssocTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[facilityassoctype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *FacilityAssocTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, facilityassoctype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *FacilityAssocTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FacilityAssocTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FacilityAssocType entity.
// If the FacilityAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityAssocTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FacilityAssocTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[facilityassoctype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FacilityAssocTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[facilityassoctype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FacilityAssocTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, facilityassoctype.FieldDescription)
}

// Op returns the operation name.
func (m *FacilityAssocTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FacilityAssocType).
func (m *FacilityAssocTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityAssocTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, facilityassoctype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, facilityassoctype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, facilityassoctype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, facilityassoctype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityAssocTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facilityassoctype.FieldCreateTime:
		return m.CreateTime()
	case facilityassoctype.FieldUpdateTime:
		return m.UpdateTime()
	case facilityassoctype.FieldStringRef:
		return m.StringRef()
	case facilityassoctype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityAssocTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facilityassoctype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case facilityassoctype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case facilityassoctype.FieldStringRef:
		return m.OldStringRef(ctx)
	case facilityassoctype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown FacilityAssocType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityAssocTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facilityassoctype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case facilityassoctype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case facilityassoctype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case facilityassoctype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown FacilityAssocType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityAssocTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityAssocTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityAssocTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FacilityAssocType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityAssocTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(facilityassoctype.FieldStringRef) {
		fields = append(fields, facilityassoctype.FieldStringRef)
	}
	if m.FieldCleared(facilityassoctype.FieldDescription) {
		fields = append(fields, facilityassoctype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityAssocTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityAssocTypeMutation) ClearField(name string) error {
	switch name {
	case facilityassoctype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case facilityassoctype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityAssocType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityAssocTypeMutation) ResetField(name string) error {
	switch name {
	case facilityassoctype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case facilityassoctype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case facilityassoctype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case facilityassoctype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityAssocType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityAssocTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityAssocTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityAssocTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityAssocTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityAssocTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityAssocTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityAssocTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FacilityAssocType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityAssocTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FacilityAssocType edge %s", name)
}

// FacilityGroupMutation represents an operation that mutates the FacilityGroup nodes in the graph.
type FacilityGroupMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	string_ref                 *string
	facility_group_name        *string
	description                *string
	clearedFields              map[string]struct{}
	facility_group_type        *int
	clearedfacility_group_type bool
	parent                     *int
	clearedparent              bool
	children                   map[int]struct{}
	removedchildren            map[int]struct{}
	clearedchildren            bool
	done                       bool
	oldValue                   func(context.Context) (*FacilityGroup, error)
	predicates                 []predicate.FacilityGroup
}

var _ ent.Mutation = (*FacilityGroupMutation)(nil)

// facilitygroupOption allows management of the mutation configuration using functional options.
type facilitygroupOption func(*FacilityGroupMutation)

// newFacilityGroupMutation creates new mutation for the FacilityGroup entity.
func newFacilityGroupMutation(c config, op Op, opts ...facilitygroupOption) *FacilityGroupMutation {
	m := &FacilityGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFacilityGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityGroupID sets the ID field of the mutation.
func withFacilityGroupID(id int) facilitygroupOption {
	return func(m *FacilityGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FacilityGroup
		)
		m.oldValue = func(ctx context.Context) (*FacilityGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FacilityGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacilityGroup sets the old FacilityGroup of the mutation.
func withFacilityGroup(node *FacilityGroup) facilitygroupOption {
	return func(m *FacilityGroupMutation) {
		m.oldValue = func(context.Context) (*FacilityGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *FacilityGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FacilityGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FacilityGroup entity.
// If the FacilityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FacilityGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FacilityGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FacilityGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FacilityGroup entity.
// If the FacilityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FacilityGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *FacilityGroupMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *FacilityGroupMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the FacilityGroup entity.
// If the FacilityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *FacilityGroupMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[facilitygroup.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *FacilityGroupMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[facilitygroup.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *FacilityGroupMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, facilitygroup.FieldStringRef)
}

// SetFacilityGroupName sets the "facility_group_name" field.
func (m *FacilityGroupMutation) SetFacilityGroupName(s string) {
	m.facility_group_name = &s
}

// FacilityGroupName returns the value of the "facility_group_name" field in the mutation.
func (m *FacilityGroupMutation) FacilityGroupName() (r string, exists bool) {
	v := m.facility_group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityGroupName returns the old "facility_group_name" field's value of the FacilityGroup entity.
// If the FacilityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupMutation) OldFacilityGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacilityGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacilityGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityGroupName: %w", err)
	}
	return oldValue.FacilityGroupName, nil
}

// ClearFacilityGroupName clears the value of the "facility_group_name" field.
func (m *FacilityGroupMutation) ClearFacilityGroupName() {
	m.facility_group_name = nil
	m.clearedFields[facilitygroup.FieldFacilityGroupName] = struct{}{}
}

// FacilityGroupNameCleared returns if the "facility_group_name" field was cleared in this mutation.
func (m *FacilityGroupMutation) FacilityGroupNameCleared() bool {
	_, ok := m.clearedFields[facilitygroup.FieldFacilityGroupName]
	return ok
}

// ResetFacilityGroupName resets all changes to the "facility_group_name" field.
func (m *FacilityGroupMutation) ResetFacilityGroupName() {
	m.facility_group_name = nil
	delete(m.clearedFields, facilitygroup.FieldFacilityGroupName)
}

// SetDescription sets the "description" field.
func (m *FacilityGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FacilityGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FacilityGroup entity.
// If the FacilityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FacilityGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[facilitygroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FacilityGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[facilitygroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FacilityGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, facilitygroup.FieldDescription)
}

// SetFacilityGroupTypeID sets the "facility_group_type" edge to the FacilityGroupType entity by id.
func (m *FacilityGroupMutation) SetFacilityGroupTypeID(id int) {
	m.facility_group_type = &id
}

// ClearFacilityGroupType clears the "facility_group_type" edge to the FacilityGroupType entity.
func (m *FacilityGroupMutation) ClearFacilityGroupType() {
	m.clearedfacility_group_type = true
}

// FacilityGroupTypeCleared reports if the "facility_group_type" edge to the FacilityGroupType entity was cleared.
func (m *FacilityGroupMutation) FacilityGroupTypeCleared() bool {
	return m.clearedfacility_group_type
}

// FacilityGroupTypeID returns the "facility_group_type" edge ID in the mutation.
func (m *FacilityGroupMutation) FacilityGroupTypeID() (id int, exists bool) {
	if m.facility_group_type != nil {
		return *m.facility_group_type, true
	}
	return
}

// FacilityGroupTypeIDs returns the "facility_group_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FacilityGroupTypeID instead. It exists only for internal usage by the builders.
func (m *FacilityGroupMutation) FacilityGroupTypeIDs() (ids []int) {
	if id := m.facility_group_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFacilityGroupType resets all changes to the "facility_group_type" edge.
func (m *FacilityGroupMutation) ResetFacilityGroupType() {
	m.facility_group_type = nil
	m.clearedfacility_group_type = false
}

// SetParentID sets the "parent" edge to the FacilityGroup entity by id.
func (m *FacilityGroupMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FacilityGroup entity.
func (m *FacilityGroupMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FacilityGroup entity was cleared.
func (m *FacilityGroupMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FacilityGroupMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FacilityGroupMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FacilityGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the FacilityGroup entity by ids.
func (m *FacilityGroupMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the FacilityGroup entity.
func (m *FacilityGroupMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the FacilityGroup entity was cleared.
func (m *FacilityGroupMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the FacilityGroup entity by IDs.
func (m *FacilityGroupMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the FacilityGroup entity.
func (m *FacilityGroupMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FacilityGroupMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FacilityGroupMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Op returns the operation name.
func (m *FacilityGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FacilityGroup).
func (m *FacilityGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, facilitygroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, facilitygroup.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, facilitygroup.FieldStringRef)
	}
	if m.facility_group_name != nil {
		fields = append(fields, facilitygroup.FieldFacilityGroupName)
	}
	if m.description != nil {
		fields = append(fields, facilitygroup.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facilitygroup.FieldCreateTime:
		return m.CreateTime()
	case facilitygroup.FieldUpdateTime:
		return m.UpdateTime()
	case facilitygroup.FieldStringRef:
		return m.StringRef()
	case facilitygroup.FieldFacilityGroupName:
		return m.FacilityGroupName()
	case facilitygroup.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facilitygroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case facilitygroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case facilitygroup.FieldStringRef:
		return m.OldStringRef(ctx)
	case facilitygroup.FieldFacilityGroupName:
		return m.OldFacilityGroupName(ctx)
	case facilitygroup.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown FacilityGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facilitygroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case facilitygroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case facilitygroup.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case facilitygroup.FieldFacilityGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityGroupName(v)
		return nil
	case facilitygroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown FacilityGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FacilityGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(facilitygroup.FieldStringRef) {
		fields = append(fields, facilitygroup.FieldStringRef)
	}
	if m.FieldCleared(facilitygroup.FieldFacilityGroupName) {
		fields = append(fields, facilitygroup.FieldFacilityGroupName)
	}
	if m.FieldCleared(facilitygroup.FieldDescription) {
		fields = append(fields, facilitygroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityGroupMutation) ClearField(name string) error {
	switch name {
	case facilitygroup.FieldStringRef:
		m.ClearStringRef()
		return nil
	case facilitygroup.FieldFacilityGroupName:
		m.ClearFacilityGroupName()
		return nil
	case facilitygroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityGroupMutation) ResetField(name string) error {
	switch name {
	case facilitygroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case facilitygroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case facilitygroup.FieldStringRef:
		m.ResetStringRef()
		return nil
	case facilitygroup.FieldFacilityGroupName:
		m.ResetFacilityGroupName()
		return nil
	case facilitygroup.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.facility_group_type != nil {
		edges = append(edges, facilitygroup.EdgeFacilityGroupType)
	}
	if m.parent != nil {
		edges = append(edges, facilitygroup.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, facilitygroup.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facilitygroup.EdgeFacilityGroupType:
		if id := m.facility_group_type; id != nil {
			return []ent.Value{*id}
		}
	case facilitygroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case facilitygroup.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, facilitygroup.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facilitygroup.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfacility_group_type {
		edges = append(edges, facilitygroup.EdgeFacilityGroupType)
	}
	if m.clearedparent {
		edges = append(edges, facilitygroup.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, facilitygroup.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case facilitygroup.EdgeFacilityGroupType:
		return m.clearedfacility_group_type
	case facilitygroup.EdgeParent:
		return m.clearedparent
	case facilitygroup.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityGroupMutation) ClearEdge(name string) error {
	switch name {
	case facilitygroup.EdgeFacilityGroupType:
		m.ClearFacilityGroupType()
		return nil
	case facilitygroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityGroupMutation) ResetEdge(name string) error {
	switch name {
	case facilitygroup.EdgeFacilityGroupType:
		m.ResetFacilityGroupType()
		return nil
	case facilitygroup.EdgeParent:
		m.ResetParent()
		return nil
	case facilitygroup.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroup edge %s", name)
}

// FacilityGroupTypeMutation represents an operation that mutates the FacilityGroupType nodes in the graph.
type FacilityGroupTypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	string_ref             *string
	description            *string
	clearedFields          map[string]struct{}
	facility_groups        map[int]struct{}
	removedfacility_groups map[int]struct{}
	clearedfacility_groups bool
	done                   bool
	oldValue               func(context.Context) (*FacilityGroupType, error)
	predicates             []predicate.FacilityGroupType
}

var _ ent.Mutation = (*FacilityGroupTypeMutation)(nil)

// facilitygrouptypeOption allows management of the mutation configuration using functional options.
type facilitygrouptypeOption func(*FacilityGroupTypeMutation)

// newFacilityGroupTypeMutation creates new mutation for the FacilityGroupType entity.
func newFacilityGroupTypeMutation(c config, op Op, opts ...facilitygrouptypeOption) *FacilityGroupTypeMutation {
	m := &FacilityGroupTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFacilityGroupType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityGroupTypeID sets the ID field of the mutation.
func withFacilityGroupTypeID(id int) facilitygrouptypeOption {
	return func(m *FacilityGroupTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FacilityGroupType
		)
		m.oldValue = func(ctx context.Context) (*FacilityGroupType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FacilityGroupType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacilityGroupType sets the old FacilityGroupType of the mutation.
func withFacilityGroupType(node *FacilityGroupType) facilitygrouptypeOption {
	return func(m *FacilityGroupTypeMutation) {
		m.oldValue = func(context.Context) (*FacilityGroupType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityGroupTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityGroupTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityGroupTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *FacilityGroupTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FacilityGroupTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FacilityGroupType entity.
// If the FacilityGroupType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FacilityGroupTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FacilityGroupTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FacilityGroupTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FacilityGroupType entity.
// If the FacilityGroupType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FacilityGroupTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *FacilityGroupTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *FacilityGroupTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the FacilityGroupType entity.
// If the FacilityGroupType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *FacilityGroupTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[facilitygrouptype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *FacilityGroupTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[facilitygrouptype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *FacilityGroupTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, facilitygrouptype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *FacilityGroupTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FacilityGroupTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FacilityGroupType entity.
// If the FacilityGroupType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityGroupTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FacilityGroupTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[facilitygrouptype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FacilityGroupTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[facilitygrouptype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FacilityGroupTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, facilitygrouptype.FieldDescription)
}

// AddFacilityGroupIDs adds the "facility_groups" edge to the FacilityGroup entity by ids.
func (m *FacilityGroupTypeMutation) AddFacilityGroupIDs(ids ...int) {
	if m.facility_groups == nil {
		m.facility_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.facility_groups[ids[i]] = struct{}{}
	}
}

// ClearFacilityGroups clears the "facility_groups" edge to the FacilityGroup entity.
func (m *FacilityGroupTypeMutation) ClearFacilityGroups() {
	m.clearedfacility_groups = true
}

// FacilityGroupsCleared reports if the "facility_groups" edge to the FacilityGroup entity was cleared.
func (m *FacilityGroupTypeMutation) FacilityGroupsCleared() bool {
	return m.clearedfacility_groups
}

// RemoveFacilityGroupIDs removes the "facility_groups" edge to the FacilityGroup entity by IDs.
func (m *FacilityGroupTypeMutation) RemoveFacilityGroupIDs(ids ...int) {
	if m.removedfacility_groups == nil {
		m.removedfacility_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfacility_groups[ids[i]] = struct{}{}
	}
}

// RemovedFacilityGroups returns the removed IDs of the "facility_groups" edge to the FacilityGroup entity.
func (m *FacilityGroupTypeMutation) RemovedFacilityGroupsIDs() (ids []int) {
	for id := range m.removedfacility_groups {
		ids = append(ids, id)
	}
	return
}

// FacilityGroupsIDs returns the "facility_groups" edge IDs in the mutation.
func (m *FacilityGroupTypeMutation) FacilityGroupsIDs() (ids []int) {
	for id := range m.facility_groups {
		ids = append(ids, id)
	}
	return
}

// ResetFacilityGroups resets all changes to the "facility_groups" edge.
func (m *FacilityGroupTypeMutation) ResetFacilityGroups() {
	m.facility_groups = nil
	m.clearedfacility_groups = false
	m.removedfacility_groups = nil
}

// Op returns the operation name.
func (m *FacilityGroupTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FacilityGroupType).
func (m *FacilityGroupTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityGroupTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, facilitygrouptype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, facilitygrouptype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, facilitygrouptype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, facilitygrouptype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityGroupTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facilitygrouptype.FieldCreateTime:
		return m.CreateTime()
	case facilitygrouptype.FieldUpdateTime:
		return m.UpdateTime()
	case facilitygrouptype.FieldStringRef:
		return m.StringRef()
	case facilitygrouptype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityGroupTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facilitygrouptype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case facilitygrouptype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case facilitygrouptype.FieldStringRef:
		return m.OldStringRef(ctx)
	case facilitygrouptype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown FacilityGroupType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityGroupTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facilitygrouptype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case facilitygrouptype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case facilitygrouptype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case facilitygrouptype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown FacilityGroupType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityGroupTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityGroupTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityGroupTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FacilityGroupType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityGroupTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(facilitygrouptype.FieldStringRef) {
		fields = append(fields, facilitygrouptype.FieldStringRef)
	}
	if m.FieldCleared(facilitygrouptype.FieldDescription) {
		fields = append(fields, facilitygrouptype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityGroupTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityGroupTypeMutation) ClearField(name string) error {
	switch name {
	case facilitygrouptype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case facilitygrouptype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroupType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityGroupTypeMutation) ResetField(name string) error {
	switch name {
	case facilitygrouptype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case facilitygrouptype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case facilitygrouptype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case facilitygrouptype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroupType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityGroupTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.facility_groups != nil {
		edges = append(edges, facilitygrouptype.EdgeFacilityGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityGroupTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facilitygrouptype.EdgeFacilityGroups:
		ids := make([]ent.Value, 0, len(m.facility_groups))
		for id := range m.facility_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityGroupTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfacility_groups != nil {
		edges = append(edges, facilitygrouptype.EdgeFacilityGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityGroupTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facilitygrouptype.EdgeFacilityGroups:
		ids := make([]ent.Value, 0, len(m.removedfacility_groups))
		for id := range m.removedfacility_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityGroupTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfacility_groups {
		edges = append(edges, facilitygrouptype.EdgeFacilityGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityGroupTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case facilitygrouptype.EdgeFacilityGroups:
		return m.clearedfacility_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityGroupTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FacilityGroupType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityGroupTypeMutation) ResetEdge(name string) error {
	switch name {
	case facilitygrouptype.EdgeFacilityGroups:
		m.ResetFacilityGroups()
		return nil
	}
	return fmt.Errorf("unknown FacilityGroupType edge %s", name)
}

// FacilityTypeMutation represents an operation that mutates the FacilityType nodes in the graph.
type FacilityTypeMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	string_ref                  *string
	has_table                   *facilitytype.HasTable
	description                 *string
	clearedFields               map[string]struct{}
	parent                      *int
	clearedparent               bool
	children                    map[int]struct{}
	removedchildren             map[int]struct{}
	clearedchildren             bool
	child_facility_types        map[int]struct{}
	removedchild_facility_types map[int]struct{}
	clearedchild_facility_types bool
	done                        bool
	oldValue                    func(context.Context) (*FacilityType, error)
	predicates                  []predicate.FacilityType
}

var _ ent.Mutation = (*FacilityTypeMutation)(nil)

// facilitytypeOption allows management of the mutation configuration using functional options.
type facilitytypeOption func(*FacilityTypeMutation)

// newFacilityTypeMutation creates new mutation for the FacilityType entity.
func newFacilityTypeMutation(c config, op Op, opts ...facilitytypeOption) *FacilityTypeMutation {
	m := &FacilityTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFacilityType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFacilityTypeID sets the ID field of the mutation.
func withFacilityTypeID(id int) facilitytypeOption {
	return func(m *FacilityTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FacilityType
		)
		m.oldValue = func(ctx context.Context) (*FacilityType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FacilityType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFacilityType sets the old FacilityType of the mutation.
func withFacilityType(node *FacilityType) facilitytypeOption {
	return func(m *FacilityTypeMutation) {
		m.oldValue = func(context.Context) (*FacilityType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FacilityTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FacilityTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FacilityTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *FacilityTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FacilityTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the FacilityType entity.
// If the FacilityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FacilityTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FacilityTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FacilityTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the FacilityType entity.
// If the FacilityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FacilityTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *FacilityTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *FacilityTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the FacilityType entity.
// If the FacilityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *FacilityTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[facilitytype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *FacilityTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[facilitytype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *FacilityTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, facilitytype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *FacilityTypeMutation) SetHasTable(ft facilitytype.HasTable) {
	m.has_table = &ft
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *FacilityTypeMutation) HasTable() (r facilitytype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the FacilityType entity.
// If the FacilityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityTypeMutation) OldHasTable(ctx context.Context) (v facilitytype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *FacilityTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[facilitytype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *FacilityTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[facilitytype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *FacilityTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, facilitytype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *FacilityTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FacilityTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FacilityType entity.
// If the FacilityType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FacilityTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FacilityTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[facilitytype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FacilityTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[facilitytype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FacilityTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, facilitytype.FieldDescription)
}

// SetParentID sets the "parent" edge to the FacilityType entity by id.
func (m *FacilityTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FacilityType entity.
func (m *FacilityTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FacilityType entity was cleared.
func (m *FacilityTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FacilityTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FacilityTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FacilityTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the FacilityType entity by ids.
func (m *FacilityTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the FacilityType entity.
func (m *FacilityTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the FacilityType entity was cleared.
func (m *FacilityTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the FacilityType entity by IDs.
func (m *FacilityTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the FacilityType entity.
func (m *FacilityTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FacilityTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FacilityTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildFacilityTypeIDs adds the "child_facility_types" edge to the FacilityType entity by ids.
func (m *FacilityTypeMutation) AddChildFacilityTypeIDs(ids ...int) {
	if m.child_facility_types == nil {
		m.child_facility_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_facility_types[ids[i]] = struct{}{}
	}
}

// ClearChildFacilityTypes clears the "child_facility_types" edge to the FacilityType entity.
func (m *FacilityTypeMutation) ClearChildFacilityTypes() {
	m.clearedchild_facility_types = true
}

// ChildFacilityTypesCleared reports if the "child_facility_types" edge to the FacilityType entity was cleared.
func (m *FacilityTypeMutation) ChildFacilityTypesCleared() bool {
	return m.clearedchild_facility_types
}

// RemoveChildFacilityTypeIDs removes the "child_facility_types" edge to the FacilityType entity by IDs.
func (m *FacilityTypeMutation) RemoveChildFacilityTypeIDs(ids ...int) {
	if m.removedchild_facility_types == nil {
		m.removedchild_facility_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_facility_types[ids[i]] = struct{}{}
	}
}

// RemovedChildFacilityTypes returns the removed IDs of the "child_facility_types" edge to the FacilityType entity.
func (m *FacilityTypeMutation) RemovedChildFacilityTypesIDs() (ids []int) {
	for id := range m.removedchild_facility_types {
		ids = append(ids, id)
	}
	return
}

// ChildFacilityTypesIDs returns the "child_facility_types" edge IDs in the mutation.
func (m *FacilityTypeMutation) ChildFacilityTypesIDs() (ids []int) {
	for id := range m.child_facility_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildFacilityTypes resets all changes to the "child_facility_types" edge.
func (m *FacilityTypeMutation) ResetChildFacilityTypes() {
	m.child_facility_types = nil
	m.clearedchild_facility_types = false
	m.removedchild_facility_types = nil
}

// Op returns the operation name.
func (m *FacilityTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FacilityType).
func (m *FacilityTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FacilityTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, facilitytype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, facilitytype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, facilitytype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, facilitytype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, facilitytype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FacilityTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case facilitytype.FieldCreateTime:
		return m.CreateTime()
	case facilitytype.FieldUpdateTime:
		return m.UpdateTime()
	case facilitytype.FieldStringRef:
		return m.StringRef()
	case facilitytype.FieldHasTable:
		return m.HasTable()
	case facilitytype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FacilityTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case facilitytype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case facilitytype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case facilitytype.FieldStringRef:
		return m.OldStringRef(ctx)
	case facilitytype.FieldHasTable:
		return m.OldHasTable(ctx)
	case facilitytype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown FacilityType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case facilitytype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case facilitytype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case facilitytype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case facilitytype.FieldHasTable:
		v, ok := value.(facilitytype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case facilitytype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown FacilityType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FacilityTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FacilityTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FacilityTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FacilityType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FacilityTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(facilitytype.FieldStringRef) {
		fields = append(fields, facilitytype.FieldStringRef)
	}
	if m.FieldCleared(facilitytype.FieldHasTable) {
		fields = append(fields, facilitytype.FieldHasTable)
	}
	if m.FieldCleared(facilitytype.FieldDescription) {
		fields = append(fields, facilitytype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FacilityTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FacilityTypeMutation) ClearField(name string) error {
	switch name {
	case facilitytype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case facilitytype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case facilitytype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FacilityTypeMutation) ResetField(name string) error {
	switch name {
	case facilitytype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case facilitytype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case facilitytype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case facilitytype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case facilitytype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown FacilityType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FacilityTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, facilitytype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, facilitytype.EdgeChildren)
	}
	if m.child_facility_types != nil {
		edges = append(edges, facilitytype.EdgeChildFacilityTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FacilityTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case facilitytype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case facilitytype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case facilitytype.EdgeChildFacilityTypes:
		ids := make([]ent.Value, 0, len(m.child_facility_types))
		for id := range m.child_facility_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FacilityTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, facilitytype.EdgeChildren)
	}
	if m.removedchild_facility_types != nil {
		edges = append(edges, facilitytype.EdgeChildFacilityTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FacilityTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case facilitytype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case facilitytype.EdgeChildFacilityTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_facility_types))
		for id := range m.removedchild_facility_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FacilityTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, facilitytype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, facilitytype.EdgeChildren)
	}
	if m.clearedchild_facility_types {
		edges = append(edges, facilitytype.EdgeChildFacilityTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FacilityTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case facilitytype.EdgeParent:
		return m.clearedparent
	case facilitytype.EdgeChildren:
		return m.clearedchildren
	case facilitytype.EdgeChildFacilityTypes:
		return m.clearedchild_facility_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FacilityTypeMutation) ClearEdge(name string) error {
	switch name {
	case facilitytype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FacilityType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FacilityTypeMutation) ResetEdge(name string) error {
	switch name {
	case facilitytype.EdgeParent:
		m.ResetParent()
		return nil
	case facilitytype.EdgeChildren:
		m.ResetChildren()
		return nil
	case facilitytype.EdgeChildFacilityTypes:
		m.ResetChildFacilityTypes()
		return nil
	}
	return fmt.Errorf("unknown FacilityType edge %s", name)
}

// GoodIdentificationTypeMutation represents an operation that mutates the GoodIdentificationType nodes in the graph.
type GoodIdentificationTypeMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	create_time                            *time.Time
	update_time                            *time.Time
	string_ref                             *string
	has_table                              *goodidentificationtype.HasTable
	description                            *string
	clearedFields                          map[string]struct{}
	parent                                 *int
	clearedparent                          bool
	children                               map[int]struct{}
	removedchildren                        map[int]struct{}
	clearedchildren                        bool
	child_good_identification_types        map[int]struct{}
	removedchild_good_identification_types map[int]struct{}
	clearedchild_good_identification_types bool
	done                                   bool
	oldValue                               func(context.Context) (*GoodIdentificationType, error)
	predicates                             []predicate.GoodIdentificationType
}

var _ ent.Mutation = (*GoodIdentificationTypeMutation)(nil)

// goodidentificationtypeOption allows management of the mutation configuration using functional options.
type goodidentificationtypeOption func(*GoodIdentificationTypeMutation)

// newGoodIdentificationTypeMutation creates new mutation for the GoodIdentificationType entity.
func newGoodIdentificationTypeMutation(c config, op Op, opts ...goodidentificationtypeOption) *GoodIdentificationTypeMutation {
	m := &GoodIdentificationTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodIdentificationType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodIdentificationTypeID sets the ID field of the mutation.
func withGoodIdentificationTypeID(id int) goodidentificationtypeOption {
	return func(m *GoodIdentificationTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodIdentificationType
		)
		m.oldValue = func(ctx context.Context) (*GoodIdentificationType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodIdentificationType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodIdentificationType sets the old GoodIdentificationType of the mutation.
func withGoodIdentificationType(node *GoodIdentificationType) goodidentificationtypeOption {
	return func(m *GoodIdentificationTypeMutation) {
		m.oldValue = func(context.Context) (*GoodIdentificationType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodIdentificationTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodIdentificationTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodIdentificationTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *GoodIdentificationTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GoodIdentificationTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the GoodIdentificationType entity.
// If the GoodIdentificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodIdentificationTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GoodIdentificationTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GoodIdentificationTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GoodIdentificationTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the GoodIdentificationType entity.
// If the GoodIdentificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodIdentificationTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GoodIdentificationTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *GoodIdentificationTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *GoodIdentificationTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the GoodIdentificationType entity.
// If the GoodIdentificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodIdentificationTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *GoodIdentificationTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[goodidentificationtype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *GoodIdentificationTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[goodidentificationtype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *GoodIdentificationTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, goodidentificationtype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *GoodIdentificationTypeMutation) SetHasTable(gt goodidentificationtype.HasTable) {
	m.has_table = &gt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *GoodIdentificationTypeMutation) HasTable() (r goodidentificationtype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the GoodIdentificationType entity.
// If the GoodIdentificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodIdentificationTypeMutation) OldHasTable(ctx context.Context) (v goodidentificationtype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *GoodIdentificationTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[goodidentificationtype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *GoodIdentificationTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[goodidentificationtype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *GoodIdentificationTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, goodidentificationtype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *GoodIdentificationTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GoodIdentificationTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GoodIdentificationType entity.
// If the GoodIdentificationType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodIdentificationTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GoodIdentificationTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[goodidentificationtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GoodIdentificationTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[goodidentificationtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GoodIdentificationTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, goodidentificationtype.FieldDescription)
}

// SetParentID sets the "parent" edge to the GoodIdentificationType entity by id.
func (m *GoodIdentificationTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the GoodIdentificationType entity.
func (m *GoodIdentificationTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the GoodIdentificationType entity was cleared.
func (m *GoodIdentificationTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *GoodIdentificationTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *GoodIdentificationTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *GoodIdentificationTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the GoodIdentificationType entity by ids.
func (m *GoodIdentificationTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the GoodIdentificationType entity.
func (m *GoodIdentificationTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the GoodIdentificationType entity was cleared.
func (m *GoodIdentificationTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the GoodIdentificationType entity by IDs.
func (m *GoodIdentificationTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the GoodIdentificationType entity.
func (m *GoodIdentificationTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *GoodIdentificationTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *GoodIdentificationTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildGoodIdentificationTypeIDs adds the "child_good_identification_types" edge to the GoodIdentificationType entity by ids.
func (m *GoodIdentificationTypeMutation) AddChildGoodIdentificationTypeIDs(ids ...int) {
	if m.child_good_identification_types == nil {
		m.child_good_identification_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_good_identification_types[ids[i]] = struct{}{}
	}
}

// ClearChildGoodIdentificationTypes clears the "child_good_identification_types" edge to the GoodIdentificationType entity.
func (m *GoodIdentificationTypeMutation) ClearChildGoodIdentificationTypes() {
	m.clearedchild_good_identification_types = true
}

// ChildGoodIdentificationTypesCleared reports if the "child_good_identification_types" edge to the GoodIdentificationType entity was cleared.
func (m *GoodIdentificationTypeMutation) ChildGoodIdentificationTypesCleared() bool {
	return m.clearedchild_good_identification_types
}

// RemoveChildGoodIdentificationTypeIDs removes the "child_good_identification_types" edge to the GoodIdentificationType entity by IDs.
func (m *GoodIdentificationTypeMutation) RemoveChildGoodIdentificationTypeIDs(ids ...int) {
	if m.removedchild_good_identification_types == nil {
		m.removedchild_good_identification_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_good_identification_types[ids[i]] = struct{}{}
	}
}

// RemovedChildGoodIdentificationTypes returns the removed IDs of the "child_good_identification_types" edge to the GoodIdentificationType entity.
func (m *GoodIdentificationTypeMutation) RemovedChildGoodIdentificationTypesIDs() (ids []int) {
	for id := range m.removedchild_good_identification_types {
		ids = append(ids, id)
	}
	return
}

// ChildGoodIdentificationTypesIDs returns the "child_good_identification_types" edge IDs in the mutation.
func (m *GoodIdentificationTypeMutation) ChildGoodIdentificationTypesIDs() (ids []int) {
	for id := range m.child_good_identification_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildGoodIdentificationTypes resets all changes to the "child_good_identification_types" edge.
func (m *GoodIdentificationTypeMutation) ResetChildGoodIdentificationTypes() {
	m.child_good_identification_types = nil
	m.clearedchild_good_identification_types = false
	m.removedchild_good_identification_types = nil
}

// Op returns the operation name.
func (m *GoodIdentificationTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodIdentificationType).
func (m *GoodIdentificationTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodIdentificationTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, goodidentificationtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, goodidentificationtype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, goodidentificationtype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, goodidentificationtype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, goodidentificationtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodIdentificationTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodidentificationtype.FieldCreateTime:
		return m.CreateTime()
	case goodidentificationtype.FieldUpdateTime:
		return m.UpdateTime()
	case goodidentificationtype.FieldStringRef:
		return m.StringRef()
	case goodidentificationtype.FieldHasTable:
		return m.HasTable()
	case goodidentificationtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodIdentificationTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodidentificationtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case goodidentificationtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case goodidentificationtype.FieldStringRef:
		return m.OldStringRef(ctx)
	case goodidentificationtype.FieldHasTable:
		return m.OldHasTable(ctx)
	case goodidentificationtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown GoodIdentificationType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodIdentificationTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodidentificationtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case goodidentificationtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case goodidentificationtype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case goodidentificationtype.FieldHasTable:
		v, ok := value.(goodidentificationtype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case goodidentificationtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown GoodIdentificationType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodIdentificationTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodIdentificationTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodIdentificationTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoodIdentificationType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodIdentificationTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goodidentificationtype.FieldStringRef) {
		fields = append(fields, goodidentificationtype.FieldStringRef)
	}
	if m.FieldCleared(goodidentificationtype.FieldHasTable) {
		fields = append(fields, goodidentificationtype.FieldHasTable)
	}
	if m.FieldCleared(goodidentificationtype.FieldDescription) {
		fields = append(fields, goodidentificationtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodIdentificationTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodIdentificationTypeMutation) ClearField(name string) error {
	switch name {
	case goodidentificationtype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case goodidentificationtype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case goodidentificationtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown GoodIdentificationType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodIdentificationTypeMutation) ResetField(name string) error {
	switch name {
	case goodidentificationtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case goodidentificationtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case goodidentificationtype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case goodidentificationtype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case goodidentificationtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown GoodIdentificationType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodIdentificationTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, goodidentificationtype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, goodidentificationtype.EdgeChildren)
	}
	if m.child_good_identification_types != nil {
		edges = append(edges, goodidentificationtype.EdgeChildGoodIdentificationTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodIdentificationTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goodidentificationtype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case goodidentificationtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case goodidentificationtype.EdgeChildGoodIdentificationTypes:
		ids := make([]ent.Value, 0, len(m.child_good_identification_types))
		for id := range m.child_good_identification_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodIdentificationTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, goodidentificationtype.EdgeChildren)
	}
	if m.removedchild_good_identification_types != nil {
		edges = append(edges, goodidentificationtype.EdgeChildGoodIdentificationTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodIdentificationTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goodidentificationtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case goodidentificationtype.EdgeChildGoodIdentificationTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_good_identification_types))
		for id := range m.removedchild_good_identification_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodIdentificationTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, goodidentificationtype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, goodidentificationtype.EdgeChildren)
	}
	if m.clearedchild_good_identification_types {
		edges = append(edges, goodidentificationtype.EdgeChildGoodIdentificationTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodIdentificationTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case goodidentificationtype.EdgeParent:
		return m.clearedparent
	case goodidentificationtype.EdgeChildren:
		return m.clearedchildren
	case goodidentificationtype.EdgeChildGoodIdentificationTypes:
		return m.clearedchild_good_identification_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodIdentificationTypeMutation) ClearEdge(name string) error {
	switch name {
	case goodidentificationtype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown GoodIdentificationType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodIdentificationTypeMutation) ResetEdge(name string) error {
	switch name {
	case goodidentificationtype.EdgeParent:
		m.ResetParent()
		return nil
	case goodidentificationtype.EdgeChildren:
		m.ResetChildren()
		return nil
	case goodidentificationtype.EdgeChildGoodIdentificationTypes:
		m.ResetChildGoodIdentificationTypes()
		return nil
	}
	return fmt.Errorf("unknown GoodIdentificationType edge %s", name)
}

// InventoryItemDetailMutation represents an operation that mutates the InventoryItemDetail nodes in the graph.
type InventoryItemDetailMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	string_ref                         *string
	inventory_item_detail_seq_id       *int
	addinventory_item_detail_seq_id    *int
	effective_date                     *time.Time
	quantity_on_hand_diff              *float64
	addquantity_on_hand_diff           *float64
	available_to_promise_diff          *float64
	addavailable_to_promise_diff       *float64
	accounting_quantity_diff           *float64
	addaccounting_quantity_diff        *float64
	unit_cost                          *float64
	addunit_cost                       *float64
	order_item_seq_id                  *int
	addorder_item_seq_id               *int
	ship_group_seq_id                  *int
	addship_group_seq_id               *int
	shipment_id                        *int
	addshipment_id                     *int
	shipment_item_seq_id               *int
	addshipment_item_seq_id            *int
	return_id                          *int
	addreturn_id                       *int
	return_item_seq_id                 *int
	addreturn_item_seq_id              *int
	work_effort_id                     *int
	addwork_effort_id                  *int
	fixed_asset_id                     *int
	addfixed_asset_id                  *int
	maint_hist_seq_id                  *int
	addmaint_hist_seq_id               *int
	item_issuance_id                   *int
	additem_issuance_id                *int
	receipt_id                         *int
	addreceipt_id                      *int
	physical_inventory_id              *int
	addphysical_inventory_id           *int
	description                        *string
	clearedFields                      map[string]struct{}
	order_item_ship_grp_inv_res        *int
	clearedorder_item_ship_grp_inv_res bool
	reason_enumeration                 *int
	clearedreason_enumeration          bool
	done                               bool
	oldValue                           func(context.Context) (*InventoryItemDetail, error)
	predicates                         []predicate.InventoryItemDetail
}

var _ ent.Mutation = (*InventoryItemDetailMutation)(nil)

// inventoryitemdetailOption allows management of the mutation configuration using functional options.
type inventoryitemdetailOption func(*InventoryItemDetailMutation)

// newInventoryItemDetailMutation creates new mutation for the InventoryItemDetail entity.
func newInventoryItemDetailMutation(c config, op Op, opts ...inventoryitemdetailOption) *InventoryItemDetailMutation {
	m := &InventoryItemDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryItemDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryItemDetailID sets the ID field of the mutation.
func withInventoryItemDetailID(id int) inventoryitemdetailOption {
	return func(m *InventoryItemDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryItemDetail
		)
		m.oldValue = func(ctx context.Context) (*InventoryItemDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryItemDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryItemDetail sets the old InventoryItemDetail of the mutation.
func withInventoryItemDetail(node *InventoryItemDetail) inventoryitemdetailOption {
	return func(m *InventoryItemDetailMutation) {
		m.oldValue = func(context.Context) (*InventoryItemDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryItemDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryItemDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryItemDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *InventoryItemDetailMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InventoryItemDetailMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InventoryItemDetailMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InventoryItemDetailMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InventoryItemDetailMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InventoryItemDetailMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *InventoryItemDetailMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *InventoryItemDetailMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *InventoryItemDetailMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[inventoryitemdetail.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *InventoryItemDetailMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, inventoryitemdetail.FieldStringRef)
}

// SetInventoryItemDetailSeqID sets the "inventory_item_detail_seq_id" field.
func (m *InventoryItemDetailMutation) SetInventoryItemDetailSeqID(i int) {
	m.inventory_item_detail_seq_id = &i
	m.addinventory_item_detail_seq_id = nil
}

// InventoryItemDetailSeqID returns the value of the "inventory_item_detail_seq_id" field in the mutation.
func (m *InventoryItemDetailMutation) InventoryItemDetailSeqID() (r int, exists bool) {
	v := m.inventory_item_detail_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryItemDetailSeqID returns the old "inventory_item_detail_seq_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldInventoryItemDetailSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventoryItemDetailSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventoryItemDetailSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryItemDetailSeqID: %w", err)
	}
	return oldValue.InventoryItemDetailSeqID, nil
}

// AddInventoryItemDetailSeqID adds i to the "inventory_item_detail_seq_id" field.
func (m *InventoryItemDetailMutation) AddInventoryItemDetailSeqID(i int) {
	if m.addinventory_item_detail_seq_id != nil {
		*m.addinventory_item_detail_seq_id += i
	} else {
		m.addinventory_item_detail_seq_id = &i
	}
}

// AddedInventoryItemDetailSeqID returns the value that was added to the "inventory_item_detail_seq_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedInventoryItemDetailSeqID() (r int, exists bool) {
	v := m.addinventory_item_detail_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetInventoryItemDetailSeqID resets all changes to the "inventory_item_detail_seq_id" field.
func (m *InventoryItemDetailMutation) ResetInventoryItemDetailSeqID() {
	m.inventory_item_detail_seq_id = nil
	m.addinventory_item_detail_seq_id = nil
}

// SetEffectiveDate sets the "effective_date" field.
func (m *InventoryItemDetailMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *InventoryItemDetailMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldEffectiveDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *InventoryItemDetailMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[inventoryitemdetail.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *InventoryItemDetailMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, inventoryitemdetail.FieldEffectiveDate)
}

// SetQuantityOnHandDiff sets the "quantity_on_hand_diff" field.
func (m *InventoryItemDetailMutation) SetQuantityOnHandDiff(f float64) {
	m.quantity_on_hand_diff = &f
	m.addquantity_on_hand_diff = nil
}

// QuantityOnHandDiff returns the value of the "quantity_on_hand_diff" field in the mutation.
func (m *InventoryItemDetailMutation) QuantityOnHandDiff() (r float64, exists bool) {
	v := m.quantity_on_hand_diff
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityOnHandDiff returns the old "quantity_on_hand_diff" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldQuantityOnHandDiff(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityOnHandDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityOnHandDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityOnHandDiff: %w", err)
	}
	return oldValue.QuantityOnHandDiff, nil
}

// AddQuantityOnHandDiff adds f to the "quantity_on_hand_diff" field.
func (m *InventoryItemDetailMutation) AddQuantityOnHandDiff(f float64) {
	if m.addquantity_on_hand_diff != nil {
		*m.addquantity_on_hand_diff += f
	} else {
		m.addquantity_on_hand_diff = &f
	}
}

// AddedQuantityOnHandDiff returns the value that was added to the "quantity_on_hand_diff" field in this mutation.
func (m *InventoryItemDetailMutation) AddedQuantityOnHandDiff() (r float64, exists bool) {
	v := m.addquantity_on_hand_diff
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityOnHandDiff clears the value of the "quantity_on_hand_diff" field.
func (m *InventoryItemDetailMutation) ClearQuantityOnHandDiff() {
	m.quantity_on_hand_diff = nil
	m.addquantity_on_hand_diff = nil
	m.clearedFields[inventoryitemdetail.FieldQuantityOnHandDiff] = struct{}{}
}

// QuantityOnHandDiffCleared returns if the "quantity_on_hand_diff" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) QuantityOnHandDiffCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldQuantityOnHandDiff]
	return ok
}

// ResetQuantityOnHandDiff resets all changes to the "quantity_on_hand_diff" field.
func (m *InventoryItemDetailMutation) ResetQuantityOnHandDiff() {
	m.quantity_on_hand_diff = nil
	m.addquantity_on_hand_diff = nil
	delete(m.clearedFields, inventoryitemdetail.FieldQuantityOnHandDiff)
}

// SetAvailableToPromiseDiff sets the "available_to_promise_diff" field.
func (m *InventoryItemDetailMutation) SetAvailableToPromiseDiff(f float64) {
	m.available_to_promise_diff = &f
	m.addavailable_to_promise_diff = nil
}

// AvailableToPromiseDiff returns the value of the "available_to_promise_diff" field in the mutation.
func (m *InventoryItemDetailMutation) AvailableToPromiseDiff() (r float64, exists bool) {
	v := m.available_to_promise_diff
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableToPromiseDiff returns the old "available_to_promise_diff" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldAvailableToPromiseDiff(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvailableToPromiseDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvailableToPromiseDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableToPromiseDiff: %w", err)
	}
	return oldValue.AvailableToPromiseDiff, nil
}

// AddAvailableToPromiseDiff adds f to the "available_to_promise_diff" field.
func (m *InventoryItemDetailMutation) AddAvailableToPromiseDiff(f float64) {
	if m.addavailable_to_promise_diff != nil {
		*m.addavailable_to_promise_diff += f
	} else {
		m.addavailable_to_promise_diff = &f
	}
}

// AddedAvailableToPromiseDiff returns the value that was added to the "available_to_promise_diff" field in this mutation.
func (m *InventoryItemDetailMutation) AddedAvailableToPromiseDiff() (r float64, exists bool) {
	v := m.addavailable_to_promise_diff
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvailableToPromiseDiff clears the value of the "available_to_promise_diff" field.
func (m *InventoryItemDetailMutation) ClearAvailableToPromiseDiff() {
	m.available_to_promise_diff = nil
	m.addavailable_to_promise_diff = nil
	m.clearedFields[inventoryitemdetail.FieldAvailableToPromiseDiff] = struct{}{}
}

// AvailableToPromiseDiffCleared returns if the "available_to_promise_diff" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) AvailableToPromiseDiffCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldAvailableToPromiseDiff]
	return ok
}

// ResetAvailableToPromiseDiff resets all changes to the "available_to_promise_diff" field.
func (m *InventoryItemDetailMutation) ResetAvailableToPromiseDiff() {
	m.available_to_promise_diff = nil
	m.addavailable_to_promise_diff = nil
	delete(m.clearedFields, inventoryitemdetail.FieldAvailableToPromiseDiff)
}

// SetAccountingQuantityDiff sets the "accounting_quantity_diff" field.
func (m *InventoryItemDetailMutation) SetAccountingQuantityDiff(f float64) {
	m.accounting_quantity_diff = &f
	m.addaccounting_quantity_diff = nil
}

// AccountingQuantityDiff returns the value of the "accounting_quantity_diff" field in the mutation.
func (m *InventoryItemDetailMutation) AccountingQuantityDiff() (r float64, exists bool) {
	v := m.accounting_quantity_diff
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingQuantityDiff returns the old "accounting_quantity_diff" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldAccountingQuantityDiff(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountingQuantityDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountingQuantityDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingQuantityDiff: %w", err)
	}
	return oldValue.AccountingQuantityDiff, nil
}

// AddAccountingQuantityDiff adds f to the "accounting_quantity_diff" field.
func (m *InventoryItemDetailMutation) AddAccountingQuantityDiff(f float64) {
	if m.addaccounting_quantity_diff != nil {
		*m.addaccounting_quantity_diff += f
	} else {
		m.addaccounting_quantity_diff = &f
	}
}

// AddedAccountingQuantityDiff returns the value that was added to the "accounting_quantity_diff" field in this mutation.
func (m *InventoryItemDetailMutation) AddedAccountingQuantityDiff() (r float64, exists bool) {
	v := m.addaccounting_quantity_diff
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccountingQuantityDiff clears the value of the "accounting_quantity_diff" field.
func (m *InventoryItemDetailMutation) ClearAccountingQuantityDiff() {
	m.accounting_quantity_diff = nil
	m.addaccounting_quantity_diff = nil
	m.clearedFields[inventoryitemdetail.FieldAccountingQuantityDiff] = struct{}{}
}

// AccountingQuantityDiffCleared returns if the "accounting_quantity_diff" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) AccountingQuantityDiffCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldAccountingQuantityDiff]
	return ok
}

// ResetAccountingQuantityDiff resets all changes to the "accounting_quantity_diff" field.
func (m *InventoryItemDetailMutation) ResetAccountingQuantityDiff() {
	m.accounting_quantity_diff = nil
	m.addaccounting_quantity_diff = nil
	delete(m.clearedFields, inventoryitemdetail.FieldAccountingQuantityDiff)
}

// SetUnitCost sets the "unit_cost" field.
func (m *InventoryItemDetailMutation) SetUnitCost(f float64) {
	m.unit_cost = &f
	m.addunit_cost = nil
}

// UnitCost returns the value of the "unit_cost" field in the mutation.
func (m *InventoryItemDetailMutation) UnitCost() (r float64, exists bool) {
	v := m.unit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitCost returns the old "unit_cost" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldUnitCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnitCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnitCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitCost: %w", err)
	}
	return oldValue.UnitCost, nil
}

// AddUnitCost adds f to the "unit_cost" field.
func (m *InventoryItemDetailMutation) AddUnitCost(f float64) {
	if m.addunit_cost != nil {
		*m.addunit_cost += f
	} else {
		m.addunit_cost = &f
	}
}

// AddedUnitCost returns the value that was added to the "unit_cost" field in this mutation.
func (m *InventoryItemDetailMutation) AddedUnitCost() (r float64, exists bool) {
	v := m.addunit_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitCost clears the value of the "unit_cost" field.
func (m *InventoryItemDetailMutation) ClearUnitCost() {
	m.unit_cost = nil
	m.addunit_cost = nil
	m.clearedFields[inventoryitemdetail.FieldUnitCost] = struct{}{}
}

// UnitCostCleared returns if the "unit_cost" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) UnitCostCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldUnitCost]
	return ok
}

// ResetUnitCost resets all changes to the "unit_cost" field.
func (m *InventoryItemDetailMutation) ResetUnitCost() {
	m.unit_cost = nil
	m.addunit_cost = nil
	delete(m.clearedFields, inventoryitemdetail.FieldUnitCost)
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *InventoryItemDetailMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *InventoryItemDetailMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *InventoryItemDetailMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemSeqID clears the value of the "order_item_seq_id" field.
func (m *InventoryItemDetailMutation) ClearOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	m.clearedFields[inventoryitemdetail.FieldOrderItemSeqID] = struct{}{}
}

// OrderItemSeqIDCleared returns if the "order_item_seq_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) OrderItemSeqIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldOrderItemSeqID]
	return ok
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *InventoryItemDetailMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldOrderItemSeqID)
}

// SetShipGroupSeqID sets the "ship_group_seq_id" field.
func (m *InventoryItemDetailMutation) SetShipGroupSeqID(i int) {
	m.ship_group_seq_id = &i
	m.addship_group_seq_id = nil
}

// ShipGroupSeqID returns the value of the "ship_group_seq_id" field in the mutation.
func (m *InventoryItemDetailMutation) ShipGroupSeqID() (r int, exists bool) {
	v := m.ship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipGroupSeqID returns the old "ship_group_seq_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldShipGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipGroupSeqID: %w", err)
	}
	return oldValue.ShipGroupSeqID, nil
}

// AddShipGroupSeqID adds i to the "ship_group_seq_id" field.
func (m *InventoryItemDetailMutation) AddShipGroupSeqID(i int) {
	if m.addship_group_seq_id != nil {
		*m.addship_group_seq_id += i
	} else {
		m.addship_group_seq_id = &i
	}
}

// AddedShipGroupSeqID returns the value that was added to the "ship_group_seq_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedShipGroupSeqID() (r int, exists bool) {
	v := m.addship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipGroupSeqID clears the value of the "ship_group_seq_id" field.
func (m *InventoryItemDetailMutation) ClearShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
	m.clearedFields[inventoryitemdetail.FieldShipGroupSeqID] = struct{}{}
}

// ShipGroupSeqIDCleared returns if the "ship_group_seq_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ShipGroupSeqIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldShipGroupSeqID]
	return ok
}

// ResetShipGroupSeqID resets all changes to the "ship_group_seq_id" field.
func (m *InventoryItemDetailMutation) ResetShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldShipGroupSeqID)
}

// SetShipmentID sets the "shipment_id" field.
func (m *InventoryItemDetailMutation) SetShipmentID(i int) {
	m.shipment_id = &i
	m.addshipment_id = nil
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *InventoryItemDetailMutation) ShipmentID() (r int, exists bool) {
	v := m.shipment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldShipmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// AddShipmentID adds i to the "shipment_id" field.
func (m *InventoryItemDetailMutation) AddShipmentID(i int) {
	if m.addshipment_id != nil {
		*m.addshipment_id += i
	} else {
		m.addshipment_id = &i
	}
}

// AddedShipmentID returns the value that was added to the "shipment_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedShipmentID() (r int, exists bool) {
	v := m.addshipment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentID clears the value of the "shipment_id" field.
func (m *InventoryItemDetailMutation) ClearShipmentID() {
	m.shipment_id = nil
	m.addshipment_id = nil
	m.clearedFields[inventoryitemdetail.FieldShipmentID] = struct{}{}
}

// ShipmentIDCleared returns if the "shipment_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ShipmentIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldShipmentID]
	return ok
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *InventoryItemDetailMutation) ResetShipmentID() {
	m.shipment_id = nil
	m.addshipment_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldShipmentID)
}

// SetShipmentItemSeqID sets the "shipment_item_seq_id" field.
func (m *InventoryItemDetailMutation) SetShipmentItemSeqID(i int) {
	m.shipment_item_seq_id = &i
	m.addshipment_item_seq_id = nil
}

// ShipmentItemSeqID returns the value of the "shipment_item_seq_id" field in the mutation.
func (m *InventoryItemDetailMutation) ShipmentItemSeqID() (r int, exists bool) {
	v := m.shipment_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentItemSeqID returns the old "shipment_item_seq_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldShipmentItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipmentItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipmentItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentItemSeqID: %w", err)
	}
	return oldValue.ShipmentItemSeqID, nil
}

// AddShipmentItemSeqID adds i to the "shipment_item_seq_id" field.
func (m *InventoryItemDetailMutation) AddShipmentItemSeqID(i int) {
	if m.addshipment_item_seq_id != nil {
		*m.addshipment_item_seq_id += i
	} else {
		m.addshipment_item_seq_id = &i
	}
}

// AddedShipmentItemSeqID returns the value that was added to the "shipment_item_seq_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedShipmentItemSeqID() (r int, exists bool) {
	v := m.addshipment_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentItemSeqID clears the value of the "shipment_item_seq_id" field.
func (m *InventoryItemDetailMutation) ClearShipmentItemSeqID() {
	m.shipment_item_seq_id = nil
	m.addshipment_item_seq_id = nil
	m.clearedFields[inventoryitemdetail.FieldShipmentItemSeqID] = struct{}{}
}

// ShipmentItemSeqIDCleared returns if the "shipment_item_seq_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ShipmentItemSeqIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldShipmentItemSeqID]
	return ok
}

// ResetShipmentItemSeqID resets all changes to the "shipment_item_seq_id" field.
func (m *InventoryItemDetailMutation) ResetShipmentItemSeqID() {
	m.shipment_item_seq_id = nil
	m.addshipment_item_seq_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldShipmentItemSeqID)
}

// SetReturnID sets the "return_id" field.
func (m *InventoryItemDetailMutation) SetReturnID(i int) {
	m.return_id = &i
	m.addreturn_id = nil
}

// ReturnID returns the value of the "return_id" field in the mutation.
func (m *InventoryItemDetailMutation) ReturnID() (r int, exists bool) {
	v := m.return_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnID returns the old "return_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldReturnID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReturnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReturnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnID: %w", err)
	}
	return oldValue.ReturnID, nil
}

// AddReturnID adds i to the "return_id" field.
func (m *InventoryItemDetailMutation) AddReturnID(i int) {
	if m.addreturn_id != nil {
		*m.addreturn_id += i
	} else {
		m.addreturn_id = &i
	}
}

// AddedReturnID returns the value that was added to the "return_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedReturnID() (r int, exists bool) {
	v := m.addreturn_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReturnID clears the value of the "return_id" field.
func (m *InventoryItemDetailMutation) ClearReturnID() {
	m.return_id = nil
	m.addreturn_id = nil
	m.clearedFields[inventoryitemdetail.FieldReturnID] = struct{}{}
}

// ReturnIDCleared returns if the "return_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ReturnIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldReturnID]
	return ok
}

// ResetReturnID resets all changes to the "return_id" field.
func (m *InventoryItemDetailMutation) ResetReturnID() {
	m.return_id = nil
	m.addreturn_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldReturnID)
}

// SetReturnItemSeqID sets the "return_item_seq_id" field.
func (m *InventoryItemDetailMutation) SetReturnItemSeqID(i int) {
	m.return_item_seq_id = &i
	m.addreturn_item_seq_id = nil
}

// ReturnItemSeqID returns the value of the "return_item_seq_id" field in the mutation.
func (m *InventoryItemDetailMutation) ReturnItemSeqID() (r int, exists bool) {
	v := m.return_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnItemSeqID returns the old "return_item_seq_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldReturnItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReturnItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReturnItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnItemSeqID: %w", err)
	}
	return oldValue.ReturnItemSeqID, nil
}

// AddReturnItemSeqID adds i to the "return_item_seq_id" field.
func (m *InventoryItemDetailMutation) AddReturnItemSeqID(i int) {
	if m.addreturn_item_seq_id != nil {
		*m.addreturn_item_seq_id += i
	} else {
		m.addreturn_item_seq_id = &i
	}
}

// AddedReturnItemSeqID returns the value that was added to the "return_item_seq_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedReturnItemSeqID() (r int, exists bool) {
	v := m.addreturn_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReturnItemSeqID clears the value of the "return_item_seq_id" field.
func (m *InventoryItemDetailMutation) ClearReturnItemSeqID() {
	m.return_item_seq_id = nil
	m.addreturn_item_seq_id = nil
	m.clearedFields[inventoryitemdetail.FieldReturnItemSeqID] = struct{}{}
}

// ReturnItemSeqIDCleared returns if the "return_item_seq_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ReturnItemSeqIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldReturnItemSeqID]
	return ok
}

// ResetReturnItemSeqID resets all changes to the "return_item_seq_id" field.
func (m *InventoryItemDetailMutation) ResetReturnItemSeqID() {
	m.return_item_seq_id = nil
	m.addreturn_item_seq_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldReturnItemSeqID)
}

// SetWorkEffortID sets the "work_effort_id" field.
func (m *InventoryItemDetailMutation) SetWorkEffortID(i int) {
	m.work_effort_id = &i
	m.addwork_effort_id = nil
}

// WorkEffortID returns the value of the "work_effort_id" field in the mutation.
func (m *InventoryItemDetailMutation) WorkEffortID() (r int, exists bool) {
	v := m.work_effort_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEffortID returns the old "work_effort_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldWorkEffortID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkEffortID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkEffortID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEffortID: %w", err)
	}
	return oldValue.WorkEffortID, nil
}

// AddWorkEffortID adds i to the "work_effort_id" field.
func (m *InventoryItemDetailMutation) AddWorkEffortID(i int) {
	if m.addwork_effort_id != nil {
		*m.addwork_effort_id += i
	} else {
		m.addwork_effort_id = &i
	}
}

// AddedWorkEffortID returns the value that was added to the "work_effort_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedWorkEffortID() (r int, exists bool) {
	v := m.addwork_effort_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkEffortID clears the value of the "work_effort_id" field.
func (m *InventoryItemDetailMutation) ClearWorkEffortID() {
	m.work_effort_id = nil
	m.addwork_effort_id = nil
	m.clearedFields[inventoryitemdetail.FieldWorkEffortID] = struct{}{}
}

// WorkEffortIDCleared returns if the "work_effort_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) WorkEffortIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldWorkEffortID]
	return ok
}

// ResetWorkEffortID resets all changes to the "work_effort_id" field.
func (m *InventoryItemDetailMutation) ResetWorkEffortID() {
	m.work_effort_id = nil
	m.addwork_effort_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldWorkEffortID)
}

// SetFixedAssetID sets the "fixed_asset_id" field.
func (m *InventoryItemDetailMutation) SetFixedAssetID(i int) {
	m.fixed_asset_id = &i
	m.addfixed_asset_id = nil
}

// FixedAssetID returns the value of the "fixed_asset_id" field in the mutation.
func (m *InventoryItemDetailMutation) FixedAssetID() (r int, exists bool) {
	v := m.fixed_asset_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedAssetID returns the old "fixed_asset_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldFixedAssetID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixedAssetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixedAssetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedAssetID: %w", err)
	}
	return oldValue.FixedAssetID, nil
}

// AddFixedAssetID adds i to the "fixed_asset_id" field.
func (m *InventoryItemDetailMutation) AddFixedAssetID(i int) {
	if m.addfixed_asset_id != nil {
		*m.addfixed_asset_id += i
	} else {
		m.addfixed_asset_id = &i
	}
}

// AddedFixedAssetID returns the value that was added to the "fixed_asset_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedFixedAssetID() (r int, exists bool) {
	v := m.addfixed_asset_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedAssetID clears the value of the "fixed_asset_id" field.
func (m *InventoryItemDetailMutation) ClearFixedAssetID() {
	m.fixed_asset_id = nil
	m.addfixed_asset_id = nil
	m.clearedFields[inventoryitemdetail.FieldFixedAssetID] = struct{}{}
}

// FixedAssetIDCleared returns if the "fixed_asset_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) FixedAssetIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldFixedAssetID]
	return ok
}

// ResetFixedAssetID resets all changes to the "fixed_asset_id" field.
func (m *InventoryItemDetailMutation) ResetFixedAssetID() {
	m.fixed_asset_id = nil
	m.addfixed_asset_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldFixedAssetID)
}

// SetMaintHistSeqID sets the "maint_hist_seq_id" field.
func (m *InventoryItemDetailMutation) SetMaintHistSeqID(i int) {
	m.maint_hist_seq_id = &i
	m.addmaint_hist_seq_id = nil
}

// MaintHistSeqID returns the value of the "maint_hist_seq_id" field in the mutation.
func (m *InventoryItemDetailMutation) MaintHistSeqID() (r int, exists bool) {
	v := m.maint_hist_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintHistSeqID returns the old "maint_hist_seq_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldMaintHistSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaintHistSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaintHistSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintHistSeqID: %w", err)
	}
	return oldValue.MaintHistSeqID, nil
}

// AddMaintHistSeqID adds i to the "maint_hist_seq_id" field.
func (m *InventoryItemDetailMutation) AddMaintHistSeqID(i int) {
	if m.addmaint_hist_seq_id != nil {
		*m.addmaint_hist_seq_id += i
	} else {
		m.addmaint_hist_seq_id = &i
	}
}

// AddedMaintHistSeqID returns the value that was added to the "maint_hist_seq_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedMaintHistSeqID() (r int, exists bool) {
	v := m.addmaint_hist_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaintHistSeqID clears the value of the "maint_hist_seq_id" field.
func (m *InventoryItemDetailMutation) ClearMaintHistSeqID() {
	m.maint_hist_seq_id = nil
	m.addmaint_hist_seq_id = nil
	m.clearedFields[inventoryitemdetail.FieldMaintHistSeqID] = struct{}{}
}

// MaintHistSeqIDCleared returns if the "maint_hist_seq_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) MaintHistSeqIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldMaintHistSeqID]
	return ok
}

// ResetMaintHistSeqID resets all changes to the "maint_hist_seq_id" field.
func (m *InventoryItemDetailMutation) ResetMaintHistSeqID() {
	m.maint_hist_seq_id = nil
	m.addmaint_hist_seq_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldMaintHistSeqID)
}

// SetItemIssuanceID sets the "item_issuance_id" field.
func (m *InventoryItemDetailMutation) SetItemIssuanceID(i int) {
	m.item_issuance_id = &i
	m.additem_issuance_id = nil
}

// ItemIssuanceID returns the value of the "item_issuance_id" field in the mutation.
func (m *InventoryItemDetailMutation) ItemIssuanceID() (r int, exists bool) {
	v := m.item_issuance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemIssuanceID returns the old "item_issuance_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldItemIssuanceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemIssuanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemIssuanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemIssuanceID: %w", err)
	}
	return oldValue.ItemIssuanceID, nil
}

// AddItemIssuanceID adds i to the "item_issuance_id" field.
func (m *InventoryItemDetailMutation) AddItemIssuanceID(i int) {
	if m.additem_issuance_id != nil {
		*m.additem_issuance_id += i
	} else {
		m.additem_issuance_id = &i
	}
}

// AddedItemIssuanceID returns the value that was added to the "item_issuance_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedItemIssuanceID() (r int, exists bool) {
	v := m.additem_issuance_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearItemIssuanceID clears the value of the "item_issuance_id" field.
func (m *InventoryItemDetailMutation) ClearItemIssuanceID() {
	m.item_issuance_id = nil
	m.additem_issuance_id = nil
	m.clearedFields[inventoryitemdetail.FieldItemIssuanceID] = struct{}{}
}

// ItemIssuanceIDCleared returns if the "item_issuance_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ItemIssuanceIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldItemIssuanceID]
	return ok
}

// ResetItemIssuanceID resets all changes to the "item_issuance_id" field.
func (m *InventoryItemDetailMutation) ResetItemIssuanceID() {
	m.item_issuance_id = nil
	m.additem_issuance_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldItemIssuanceID)
}

// SetReceiptID sets the "receipt_id" field.
func (m *InventoryItemDetailMutation) SetReceiptID(i int) {
	m.receipt_id = &i
	m.addreceipt_id = nil
}

// ReceiptID returns the value of the "receipt_id" field in the mutation.
func (m *InventoryItemDetailMutation) ReceiptID() (r int, exists bool) {
	v := m.receipt_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiptID returns the old "receipt_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldReceiptID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReceiptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReceiptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiptID: %w", err)
	}
	return oldValue.ReceiptID, nil
}

// AddReceiptID adds i to the "receipt_id" field.
func (m *InventoryItemDetailMutation) AddReceiptID(i int) {
	if m.addreceipt_id != nil {
		*m.addreceipt_id += i
	} else {
		m.addreceipt_id = &i
	}
}

// AddedReceiptID returns the value that was added to the "receipt_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedReceiptID() (r int, exists bool) {
	v := m.addreceipt_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReceiptID clears the value of the "receipt_id" field.
func (m *InventoryItemDetailMutation) ClearReceiptID() {
	m.receipt_id = nil
	m.addreceipt_id = nil
	m.clearedFields[inventoryitemdetail.FieldReceiptID] = struct{}{}
}

// ReceiptIDCleared returns if the "receipt_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) ReceiptIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldReceiptID]
	return ok
}

// ResetReceiptID resets all changes to the "receipt_id" field.
func (m *InventoryItemDetailMutation) ResetReceiptID() {
	m.receipt_id = nil
	m.addreceipt_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldReceiptID)
}

// SetPhysicalInventoryID sets the "physical_inventory_id" field.
func (m *InventoryItemDetailMutation) SetPhysicalInventoryID(i int) {
	m.physical_inventory_id = &i
	m.addphysical_inventory_id = nil
}

// PhysicalInventoryID returns the value of the "physical_inventory_id" field in the mutation.
func (m *InventoryItemDetailMutation) PhysicalInventoryID() (r int, exists bool) {
	v := m.physical_inventory_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalInventoryID returns the old "physical_inventory_id" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldPhysicalInventoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhysicalInventoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhysicalInventoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalInventoryID: %w", err)
	}
	return oldValue.PhysicalInventoryID, nil
}

// AddPhysicalInventoryID adds i to the "physical_inventory_id" field.
func (m *InventoryItemDetailMutation) AddPhysicalInventoryID(i int) {
	if m.addphysical_inventory_id != nil {
		*m.addphysical_inventory_id += i
	} else {
		m.addphysical_inventory_id = &i
	}
}

// AddedPhysicalInventoryID returns the value that was added to the "physical_inventory_id" field in this mutation.
func (m *InventoryItemDetailMutation) AddedPhysicalInventoryID() (r int, exists bool) {
	v := m.addphysical_inventory_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPhysicalInventoryID clears the value of the "physical_inventory_id" field.
func (m *InventoryItemDetailMutation) ClearPhysicalInventoryID() {
	m.physical_inventory_id = nil
	m.addphysical_inventory_id = nil
	m.clearedFields[inventoryitemdetail.FieldPhysicalInventoryID] = struct{}{}
}

// PhysicalInventoryIDCleared returns if the "physical_inventory_id" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) PhysicalInventoryIDCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldPhysicalInventoryID]
	return ok
}

// ResetPhysicalInventoryID resets all changes to the "physical_inventory_id" field.
func (m *InventoryItemDetailMutation) ResetPhysicalInventoryID() {
	m.physical_inventory_id = nil
	m.addphysical_inventory_id = nil
	delete(m.clearedFields, inventoryitemdetail.FieldPhysicalInventoryID)
}

// SetDescription sets the "description" field.
func (m *InventoryItemDetailMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InventoryItemDetailMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InventoryItemDetail entity.
// If the InventoryItemDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemDetailMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InventoryItemDetailMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[inventoryitemdetail.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InventoryItemDetailMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[inventoryitemdetail.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InventoryItemDetailMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, inventoryitemdetail.FieldDescription)
}

// SetOrderItemShipGrpInvResID sets the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by id.
func (m *InventoryItemDetailMutation) SetOrderItemShipGrpInvResID(id int) {
	m.order_item_ship_grp_inv_res = &id
}

// ClearOrderItemShipGrpInvRes clears the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *InventoryItemDetailMutation) ClearOrderItemShipGrpInvRes() {
	m.clearedorder_item_ship_grp_inv_res = true
}

// OrderItemShipGrpInvResCleared reports if the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity was cleared.
func (m *InventoryItemDetailMutation) OrderItemShipGrpInvResCleared() bool {
	return m.clearedorder_item_ship_grp_inv_res
}

// OrderItemShipGrpInvResID returns the "order_item_ship_grp_inv_res" edge ID in the mutation.
func (m *InventoryItemDetailMutation) OrderItemShipGrpInvResID() (id int, exists bool) {
	if m.order_item_ship_grp_inv_res != nil {
		return *m.order_item_ship_grp_inv_res, true
	}
	return
}

// OrderItemShipGrpInvResIDs returns the "order_item_ship_grp_inv_res" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGrpInvResID instead. It exists only for internal usage by the builders.
func (m *InventoryItemDetailMutation) OrderItemShipGrpInvResIDs() (ids []int) {
	if id := m.order_item_ship_grp_inv_res; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGrpInvRes resets all changes to the "order_item_ship_grp_inv_res" edge.
func (m *InventoryItemDetailMutation) ResetOrderItemShipGrpInvRes() {
	m.order_item_ship_grp_inv_res = nil
	m.clearedorder_item_ship_grp_inv_res = false
}

// SetReasonEnumerationID sets the "reason_enumeration" edge to the Enumeration entity by id.
func (m *InventoryItemDetailMutation) SetReasonEnumerationID(id int) {
	m.reason_enumeration = &id
}

// ClearReasonEnumeration clears the "reason_enumeration" edge to the Enumeration entity.
func (m *InventoryItemDetailMutation) ClearReasonEnumeration() {
	m.clearedreason_enumeration = true
}

// ReasonEnumerationCleared reports if the "reason_enumeration" edge to the Enumeration entity was cleared.
func (m *InventoryItemDetailMutation) ReasonEnumerationCleared() bool {
	return m.clearedreason_enumeration
}

// ReasonEnumerationID returns the "reason_enumeration" edge ID in the mutation.
func (m *InventoryItemDetailMutation) ReasonEnumerationID() (id int, exists bool) {
	if m.reason_enumeration != nil {
		return *m.reason_enumeration, true
	}
	return
}

// ReasonEnumerationIDs returns the "reason_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReasonEnumerationID instead. It exists only for internal usage by the builders.
func (m *InventoryItemDetailMutation) ReasonEnumerationIDs() (ids []int) {
	if id := m.reason_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReasonEnumeration resets all changes to the "reason_enumeration" edge.
func (m *InventoryItemDetailMutation) ResetReasonEnumeration() {
	m.reason_enumeration = nil
	m.clearedreason_enumeration = false
}

// Op returns the operation name.
func (m *InventoryItemDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InventoryItemDetail).
func (m *InventoryItemDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryItemDetailMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, inventoryitemdetail.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, inventoryitemdetail.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, inventoryitemdetail.FieldStringRef)
	}
	if m.inventory_item_detail_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldInventoryItemDetailSeqID)
	}
	if m.effective_date != nil {
		fields = append(fields, inventoryitemdetail.FieldEffectiveDate)
	}
	if m.quantity_on_hand_diff != nil {
		fields = append(fields, inventoryitemdetail.FieldQuantityOnHandDiff)
	}
	if m.available_to_promise_diff != nil {
		fields = append(fields, inventoryitemdetail.FieldAvailableToPromiseDiff)
	}
	if m.accounting_quantity_diff != nil {
		fields = append(fields, inventoryitemdetail.FieldAccountingQuantityDiff)
	}
	if m.unit_cost != nil {
		fields = append(fields, inventoryitemdetail.FieldUnitCost)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldOrderItemSeqID)
	}
	if m.ship_group_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldShipGroupSeqID)
	}
	if m.shipment_id != nil {
		fields = append(fields, inventoryitemdetail.FieldShipmentID)
	}
	if m.shipment_item_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldShipmentItemSeqID)
	}
	if m.return_id != nil {
		fields = append(fields, inventoryitemdetail.FieldReturnID)
	}
	if m.return_item_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldReturnItemSeqID)
	}
	if m.work_effort_id != nil {
		fields = append(fields, inventoryitemdetail.FieldWorkEffortID)
	}
	if m.fixed_asset_id != nil {
		fields = append(fields, inventoryitemdetail.FieldFixedAssetID)
	}
	if m.maint_hist_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldMaintHistSeqID)
	}
	if m.item_issuance_id != nil {
		fields = append(fields, inventoryitemdetail.FieldItemIssuanceID)
	}
	if m.receipt_id != nil {
		fields = append(fields, inventoryitemdetail.FieldReceiptID)
	}
	if m.physical_inventory_id != nil {
		fields = append(fields, inventoryitemdetail.FieldPhysicalInventoryID)
	}
	if m.description != nil {
		fields = append(fields, inventoryitemdetail.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryItemDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryitemdetail.FieldCreateTime:
		return m.CreateTime()
	case inventoryitemdetail.FieldUpdateTime:
		return m.UpdateTime()
	case inventoryitemdetail.FieldStringRef:
		return m.StringRef()
	case inventoryitemdetail.FieldInventoryItemDetailSeqID:
		return m.InventoryItemDetailSeqID()
	case inventoryitemdetail.FieldEffectiveDate:
		return m.EffectiveDate()
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		return m.QuantityOnHandDiff()
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		return m.AvailableToPromiseDiff()
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		return m.AccountingQuantityDiff()
	case inventoryitemdetail.FieldUnitCost:
		return m.UnitCost()
	case inventoryitemdetail.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case inventoryitemdetail.FieldShipGroupSeqID:
		return m.ShipGroupSeqID()
	case inventoryitemdetail.FieldShipmentID:
		return m.ShipmentID()
	case inventoryitemdetail.FieldShipmentItemSeqID:
		return m.ShipmentItemSeqID()
	case inventoryitemdetail.FieldReturnID:
		return m.ReturnID()
	case inventoryitemdetail.FieldReturnItemSeqID:
		return m.ReturnItemSeqID()
	case inventoryitemdetail.FieldWorkEffortID:
		return m.WorkEffortID()
	case inventoryitemdetail.FieldFixedAssetID:
		return m.FixedAssetID()
	case inventoryitemdetail.FieldMaintHistSeqID:
		return m.MaintHistSeqID()
	case inventoryitemdetail.FieldItemIssuanceID:
		return m.ItemIssuanceID()
	case inventoryitemdetail.FieldReceiptID:
		return m.ReceiptID()
	case inventoryitemdetail.FieldPhysicalInventoryID:
		return m.PhysicalInventoryID()
	case inventoryitemdetail.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryItemDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryitemdetail.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case inventoryitemdetail.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case inventoryitemdetail.FieldStringRef:
		return m.OldStringRef(ctx)
	case inventoryitemdetail.FieldInventoryItemDetailSeqID:
		return m.OldInventoryItemDetailSeqID(ctx)
	case inventoryitemdetail.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		return m.OldQuantityOnHandDiff(ctx)
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		return m.OldAvailableToPromiseDiff(ctx)
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		return m.OldAccountingQuantityDiff(ctx)
	case inventoryitemdetail.FieldUnitCost:
		return m.OldUnitCost(ctx)
	case inventoryitemdetail.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case inventoryitemdetail.FieldShipGroupSeqID:
		return m.OldShipGroupSeqID(ctx)
	case inventoryitemdetail.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case inventoryitemdetail.FieldShipmentItemSeqID:
		return m.OldShipmentItemSeqID(ctx)
	case inventoryitemdetail.FieldReturnID:
		return m.OldReturnID(ctx)
	case inventoryitemdetail.FieldReturnItemSeqID:
		return m.OldReturnItemSeqID(ctx)
	case inventoryitemdetail.FieldWorkEffortID:
		return m.OldWorkEffortID(ctx)
	case inventoryitemdetail.FieldFixedAssetID:
		return m.OldFixedAssetID(ctx)
	case inventoryitemdetail.FieldMaintHistSeqID:
		return m.OldMaintHistSeqID(ctx)
	case inventoryitemdetail.FieldItemIssuanceID:
		return m.OldItemIssuanceID(ctx)
	case inventoryitemdetail.FieldReceiptID:
		return m.OldReceiptID(ctx)
	case inventoryitemdetail.FieldPhysicalInventoryID:
		return m.OldPhysicalInventoryID(ctx)
	case inventoryitemdetail.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryItemDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryitemdetail.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case inventoryitemdetail.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case inventoryitemdetail.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case inventoryitemdetail.FieldInventoryItemDetailSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryItemDetailSeqID(v)
		return nil
	case inventoryitemdetail.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityOnHandDiff(v)
		return nil
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableToPromiseDiff(v)
		return nil
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingQuantityDiff(v)
		return nil
	case inventoryitemdetail.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitCost(v)
		return nil
	case inventoryitemdetail.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case inventoryitemdetail.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipGroupSeqID(v)
		return nil
	case inventoryitemdetail.FieldShipmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case inventoryitemdetail.FieldShipmentItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentItemSeqID(v)
		return nil
	case inventoryitemdetail.FieldReturnID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnID(v)
		return nil
	case inventoryitemdetail.FieldReturnItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnItemSeqID(v)
		return nil
	case inventoryitemdetail.FieldWorkEffortID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEffortID(v)
		return nil
	case inventoryitemdetail.FieldFixedAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedAssetID(v)
		return nil
	case inventoryitemdetail.FieldMaintHistSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintHistSeqID(v)
		return nil
	case inventoryitemdetail.FieldItemIssuanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemIssuanceID(v)
		return nil
	case inventoryitemdetail.FieldReceiptID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiptID(v)
		return nil
	case inventoryitemdetail.FieldPhysicalInventoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalInventoryID(v)
		return nil
	case inventoryitemdetail.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItemDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryItemDetailMutation) AddedFields() []string {
	var fields []string
	if m.addinventory_item_detail_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldInventoryItemDetailSeqID)
	}
	if m.addquantity_on_hand_diff != nil {
		fields = append(fields, inventoryitemdetail.FieldQuantityOnHandDiff)
	}
	if m.addavailable_to_promise_diff != nil {
		fields = append(fields, inventoryitemdetail.FieldAvailableToPromiseDiff)
	}
	if m.addaccounting_quantity_diff != nil {
		fields = append(fields, inventoryitemdetail.FieldAccountingQuantityDiff)
	}
	if m.addunit_cost != nil {
		fields = append(fields, inventoryitemdetail.FieldUnitCost)
	}
	if m.addorder_item_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldOrderItemSeqID)
	}
	if m.addship_group_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldShipGroupSeqID)
	}
	if m.addshipment_id != nil {
		fields = append(fields, inventoryitemdetail.FieldShipmentID)
	}
	if m.addshipment_item_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldShipmentItemSeqID)
	}
	if m.addreturn_id != nil {
		fields = append(fields, inventoryitemdetail.FieldReturnID)
	}
	if m.addreturn_item_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldReturnItemSeqID)
	}
	if m.addwork_effort_id != nil {
		fields = append(fields, inventoryitemdetail.FieldWorkEffortID)
	}
	if m.addfixed_asset_id != nil {
		fields = append(fields, inventoryitemdetail.FieldFixedAssetID)
	}
	if m.addmaint_hist_seq_id != nil {
		fields = append(fields, inventoryitemdetail.FieldMaintHistSeqID)
	}
	if m.additem_issuance_id != nil {
		fields = append(fields, inventoryitemdetail.FieldItemIssuanceID)
	}
	if m.addreceipt_id != nil {
		fields = append(fields, inventoryitemdetail.FieldReceiptID)
	}
	if m.addphysical_inventory_id != nil {
		fields = append(fields, inventoryitemdetail.FieldPhysicalInventoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryItemDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventoryitemdetail.FieldInventoryItemDetailSeqID:
		return m.AddedInventoryItemDetailSeqID()
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		return m.AddedQuantityOnHandDiff()
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		return m.AddedAvailableToPromiseDiff()
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		return m.AddedAccountingQuantityDiff()
	case inventoryitemdetail.FieldUnitCost:
		return m.AddedUnitCost()
	case inventoryitemdetail.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	case inventoryitemdetail.FieldShipGroupSeqID:
		return m.AddedShipGroupSeqID()
	case inventoryitemdetail.FieldShipmentID:
		return m.AddedShipmentID()
	case inventoryitemdetail.FieldShipmentItemSeqID:
		return m.AddedShipmentItemSeqID()
	case inventoryitemdetail.FieldReturnID:
		return m.AddedReturnID()
	case inventoryitemdetail.FieldReturnItemSeqID:
		return m.AddedReturnItemSeqID()
	case inventoryitemdetail.FieldWorkEffortID:
		return m.AddedWorkEffortID()
	case inventoryitemdetail.FieldFixedAssetID:
		return m.AddedFixedAssetID()
	case inventoryitemdetail.FieldMaintHistSeqID:
		return m.AddedMaintHistSeqID()
	case inventoryitemdetail.FieldItemIssuanceID:
		return m.AddedItemIssuanceID()
	case inventoryitemdetail.FieldReceiptID:
		return m.AddedReceiptID()
	case inventoryitemdetail.FieldPhysicalInventoryID:
		return m.AddedPhysicalInventoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventoryitemdetail.FieldInventoryItemDetailSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInventoryItemDetailSeqID(v)
		return nil
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityOnHandDiff(v)
		return nil
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableToPromiseDiff(v)
		return nil
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountingQuantityDiff(v)
		return nil
	case inventoryitemdetail.FieldUnitCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitCost(v)
		return nil
	case inventoryitemdetail.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	case inventoryitemdetail.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipGroupSeqID(v)
		return nil
	case inventoryitemdetail.FieldShipmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentID(v)
		return nil
	case inventoryitemdetail.FieldShipmentItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentItemSeqID(v)
		return nil
	case inventoryitemdetail.FieldReturnID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReturnID(v)
		return nil
	case inventoryitemdetail.FieldReturnItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReturnItemSeqID(v)
		return nil
	case inventoryitemdetail.FieldWorkEffortID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkEffortID(v)
		return nil
	case inventoryitemdetail.FieldFixedAssetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedAssetID(v)
		return nil
	case inventoryitemdetail.FieldMaintHistSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintHistSeqID(v)
		return nil
	case inventoryitemdetail.FieldItemIssuanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemIssuanceID(v)
		return nil
	case inventoryitemdetail.FieldReceiptID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceiptID(v)
		return nil
	case inventoryitemdetail.FieldPhysicalInventoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhysicalInventoryID(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItemDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryItemDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventoryitemdetail.FieldStringRef) {
		fields = append(fields, inventoryitemdetail.FieldStringRef)
	}
	if m.FieldCleared(inventoryitemdetail.FieldEffectiveDate) {
		fields = append(fields, inventoryitemdetail.FieldEffectiveDate)
	}
	if m.FieldCleared(inventoryitemdetail.FieldQuantityOnHandDiff) {
		fields = append(fields, inventoryitemdetail.FieldQuantityOnHandDiff)
	}
	if m.FieldCleared(inventoryitemdetail.FieldAvailableToPromiseDiff) {
		fields = append(fields, inventoryitemdetail.FieldAvailableToPromiseDiff)
	}
	if m.FieldCleared(inventoryitemdetail.FieldAccountingQuantityDiff) {
		fields = append(fields, inventoryitemdetail.FieldAccountingQuantityDiff)
	}
	if m.FieldCleared(inventoryitemdetail.FieldUnitCost) {
		fields = append(fields, inventoryitemdetail.FieldUnitCost)
	}
	if m.FieldCleared(inventoryitemdetail.FieldOrderItemSeqID) {
		fields = append(fields, inventoryitemdetail.FieldOrderItemSeqID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldShipGroupSeqID) {
		fields = append(fields, inventoryitemdetail.FieldShipGroupSeqID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldShipmentID) {
		fields = append(fields, inventoryitemdetail.FieldShipmentID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldShipmentItemSeqID) {
		fields = append(fields, inventoryitemdetail.FieldShipmentItemSeqID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldReturnID) {
		fields = append(fields, inventoryitemdetail.FieldReturnID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldReturnItemSeqID) {
		fields = append(fields, inventoryitemdetail.FieldReturnItemSeqID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldWorkEffortID) {
		fields = append(fields, inventoryitemdetail.FieldWorkEffortID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldFixedAssetID) {
		fields = append(fields, inventoryitemdetail.FieldFixedAssetID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldMaintHistSeqID) {
		fields = append(fields, inventoryitemdetail.FieldMaintHistSeqID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldItemIssuanceID) {
		fields = append(fields, inventoryitemdetail.FieldItemIssuanceID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldReceiptID) {
		fields = append(fields, inventoryitemdetail.FieldReceiptID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldPhysicalInventoryID) {
		fields = append(fields, inventoryitemdetail.FieldPhysicalInventoryID)
	}
	if m.FieldCleared(inventoryitemdetail.FieldDescription) {
		fields = append(fields, inventoryitemdetail.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryItemDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryItemDetailMutation) ClearField(name string) error {
	switch name {
	case inventoryitemdetail.FieldStringRef:
		m.ClearStringRef()
		return nil
	case inventoryitemdetail.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		m.ClearQuantityOnHandDiff()
		return nil
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		m.ClearAvailableToPromiseDiff()
		return nil
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		m.ClearAccountingQuantityDiff()
		return nil
	case inventoryitemdetail.FieldUnitCost:
		m.ClearUnitCost()
		return nil
	case inventoryitemdetail.FieldOrderItemSeqID:
		m.ClearOrderItemSeqID()
		return nil
	case inventoryitemdetail.FieldShipGroupSeqID:
		m.ClearShipGroupSeqID()
		return nil
	case inventoryitemdetail.FieldShipmentID:
		m.ClearShipmentID()
		return nil
	case inventoryitemdetail.FieldShipmentItemSeqID:
		m.ClearShipmentItemSeqID()
		return nil
	case inventoryitemdetail.FieldReturnID:
		m.ClearReturnID()
		return nil
	case inventoryitemdetail.FieldReturnItemSeqID:
		m.ClearReturnItemSeqID()
		return nil
	case inventoryitemdetail.FieldWorkEffortID:
		m.ClearWorkEffortID()
		return nil
	case inventoryitemdetail.FieldFixedAssetID:
		m.ClearFixedAssetID()
		return nil
	case inventoryitemdetail.FieldMaintHistSeqID:
		m.ClearMaintHistSeqID()
		return nil
	case inventoryitemdetail.FieldItemIssuanceID:
		m.ClearItemIssuanceID()
		return nil
	case inventoryitemdetail.FieldReceiptID:
		m.ClearReceiptID()
		return nil
	case inventoryitemdetail.FieldPhysicalInventoryID:
		m.ClearPhysicalInventoryID()
		return nil
	case inventoryitemdetail.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryItemDetailMutation) ResetField(name string) error {
	switch name {
	case inventoryitemdetail.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case inventoryitemdetail.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case inventoryitemdetail.FieldStringRef:
		m.ResetStringRef()
		return nil
	case inventoryitemdetail.FieldInventoryItemDetailSeqID:
		m.ResetInventoryItemDetailSeqID()
		return nil
	case inventoryitemdetail.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case inventoryitemdetail.FieldQuantityOnHandDiff:
		m.ResetQuantityOnHandDiff()
		return nil
	case inventoryitemdetail.FieldAvailableToPromiseDiff:
		m.ResetAvailableToPromiseDiff()
		return nil
	case inventoryitemdetail.FieldAccountingQuantityDiff:
		m.ResetAccountingQuantityDiff()
		return nil
	case inventoryitemdetail.FieldUnitCost:
		m.ResetUnitCost()
		return nil
	case inventoryitemdetail.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case inventoryitemdetail.FieldShipGroupSeqID:
		m.ResetShipGroupSeqID()
		return nil
	case inventoryitemdetail.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case inventoryitemdetail.FieldShipmentItemSeqID:
		m.ResetShipmentItemSeqID()
		return nil
	case inventoryitemdetail.FieldReturnID:
		m.ResetReturnID()
		return nil
	case inventoryitemdetail.FieldReturnItemSeqID:
		m.ResetReturnItemSeqID()
		return nil
	case inventoryitemdetail.FieldWorkEffortID:
		m.ResetWorkEffortID()
		return nil
	case inventoryitemdetail.FieldFixedAssetID:
		m.ResetFixedAssetID()
		return nil
	case inventoryitemdetail.FieldMaintHistSeqID:
		m.ResetMaintHistSeqID()
		return nil
	case inventoryitemdetail.FieldItemIssuanceID:
		m.ResetItemIssuanceID()
		return nil
	case inventoryitemdetail.FieldReceiptID:
		m.ResetReceiptID()
		return nil
	case inventoryitemdetail.FieldPhysicalInventoryID:
		m.ResetPhysicalInventoryID()
		return nil
	case inventoryitemdetail.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryItemDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_item_ship_grp_inv_res != nil {
		edges = append(edges, inventoryitemdetail.EdgeOrderItemShipGrpInvRes)
	}
	if m.reason_enumeration != nil {
		edges = append(edges, inventoryitemdetail.EdgeReasonEnumeration)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryItemDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryitemdetail.EdgeOrderItemShipGrpInvRes:
		if id := m.order_item_ship_grp_inv_res; id != nil {
			return []ent.Value{*id}
		}
	case inventoryitemdetail.EdgeReasonEnumeration:
		if id := m.reason_enumeration; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryItemDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryItemDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryItemDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_item_ship_grp_inv_res {
		edges = append(edges, inventoryitemdetail.EdgeOrderItemShipGrpInvRes)
	}
	if m.clearedreason_enumeration {
		edges = append(edges, inventoryitemdetail.EdgeReasonEnumeration)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryItemDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryitemdetail.EdgeOrderItemShipGrpInvRes:
		return m.clearedorder_item_ship_grp_inv_res
	case inventoryitemdetail.EdgeReasonEnumeration:
		return m.clearedreason_enumeration
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryItemDetailMutation) ClearEdge(name string) error {
	switch name {
	case inventoryitemdetail.EdgeOrderItemShipGrpInvRes:
		m.ClearOrderItemShipGrpInvRes()
		return nil
	case inventoryitemdetail.EdgeReasonEnumeration:
		m.ClearReasonEnumeration()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryItemDetailMutation) ResetEdge(name string) error {
	switch name {
	case inventoryitemdetail.EdgeOrderItemShipGrpInvRes:
		m.ResetOrderItemShipGrpInvRes()
		return nil
	case inventoryitemdetail.EdgeReasonEnumeration:
		m.ResetReasonEnumeration()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemDetail edge %s", name)
}

// InventoryItemTypeMutation represents an operation that mutates the InventoryItemType nodes in the graph.
type InventoryItemTypeMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	create_time                       *time.Time
	update_time                       *time.Time
	string_ref                        *string
	has_table                         *inventoryitemtype.HasTable
	description                       *string
	clearedFields                     map[string]struct{}
	parent                            *int
	clearedparent                     bool
	children                          map[int]struct{}
	removedchildren                   map[int]struct{}
	clearedchildren                   bool
	child_inventory_item_types        map[int]struct{}
	removedchild_inventory_item_types map[int]struct{}
	clearedchild_inventory_item_types bool
	products                          map[int]struct{}
	removedproducts                   map[int]struct{}
	clearedproducts                   bool
	done                              bool
	oldValue                          func(context.Context) (*InventoryItemType, error)
	predicates                        []predicate.InventoryItemType
}

var _ ent.Mutation = (*InventoryItemTypeMutation)(nil)

// inventoryitemtypeOption allows management of the mutation configuration using functional options.
type inventoryitemtypeOption func(*InventoryItemTypeMutation)

// newInventoryItemTypeMutation creates new mutation for the InventoryItemType entity.
func newInventoryItemTypeMutation(c config, op Op, opts ...inventoryitemtypeOption) *InventoryItemTypeMutation {
	m := &InventoryItemTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryItemType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryItemTypeID sets the ID field of the mutation.
func withInventoryItemTypeID(id int) inventoryitemtypeOption {
	return func(m *InventoryItemTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryItemType
		)
		m.oldValue = func(ctx context.Context) (*InventoryItemType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryItemType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryItemType sets the old InventoryItemType of the mutation.
func withInventoryItemType(node *InventoryItemType) inventoryitemtypeOption {
	return func(m *InventoryItemTypeMutation) {
		m.oldValue = func(context.Context) (*InventoryItemType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryItemTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryItemTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryItemTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *InventoryItemTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InventoryItemTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the InventoryItemType entity.
// If the InventoryItemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InventoryItemTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InventoryItemTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InventoryItemTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the InventoryItemType entity.
// If the InventoryItemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InventoryItemTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *InventoryItemTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *InventoryItemTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the InventoryItemType entity.
// If the InventoryItemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *InventoryItemTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[inventoryitemtype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *InventoryItemTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[inventoryitemtype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *InventoryItemTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, inventoryitemtype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *InventoryItemTypeMutation) SetHasTable(it inventoryitemtype.HasTable) {
	m.has_table = &it
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *InventoryItemTypeMutation) HasTable() (r inventoryitemtype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the InventoryItemType entity.
// If the InventoryItemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemTypeMutation) OldHasTable(ctx context.Context) (v inventoryitemtype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *InventoryItemTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[inventoryitemtype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *InventoryItemTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[inventoryitemtype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *InventoryItemTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, inventoryitemtype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *InventoryItemTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InventoryItemTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InventoryItemType entity.
// If the InventoryItemType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *InventoryItemTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[inventoryitemtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *InventoryItemTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[inventoryitemtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *InventoryItemTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, inventoryitemtype.FieldDescription)
}

// SetParentID sets the "parent" edge to the InventoryItemType entity by id.
func (m *InventoryItemTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the InventoryItemType entity.
func (m *InventoryItemTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the InventoryItemType entity was cleared.
func (m *InventoryItemTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *InventoryItemTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *InventoryItemTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *InventoryItemTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the InventoryItemType entity by ids.
func (m *InventoryItemTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the InventoryItemType entity.
func (m *InventoryItemTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the InventoryItemType entity was cleared.
func (m *InventoryItemTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the InventoryItemType entity by IDs.
func (m *InventoryItemTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the InventoryItemType entity.
func (m *InventoryItemTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *InventoryItemTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *InventoryItemTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildInventoryItemTypeIDs adds the "child_inventory_item_types" edge to the InventoryItemType entity by ids.
func (m *InventoryItemTypeMutation) AddChildInventoryItemTypeIDs(ids ...int) {
	if m.child_inventory_item_types == nil {
		m.child_inventory_item_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_inventory_item_types[ids[i]] = struct{}{}
	}
}

// ClearChildInventoryItemTypes clears the "child_inventory_item_types" edge to the InventoryItemType entity.
func (m *InventoryItemTypeMutation) ClearChildInventoryItemTypes() {
	m.clearedchild_inventory_item_types = true
}

// ChildInventoryItemTypesCleared reports if the "child_inventory_item_types" edge to the InventoryItemType entity was cleared.
func (m *InventoryItemTypeMutation) ChildInventoryItemTypesCleared() bool {
	return m.clearedchild_inventory_item_types
}

// RemoveChildInventoryItemTypeIDs removes the "child_inventory_item_types" edge to the InventoryItemType entity by IDs.
func (m *InventoryItemTypeMutation) RemoveChildInventoryItemTypeIDs(ids ...int) {
	if m.removedchild_inventory_item_types == nil {
		m.removedchild_inventory_item_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_inventory_item_types[ids[i]] = struct{}{}
	}
}

// RemovedChildInventoryItemTypes returns the removed IDs of the "child_inventory_item_types" edge to the InventoryItemType entity.
func (m *InventoryItemTypeMutation) RemovedChildInventoryItemTypesIDs() (ids []int) {
	for id := range m.removedchild_inventory_item_types {
		ids = append(ids, id)
	}
	return
}

// ChildInventoryItemTypesIDs returns the "child_inventory_item_types" edge IDs in the mutation.
func (m *InventoryItemTypeMutation) ChildInventoryItemTypesIDs() (ids []int) {
	for id := range m.child_inventory_item_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildInventoryItemTypes resets all changes to the "child_inventory_item_types" edge.
func (m *InventoryItemTypeMutation) ResetChildInventoryItemTypes() {
	m.child_inventory_item_types = nil
	m.clearedchild_inventory_item_types = false
	m.removedchild_inventory_item_types = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *InventoryItemTypeMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *InventoryItemTypeMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *InventoryItemTypeMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *InventoryItemTypeMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *InventoryItemTypeMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *InventoryItemTypeMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *InventoryItemTypeMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Op returns the operation name.
func (m *InventoryItemTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InventoryItemType).
func (m *InventoryItemTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryItemTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, inventoryitemtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, inventoryitemtype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, inventoryitemtype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, inventoryitemtype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, inventoryitemtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryItemTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryitemtype.FieldCreateTime:
		return m.CreateTime()
	case inventoryitemtype.FieldUpdateTime:
		return m.UpdateTime()
	case inventoryitemtype.FieldStringRef:
		return m.StringRef()
	case inventoryitemtype.FieldHasTable:
		return m.HasTable()
	case inventoryitemtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryItemTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryitemtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case inventoryitemtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case inventoryitemtype.FieldStringRef:
		return m.OldStringRef(ctx)
	case inventoryitemtype.FieldHasTable:
		return m.OldHasTable(ctx)
	case inventoryitemtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryItemType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryitemtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case inventoryitemtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case inventoryitemtype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case inventoryitemtype.FieldHasTable:
		v, ok := value.(inventoryitemtype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case inventoryitemtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItemType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryItemTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryItemTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryItemType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryItemTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventoryitemtype.FieldStringRef) {
		fields = append(fields, inventoryitemtype.FieldStringRef)
	}
	if m.FieldCleared(inventoryitemtype.FieldHasTable) {
		fields = append(fields, inventoryitemtype.FieldHasTable)
	}
	if m.FieldCleared(inventoryitemtype.FieldDescription) {
		fields = append(fields, inventoryitemtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryItemTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryItemTypeMutation) ClearField(name string) error {
	switch name {
	case inventoryitemtype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case inventoryitemtype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case inventoryitemtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryItemTypeMutation) ResetField(name string) error {
	switch name {
	case inventoryitemtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case inventoryitemtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case inventoryitemtype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case inventoryitemtype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case inventoryitemtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryItemTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, inventoryitemtype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, inventoryitemtype.EdgeChildren)
	}
	if m.child_inventory_item_types != nil {
		edges = append(edges, inventoryitemtype.EdgeChildInventoryItemTypes)
	}
	if m.products != nil {
		edges = append(edges, inventoryitemtype.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryItemTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryitemtype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case inventoryitemtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case inventoryitemtype.EdgeChildInventoryItemTypes:
		ids := make([]ent.Value, 0, len(m.child_inventory_item_types))
		for id := range m.child_inventory_item_types {
			ids = append(ids, id)
		}
		return ids
	case inventoryitemtype.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryItemTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, inventoryitemtype.EdgeChildren)
	}
	if m.removedchild_inventory_item_types != nil {
		edges = append(edges, inventoryitemtype.EdgeChildInventoryItemTypes)
	}
	if m.removedproducts != nil {
		edges = append(edges, inventoryitemtype.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryItemTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inventoryitemtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case inventoryitemtype.EdgeChildInventoryItemTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_inventory_item_types))
		for id := range m.removedchild_inventory_item_types {
			ids = append(ids, id)
		}
		return ids
	case inventoryitemtype.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryItemTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, inventoryitemtype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, inventoryitemtype.EdgeChildren)
	}
	if m.clearedchild_inventory_item_types {
		edges = append(edges, inventoryitemtype.EdgeChildInventoryItemTypes)
	}
	if m.clearedproducts {
		edges = append(edges, inventoryitemtype.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryItemTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryitemtype.EdgeParent:
		return m.clearedparent
	case inventoryitemtype.EdgeChildren:
		return m.clearedchildren
	case inventoryitemtype.EdgeChildInventoryItemTypes:
		return m.clearedchild_inventory_item_types
	case inventoryitemtype.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryItemTypeMutation) ClearEdge(name string) error {
	switch name {
	case inventoryitemtype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryItemTypeMutation) ResetEdge(name string) error {
	switch name {
	case inventoryitemtype.EdgeParent:
		m.ResetParent()
		return nil
	case inventoryitemtype.EdgeChildren:
		m.ResetChildren()
		return nil
	case inventoryitemtype.EdgeChildInventoryItemTypes:
		m.ResetChildInventoryItemTypes()
		return nil
	case inventoryitemtype.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown InventoryItemType edge %s", name)
}

// OrderAdjustmentMutation represents an operation that mutates the OrderAdjustment nodes in the graph.
type OrderAdjustmentMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	string_ref                         *string
	order_adjustment_type_id           *int
	addorder_adjustment_type_id        *int
	order_item_seq_id                  *int
	addorder_item_seq_id               *int
	ship_group_seq_id                  *int
	addship_group_seq_id               *int
	comments                           *string
	description                        *string
	amount                             *float64
	addamount                          *float64
	recurring_amount                   *float64
	addrecurring_amount                *float64
	amount_already_included            *float64
	addamount_already_included         *float64
	product_promo_id                   *int
	addproduct_promo_id                *int
	product_promo_rule_id              *int
	addproduct_promo_rule_id           *int
	product_promo_action_seq_id        *int
	addproduct_promo_action_seq_id     *int
	product_feature_id                 *int
	addproduct_feature_id              *int
	corresponding_product_id           *int
	addcorresponding_product_id        *int
	tax_authority_rate_seq_id          *int
	addtax_authority_rate_seq_id       *int
	source_reference_id                *string
	source_percentage                  *float64
	addsource_percentage               *float64
	customer_reference_id              *string
	primary_geo_id                     *int
	addprimary_geo_id                  *int
	secondary_geo_id                   *int
	addsecondary_geo_id                *int
	exempt_amount                      *float64
	addexempt_amount                   *float64
	tax_auth_geo_id                    *int
	addtax_auth_geo_id                 *int
	tax_auth_party_id                  *int
	addtax_auth_party_id               *int
	override_gl_account_id             *int
	addoverride_gl_account_id          *int
	include_in_tax                     *orderadjustment.IncludeInTax
	include_in_shipping                *orderadjustment.IncludeInShipping
	is_manual                          *orderadjustment.IsManual
	created_date                       *time.Time
	created_by_user_login              *string
	last_modified_date                 *time.Time
	last_modified_by_user_login        *string
	clearedFields                      map[string]struct{}
	order_header                       *int
	clearedorder_header                bool
	order_item                         *int
	clearedorder_item                  bool
	order_item_ship_group              *int
	clearedorder_item_ship_group       bool
	order_item_ship_group_assoc        *int
	clearedorder_item_ship_group_assoc bool
	parent                             *int
	clearedparent                      bool
	children                           map[int]struct{}
	removedchildren                    map[int]struct{}
	clearedchildren                    bool
	done                               bool
	oldValue                           func(context.Context) (*OrderAdjustment, error)
	predicates                         []predicate.OrderAdjustment
}

var _ ent.Mutation = (*OrderAdjustmentMutation)(nil)

// orderadjustmentOption allows management of the mutation configuration using functional options.
type orderadjustmentOption func(*OrderAdjustmentMutation)

// newOrderAdjustmentMutation creates new mutation for the OrderAdjustment entity.
func newOrderAdjustmentMutation(c config, op Op, opts ...orderadjustmentOption) *OrderAdjustmentMutation {
	m := &OrderAdjustmentMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderAdjustment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderAdjustmentID sets the ID field of the mutation.
func withOrderAdjustmentID(id int) orderadjustmentOption {
	return func(m *OrderAdjustmentMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderAdjustment
		)
		m.oldValue = func(ctx context.Context) (*OrderAdjustment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderAdjustment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderAdjustment sets the old OrderAdjustment of the mutation.
func withOrderAdjustment(node *OrderAdjustment) orderadjustmentOption {
	return func(m *OrderAdjustmentMutation) {
		m.oldValue = func(context.Context) (*OrderAdjustment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderAdjustmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderAdjustmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderAdjustmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderAdjustmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderAdjustmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderAdjustmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderAdjustmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderAdjustmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderAdjustmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderAdjustmentMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderAdjustmentMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderAdjustmentMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderadjustment.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderAdjustmentMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderadjustment.FieldStringRef)
}

// SetOrderAdjustmentTypeID sets the "order_adjustment_type_id" field.
func (m *OrderAdjustmentMutation) SetOrderAdjustmentTypeID(i int) {
	m.order_adjustment_type_id = &i
	m.addorder_adjustment_type_id = nil
}

// OrderAdjustmentTypeID returns the value of the "order_adjustment_type_id" field in the mutation.
func (m *OrderAdjustmentMutation) OrderAdjustmentTypeID() (r int, exists bool) {
	v := m.order_adjustment_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderAdjustmentTypeID returns the old "order_adjustment_type_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldOrderAdjustmentTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderAdjustmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderAdjustmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderAdjustmentTypeID: %w", err)
	}
	return oldValue.OrderAdjustmentTypeID, nil
}

// AddOrderAdjustmentTypeID adds i to the "order_adjustment_type_id" field.
func (m *OrderAdjustmentMutation) AddOrderAdjustmentTypeID(i int) {
	if m.addorder_adjustment_type_id != nil {
		*m.addorder_adjustment_type_id += i
	} else {
		m.addorder_adjustment_type_id = &i
	}
}

// AddedOrderAdjustmentTypeID returns the value that was added to the "order_adjustment_type_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedOrderAdjustmentTypeID() (r int, exists bool) {
	v := m.addorder_adjustment_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderAdjustmentTypeID clears the value of the "order_adjustment_type_id" field.
func (m *OrderAdjustmentMutation) ClearOrderAdjustmentTypeID() {
	m.order_adjustment_type_id = nil
	m.addorder_adjustment_type_id = nil
	m.clearedFields[orderadjustment.FieldOrderAdjustmentTypeID] = struct{}{}
}

// OrderAdjustmentTypeIDCleared returns if the "order_adjustment_type_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) OrderAdjustmentTypeIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldOrderAdjustmentTypeID]
	return ok
}

// ResetOrderAdjustmentTypeID resets all changes to the "order_adjustment_type_id" field.
func (m *OrderAdjustmentMutation) ResetOrderAdjustmentTypeID() {
	m.order_adjustment_type_id = nil
	m.addorder_adjustment_type_id = nil
	delete(m.clearedFields, orderadjustment.FieldOrderAdjustmentTypeID)
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *OrderAdjustmentMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *OrderAdjustmentMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *OrderAdjustmentMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemSeqID clears the value of the "order_item_seq_id" field.
func (m *OrderAdjustmentMutation) ClearOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	m.clearedFields[orderadjustment.FieldOrderItemSeqID] = struct{}{}
}

// OrderItemSeqIDCleared returns if the "order_item_seq_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) OrderItemSeqIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldOrderItemSeqID]
	return ok
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *OrderAdjustmentMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	delete(m.clearedFields, orderadjustment.FieldOrderItemSeqID)
}

// SetShipGroupSeqID sets the "ship_group_seq_id" field.
func (m *OrderAdjustmentMutation) SetShipGroupSeqID(i int) {
	m.ship_group_seq_id = &i
	m.addship_group_seq_id = nil
}

// ShipGroupSeqID returns the value of the "ship_group_seq_id" field in the mutation.
func (m *OrderAdjustmentMutation) ShipGroupSeqID() (r int, exists bool) {
	v := m.ship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipGroupSeqID returns the old "ship_group_seq_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldShipGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipGroupSeqID: %w", err)
	}
	return oldValue.ShipGroupSeqID, nil
}

// AddShipGroupSeqID adds i to the "ship_group_seq_id" field.
func (m *OrderAdjustmentMutation) AddShipGroupSeqID(i int) {
	if m.addship_group_seq_id != nil {
		*m.addship_group_seq_id += i
	} else {
		m.addship_group_seq_id = &i
	}
}

// AddedShipGroupSeqID returns the value that was added to the "ship_group_seq_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedShipGroupSeqID() (r int, exists bool) {
	v := m.addship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipGroupSeqID clears the value of the "ship_group_seq_id" field.
func (m *OrderAdjustmentMutation) ClearShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
	m.clearedFields[orderadjustment.FieldShipGroupSeqID] = struct{}{}
}

// ShipGroupSeqIDCleared returns if the "ship_group_seq_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) ShipGroupSeqIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldShipGroupSeqID]
	return ok
}

// ResetShipGroupSeqID resets all changes to the "ship_group_seq_id" field.
func (m *OrderAdjustmentMutation) ResetShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
	delete(m.clearedFields, orderadjustment.FieldShipGroupSeqID)
}

// SetComments sets the "comments" field.
func (m *OrderAdjustmentMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *OrderAdjustmentMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *OrderAdjustmentMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[orderadjustment.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *OrderAdjustmentMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, orderadjustment.FieldComments)
}

// SetDescription sets the "description" field.
func (m *OrderAdjustmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrderAdjustmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OrderAdjustmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[orderadjustment.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OrderAdjustmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, orderadjustment.FieldDescription)
}

// SetAmount sets the "amount" field.
func (m *OrderAdjustmentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderAdjustmentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderAdjustmentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderAdjustmentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *OrderAdjustmentMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[orderadjustment.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) AmountCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderAdjustmentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, orderadjustment.FieldAmount)
}

// SetRecurringAmount sets the "recurring_amount" field.
func (m *OrderAdjustmentMutation) SetRecurringAmount(f float64) {
	m.recurring_amount = &f
	m.addrecurring_amount = nil
}

// RecurringAmount returns the value of the "recurring_amount" field in the mutation.
func (m *OrderAdjustmentMutation) RecurringAmount() (r float64, exists bool) {
	v := m.recurring_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurringAmount returns the old "recurring_amount" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldRecurringAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecurringAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecurringAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurringAmount: %w", err)
	}
	return oldValue.RecurringAmount, nil
}

// AddRecurringAmount adds f to the "recurring_amount" field.
func (m *OrderAdjustmentMutation) AddRecurringAmount(f float64) {
	if m.addrecurring_amount != nil {
		*m.addrecurring_amount += f
	} else {
		m.addrecurring_amount = &f
	}
}

// AddedRecurringAmount returns the value that was added to the "recurring_amount" field in this mutation.
func (m *OrderAdjustmentMutation) AddedRecurringAmount() (r float64, exists bool) {
	v := m.addrecurring_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecurringAmount clears the value of the "recurring_amount" field.
func (m *OrderAdjustmentMutation) ClearRecurringAmount() {
	m.recurring_amount = nil
	m.addrecurring_amount = nil
	m.clearedFields[orderadjustment.FieldRecurringAmount] = struct{}{}
}

// RecurringAmountCleared returns if the "recurring_amount" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) RecurringAmountCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldRecurringAmount]
	return ok
}

// ResetRecurringAmount resets all changes to the "recurring_amount" field.
func (m *OrderAdjustmentMutation) ResetRecurringAmount() {
	m.recurring_amount = nil
	m.addrecurring_amount = nil
	delete(m.clearedFields, orderadjustment.FieldRecurringAmount)
}

// SetAmountAlreadyIncluded sets the "amount_already_included" field.
func (m *OrderAdjustmentMutation) SetAmountAlreadyIncluded(f float64) {
	m.amount_already_included = &f
	m.addamount_already_included = nil
}

// AmountAlreadyIncluded returns the value of the "amount_already_included" field in the mutation.
func (m *OrderAdjustmentMutation) AmountAlreadyIncluded() (r float64, exists bool) {
	v := m.amount_already_included
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountAlreadyIncluded returns the old "amount_already_included" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldAmountAlreadyIncluded(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmountAlreadyIncluded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmountAlreadyIncluded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountAlreadyIncluded: %w", err)
	}
	return oldValue.AmountAlreadyIncluded, nil
}

// AddAmountAlreadyIncluded adds f to the "amount_already_included" field.
func (m *OrderAdjustmentMutation) AddAmountAlreadyIncluded(f float64) {
	if m.addamount_already_included != nil {
		*m.addamount_already_included += f
	} else {
		m.addamount_already_included = &f
	}
}

// AddedAmountAlreadyIncluded returns the value that was added to the "amount_already_included" field in this mutation.
func (m *OrderAdjustmentMutation) AddedAmountAlreadyIncluded() (r float64, exists bool) {
	v := m.addamount_already_included
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmountAlreadyIncluded clears the value of the "amount_already_included" field.
func (m *OrderAdjustmentMutation) ClearAmountAlreadyIncluded() {
	m.amount_already_included = nil
	m.addamount_already_included = nil
	m.clearedFields[orderadjustment.FieldAmountAlreadyIncluded] = struct{}{}
}

// AmountAlreadyIncludedCleared returns if the "amount_already_included" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) AmountAlreadyIncludedCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldAmountAlreadyIncluded]
	return ok
}

// ResetAmountAlreadyIncluded resets all changes to the "amount_already_included" field.
func (m *OrderAdjustmentMutation) ResetAmountAlreadyIncluded() {
	m.amount_already_included = nil
	m.addamount_already_included = nil
	delete(m.clearedFields, orderadjustment.FieldAmountAlreadyIncluded)
}

// SetProductPromoID sets the "product_promo_id" field.
func (m *OrderAdjustmentMutation) SetProductPromoID(i int) {
	m.product_promo_id = &i
	m.addproduct_promo_id = nil
}

// ProductPromoID returns the value of the "product_promo_id" field in the mutation.
func (m *OrderAdjustmentMutation) ProductPromoID() (r int, exists bool) {
	v := m.product_promo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPromoID returns the old "product_promo_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldProductPromoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPromoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPromoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPromoID: %w", err)
	}
	return oldValue.ProductPromoID, nil
}

// AddProductPromoID adds i to the "product_promo_id" field.
func (m *OrderAdjustmentMutation) AddProductPromoID(i int) {
	if m.addproduct_promo_id != nil {
		*m.addproduct_promo_id += i
	} else {
		m.addproduct_promo_id = &i
	}
}

// AddedProductPromoID returns the value that was added to the "product_promo_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedProductPromoID() (r int, exists bool) {
	v := m.addproduct_promo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductPromoID clears the value of the "product_promo_id" field.
func (m *OrderAdjustmentMutation) ClearProductPromoID() {
	m.product_promo_id = nil
	m.addproduct_promo_id = nil
	m.clearedFields[orderadjustment.FieldProductPromoID] = struct{}{}
}

// ProductPromoIDCleared returns if the "product_promo_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) ProductPromoIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldProductPromoID]
	return ok
}

// ResetProductPromoID resets all changes to the "product_promo_id" field.
func (m *OrderAdjustmentMutation) ResetProductPromoID() {
	m.product_promo_id = nil
	m.addproduct_promo_id = nil
	delete(m.clearedFields, orderadjustment.FieldProductPromoID)
}

// SetProductPromoRuleID sets the "product_promo_rule_id" field.
func (m *OrderAdjustmentMutation) SetProductPromoRuleID(i int) {
	m.product_promo_rule_id = &i
	m.addproduct_promo_rule_id = nil
}

// ProductPromoRuleID returns the value of the "product_promo_rule_id" field in the mutation.
func (m *OrderAdjustmentMutation) ProductPromoRuleID() (r int, exists bool) {
	v := m.product_promo_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPromoRuleID returns the old "product_promo_rule_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldProductPromoRuleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPromoRuleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPromoRuleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPromoRuleID: %w", err)
	}
	return oldValue.ProductPromoRuleID, nil
}

// AddProductPromoRuleID adds i to the "product_promo_rule_id" field.
func (m *OrderAdjustmentMutation) AddProductPromoRuleID(i int) {
	if m.addproduct_promo_rule_id != nil {
		*m.addproduct_promo_rule_id += i
	} else {
		m.addproduct_promo_rule_id = &i
	}
}

// AddedProductPromoRuleID returns the value that was added to the "product_promo_rule_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedProductPromoRuleID() (r int, exists bool) {
	v := m.addproduct_promo_rule_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductPromoRuleID clears the value of the "product_promo_rule_id" field.
func (m *OrderAdjustmentMutation) ClearProductPromoRuleID() {
	m.product_promo_rule_id = nil
	m.addproduct_promo_rule_id = nil
	m.clearedFields[orderadjustment.FieldProductPromoRuleID] = struct{}{}
}

// ProductPromoRuleIDCleared returns if the "product_promo_rule_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) ProductPromoRuleIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldProductPromoRuleID]
	return ok
}

// ResetProductPromoRuleID resets all changes to the "product_promo_rule_id" field.
func (m *OrderAdjustmentMutation) ResetProductPromoRuleID() {
	m.product_promo_rule_id = nil
	m.addproduct_promo_rule_id = nil
	delete(m.clearedFields, orderadjustment.FieldProductPromoRuleID)
}

// SetProductPromoActionSeqID sets the "product_promo_action_seq_id" field.
func (m *OrderAdjustmentMutation) SetProductPromoActionSeqID(i int) {
	m.product_promo_action_seq_id = &i
	m.addproduct_promo_action_seq_id = nil
}

// ProductPromoActionSeqID returns the value of the "product_promo_action_seq_id" field in the mutation.
func (m *OrderAdjustmentMutation) ProductPromoActionSeqID() (r int, exists bool) {
	v := m.product_promo_action_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPromoActionSeqID returns the old "product_promo_action_seq_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldProductPromoActionSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPromoActionSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPromoActionSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPromoActionSeqID: %w", err)
	}
	return oldValue.ProductPromoActionSeqID, nil
}

// AddProductPromoActionSeqID adds i to the "product_promo_action_seq_id" field.
func (m *OrderAdjustmentMutation) AddProductPromoActionSeqID(i int) {
	if m.addproduct_promo_action_seq_id != nil {
		*m.addproduct_promo_action_seq_id += i
	} else {
		m.addproduct_promo_action_seq_id = &i
	}
}

// AddedProductPromoActionSeqID returns the value that was added to the "product_promo_action_seq_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedProductPromoActionSeqID() (r int, exists bool) {
	v := m.addproduct_promo_action_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductPromoActionSeqID clears the value of the "product_promo_action_seq_id" field.
func (m *OrderAdjustmentMutation) ClearProductPromoActionSeqID() {
	m.product_promo_action_seq_id = nil
	m.addproduct_promo_action_seq_id = nil
	m.clearedFields[orderadjustment.FieldProductPromoActionSeqID] = struct{}{}
}

// ProductPromoActionSeqIDCleared returns if the "product_promo_action_seq_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) ProductPromoActionSeqIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldProductPromoActionSeqID]
	return ok
}

// ResetProductPromoActionSeqID resets all changes to the "product_promo_action_seq_id" field.
func (m *OrderAdjustmentMutation) ResetProductPromoActionSeqID() {
	m.product_promo_action_seq_id = nil
	m.addproduct_promo_action_seq_id = nil
	delete(m.clearedFields, orderadjustment.FieldProductPromoActionSeqID)
}

// SetProductFeatureID sets the "product_feature_id" field.
func (m *OrderAdjustmentMutation) SetProductFeatureID(i int) {
	m.product_feature_id = &i
	m.addproduct_feature_id = nil
}

// ProductFeatureID returns the value of the "product_feature_id" field in the mutation.
func (m *OrderAdjustmentMutation) ProductFeatureID() (r int, exists bool) {
	v := m.product_feature_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductFeatureID returns the old "product_feature_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldProductFeatureID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductFeatureID: %w", err)
	}
	return oldValue.ProductFeatureID, nil
}

// AddProductFeatureID adds i to the "product_feature_id" field.
func (m *OrderAdjustmentMutation) AddProductFeatureID(i int) {
	if m.addproduct_feature_id != nil {
		*m.addproduct_feature_id += i
	} else {
		m.addproduct_feature_id = &i
	}
}

// AddedProductFeatureID returns the value that was added to the "product_feature_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedProductFeatureID() (r int, exists bool) {
	v := m.addproduct_feature_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductFeatureID clears the value of the "product_feature_id" field.
func (m *OrderAdjustmentMutation) ClearProductFeatureID() {
	m.product_feature_id = nil
	m.addproduct_feature_id = nil
	m.clearedFields[orderadjustment.FieldProductFeatureID] = struct{}{}
}

// ProductFeatureIDCleared returns if the "product_feature_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) ProductFeatureIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldProductFeatureID]
	return ok
}

// ResetProductFeatureID resets all changes to the "product_feature_id" field.
func (m *OrderAdjustmentMutation) ResetProductFeatureID() {
	m.product_feature_id = nil
	m.addproduct_feature_id = nil
	delete(m.clearedFields, orderadjustment.FieldProductFeatureID)
}

// SetCorrespondingProductID sets the "corresponding_product_id" field.
func (m *OrderAdjustmentMutation) SetCorrespondingProductID(i int) {
	m.corresponding_product_id = &i
	m.addcorresponding_product_id = nil
}

// CorrespondingProductID returns the value of the "corresponding_product_id" field in the mutation.
func (m *OrderAdjustmentMutation) CorrespondingProductID() (r int, exists bool) {
	v := m.corresponding_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrespondingProductID returns the old "corresponding_product_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldCorrespondingProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCorrespondingProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCorrespondingProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrespondingProductID: %w", err)
	}
	return oldValue.CorrespondingProductID, nil
}

// AddCorrespondingProductID adds i to the "corresponding_product_id" field.
func (m *OrderAdjustmentMutation) AddCorrespondingProductID(i int) {
	if m.addcorresponding_product_id != nil {
		*m.addcorresponding_product_id += i
	} else {
		m.addcorresponding_product_id = &i
	}
}

// AddedCorrespondingProductID returns the value that was added to the "corresponding_product_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedCorrespondingProductID() (r int, exists bool) {
	v := m.addcorresponding_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCorrespondingProductID clears the value of the "corresponding_product_id" field.
func (m *OrderAdjustmentMutation) ClearCorrespondingProductID() {
	m.corresponding_product_id = nil
	m.addcorresponding_product_id = nil
	m.clearedFields[orderadjustment.FieldCorrespondingProductID] = struct{}{}
}

// CorrespondingProductIDCleared returns if the "corresponding_product_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) CorrespondingProductIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldCorrespondingProductID]
	return ok
}

// ResetCorrespondingProductID resets all changes to the "corresponding_product_id" field.
func (m *OrderAdjustmentMutation) ResetCorrespondingProductID() {
	m.corresponding_product_id = nil
	m.addcorresponding_product_id = nil
	delete(m.clearedFields, orderadjustment.FieldCorrespondingProductID)
}

// SetTaxAuthorityRateSeqID sets the "tax_authority_rate_seq_id" field.
func (m *OrderAdjustmentMutation) SetTaxAuthorityRateSeqID(i int) {
	m.tax_authority_rate_seq_id = &i
	m.addtax_authority_rate_seq_id = nil
}

// TaxAuthorityRateSeqID returns the value of the "tax_authority_rate_seq_id" field in the mutation.
func (m *OrderAdjustmentMutation) TaxAuthorityRateSeqID() (r int, exists bool) {
	v := m.tax_authority_rate_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAuthorityRateSeqID returns the old "tax_authority_rate_seq_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldTaxAuthorityRateSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxAuthorityRateSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxAuthorityRateSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAuthorityRateSeqID: %w", err)
	}
	return oldValue.TaxAuthorityRateSeqID, nil
}

// AddTaxAuthorityRateSeqID adds i to the "tax_authority_rate_seq_id" field.
func (m *OrderAdjustmentMutation) AddTaxAuthorityRateSeqID(i int) {
	if m.addtax_authority_rate_seq_id != nil {
		*m.addtax_authority_rate_seq_id += i
	} else {
		m.addtax_authority_rate_seq_id = &i
	}
}

// AddedTaxAuthorityRateSeqID returns the value that was added to the "tax_authority_rate_seq_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedTaxAuthorityRateSeqID() (r int, exists bool) {
	v := m.addtax_authority_rate_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAuthorityRateSeqID clears the value of the "tax_authority_rate_seq_id" field.
func (m *OrderAdjustmentMutation) ClearTaxAuthorityRateSeqID() {
	m.tax_authority_rate_seq_id = nil
	m.addtax_authority_rate_seq_id = nil
	m.clearedFields[orderadjustment.FieldTaxAuthorityRateSeqID] = struct{}{}
}

// TaxAuthorityRateSeqIDCleared returns if the "tax_authority_rate_seq_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) TaxAuthorityRateSeqIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldTaxAuthorityRateSeqID]
	return ok
}

// ResetTaxAuthorityRateSeqID resets all changes to the "tax_authority_rate_seq_id" field.
func (m *OrderAdjustmentMutation) ResetTaxAuthorityRateSeqID() {
	m.tax_authority_rate_seq_id = nil
	m.addtax_authority_rate_seq_id = nil
	delete(m.clearedFields, orderadjustment.FieldTaxAuthorityRateSeqID)
}

// SetSourceReferenceID sets the "source_reference_id" field.
func (m *OrderAdjustmentMutation) SetSourceReferenceID(s string) {
	m.source_reference_id = &s
}

// SourceReferenceID returns the value of the "source_reference_id" field in the mutation.
func (m *OrderAdjustmentMutation) SourceReferenceID() (r string, exists bool) {
	v := m.source_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceReferenceID returns the old "source_reference_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldSourceReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceReferenceID: %w", err)
	}
	return oldValue.SourceReferenceID, nil
}

// ClearSourceReferenceID clears the value of the "source_reference_id" field.
func (m *OrderAdjustmentMutation) ClearSourceReferenceID() {
	m.source_reference_id = nil
	m.clearedFields[orderadjustment.FieldSourceReferenceID] = struct{}{}
}

// SourceReferenceIDCleared returns if the "source_reference_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) SourceReferenceIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldSourceReferenceID]
	return ok
}

// ResetSourceReferenceID resets all changes to the "source_reference_id" field.
func (m *OrderAdjustmentMutation) ResetSourceReferenceID() {
	m.source_reference_id = nil
	delete(m.clearedFields, orderadjustment.FieldSourceReferenceID)
}

// SetSourcePercentage sets the "source_percentage" field.
func (m *OrderAdjustmentMutation) SetSourcePercentage(f float64) {
	m.source_percentage = &f
	m.addsource_percentage = nil
}

// SourcePercentage returns the value of the "source_percentage" field in the mutation.
func (m *OrderAdjustmentMutation) SourcePercentage() (r float64, exists bool) {
	v := m.source_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldSourcePercentage returns the old "source_percentage" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldSourcePercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourcePercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourcePercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourcePercentage: %w", err)
	}
	return oldValue.SourcePercentage, nil
}

// AddSourcePercentage adds f to the "source_percentage" field.
func (m *OrderAdjustmentMutation) AddSourcePercentage(f float64) {
	if m.addsource_percentage != nil {
		*m.addsource_percentage += f
	} else {
		m.addsource_percentage = &f
	}
}

// AddedSourcePercentage returns the value that was added to the "source_percentage" field in this mutation.
func (m *OrderAdjustmentMutation) AddedSourcePercentage() (r float64, exists bool) {
	v := m.addsource_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearSourcePercentage clears the value of the "source_percentage" field.
func (m *OrderAdjustmentMutation) ClearSourcePercentage() {
	m.source_percentage = nil
	m.addsource_percentage = nil
	m.clearedFields[orderadjustment.FieldSourcePercentage] = struct{}{}
}

// SourcePercentageCleared returns if the "source_percentage" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) SourcePercentageCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldSourcePercentage]
	return ok
}

// ResetSourcePercentage resets all changes to the "source_percentage" field.
func (m *OrderAdjustmentMutation) ResetSourcePercentage() {
	m.source_percentage = nil
	m.addsource_percentage = nil
	delete(m.clearedFields, orderadjustment.FieldSourcePercentage)
}

// SetCustomerReferenceID sets the "customer_reference_id" field.
func (m *OrderAdjustmentMutation) SetCustomerReferenceID(s string) {
	m.customer_reference_id = &s
}

// CustomerReferenceID returns the value of the "customer_reference_id" field in the mutation.
func (m *OrderAdjustmentMutation) CustomerReferenceID() (r string, exists bool) {
	v := m.customer_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerReferenceID returns the old "customer_reference_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldCustomerReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCustomerReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCustomerReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerReferenceID: %w", err)
	}
	return oldValue.CustomerReferenceID, nil
}

// ClearCustomerReferenceID clears the value of the "customer_reference_id" field.
func (m *OrderAdjustmentMutation) ClearCustomerReferenceID() {
	m.customer_reference_id = nil
	m.clearedFields[orderadjustment.FieldCustomerReferenceID] = struct{}{}
}

// CustomerReferenceIDCleared returns if the "customer_reference_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) CustomerReferenceIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldCustomerReferenceID]
	return ok
}

// ResetCustomerReferenceID resets all changes to the "customer_reference_id" field.
func (m *OrderAdjustmentMutation) ResetCustomerReferenceID() {
	m.customer_reference_id = nil
	delete(m.clearedFields, orderadjustment.FieldCustomerReferenceID)
}

// SetPrimaryGeoID sets the "primary_geo_id" field.
func (m *OrderAdjustmentMutation) SetPrimaryGeoID(i int) {
	m.primary_geo_id = &i
	m.addprimary_geo_id = nil
}

// PrimaryGeoID returns the value of the "primary_geo_id" field in the mutation.
func (m *OrderAdjustmentMutation) PrimaryGeoID() (r int, exists bool) {
	v := m.primary_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryGeoID returns the old "primary_geo_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldPrimaryGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrimaryGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrimaryGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryGeoID: %w", err)
	}
	return oldValue.PrimaryGeoID, nil
}

// AddPrimaryGeoID adds i to the "primary_geo_id" field.
func (m *OrderAdjustmentMutation) AddPrimaryGeoID(i int) {
	if m.addprimary_geo_id != nil {
		*m.addprimary_geo_id += i
	} else {
		m.addprimary_geo_id = &i
	}
}

// AddedPrimaryGeoID returns the value that was added to the "primary_geo_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedPrimaryGeoID() (r int, exists bool) {
	v := m.addprimary_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrimaryGeoID clears the value of the "primary_geo_id" field.
func (m *OrderAdjustmentMutation) ClearPrimaryGeoID() {
	m.primary_geo_id = nil
	m.addprimary_geo_id = nil
	m.clearedFields[orderadjustment.FieldPrimaryGeoID] = struct{}{}
}

// PrimaryGeoIDCleared returns if the "primary_geo_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) PrimaryGeoIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldPrimaryGeoID]
	return ok
}

// ResetPrimaryGeoID resets all changes to the "primary_geo_id" field.
func (m *OrderAdjustmentMutation) ResetPrimaryGeoID() {
	m.primary_geo_id = nil
	m.addprimary_geo_id = nil
	delete(m.clearedFields, orderadjustment.FieldPrimaryGeoID)
}

// SetSecondaryGeoID sets the "secondary_geo_id" field.
func (m *OrderAdjustmentMutation) SetSecondaryGeoID(i int) {
	m.secondary_geo_id = &i
	m.addsecondary_geo_id = nil
}

// SecondaryGeoID returns the value of the "secondary_geo_id" field in the mutation.
func (m *OrderAdjustmentMutation) SecondaryGeoID() (r int, exists bool) {
	v := m.secondary_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryGeoID returns the old "secondary_geo_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldSecondaryGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecondaryGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecondaryGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryGeoID: %w", err)
	}
	return oldValue.SecondaryGeoID, nil
}

// AddSecondaryGeoID adds i to the "secondary_geo_id" field.
func (m *OrderAdjustmentMutation) AddSecondaryGeoID(i int) {
	if m.addsecondary_geo_id != nil {
		*m.addsecondary_geo_id += i
	} else {
		m.addsecondary_geo_id = &i
	}
}

// AddedSecondaryGeoID returns the value that was added to the "secondary_geo_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedSecondaryGeoID() (r int, exists bool) {
	v := m.addsecondary_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSecondaryGeoID clears the value of the "secondary_geo_id" field.
func (m *OrderAdjustmentMutation) ClearSecondaryGeoID() {
	m.secondary_geo_id = nil
	m.addsecondary_geo_id = nil
	m.clearedFields[orderadjustment.FieldSecondaryGeoID] = struct{}{}
}

// SecondaryGeoIDCleared returns if the "secondary_geo_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) SecondaryGeoIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldSecondaryGeoID]
	return ok
}

// ResetSecondaryGeoID resets all changes to the "secondary_geo_id" field.
func (m *OrderAdjustmentMutation) ResetSecondaryGeoID() {
	m.secondary_geo_id = nil
	m.addsecondary_geo_id = nil
	delete(m.clearedFields, orderadjustment.FieldSecondaryGeoID)
}

// SetExemptAmount sets the "exempt_amount" field.
func (m *OrderAdjustmentMutation) SetExemptAmount(f float64) {
	m.exempt_amount = &f
	m.addexempt_amount = nil
}

// ExemptAmount returns the value of the "exempt_amount" field in the mutation.
func (m *OrderAdjustmentMutation) ExemptAmount() (r float64, exists bool) {
	v := m.exempt_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldExemptAmount returns the old "exempt_amount" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldExemptAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExemptAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExemptAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExemptAmount: %w", err)
	}
	return oldValue.ExemptAmount, nil
}

// AddExemptAmount adds f to the "exempt_amount" field.
func (m *OrderAdjustmentMutation) AddExemptAmount(f float64) {
	if m.addexempt_amount != nil {
		*m.addexempt_amount += f
	} else {
		m.addexempt_amount = &f
	}
}

// AddedExemptAmount returns the value that was added to the "exempt_amount" field in this mutation.
func (m *OrderAdjustmentMutation) AddedExemptAmount() (r float64, exists bool) {
	v := m.addexempt_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearExemptAmount clears the value of the "exempt_amount" field.
func (m *OrderAdjustmentMutation) ClearExemptAmount() {
	m.exempt_amount = nil
	m.addexempt_amount = nil
	m.clearedFields[orderadjustment.FieldExemptAmount] = struct{}{}
}

// ExemptAmountCleared returns if the "exempt_amount" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) ExemptAmountCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldExemptAmount]
	return ok
}

// ResetExemptAmount resets all changes to the "exempt_amount" field.
func (m *OrderAdjustmentMutation) ResetExemptAmount() {
	m.exempt_amount = nil
	m.addexempt_amount = nil
	delete(m.clearedFields, orderadjustment.FieldExemptAmount)
}

// SetTaxAuthGeoID sets the "tax_auth_geo_id" field.
func (m *OrderAdjustmentMutation) SetTaxAuthGeoID(i int) {
	m.tax_auth_geo_id = &i
	m.addtax_auth_geo_id = nil
}

// TaxAuthGeoID returns the value of the "tax_auth_geo_id" field in the mutation.
func (m *OrderAdjustmentMutation) TaxAuthGeoID() (r int, exists bool) {
	v := m.tax_auth_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAuthGeoID returns the old "tax_auth_geo_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldTaxAuthGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxAuthGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxAuthGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAuthGeoID: %w", err)
	}
	return oldValue.TaxAuthGeoID, nil
}

// AddTaxAuthGeoID adds i to the "tax_auth_geo_id" field.
func (m *OrderAdjustmentMutation) AddTaxAuthGeoID(i int) {
	if m.addtax_auth_geo_id != nil {
		*m.addtax_auth_geo_id += i
	} else {
		m.addtax_auth_geo_id = &i
	}
}

// AddedTaxAuthGeoID returns the value that was added to the "tax_auth_geo_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedTaxAuthGeoID() (r int, exists bool) {
	v := m.addtax_auth_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAuthGeoID clears the value of the "tax_auth_geo_id" field.
func (m *OrderAdjustmentMutation) ClearTaxAuthGeoID() {
	m.tax_auth_geo_id = nil
	m.addtax_auth_geo_id = nil
	m.clearedFields[orderadjustment.FieldTaxAuthGeoID] = struct{}{}
}

// TaxAuthGeoIDCleared returns if the "tax_auth_geo_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) TaxAuthGeoIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldTaxAuthGeoID]
	return ok
}

// ResetTaxAuthGeoID resets all changes to the "tax_auth_geo_id" field.
func (m *OrderAdjustmentMutation) ResetTaxAuthGeoID() {
	m.tax_auth_geo_id = nil
	m.addtax_auth_geo_id = nil
	delete(m.clearedFields, orderadjustment.FieldTaxAuthGeoID)
}

// SetTaxAuthPartyID sets the "tax_auth_party_id" field.
func (m *OrderAdjustmentMutation) SetTaxAuthPartyID(i int) {
	m.tax_auth_party_id = &i
	m.addtax_auth_party_id = nil
}

// TaxAuthPartyID returns the value of the "tax_auth_party_id" field in the mutation.
func (m *OrderAdjustmentMutation) TaxAuthPartyID() (r int, exists bool) {
	v := m.tax_auth_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAuthPartyID returns the old "tax_auth_party_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldTaxAuthPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxAuthPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxAuthPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAuthPartyID: %w", err)
	}
	return oldValue.TaxAuthPartyID, nil
}

// AddTaxAuthPartyID adds i to the "tax_auth_party_id" field.
func (m *OrderAdjustmentMutation) AddTaxAuthPartyID(i int) {
	if m.addtax_auth_party_id != nil {
		*m.addtax_auth_party_id += i
	} else {
		m.addtax_auth_party_id = &i
	}
}

// AddedTaxAuthPartyID returns the value that was added to the "tax_auth_party_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedTaxAuthPartyID() (r int, exists bool) {
	v := m.addtax_auth_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAuthPartyID clears the value of the "tax_auth_party_id" field.
func (m *OrderAdjustmentMutation) ClearTaxAuthPartyID() {
	m.tax_auth_party_id = nil
	m.addtax_auth_party_id = nil
	m.clearedFields[orderadjustment.FieldTaxAuthPartyID] = struct{}{}
}

// TaxAuthPartyIDCleared returns if the "tax_auth_party_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) TaxAuthPartyIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldTaxAuthPartyID]
	return ok
}

// ResetTaxAuthPartyID resets all changes to the "tax_auth_party_id" field.
func (m *OrderAdjustmentMutation) ResetTaxAuthPartyID() {
	m.tax_auth_party_id = nil
	m.addtax_auth_party_id = nil
	delete(m.clearedFields, orderadjustment.FieldTaxAuthPartyID)
}

// SetOverrideGlAccountID sets the "override_gl_account_id" field.
func (m *OrderAdjustmentMutation) SetOverrideGlAccountID(i int) {
	m.override_gl_account_id = &i
	m.addoverride_gl_account_id = nil
}

// OverrideGlAccountID returns the value of the "override_gl_account_id" field in the mutation.
func (m *OrderAdjustmentMutation) OverrideGlAccountID() (r int, exists bool) {
	v := m.override_gl_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideGlAccountID returns the old "override_gl_account_id" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldOverrideGlAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOverrideGlAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOverrideGlAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideGlAccountID: %w", err)
	}
	return oldValue.OverrideGlAccountID, nil
}

// AddOverrideGlAccountID adds i to the "override_gl_account_id" field.
func (m *OrderAdjustmentMutation) AddOverrideGlAccountID(i int) {
	if m.addoverride_gl_account_id != nil {
		*m.addoverride_gl_account_id += i
	} else {
		m.addoverride_gl_account_id = &i
	}
}

// AddedOverrideGlAccountID returns the value that was added to the "override_gl_account_id" field in this mutation.
func (m *OrderAdjustmentMutation) AddedOverrideGlAccountID() (r int, exists bool) {
	v := m.addoverride_gl_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOverrideGlAccountID clears the value of the "override_gl_account_id" field.
func (m *OrderAdjustmentMutation) ClearOverrideGlAccountID() {
	m.override_gl_account_id = nil
	m.addoverride_gl_account_id = nil
	m.clearedFields[orderadjustment.FieldOverrideGlAccountID] = struct{}{}
}

// OverrideGlAccountIDCleared returns if the "override_gl_account_id" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) OverrideGlAccountIDCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldOverrideGlAccountID]
	return ok
}

// ResetOverrideGlAccountID resets all changes to the "override_gl_account_id" field.
func (m *OrderAdjustmentMutation) ResetOverrideGlAccountID() {
	m.override_gl_account_id = nil
	m.addoverride_gl_account_id = nil
	delete(m.clearedFields, orderadjustment.FieldOverrideGlAccountID)
}

// SetIncludeInTax sets the "include_in_tax" field.
func (m *OrderAdjustmentMutation) SetIncludeInTax(oit orderadjustment.IncludeInTax) {
	m.include_in_tax = &oit
}

// IncludeInTax returns the value of the "include_in_tax" field in the mutation.
func (m *OrderAdjustmentMutation) IncludeInTax() (r orderadjustment.IncludeInTax, exists bool) {
	v := m.include_in_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeInTax returns the old "include_in_tax" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldIncludeInTax(ctx context.Context) (v orderadjustment.IncludeInTax, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIncludeInTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIncludeInTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeInTax: %w", err)
	}
	return oldValue.IncludeInTax, nil
}

// ClearIncludeInTax clears the value of the "include_in_tax" field.
func (m *OrderAdjustmentMutation) ClearIncludeInTax() {
	m.include_in_tax = nil
	m.clearedFields[orderadjustment.FieldIncludeInTax] = struct{}{}
}

// IncludeInTaxCleared returns if the "include_in_tax" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) IncludeInTaxCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldIncludeInTax]
	return ok
}

// ResetIncludeInTax resets all changes to the "include_in_tax" field.
func (m *OrderAdjustmentMutation) ResetIncludeInTax() {
	m.include_in_tax = nil
	delete(m.clearedFields, orderadjustment.FieldIncludeInTax)
}

// SetIncludeInShipping sets the "include_in_shipping" field.
func (m *OrderAdjustmentMutation) SetIncludeInShipping(ois orderadjustment.IncludeInShipping) {
	m.include_in_shipping = &ois
}

// IncludeInShipping returns the value of the "include_in_shipping" field in the mutation.
func (m *OrderAdjustmentMutation) IncludeInShipping() (r orderadjustment.IncludeInShipping, exists bool) {
	v := m.include_in_shipping
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeInShipping returns the old "include_in_shipping" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldIncludeInShipping(ctx context.Context) (v orderadjustment.IncludeInShipping, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIncludeInShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIncludeInShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeInShipping: %w", err)
	}
	return oldValue.IncludeInShipping, nil
}

// ClearIncludeInShipping clears the value of the "include_in_shipping" field.
func (m *OrderAdjustmentMutation) ClearIncludeInShipping() {
	m.include_in_shipping = nil
	m.clearedFields[orderadjustment.FieldIncludeInShipping] = struct{}{}
}

// IncludeInShippingCleared returns if the "include_in_shipping" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) IncludeInShippingCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldIncludeInShipping]
	return ok
}

// ResetIncludeInShipping resets all changes to the "include_in_shipping" field.
func (m *OrderAdjustmentMutation) ResetIncludeInShipping() {
	m.include_in_shipping = nil
	delete(m.clearedFields, orderadjustment.FieldIncludeInShipping)
}

// SetIsManual sets the "is_manual" field.
func (m *OrderAdjustmentMutation) SetIsManual(om orderadjustment.IsManual) {
	m.is_manual = &om
}

// IsManual returns the value of the "is_manual" field in the mutation.
func (m *OrderAdjustmentMutation) IsManual() (r orderadjustment.IsManual, exists bool) {
	v := m.is_manual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsManual returns the old "is_manual" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldIsManual(ctx context.Context) (v orderadjustment.IsManual, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsManual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsManual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsManual: %w", err)
	}
	return oldValue.IsManual, nil
}

// ClearIsManual clears the value of the "is_manual" field.
func (m *OrderAdjustmentMutation) ClearIsManual() {
	m.is_manual = nil
	m.clearedFields[orderadjustment.FieldIsManual] = struct{}{}
}

// IsManualCleared returns if the "is_manual" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) IsManualCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldIsManual]
	return ok
}

// ResetIsManual resets all changes to the "is_manual" field.
func (m *OrderAdjustmentMutation) ResetIsManual() {
	m.is_manual = nil
	delete(m.clearedFields, orderadjustment.FieldIsManual)
}

// SetCreatedDate sets the "created_date" field.
func (m *OrderAdjustmentMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *OrderAdjustmentMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *OrderAdjustmentMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[orderadjustment.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *OrderAdjustmentMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, orderadjustment.FieldCreatedDate)
}

// SetCreatedByUserLogin sets the "created_by_user_login" field.
func (m *OrderAdjustmentMutation) SetCreatedByUserLogin(s string) {
	m.created_by_user_login = &s
}

// CreatedByUserLogin returns the value of the "created_by_user_login" field in the mutation.
func (m *OrderAdjustmentMutation) CreatedByUserLogin() (r string, exists bool) {
	v := m.created_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByUserLogin returns the old "created_by_user_login" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldCreatedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByUserLogin: %w", err)
	}
	return oldValue.CreatedByUserLogin, nil
}

// ClearCreatedByUserLogin clears the value of the "created_by_user_login" field.
func (m *OrderAdjustmentMutation) ClearCreatedByUserLogin() {
	m.created_by_user_login = nil
	m.clearedFields[orderadjustment.FieldCreatedByUserLogin] = struct{}{}
}

// CreatedByUserLoginCleared returns if the "created_by_user_login" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) CreatedByUserLoginCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldCreatedByUserLogin]
	return ok
}

// ResetCreatedByUserLogin resets all changes to the "created_by_user_login" field.
func (m *OrderAdjustmentMutation) ResetCreatedByUserLogin() {
	m.created_by_user_login = nil
	delete(m.clearedFields, orderadjustment.FieldCreatedByUserLogin)
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *OrderAdjustmentMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *OrderAdjustmentMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ClearLastModifiedDate clears the value of the "last_modified_date" field.
func (m *OrderAdjustmentMutation) ClearLastModifiedDate() {
	m.last_modified_date = nil
	m.clearedFields[orderadjustment.FieldLastModifiedDate] = struct{}{}
}

// LastModifiedDateCleared returns if the "last_modified_date" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) LastModifiedDateCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldLastModifiedDate]
	return ok
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *OrderAdjustmentMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
	delete(m.clearedFields, orderadjustment.FieldLastModifiedDate)
}

// SetLastModifiedByUserLogin sets the "last_modified_by_user_login" field.
func (m *OrderAdjustmentMutation) SetLastModifiedByUserLogin(s string) {
	m.last_modified_by_user_login = &s
}

// LastModifiedByUserLogin returns the value of the "last_modified_by_user_login" field in the mutation.
func (m *OrderAdjustmentMutation) LastModifiedByUserLogin() (r string, exists bool) {
	v := m.last_modified_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedByUserLogin returns the old "last_modified_by_user_login" field's value of the OrderAdjustment entity.
// If the OrderAdjustment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderAdjustmentMutation) OldLastModifiedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedByUserLogin: %w", err)
	}
	return oldValue.LastModifiedByUserLogin, nil
}

// ClearLastModifiedByUserLogin clears the value of the "last_modified_by_user_login" field.
func (m *OrderAdjustmentMutation) ClearLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	m.clearedFields[orderadjustment.FieldLastModifiedByUserLogin] = struct{}{}
}

// LastModifiedByUserLoginCleared returns if the "last_modified_by_user_login" field was cleared in this mutation.
func (m *OrderAdjustmentMutation) LastModifiedByUserLoginCleared() bool {
	_, ok := m.clearedFields[orderadjustment.FieldLastModifiedByUserLogin]
	return ok
}

// ResetLastModifiedByUserLogin resets all changes to the "last_modified_by_user_login" field.
func (m *OrderAdjustmentMutation) ResetLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	delete(m.clearedFields, orderadjustment.FieldLastModifiedByUserLogin)
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderAdjustmentMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderAdjustmentMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderAdjustmentMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderAdjustmentMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderAdjustmentMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderAdjustmentMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetOrderItemID sets the "order_item" edge to the OrderItem entity by id.
func (m *OrderAdjustmentMutation) SetOrderItemID(id int) {
	m.order_item = &id
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *OrderAdjustmentMutation) ClearOrderItem() {
	m.clearedorder_item = true
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *OrderAdjustmentMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemID returns the "order_item" edge ID in the mutation.
func (m *OrderAdjustmentMutation) OrderItemID() (id int, exists bool) {
	if m.order_item != nil {
		return *m.order_item, true
	}
	return
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *OrderAdjustmentMutation) OrderItemIDs() (ids []int) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *OrderAdjustmentMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// SetOrderItemShipGroupID sets the "order_item_ship_group" edge to the OrderItemShipGroup entity by id.
func (m *OrderAdjustmentMutation) SetOrderItemShipGroupID(id int) {
	m.order_item_ship_group = &id
}

// ClearOrderItemShipGroup clears the "order_item_ship_group" edge to the OrderItemShipGroup entity.
func (m *OrderAdjustmentMutation) ClearOrderItemShipGroup() {
	m.clearedorder_item_ship_group = true
}

// OrderItemShipGroupCleared reports if the "order_item_ship_group" edge to the OrderItemShipGroup entity was cleared.
func (m *OrderAdjustmentMutation) OrderItemShipGroupCleared() bool {
	return m.clearedorder_item_ship_group
}

// OrderItemShipGroupID returns the "order_item_ship_group" edge ID in the mutation.
func (m *OrderAdjustmentMutation) OrderItemShipGroupID() (id int, exists bool) {
	if m.order_item_ship_group != nil {
		return *m.order_item_ship_group, true
	}
	return
}

// OrderItemShipGroupIDs returns the "order_item_ship_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGroupID instead. It exists only for internal usage by the builders.
func (m *OrderAdjustmentMutation) OrderItemShipGroupIDs() (ids []int) {
	if id := m.order_item_ship_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGroup resets all changes to the "order_item_ship_group" edge.
func (m *OrderAdjustmentMutation) ResetOrderItemShipGroup() {
	m.order_item_ship_group = nil
	m.clearedorder_item_ship_group = false
}

// SetOrderItemShipGroupAssocID sets the "order_item_ship_group_assoc" edge to the OrderItemShipGroupAssoc entity by id.
func (m *OrderAdjustmentMutation) SetOrderItemShipGroupAssocID(id int) {
	m.order_item_ship_group_assoc = &id
}

// ClearOrderItemShipGroupAssoc clears the "order_item_ship_group_assoc" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderAdjustmentMutation) ClearOrderItemShipGroupAssoc() {
	m.clearedorder_item_ship_group_assoc = true
}

// OrderItemShipGroupAssocCleared reports if the "order_item_ship_group_assoc" edge to the OrderItemShipGroupAssoc entity was cleared.
func (m *OrderAdjustmentMutation) OrderItemShipGroupAssocCleared() bool {
	return m.clearedorder_item_ship_group_assoc
}

// OrderItemShipGroupAssocID returns the "order_item_ship_group_assoc" edge ID in the mutation.
func (m *OrderAdjustmentMutation) OrderItemShipGroupAssocID() (id int, exists bool) {
	if m.order_item_ship_group_assoc != nil {
		return *m.order_item_ship_group_assoc, true
	}
	return
}

// OrderItemShipGroupAssocIDs returns the "order_item_ship_group_assoc" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGroupAssocID instead. It exists only for internal usage by the builders.
func (m *OrderAdjustmentMutation) OrderItemShipGroupAssocIDs() (ids []int) {
	if id := m.order_item_ship_group_assoc; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGroupAssoc resets all changes to the "order_item_ship_group_assoc" edge.
func (m *OrderAdjustmentMutation) ResetOrderItemShipGroupAssoc() {
	m.order_item_ship_group_assoc = nil
	m.clearedorder_item_ship_group_assoc = false
}

// SetParentID sets the "parent" edge to the OrderAdjustment entity by id.
func (m *OrderAdjustmentMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OrderAdjustment entity.
func (m *OrderAdjustmentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OrderAdjustment entity was cleared.
func (m *OrderAdjustmentMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OrderAdjustmentMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrderAdjustmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrderAdjustmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the OrderAdjustment entity by ids.
func (m *OrderAdjustmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the OrderAdjustment entity.
func (m *OrderAdjustmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the OrderAdjustment entity was cleared.
func (m *OrderAdjustmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the OrderAdjustment entity by IDs.
func (m *OrderAdjustmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the OrderAdjustment entity.
func (m *OrderAdjustmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrderAdjustmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrderAdjustmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Op returns the operation name.
func (m *OrderAdjustmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderAdjustment).
func (m *OrderAdjustmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderAdjustmentMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.create_time != nil {
		fields = append(fields, orderadjustment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderadjustment.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderadjustment.FieldStringRef)
	}
	if m.order_adjustment_type_id != nil {
		fields = append(fields, orderadjustment.FieldOrderAdjustmentTypeID)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, orderadjustment.FieldOrderItemSeqID)
	}
	if m.ship_group_seq_id != nil {
		fields = append(fields, orderadjustment.FieldShipGroupSeqID)
	}
	if m.comments != nil {
		fields = append(fields, orderadjustment.FieldComments)
	}
	if m.description != nil {
		fields = append(fields, orderadjustment.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, orderadjustment.FieldAmount)
	}
	if m.recurring_amount != nil {
		fields = append(fields, orderadjustment.FieldRecurringAmount)
	}
	if m.amount_already_included != nil {
		fields = append(fields, orderadjustment.FieldAmountAlreadyIncluded)
	}
	if m.product_promo_id != nil {
		fields = append(fields, orderadjustment.FieldProductPromoID)
	}
	if m.product_promo_rule_id != nil {
		fields = append(fields, orderadjustment.FieldProductPromoRuleID)
	}
	if m.product_promo_action_seq_id != nil {
		fields = append(fields, orderadjustment.FieldProductPromoActionSeqID)
	}
	if m.product_feature_id != nil {
		fields = append(fields, orderadjustment.FieldProductFeatureID)
	}
	if m.corresponding_product_id != nil {
		fields = append(fields, orderadjustment.FieldCorrespondingProductID)
	}
	if m.tax_authority_rate_seq_id != nil {
		fields = append(fields, orderadjustment.FieldTaxAuthorityRateSeqID)
	}
	if m.source_reference_id != nil {
		fields = append(fields, orderadjustment.FieldSourceReferenceID)
	}
	if m.source_percentage != nil {
		fields = append(fields, orderadjustment.FieldSourcePercentage)
	}
	if m.customer_reference_id != nil {
		fields = append(fields, orderadjustment.FieldCustomerReferenceID)
	}
	if m.primary_geo_id != nil {
		fields = append(fields, orderadjustment.FieldPrimaryGeoID)
	}
	if m.secondary_geo_id != nil {
		fields = append(fields, orderadjustment.FieldSecondaryGeoID)
	}
	if m.exempt_amount != nil {
		fields = append(fields, orderadjustment.FieldExemptAmount)
	}
	if m.tax_auth_geo_id != nil {
		fields = append(fields, orderadjustment.FieldTaxAuthGeoID)
	}
	if m.tax_auth_party_id != nil {
		fields = append(fields, orderadjustment.FieldTaxAuthPartyID)
	}
	if m.override_gl_account_id != nil {
		fields = append(fields, orderadjustment.FieldOverrideGlAccountID)
	}
	if m.include_in_tax != nil {
		fields = append(fields, orderadjustment.FieldIncludeInTax)
	}
	if m.include_in_shipping != nil {
		fields = append(fields, orderadjustment.FieldIncludeInShipping)
	}
	if m.is_manual != nil {
		fields = append(fields, orderadjustment.FieldIsManual)
	}
	if m.created_date != nil {
		fields = append(fields, orderadjustment.FieldCreatedDate)
	}
	if m.created_by_user_login != nil {
		fields = append(fields, orderadjustment.FieldCreatedByUserLogin)
	}
	if m.last_modified_date != nil {
		fields = append(fields, orderadjustment.FieldLastModifiedDate)
	}
	if m.last_modified_by_user_login != nil {
		fields = append(fields, orderadjustment.FieldLastModifiedByUserLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderAdjustmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderadjustment.FieldCreateTime:
		return m.CreateTime()
	case orderadjustment.FieldUpdateTime:
		return m.UpdateTime()
	case orderadjustment.FieldStringRef:
		return m.StringRef()
	case orderadjustment.FieldOrderAdjustmentTypeID:
		return m.OrderAdjustmentTypeID()
	case orderadjustment.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case orderadjustment.FieldShipGroupSeqID:
		return m.ShipGroupSeqID()
	case orderadjustment.FieldComments:
		return m.Comments()
	case orderadjustment.FieldDescription:
		return m.Description()
	case orderadjustment.FieldAmount:
		return m.Amount()
	case orderadjustment.FieldRecurringAmount:
		return m.RecurringAmount()
	case orderadjustment.FieldAmountAlreadyIncluded:
		return m.AmountAlreadyIncluded()
	case orderadjustment.FieldProductPromoID:
		return m.ProductPromoID()
	case orderadjustment.FieldProductPromoRuleID:
		return m.ProductPromoRuleID()
	case orderadjustment.FieldProductPromoActionSeqID:
		return m.ProductPromoActionSeqID()
	case orderadjustment.FieldProductFeatureID:
		return m.ProductFeatureID()
	case orderadjustment.FieldCorrespondingProductID:
		return m.CorrespondingProductID()
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		return m.TaxAuthorityRateSeqID()
	case orderadjustment.FieldSourceReferenceID:
		return m.SourceReferenceID()
	case orderadjustment.FieldSourcePercentage:
		return m.SourcePercentage()
	case orderadjustment.FieldCustomerReferenceID:
		return m.CustomerReferenceID()
	case orderadjustment.FieldPrimaryGeoID:
		return m.PrimaryGeoID()
	case orderadjustment.FieldSecondaryGeoID:
		return m.SecondaryGeoID()
	case orderadjustment.FieldExemptAmount:
		return m.ExemptAmount()
	case orderadjustment.FieldTaxAuthGeoID:
		return m.TaxAuthGeoID()
	case orderadjustment.FieldTaxAuthPartyID:
		return m.TaxAuthPartyID()
	case orderadjustment.FieldOverrideGlAccountID:
		return m.OverrideGlAccountID()
	case orderadjustment.FieldIncludeInTax:
		return m.IncludeInTax()
	case orderadjustment.FieldIncludeInShipping:
		return m.IncludeInShipping()
	case orderadjustment.FieldIsManual:
		return m.IsManual()
	case orderadjustment.FieldCreatedDate:
		return m.CreatedDate()
	case orderadjustment.FieldCreatedByUserLogin:
		return m.CreatedByUserLogin()
	case orderadjustment.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case orderadjustment.FieldLastModifiedByUserLogin:
		return m.LastModifiedByUserLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderAdjustmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderadjustment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderadjustment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderadjustment.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderadjustment.FieldOrderAdjustmentTypeID:
		return m.OldOrderAdjustmentTypeID(ctx)
	case orderadjustment.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case orderadjustment.FieldShipGroupSeqID:
		return m.OldShipGroupSeqID(ctx)
	case orderadjustment.FieldComments:
		return m.OldComments(ctx)
	case orderadjustment.FieldDescription:
		return m.OldDescription(ctx)
	case orderadjustment.FieldAmount:
		return m.OldAmount(ctx)
	case orderadjustment.FieldRecurringAmount:
		return m.OldRecurringAmount(ctx)
	case orderadjustment.FieldAmountAlreadyIncluded:
		return m.OldAmountAlreadyIncluded(ctx)
	case orderadjustment.FieldProductPromoID:
		return m.OldProductPromoID(ctx)
	case orderadjustment.FieldProductPromoRuleID:
		return m.OldProductPromoRuleID(ctx)
	case orderadjustment.FieldProductPromoActionSeqID:
		return m.OldProductPromoActionSeqID(ctx)
	case orderadjustment.FieldProductFeatureID:
		return m.OldProductFeatureID(ctx)
	case orderadjustment.FieldCorrespondingProductID:
		return m.OldCorrespondingProductID(ctx)
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		return m.OldTaxAuthorityRateSeqID(ctx)
	case orderadjustment.FieldSourceReferenceID:
		return m.OldSourceReferenceID(ctx)
	case orderadjustment.FieldSourcePercentage:
		return m.OldSourcePercentage(ctx)
	case orderadjustment.FieldCustomerReferenceID:
		return m.OldCustomerReferenceID(ctx)
	case orderadjustment.FieldPrimaryGeoID:
		return m.OldPrimaryGeoID(ctx)
	case orderadjustment.FieldSecondaryGeoID:
		return m.OldSecondaryGeoID(ctx)
	case orderadjustment.FieldExemptAmount:
		return m.OldExemptAmount(ctx)
	case orderadjustment.FieldTaxAuthGeoID:
		return m.OldTaxAuthGeoID(ctx)
	case orderadjustment.FieldTaxAuthPartyID:
		return m.OldTaxAuthPartyID(ctx)
	case orderadjustment.FieldOverrideGlAccountID:
		return m.OldOverrideGlAccountID(ctx)
	case orderadjustment.FieldIncludeInTax:
		return m.OldIncludeInTax(ctx)
	case orderadjustment.FieldIncludeInShipping:
		return m.OldIncludeInShipping(ctx)
	case orderadjustment.FieldIsManual:
		return m.OldIsManual(ctx)
	case orderadjustment.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case orderadjustment.FieldCreatedByUserLogin:
		return m.OldCreatedByUserLogin(ctx)
	case orderadjustment.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case orderadjustment.FieldLastModifiedByUserLogin:
		return m.OldLastModifiedByUserLogin(ctx)
	}
	return nil, fmt.Errorf("unknown OrderAdjustment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAdjustmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderadjustment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderadjustment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderadjustment.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderadjustment.FieldOrderAdjustmentTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderAdjustmentTypeID(v)
		return nil
	case orderadjustment.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case orderadjustment.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipGroupSeqID(v)
		return nil
	case orderadjustment.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case orderadjustment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case orderadjustment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderadjustment.FieldRecurringAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurringAmount(v)
		return nil
	case orderadjustment.FieldAmountAlreadyIncluded:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountAlreadyIncluded(v)
		return nil
	case orderadjustment.FieldProductPromoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPromoID(v)
		return nil
	case orderadjustment.FieldProductPromoRuleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPromoRuleID(v)
		return nil
	case orderadjustment.FieldProductPromoActionSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPromoActionSeqID(v)
		return nil
	case orderadjustment.FieldProductFeatureID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductFeatureID(v)
		return nil
	case orderadjustment.FieldCorrespondingProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrespondingProductID(v)
		return nil
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAuthorityRateSeqID(v)
		return nil
	case orderadjustment.FieldSourceReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceReferenceID(v)
		return nil
	case orderadjustment.FieldSourcePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourcePercentage(v)
		return nil
	case orderadjustment.FieldCustomerReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerReferenceID(v)
		return nil
	case orderadjustment.FieldPrimaryGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryGeoID(v)
		return nil
	case orderadjustment.FieldSecondaryGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryGeoID(v)
		return nil
	case orderadjustment.FieldExemptAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExemptAmount(v)
		return nil
	case orderadjustment.FieldTaxAuthGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAuthGeoID(v)
		return nil
	case orderadjustment.FieldTaxAuthPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAuthPartyID(v)
		return nil
	case orderadjustment.FieldOverrideGlAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideGlAccountID(v)
		return nil
	case orderadjustment.FieldIncludeInTax:
		v, ok := value.(orderadjustment.IncludeInTax)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeInTax(v)
		return nil
	case orderadjustment.FieldIncludeInShipping:
		v, ok := value.(orderadjustment.IncludeInShipping)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeInShipping(v)
		return nil
	case orderadjustment.FieldIsManual:
		v, ok := value.(orderadjustment.IsManual)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsManual(v)
		return nil
	case orderadjustment.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case orderadjustment.FieldCreatedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByUserLogin(v)
		return nil
	case orderadjustment.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case orderadjustment.FieldLastModifiedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedByUserLogin(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAdjustment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderAdjustmentMutation) AddedFields() []string {
	var fields []string
	if m.addorder_adjustment_type_id != nil {
		fields = append(fields, orderadjustment.FieldOrderAdjustmentTypeID)
	}
	if m.addorder_item_seq_id != nil {
		fields = append(fields, orderadjustment.FieldOrderItemSeqID)
	}
	if m.addship_group_seq_id != nil {
		fields = append(fields, orderadjustment.FieldShipGroupSeqID)
	}
	if m.addamount != nil {
		fields = append(fields, orderadjustment.FieldAmount)
	}
	if m.addrecurring_amount != nil {
		fields = append(fields, orderadjustment.FieldRecurringAmount)
	}
	if m.addamount_already_included != nil {
		fields = append(fields, orderadjustment.FieldAmountAlreadyIncluded)
	}
	if m.addproduct_promo_id != nil {
		fields = append(fields, orderadjustment.FieldProductPromoID)
	}
	if m.addproduct_promo_rule_id != nil {
		fields = append(fields, orderadjustment.FieldProductPromoRuleID)
	}
	if m.addproduct_promo_action_seq_id != nil {
		fields = append(fields, orderadjustment.FieldProductPromoActionSeqID)
	}
	if m.addproduct_feature_id != nil {
		fields = append(fields, orderadjustment.FieldProductFeatureID)
	}
	if m.addcorresponding_product_id != nil {
		fields = append(fields, orderadjustment.FieldCorrespondingProductID)
	}
	if m.addtax_authority_rate_seq_id != nil {
		fields = append(fields, orderadjustment.FieldTaxAuthorityRateSeqID)
	}
	if m.addsource_percentage != nil {
		fields = append(fields, orderadjustment.FieldSourcePercentage)
	}
	if m.addprimary_geo_id != nil {
		fields = append(fields, orderadjustment.FieldPrimaryGeoID)
	}
	if m.addsecondary_geo_id != nil {
		fields = append(fields, orderadjustment.FieldSecondaryGeoID)
	}
	if m.addexempt_amount != nil {
		fields = append(fields, orderadjustment.FieldExemptAmount)
	}
	if m.addtax_auth_geo_id != nil {
		fields = append(fields, orderadjustment.FieldTaxAuthGeoID)
	}
	if m.addtax_auth_party_id != nil {
		fields = append(fields, orderadjustment.FieldTaxAuthPartyID)
	}
	if m.addoverride_gl_account_id != nil {
		fields = append(fields, orderadjustment.FieldOverrideGlAccountID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderAdjustmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderadjustment.FieldOrderAdjustmentTypeID:
		return m.AddedOrderAdjustmentTypeID()
	case orderadjustment.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	case orderadjustment.FieldShipGroupSeqID:
		return m.AddedShipGroupSeqID()
	case orderadjustment.FieldAmount:
		return m.AddedAmount()
	case orderadjustment.FieldRecurringAmount:
		return m.AddedRecurringAmount()
	case orderadjustment.FieldAmountAlreadyIncluded:
		return m.AddedAmountAlreadyIncluded()
	case orderadjustment.FieldProductPromoID:
		return m.AddedProductPromoID()
	case orderadjustment.FieldProductPromoRuleID:
		return m.AddedProductPromoRuleID()
	case orderadjustment.FieldProductPromoActionSeqID:
		return m.AddedProductPromoActionSeqID()
	case orderadjustment.FieldProductFeatureID:
		return m.AddedProductFeatureID()
	case orderadjustment.FieldCorrespondingProductID:
		return m.AddedCorrespondingProductID()
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		return m.AddedTaxAuthorityRateSeqID()
	case orderadjustment.FieldSourcePercentage:
		return m.AddedSourcePercentage()
	case orderadjustment.FieldPrimaryGeoID:
		return m.AddedPrimaryGeoID()
	case orderadjustment.FieldSecondaryGeoID:
		return m.AddedSecondaryGeoID()
	case orderadjustment.FieldExemptAmount:
		return m.AddedExemptAmount()
	case orderadjustment.FieldTaxAuthGeoID:
		return m.AddedTaxAuthGeoID()
	case orderadjustment.FieldTaxAuthPartyID:
		return m.AddedTaxAuthPartyID()
	case orderadjustment.FieldOverrideGlAccountID:
		return m.AddedOverrideGlAccountID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderAdjustmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderadjustment.FieldOrderAdjustmentTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderAdjustmentTypeID(v)
		return nil
	case orderadjustment.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	case orderadjustment.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipGroupSeqID(v)
		return nil
	case orderadjustment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case orderadjustment.FieldRecurringAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecurringAmount(v)
		return nil
	case orderadjustment.FieldAmountAlreadyIncluded:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountAlreadyIncluded(v)
		return nil
	case orderadjustment.FieldProductPromoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPromoID(v)
		return nil
	case orderadjustment.FieldProductPromoRuleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPromoRuleID(v)
		return nil
	case orderadjustment.FieldProductPromoActionSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPromoActionSeqID(v)
		return nil
	case orderadjustment.FieldProductFeatureID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductFeatureID(v)
		return nil
	case orderadjustment.FieldCorrespondingProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrespondingProductID(v)
		return nil
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAuthorityRateSeqID(v)
		return nil
	case orderadjustment.FieldSourcePercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourcePercentage(v)
		return nil
	case orderadjustment.FieldPrimaryGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrimaryGeoID(v)
		return nil
	case orderadjustment.FieldSecondaryGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecondaryGeoID(v)
		return nil
	case orderadjustment.FieldExemptAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExemptAmount(v)
		return nil
	case orderadjustment.FieldTaxAuthGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAuthGeoID(v)
		return nil
	case orderadjustment.FieldTaxAuthPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAuthPartyID(v)
		return nil
	case orderadjustment.FieldOverrideGlAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverrideGlAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderAdjustment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderAdjustmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderadjustment.FieldStringRef) {
		fields = append(fields, orderadjustment.FieldStringRef)
	}
	if m.FieldCleared(orderadjustment.FieldOrderAdjustmentTypeID) {
		fields = append(fields, orderadjustment.FieldOrderAdjustmentTypeID)
	}
	if m.FieldCleared(orderadjustment.FieldOrderItemSeqID) {
		fields = append(fields, orderadjustment.FieldOrderItemSeqID)
	}
	if m.FieldCleared(orderadjustment.FieldShipGroupSeqID) {
		fields = append(fields, orderadjustment.FieldShipGroupSeqID)
	}
	if m.FieldCleared(orderadjustment.FieldComments) {
		fields = append(fields, orderadjustment.FieldComments)
	}
	if m.FieldCleared(orderadjustment.FieldDescription) {
		fields = append(fields, orderadjustment.FieldDescription)
	}
	if m.FieldCleared(orderadjustment.FieldAmount) {
		fields = append(fields, orderadjustment.FieldAmount)
	}
	if m.FieldCleared(orderadjustment.FieldRecurringAmount) {
		fields = append(fields, orderadjustment.FieldRecurringAmount)
	}
	if m.FieldCleared(orderadjustment.FieldAmountAlreadyIncluded) {
		fields = append(fields, orderadjustment.FieldAmountAlreadyIncluded)
	}
	if m.FieldCleared(orderadjustment.FieldProductPromoID) {
		fields = append(fields, orderadjustment.FieldProductPromoID)
	}
	if m.FieldCleared(orderadjustment.FieldProductPromoRuleID) {
		fields = append(fields, orderadjustment.FieldProductPromoRuleID)
	}
	if m.FieldCleared(orderadjustment.FieldProductPromoActionSeqID) {
		fields = append(fields, orderadjustment.FieldProductPromoActionSeqID)
	}
	if m.FieldCleared(orderadjustment.FieldProductFeatureID) {
		fields = append(fields, orderadjustment.FieldProductFeatureID)
	}
	if m.FieldCleared(orderadjustment.FieldCorrespondingProductID) {
		fields = append(fields, orderadjustment.FieldCorrespondingProductID)
	}
	if m.FieldCleared(orderadjustment.FieldTaxAuthorityRateSeqID) {
		fields = append(fields, orderadjustment.FieldTaxAuthorityRateSeqID)
	}
	if m.FieldCleared(orderadjustment.FieldSourceReferenceID) {
		fields = append(fields, orderadjustment.FieldSourceReferenceID)
	}
	if m.FieldCleared(orderadjustment.FieldSourcePercentage) {
		fields = append(fields, orderadjustment.FieldSourcePercentage)
	}
	if m.FieldCleared(orderadjustment.FieldCustomerReferenceID) {
		fields = append(fields, orderadjustment.FieldCustomerReferenceID)
	}
	if m.FieldCleared(orderadjustment.FieldPrimaryGeoID) {
		fields = append(fields, orderadjustment.FieldPrimaryGeoID)
	}
	if m.FieldCleared(orderadjustment.FieldSecondaryGeoID) {
		fields = append(fields, orderadjustment.FieldSecondaryGeoID)
	}
	if m.FieldCleared(orderadjustment.FieldExemptAmount) {
		fields = append(fields, orderadjustment.FieldExemptAmount)
	}
	if m.FieldCleared(orderadjustment.FieldTaxAuthGeoID) {
		fields = append(fields, orderadjustment.FieldTaxAuthGeoID)
	}
	if m.FieldCleared(orderadjustment.FieldTaxAuthPartyID) {
		fields = append(fields, orderadjustment.FieldTaxAuthPartyID)
	}
	if m.FieldCleared(orderadjustment.FieldOverrideGlAccountID) {
		fields = append(fields, orderadjustment.FieldOverrideGlAccountID)
	}
	if m.FieldCleared(orderadjustment.FieldIncludeInTax) {
		fields = append(fields, orderadjustment.FieldIncludeInTax)
	}
	if m.FieldCleared(orderadjustment.FieldIncludeInShipping) {
		fields = append(fields, orderadjustment.FieldIncludeInShipping)
	}
	if m.FieldCleared(orderadjustment.FieldIsManual) {
		fields = append(fields, orderadjustment.FieldIsManual)
	}
	if m.FieldCleared(orderadjustment.FieldCreatedDate) {
		fields = append(fields, orderadjustment.FieldCreatedDate)
	}
	if m.FieldCleared(orderadjustment.FieldCreatedByUserLogin) {
		fields = append(fields, orderadjustment.FieldCreatedByUserLogin)
	}
	if m.FieldCleared(orderadjustment.FieldLastModifiedDate) {
		fields = append(fields, orderadjustment.FieldLastModifiedDate)
	}
	if m.FieldCleared(orderadjustment.FieldLastModifiedByUserLogin) {
		fields = append(fields, orderadjustment.FieldLastModifiedByUserLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderAdjustmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderAdjustmentMutation) ClearField(name string) error {
	switch name {
	case orderadjustment.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderadjustment.FieldOrderAdjustmentTypeID:
		m.ClearOrderAdjustmentTypeID()
		return nil
	case orderadjustment.FieldOrderItemSeqID:
		m.ClearOrderItemSeqID()
		return nil
	case orderadjustment.FieldShipGroupSeqID:
		m.ClearShipGroupSeqID()
		return nil
	case orderadjustment.FieldComments:
		m.ClearComments()
		return nil
	case orderadjustment.FieldDescription:
		m.ClearDescription()
		return nil
	case orderadjustment.FieldAmount:
		m.ClearAmount()
		return nil
	case orderadjustment.FieldRecurringAmount:
		m.ClearRecurringAmount()
		return nil
	case orderadjustment.FieldAmountAlreadyIncluded:
		m.ClearAmountAlreadyIncluded()
		return nil
	case orderadjustment.FieldProductPromoID:
		m.ClearProductPromoID()
		return nil
	case orderadjustment.FieldProductPromoRuleID:
		m.ClearProductPromoRuleID()
		return nil
	case orderadjustment.FieldProductPromoActionSeqID:
		m.ClearProductPromoActionSeqID()
		return nil
	case orderadjustment.FieldProductFeatureID:
		m.ClearProductFeatureID()
		return nil
	case orderadjustment.FieldCorrespondingProductID:
		m.ClearCorrespondingProductID()
		return nil
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		m.ClearTaxAuthorityRateSeqID()
		return nil
	case orderadjustment.FieldSourceReferenceID:
		m.ClearSourceReferenceID()
		return nil
	case orderadjustment.FieldSourcePercentage:
		m.ClearSourcePercentage()
		return nil
	case orderadjustment.FieldCustomerReferenceID:
		m.ClearCustomerReferenceID()
		return nil
	case orderadjustment.FieldPrimaryGeoID:
		m.ClearPrimaryGeoID()
		return nil
	case orderadjustment.FieldSecondaryGeoID:
		m.ClearSecondaryGeoID()
		return nil
	case orderadjustment.FieldExemptAmount:
		m.ClearExemptAmount()
		return nil
	case orderadjustment.FieldTaxAuthGeoID:
		m.ClearTaxAuthGeoID()
		return nil
	case orderadjustment.FieldTaxAuthPartyID:
		m.ClearTaxAuthPartyID()
		return nil
	case orderadjustment.FieldOverrideGlAccountID:
		m.ClearOverrideGlAccountID()
		return nil
	case orderadjustment.FieldIncludeInTax:
		m.ClearIncludeInTax()
		return nil
	case orderadjustment.FieldIncludeInShipping:
		m.ClearIncludeInShipping()
		return nil
	case orderadjustment.FieldIsManual:
		m.ClearIsManual()
		return nil
	case orderadjustment.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case orderadjustment.FieldCreatedByUserLogin:
		m.ClearCreatedByUserLogin()
		return nil
	case orderadjustment.FieldLastModifiedDate:
		m.ClearLastModifiedDate()
		return nil
	case orderadjustment.FieldLastModifiedByUserLogin:
		m.ClearLastModifiedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown OrderAdjustment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderAdjustmentMutation) ResetField(name string) error {
	switch name {
	case orderadjustment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderadjustment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderadjustment.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderadjustment.FieldOrderAdjustmentTypeID:
		m.ResetOrderAdjustmentTypeID()
		return nil
	case orderadjustment.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case orderadjustment.FieldShipGroupSeqID:
		m.ResetShipGroupSeqID()
		return nil
	case orderadjustment.FieldComments:
		m.ResetComments()
		return nil
	case orderadjustment.FieldDescription:
		m.ResetDescription()
		return nil
	case orderadjustment.FieldAmount:
		m.ResetAmount()
		return nil
	case orderadjustment.FieldRecurringAmount:
		m.ResetRecurringAmount()
		return nil
	case orderadjustment.FieldAmountAlreadyIncluded:
		m.ResetAmountAlreadyIncluded()
		return nil
	case orderadjustment.FieldProductPromoID:
		m.ResetProductPromoID()
		return nil
	case orderadjustment.FieldProductPromoRuleID:
		m.ResetProductPromoRuleID()
		return nil
	case orderadjustment.FieldProductPromoActionSeqID:
		m.ResetProductPromoActionSeqID()
		return nil
	case orderadjustment.FieldProductFeatureID:
		m.ResetProductFeatureID()
		return nil
	case orderadjustment.FieldCorrespondingProductID:
		m.ResetCorrespondingProductID()
		return nil
	case orderadjustment.FieldTaxAuthorityRateSeqID:
		m.ResetTaxAuthorityRateSeqID()
		return nil
	case orderadjustment.FieldSourceReferenceID:
		m.ResetSourceReferenceID()
		return nil
	case orderadjustment.FieldSourcePercentage:
		m.ResetSourcePercentage()
		return nil
	case orderadjustment.FieldCustomerReferenceID:
		m.ResetCustomerReferenceID()
		return nil
	case orderadjustment.FieldPrimaryGeoID:
		m.ResetPrimaryGeoID()
		return nil
	case orderadjustment.FieldSecondaryGeoID:
		m.ResetSecondaryGeoID()
		return nil
	case orderadjustment.FieldExemptAmount:
		m.ResetExemptAmount()
		return nil
	case orderadjustment.FieldTaxAuthGeoID:
		m.ResetTaxAuthGeoID()
		return nil
	case orderadjustment.FieldTaxAuthPartyID:
		m.ResetTaxAuthPartyID()
		return nil
	case orderadjustment.FieldOverrideGlAccountID:
		m.ResetOverrideGlAccountID()
		return nil
	case orderadjustment.FieldIncludeInTax:
		m.ResetIncludeInTax()
		return nil
	case orderadjustment.FieldIncludeInShipping:
		m.ResetIncludeInShipping()
		return nil
	case orderadjustment.FieldIsManual:
		m.ResetIsManual()
		return nil
	case orderadjustment.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case orderadjustment.FieldCreatedByUserLogin:
		m.ResetCreatedByUserLogin()
		return nil
	case orderadjustment.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case orderadjustment.FieldLastModifiedByUserLogin:
		m.ResetLastModifiedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown OrderAdjustment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderAdjustmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.order_header != nil {
		edges = append(edges, orderadjustment.EdgeOrderHeader)
	}
	if m.order_item != nil {
		edges = append(edges, orderadjustment.EdgeOrderItem)
	}
	if m.order_item_ship_group != nil {
		edges = append(edges, orderadjustment.EdgeOrderItemShipGroup)
	}
	if m.order_item_ship_group_assoc != nil {
		edges = append(edges, orderadjustment.EdgeOrderItemShipGroupAssoc)
	}
	if m.parent != nil {
		edges = append(edges, orderadjustment.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, orderadjustment.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderAdjustmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderadjustment.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderadjustment.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	case orderadjustment.EdgeOrderItemShipGroup:
		if id := m.order_item_ship_group; id != nil {
			return []ent.Value{*id}
		}
	case orderadjustment.EdgeOrderItemShipGroupAssoc:
		if id := m.order_item_ship_group_assoc; id != nil {
			return []ent.Value{*id}
		}
	case orderadjustment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case orderadjustment.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderAdjustmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedchildren != nil {
		edges = append(edges, orderadjustment.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderAdjustmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderadjustment.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderAdjustmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedorder_header {
		edges = append(edges, orderadjustment.EdgeOrderHeader)
	}
	if m.clearedorder_item {
		edges = append(edges, orderadjustment.EdgeOrderItem)
	}
	if m.clearedorder_item_ship_group {
		edges = append(edges, orderadjustment.EdgeOrderItemShipGroup)
	}
	if m.clearedorder_item_ship_group_assoc {
		edges = append(edges, orderadjustment.EdgeOrderItemShipGroupAssoc)
	}
	if m.clearedparent {
		edges = append(edges, orderadjustment.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, orderadjustment.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderAdjustmentMutation) EdgeCleared(name string) bool {
	switch name {
	case orderadjustment.EdgeOrderHeader:
		return m.clearedorder_header
	case orderadjustment.EdgeOrderItem:
		return m.clearedorder_item
	case orderadjustment.EdgeOrderItemShipGroup:
		return m.clearedorder_item_ship_group
	case orderadjustment.EdgeOrderItemShipGroupAssoc:
		return m.clearedorder_item_ship_group_assoc
	case orderadjustment.EdgeParent:
		return m.clearedparent
	case orderadjustment.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderAdjustmentMutation) ClearEdge(name string) error {
	switch name {
	case orderadjustment.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderadjustment.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	case orderadjustment.EdgeOrderItemShipGroup:
		m.ClearOrderItemShipGroup()
		return nil
	case orderadjustment.EdgeOrderItemShipGroupAssoc:
		m.ClearOrderItemShipGroupAssoc()
		return nil
	case orderadjustment.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OrderAdjustment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderAdjustmentMutation) ResetEdge(name string) error {
	switch name {
	case orderadjustment.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderadjustment.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	case orderadjustment.EdgeOrderItemShipGroup:
		m.ResetOrderItemShipGroup()
		return nil
	case orderadjustment.EdgeOrderItemShipGroupAssoc:
		m.ResetOrderItemShipGroupAssoc()
		return nil
	case orderadjustment.EdgeParent:
		m.ResetParent()
		return nil
	case orderadjustment.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown OrderAdjustment edge %s", name)
}

// OrderContactMechMutation represents an operation that mutates the OrderContactMech nodes in the graph.
type OrderContactMechMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	create_time                     *time.Time
	update_time                     *time.Time
	string_ref                      *string
	contact_mech_purpose_type_id    *int
	addcontact_mech_purpose_type_id *int
	contact_mech_id                 *int
	addcontact_mech_id              *int
	clearedFields                   map[string]struct{}
	order_header                    *int
	clearedorder_header             bool
	done                            bool
	oldValue                        func(context.Context) (*OrderContactMech, error)
	predicates                      []predicate.OrderContactMech
}

var _ ent.Mutation = (*OrderContactMechMutation)(nil)

// ordercontactmechOption allows management of the mutation configuration using functional options.
type ordercontactmechOption func(*OrderContactMechMutation)

// newOrderContactMechMutation creates new mutation for the OrderContactMech entity.
func newOrderContactMechMutation(c config, op Op, opts ...ordercontactmechOption) *OrderContactMechMutation {
	m := &OrderContactMechMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderContactMech,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderContactMechID sets the ID field of the mutation.
func withOrderContactMechID(id int) ordercontactmechOption {
	return func(m *OrderContactMechMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderContactMech
		)
		m.oldValue = func(ctx context.Context) (*OrderContactMech, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderContactMech.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderContactMech sets the old OrderContactMech of the mutation.
func withOrderContactMech(node *OrderContactMech) ordercontactmechOption {
	return func(m *OrderContactMechMutation) {
		m.oldValue = func(context.Context) (*OrderContactMech, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderContactMechMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderContactMechMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderContactMechMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderContactMechMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderContactMechMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderContactMech entity.
// If the OrderContactMech object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderContactMechMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderContactMechMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderContactMechMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderContactMechMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderContactMech entity.
// If the OrderContactMech object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderContactMechMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderContactMechMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderContactMechMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderContactMechMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderContactMech entity.
// If the OrderContactMech object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderContactMechMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderContactMechMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[ordercontactmech.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderContactMechMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[ordercontactmech.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderContactMechMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, ordercontactmech.FieldStringRef)
}

// SetContactMechPurposeTypeID sets the "contact_mech_purpose_type_id" field.
func (m *OrderContactMechMutation) SetContactMechPurposeTypeID(i int) {
	m.contact_mech_purpose_type_id = &i
	m.addcontact_mech_purpose_type_id = nil
}

// ContactMechPurposeTypeID returns the value of the "contact_mech_purpose_type_id" field in the mutation.
func (m *OrderContactMechMutation) ContactMechPurposeTypeID() (r int, exists bool) {
	v := m.contact_mech_purpose_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContactMechPurposeTypeID returns the old "contact_mech_purpose_type_id" field's value of the OrderContactMech entity.
// If the OrderContactMech object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderContactMechMutation) OldContactMechPurposeTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactMechPurposeTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactMechPurposeTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactMechPurposeTypeID: %w", err)
	}
	return oldValue.ContactMechPurposeTypeID, nil
}

// AddContactMechPurposeTypeID adds i to the "contact_mech_purpose_type_id" field.
func (m *OrderContactMechMutation) AddContactMechPurposeTypeID(i int) {
	if m.addcontact_mech_purpose_type_id != nil {
		*m.addcontact_mech_purpose_type_id += i
	} else {
		m.addcontact_mech_purpose_type_id = &i
	}
}

// AddedContactMechPurposeTypeID returns the value that was added to the "contact_mech_purpose_type_id" field in this mutation.
func (m *OrderContactMechMutation) AddedContactMechPurposeTypeID() (r int, exists bool) {
	v := m.addcontact_mech_purpose_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetContactMechPurposeTypeID resets all changes to the "contact_mech_purpose_type_id" field.
func (m *OrderContactMechMutation) ResetContactMechPurposeTypeID() {
	m.contact_mech_purpose_type_id = nil
	m.addcontact_mech_purpose_type_id = nil
}

// SetContactMechID sets the "contact_mech_id" field.
func (m *OrderContactMechMutation) SetContactMechID(i int) {
	m.contact_mech_id = &i
	m.addcontact_mech_id = nil
}

// ContactMechID returns the value of the "contact_mech_id" field in the mutation.
func (m *OrderContactMechMutation) ContactMechID() (r int, exists bool) {
	v := m.contact_mech_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContactMechID returns the old "contact_mech_id" field's value of the OrderContactMech entity.
// If the OrderContactMech object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderContactMechMutation) OldContactMechID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactMechID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactMechID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactMechID: %w", err)
	}
	return oldValue.ContactMechID, nil
}

// AddContactMechID adds i to the "contact_mech_id" field.
func (m *OrderContactMechMutation) AddContactMechID(i int) {
	if m.addcontact_mech_id != nil {
		*m.addcontact_mech_id += i
	} else {
		m.addcontact_mech_id = &i
	}
}

// AddedContactMechID returns the value that was added to the "contact_mech_id" field in this mutation.
func (m *OrderContactMechMutation) AddedContactMechID() (r int, exists bool) {
	v := m.addcontact_mech_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetContactMechID resets all changes to the "contact_mech_id" field.
func (m *OrderContactMechMutation) ResetContactMechID() {
	m.contact_mech_id = nil
	m.addcontact_mech_id = nil
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderContactMechMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderContactMechMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderContactMechMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderContactMechMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderContactMechMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderContactMechMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// Op returns the operation name.
func (m *OrderContactMechMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderContactMech).
func (m *OrderContactMechMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderContactMechMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, ordercontactmech.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ordercontactmech.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, ordercontactmech.FieldStringRef)
	}
	if m.contact_mech_purpose_type_id != nil {
		fields = append(fields, ordercontactmech.FieldContactMechPurposeTypeID)
	}
	if m.contact_mech_id != nil {
		fields = append(fields, ordercontactmech.FieldContactMechID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderContactMechMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordercontactmech.FieldCreateTime:
		return m.CreateTime()
	case ordercontactmech.FieldUpdateTime:
		return m.UpdateTime()
	case ordercontactmech.FieldStringRef:
		return m.StringRef()
	case ordercontactmech.FieldContactMechPurposeTypeID:
		return m.ContactMechPurposeTypeID()
	case ordercontactmech.FieldContactMechID:
		return m.ContactMechID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderContactMechMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordercontactmech.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ordercontactmech.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ordercontactmech.FieldStringRef:
		return m.OldStringRef(ctx)
	case ordercontactmech.FieldContactMechPurposeTypeID:
		return m.OldContactMechPurposeTypeID(ctx)
	case ordercontactmech.FieldContactMechID:
		return m.OldContactMechID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderContactMech field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderContactMechMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordercontactmech.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ordercontactmech.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ordercontactmech.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case ordercontactmech.FieldContactMechPurposeTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactMechPurposeTypeID(v)
		return nil
	case ordercontactmech.FieldContactMechID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactMechID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderContactMech field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderContactMechMutation) AddedFields() []string {
	var fields []string
	if m.addcontact_mech_purpose_type_id != nil {
		fields = append(fields, ordercontactmech.FieldContactMechPurposeTypeID)
	}
	if m.addcontact_mech_id != nil {
		fields = append(fields, ordercontactmech.FieldContactMechID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderContactMechMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordercontactmech.FieldContactMechPurposeTypeID:
		return m.AddedContactMechPurposeTypeID()
	case ordercontactmech.FieldContactMechID:
		return m.AddedContactMechID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderContactMechMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordercontactmech.FieldContactMechPurposeTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContactMechPurposeTypeID(v)
		return nil
	case ordercontactmech.FieldContactMechID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContactMechID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderContactMech numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderContactMechMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordercontactmech.FieldStringRef) {
		fields = append(fields, ordercontactmech.FieldStringRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderContactMechMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderContactMechMutation) ClearField(name string) error {
	switch name {
	case ordercontactmech.FieldStringRef:
		m.ClearStringRef()
		return nil
	}
	return fmt.Errorf("unknown OrderContactMech nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderContactMechMutation) ResetField(name string) error {
	switch name {
	case ordercontactmech.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ordercontactmech.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ordercontactmech.FieldStringRef:
		m.ResetStringRef()
		return nil
	case ordercontactmech.FieldContactMechPurposeTypeID:
		m.ResetContactMechPurposeTypeID()
		return nil
	case ordercontactmech.FieldContactMechID:
		m.ResetContactMechID()
		return nil
	}
	return fmt.Errorf("unknown OrderContactMech field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderContactMechMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order_header != nil {
		edges = append(edges, ordercontactmech.EdgeOrderHeader)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderContactMechMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordercontactmech.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderContactMechMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderContactMechMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderContactMechMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorder_header {
		edges = append(edges, ordercontactmech.EdgeOrderHeader)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderContactMechMutation) EdgeCleared(name string) bool {
	switch name {
	case ordercontactmech.EdgeOrderHeader:
		return m.clearedorder_header
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderContactMechMutation) ClearEdge(name string) error {
	switch name {
	case ordercontactmech.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	}
	return fmt.Errorf("unknown OrderContactMech unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderContactMechMutation) ResetEdge(name string) error {
	switch name {
	case ordercontactmech.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	}
	return fmt.Errorf("unknown OrderContactMech edge %s", name)
}

// OrderHeaderMutation represents an operation that mutates the OrderHeader nodes in the graph.
type OrderHeaderMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	update_time                         *time.Time
	string_ref                          *string
	order_type_id                       *int
	addorder_type_id                    *int
	order_name                          *string
	external_id                         *int
	addexternal_id                      *int
	order_date                          *time.Time
	priority                            *orderheader.Priority
	entry_date                          *time.Time
	pick_sheet_printed_date             *time.Time
	visit_id                            *int
	addvisit_id                         *int
	created_by                          *string
	first_attempt_order_id              *int
	addfirst_attempt_order_id           *int
	currency_uom                        *int
	addcurrency_uom                     *int
	billing_account_id                  *int
	addbilling_account_id               *int
	origin_facility_id                  *int
	addorigin_facility_id               *int
	web_site_id                         *int
	addweb_site_id                      *int
	agreement_id                        *int
	addagreement_id                     *int
	terminal_id                         *string
	transaction_id                      *string
	auto_order_shopping_list_id         *int
	addauto_order_shopping_list_id      *int
	needs_inventory_issuance            *orderheader.NeedsInventoryIssuance
	is_rush_order                       *orderheader.IsRushOrder
	internal_code                       *string
	remaining_sub_total                 *float64
	addremaining_sub_total              *float64
	grand_total                         *float64
	addgrand_total                      *float64
	is_viewed                           *orderheader.IsViewed
	invoice_per_shipment                *orderheader.InvoicePerShipment
	clearedFields                       map[string]struct{}
	sales_channel_enumeration           *int
	clearedsales_channel_enumeration    bool
	product_store                       *int
	clearedproduct_store                bool
	status_item                         *int
	clearedstatus_item                  bool
	sync_status_item                    *int
	clearedsync_status_item             bool
	order_adjustments                   map[int]struct{}
	removedorder_adjustments            map[int]struct{}
	clearedorder_adjustments            bool
	order_contact_meches                map[int]struct{}
	removedorder_contact_meches         map[int]struct{}
	clearedorder_contact_meches         bool
	order_items                         map[int]struct{}
	removedorder_items                  map[int]struct{}
	clearedorder_items                  bool
	order_item_ship_groups              map[int]struct{}
	removedorder_item_ship_groups       map[int]struct{}
	clearedorder_item_ship_groups       bool
	order_item_ship_group_assocs        map[int]struct{}
	removedorder_item_ship_group_assocs map[int]struct{}
	clearedorder_item_ship_group_assocs bool
	order_item_ship_grp_inv_res         map[int]struct{}
	removedorder_item_ship_grp_inv_res  map[int]struct{}
	clearedorder_item_ship_grp_inv_res  bool
	order_payment_preferences           map[int]struct{}
	removedorder_payment_preferences    map[int]struct{}
	clearedorder_payment_preferences    bool
	order_roles                         map[int]struct{}
	removedorder_roles                  map[int]struct{}
	clearedorder_roles                  bool
	order_statuses                      map[int]struct{}
	removedorder_statuses               map[int]struct{}
	clearedorder_statuses               bool
	done                                bool
	oldValue                            func(context.Context) (*OrderHeader, error)
	predicates                          []predicate.OrderHeader
}

var _ ent.Mutation = (*OrderHeaderMutation)(nil)

// orderheaderOption allows management of the mutation configuration using functional options.
type orderheaderOption func(*OrderHeaderMutation)

// newOrderHeaderMutation creates new mutation for the OrderHeader entity.
func newOrderHeaderMutation(c config, op Op, opts ...orderheaderOption) *OrderHeaderMutation {
	m := &OrderHeaderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderHeader,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderHeaderID sets the ID field of the mutation.
func withOrderHeaderID(id int) orderheaderOption {
	return func(m *OrderHeaderMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderHeader
		)
		m.oldValue = func(ctx context.Context) (*OrderHeader, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderHeader.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderHeader sets the old OrderHeader of the mutation.
func withOrderHeader(node *OrderHeader) orderheaderOption {
	return func(m *OrderHeaderMutation) {
		m.oldValue = func(context.Context) (*OrderHeader, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderHeaderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderHeaderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderHeaderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderHeaderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderHeaderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderHeaderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderHeaderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderHeaderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderHeaderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderHeaderMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderHeaderMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderHeaderMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderheader.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderHeaderMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderHeaderMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderheader.FieldStringRef)
}

// SetOrderTypeID sets the "order_type_id" field.
func (m *OrderHeaderMutation) SetOrderTypeID(i int) {
	m.order_type_id = &i
	m.addorder_type_id = nil
}

// OrderTypeID returns the value of the "order_type_id" field in the mutation.
func (m *OrderHeaderMutation) OrderTypeID() (r int, exists bool) {
	v := m.order_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderTypeID returns the old "order_type_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldOrderTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderTypeID: %w", err)
	}
	return oldValue.OrderTypeID, nil
}

// AddOrderTypeID adds i to the "order_type_id" field.
func (m *OrderHeaderMutation) AddOrderTypeID(i int) {
	if m.addorder_type_id != nil {
		*m.addorder_type_id += i
	} else {
		m.addorder_type_id = &i
	}
}

// AddedOrderTypeID returns the value that was added to the "order_type_id" field in this mutation.
func (m *OrderHeaderMutation) AddedOrderTypeID() (r int, exists bool) {
	v := m.addorder_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderTypeID clears the value of the "order_type_id" field.
func (m *OrderHeaderMutation) ClearOrderTypeID() {
	m.order_type_id = nil
	m.addorder_type_id = nil
	m.clearedFields[orderheader.FieldOrderTypeID] = struct{}{}
}

// OrderTypeIDCleared returns if the "order_type_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) OrderTypeIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldOrderTypeID]
	return ok
}

// ResetOrderTypeID resets all changes to the "order_type_id" field.
func (m *OrderHeaderMutation) ResetOrderTypeID() {
	m.order_type_id = nil
	m.addorder_type_id = nil
	delete(m.clearedFields, orderheader.FieldOrderTypeID)
}

// SetOrderName sets the "order_name" field.
func (m *OrderHeaderMutation) SetOrderName(s string) {
	m.order_name = &s
}

// OrderName returns the value of the "order_name" field in the mutation.
func (m *OrderHeaderMutation) OrderName() (r string, exists bool) {
	v := m.order_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderName returns the old "order_name" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldOrderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderName: %w", err)
	}
	return oldValue.OrderName, nil
}

// ClearOrderName clears the value of the "order_name" field.
func (m *OrderHeaderMutation) ClearOrderName() {
	m.order_name = nil
	m.clearedFields[orderheader.FieldOrderName] = struct{}{}
}

// OrderNameCleared returns if the "order_name" field was cleared in this mutation.
func (m *OrderHeaderMutation) OrderNameCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldOrderName]
	return ok
}

// ResetOrderName resets all changes to the "order_name" field.
func (m *OrderHeaderMutation) ResetOrderName() {
	m.order_name = nil
	delete(m.clearedFields, orderheader.FieldOrderName)
}

// SetExternalID sets the "external_id" field.
func (m *OrderHeaderMutation) SetExternalID(i int) {
	m.external_id = &i
	m.addexternal_id = nil
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OrderHeaderMutation) ExternalID() (r int, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldExternalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// AddExternalID adds i to the "external_id" field.
func (m *OrderHeaderMutation) AddExternalID(i int) {
	if m.addexternal_id != nil {
		*m.addexternal_id += i
	} else {
		m.addexternal_id = &i
	}
}

// AddedExternalID returns the value that was added to the "external_id" field in this mutation.
func (m *OrderHeaderMutation) AddedExternalID() (r int, exists bool) {
	v := m.addexternal_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OrderHeaderMutation) ClearExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	m.clearedFields[orderheader.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OrderHeaderMutation) ResetExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	delete(m.clearedFields, orderheader.FieldExternalID)
}

// SetOrderDate sets the "order_date" field.
func (m *OrderHeaderMutation) SetOrderDate(t time.Time) {
	m.order_date = &t
}

// OrderDate returns the value of the "order_date" field in the mutation.
func (m *OrderHeaderMutation) OrderDate() (r time.Time, exists bool) {
	v := m.order_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDate returns the old "order_date" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDate: %w", err)
	}
	return oldValue.OrderDate, nil
}

// ClearOrderDate clears the value of the "order_date" field.
func (m *OrderHeaderMutation) ClearOrderDate() {
	m.order_date = nil
	m.clearedFields[orderheader.FieldOrderDate] = struct{}{}
}

// OrderDateCleared returns if the "order_date" field was cleared in this mutation.
func (m *OrderHeaderMutation) OrderDateCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldOrderDate]
	return ok
}

// ResetOrderDate resets all changes to the "order_date" field.
func (m *OrderHeaderMutation) ResetOrderDate() {
	m.order_date = nil
	delete(m.clearedFields, orderheader.FieldOrderDate)
}

// SetPriority sets the "priority" field.
func (m *OrderHeaderMutation) SetPriority(o orderheader.Priority) {
	m.priority = &o
}

// Priority returns the value of the "priority" field in the mutation.
func (m *OrderHeaderMutation) Priority() (r orderheader.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldPriority(ctx context.Context) (v orderheader.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *OrderHeaderMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[orderheader.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *OrderHeaderMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *OrderHeaderMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, orderheader.FieldPriority)
}

// SetEntryDate sets the "entry_date" field.
func (m *OrderHeaderMutation) SetEntryDate(t time.Time) {
	m.entry_date = &t
}

// EntryDate returns the value of the "entry_date" field in the mutation.
func (m *OrderHeaderMutation) EntryDate() (r time.Time, exists bool) {
	v := m.entry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryDate returns the old "entry_date" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldEntryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryDate: %w", err)
	}
	return oldValue.EntryDate, nil
}

// ClearEntryDate clears the value of the "entry_date" field.
func (m *OrderHeaderMutation) ClearEntryDate() {
	m.entry_date = nil
	m.clearedFields[orderheader.FieldEntryDate] = struct{}{}
}

// EntryDateCleared returns if the "entry_date" field was cleared in this mutation.
func (m *OrderHeaderMutation) EntryDateCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldEntryDate]
	return ok
}

// ResetEntryDate resets all changes to the "entry_date" field.
func (m *OrderHeaderMutation) ResetEntryDate() {
	m.entry_date = nil
	delete(m.clearedFields, orderheader.FieldEntryDate)
}

// SetPickSheetPrintedDate sets the "pick_sheet_printed_date" field.
func (m *OrderHeaderMutation) SetPickSheetPrintedDate(t time.Time) {
	m.pick_sheet_printed_date = &t
}

// PickSheetPrintedDate returns the value of the "pick_sheet_printed_date" field in the mutation.
func (m *OrderHeaderMutation) PickSheetPrintedDate() (r time.Time, exists bool) {
	v := m.pick_sheet_printed_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPickSheetPrintedDate returns the old "pick_sheet_printed_date" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldPickSheetPrintedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPickSheetPrintedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPickSheetPrintedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickSheetPrintedDate: %w", err)
	}
	return oldValue.PickSheetPrintedDate, nil
}

// ClearPickSheetPrintedDate clears the value of the "pick_sheet_printed_date" field.
func (m *OrderHeaderMutation) ClearPickSheetPrintedDate() {
	m.pick_sheet_printed_date = nil
	m.clearedFields[orderheader.FieldPickSheetPrintedDate] = struct{}{}
}

// PickSheetPrintedDateCleared returns if the "pick_sheet_printed_date" field was cleared in this mutation.
func (m *OrderHeaderMutation) PickSheetPrintedDateCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldPickSheetPrintedDate]
	return ok
}

// ResetPickSheetPrintedDate resets all changes to the "pick_sheet_printed_date" field.
func (m *OrderHeaderMutation) ResetPickSheetPrintedDate() {
	m.pick_sheet_printed_date = nil
	delete(m.clearedFields, orderheader.FieldPickSheetPrintedDate)
}

// SetVisitID sets the "visit_id" field.
func (m *OrderHeaderMutation) SetVisitID(i int) {
	m.visit_id = &i
	m.addvisit_id = nil
}

// VisitID returns the value of the "visit_id" field in the mutation.
func (m *OrderHeaderMutation) VisitID() (r int, exists bool) {
	v := m.visit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVisitID returns the old "visit_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldVisitID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisitID: %w", err)
	}
	return oldValue.VisitID, nil
}

// AddVisitID adds i to the "visit_id" field.
func (m *OrderHeaderMutation) AddVisitID(i int) {
	if m.addvisit_id != nil {
		*m.addvisit_id += i
	} else {
		m.addvisit_id = &i
	}
}

// AddedVisitID returns the value that was added to the "visit_id" field in this mutation.
func (m *OrderHeaderMutation) AddedVisitID() (r int, exists bool) {
	v := m.addvisit_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVisitID clears the value of the "visit_id" field.
func (m *OrderHeaderMutation) ClearVisitID() {
	m.visit_id = nil
	m.addvisit_id = nil
	m.clearedFields[orderheader.FieldVisitID] = struct{}{}
}

// VisitIDCleared returns if the "visit_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) VisitIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldVisitID]
	return ok
}

// ResetVisitID resets all changes to the "visit_id" field.
func (m *OrderHeaderMutation) ResetVisitID() {
	m.visit_id = nil
	m.addvisit_id = nil
	delete(m.clearedFields, orderheader.FieldVisitID)
}

// SetCreatedBy sets the "created_by" field.
func (m *OrderHeaderMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrderHeaderMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrderHeaderMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[orderheader.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrderHeaderMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrderHeaderMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, orderheader.FieldCreatedBy)
}

// SetFirstAttemptOrderID sets the "first_attempt_order_id" field.
func (m *OrderHeaderMutation) SetFirstAttemptOrderID(i int) {
	m.first_attempt_order_id = &i
	m.addfirst_attempt_order_id = nil
}

// FirstAttemptOrderID returns the value of the "first_attempt_order_id" field in the mutation.
func (m *OrderHeaderMutation) FirstAttemptOrderID() (r int, exists bool) {
	v := m.first_attempt_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstAttemptOrderID returns the old "first_attempt_order_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldFirstAttemptOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstAttemptOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstAttemptOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstAttemptOrderID: %w", err)
	}
	return oldValue.FirstAttemptOrderID, nil
}

// AddFirstAttemptOrderID adds i to the "first_attempt_order_id" field.
func (m *OrderHeaderMutation) AddFirstAttemptOrderID(i int) {
	if m.addfirst_attempt_order_id != nil {
		*m.addfirst_attempt_order_id += i
	} else {
		m.addfirst_attempt_order_id = &i
	}
}

// AddedFirstAttemptOrderID returns the value that was added to the "first_attempt_order_id" field in this mutation.
func (m *OrderHeaderMutation) AddedFirstAttemptOrderID() (r int, exists bool) {
	v := m.addfirst_attempt_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstAttemptOrderID clears the value of the "first_attempt_order_id" field.
func (m *OrderHeaderMutation) ClearFirstAttemptOrderID() {
	m.first_attempt_order_id = nil
	m.addfirst_attempt_order_id = nil
	m.clearedFields[orderheader.FieldFirstAttemptOrderID] = struct{}{}
}

// FirstAttemptOrderIDCleared returns if the "first_attempt_order_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) FirstAttemptOrderIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldFirstAttemptOrderID]
	return ok
}

// ResetFirstAttemptOrderID resets all changes to the "first_attempt_order_id" field.
func (m *OrderHeaderMutation) ResetFirstAttemptOrderID() {
	m.first_attempt_order_id = nil
	m.addfirst_attempt_order_id = nil
	delete(m.clearedFields, orderheader.FieldFirstAttemptOrderID)
}

// SetCurrencyUom sets the "currency_uom" field.
func (m *OrderHeaderMutation) SetCurrencyUom(i int) {
	m.currency_uom = &i
	m.addcurrency_uom = nil
}

// CurrencyUom returns the value of the "currency_uom" field in the mutation.
func (m *OrderHeaderMutation) CurrencyUom() (r int, exists bool) {
	v := m.currency_uom
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyUom returns the old "currency_uom" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldCurrencyUom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrencyUom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrencyUom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyUom: %w", err)
	}
	return oldValue.CurrencyUom, nil
}

// AddCurrencyUom adds i to the "currency_uom" field.
func (m *OrderHeaderMutation) AddCurrencyUom(i int) {
	if m.addcurrency_uom != nil {
		*m.addcurrency_uom += i
	} else {
		m.addcurrency_uom = &i
	}
}

// AddedCurrencyUom returns the value that was added to the "currency_uom" field in this mutation.
func (m *OrderHeaderMutation) AddedCurrencyUom() (r int, exists bool) {
	v := m.addcurrency_uom
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrencyUom clears the value of the "currency_uom" field.
func (m *OrderHeaderMutation) ClearCurrencyUom() {
	m.currency_uom = nil
	m.addcurrency_uom = nil
	m.clearedFields[orderheader.FieldCurrencyUom] = struct{}{}
}

// CurrencyUomCleared returns if the "currency_uom" field was cleared in this mutation.
func (m *OrderHeaderMutation) CurrencyUomCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldCurrencyUom]
	return ok
}

// ResetCurrencyUom resets all changes to the "currency_uom" field.
func (m *OrderHeaderMutation) ResetCurrencyUom() {
	m.currency_uom = nil
	m.addcurrency_uom = nil
	delete(m.clearedFields, orderheader.FieldCurrencyUom)
}

// SetBillingAccountID sets the "billing_account_id" field.
func (m *OrderHeaderMutation) SetBillingAccountID(i int) {
	m.billing_account_id = &i
	m.addbilling_account_id = nil
}

// BillingAccountID returns the value of the "billing_account_id" field in the mutation.
func (m *OrderHeaderMutation) BillingAccountID() (r int, exists bool) {
	v := m.billing_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingAccountID returns the old "billing_account_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldBillingAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillingAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillingAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingAccountID: %w", err)
	}
	return oldValue.BillingAccountID, nil
}

// AddBillingAccountID adds i to the "billing_account_id" field.
func (m *OrderHeaderMutation) AddBillingAccountID(i int) {
	if m.addbilling_account_id != nil {
		*m.addbilling_account_id += i
	} else {
		m.addbilling_account_id = &i
	}
}

// AddedBillingAccountID returns the value that was added to the "billing_account_id" field in this mutation.
func (m *OrderHeaderMutation) AddedBillingAccountID() (r int, exists bool) {
	v := m.addbilling_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBillingAccountID clears the value of the "billing_account_id" field.
func (m *OrderHeaderMutation) ClearBillingAccountID() {
	m.billing_account_id = nil
	m.addbilling_account_id = nil
	m.clearedFields[orderheader.FieldBillingAccountID] = struct{}{}
}

// BillingAccountIDCleared returns if the "billing_account_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) BillingAccountIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldBillingAccountID]
	return ok
}

// ResetBillingAccountID resets all changes to the "billing_account_id" field.
func (m *OrderHeaderMutation) ResetBillingAccountID() {
	m.billing_account_id = nil
	m.addbilling_account_id = nil
	delete(m.clearedFields, orderheader.FieldBillingAccountID)
}

// SetOriginFacilityID sets the "origin_facility_id" field.
func (m *OrderHeaderMutation) SetOriginFacilityID(i int) {
	m.origin_facility_id = &i
	m.addorigin_facility_id = nil
}

// OriginFacilityID returns the value of the "origin_facility_id" field in the mutation.
func (m *OrderHeaderMutation) OriginFacilityID() (r int, exists bool) {
	v := m.origin_facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginFacilityID returns the old "origin_facility_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldOriginFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOriginFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOriginFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginFacilityID: %w", err)
	}
	return oldValue.OriginFacilityID, nil
}

// AddOriginFacilityID adds i to the "origin_facility_id" field.
func (m *OrderHeaderMutation) AddOriginFacilityID(i int) {
	if m.addorigin_facility_id != nil {
		*m.addorigin_facility_id += i
	} else {
		m.addorigin_facility_id = &i
	}
}

// AddedOriginFacilityID returns the value that was added to the "origin_facility_id" field in this mutation.
func (m *OrderHeaderMutation) AddedOriginFacilityID() (r int, exists bool) {
	v := m.addorigin_facility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginFacilityID clears the value of the "origin_facility_id" field.
func (m *OrderHeaderMutation) ClearOriginFacilityID() {
	m.origin_facility_id = nil
	m.addorigin_facility_id = nil
	m.clearedFields[orderheader.FieldOriginFacilityID] = struct{}{}
}

// OriginFacilityIDCleared returns if the "origin_facility_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) OriginFacilityIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldOriginFacilityID]
	return ok
}

// ResetOriginFacilityID resets all changes to the "origin_facility_id" field.
func (m *OrderHeaderMutation) ResetOriginFacilityID() {
	m.origin_facility_id = nil
	m.addorigin_facility_id = nil
	delete(m.clearedFields, orderheader.FieldOriginFacilityID)
}

// SetWebSiteID sets the "web_site_id" field.
func (m *OrderHeaderMutation) SetWebSiteID(i int) {
	m.web_site_id = &i
	m.addweb_site_id = nil
}

// WebSiteID returns the value of the "web_site_id" field in the mutation.
func (m *OrderHeaderMutation) WebSiteID() (r int, exists bool) {
	v := m.web_site_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWebSiteID returns the old "web_site_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldWebSiteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWebSiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWebSiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebSiteID: %w", err)
	}
	return oldValue.WebSiteID, nil
}

// AddWebSiteID adds i to the "web_site_id" field.
func (m *OrderHeaderMutation) AddWebSiteID(i int) {
	if m.addweb_site_id != nil {
		*m.addweb_site_id += i
	} else {
		m.addweb_site_id = &i
	}
}

// AddedWebSiteID returns the value that was added to the "web_site_id" field in this mutation.
func (m *OrderHeaderMutation) AddedWebSiteID() (r int, exists bool) {
	v := m.addweb_site_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWebSiteID clears the value of the "web_site_id" field.
func (m *OrderHeaderMutation) ClearWebSiteID() {
	m.web_site_id = nil
	m.addweb_site_id = nil
	m.clearedFields[orderheader.FieldWebSiteID] = struct{}{}
}

// WebSiteIDCleared returns if the "web_site_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) WebSiteIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldWebSiteID]
	return ok
}

// ResetWebSiteID resets all changes to the "web_site_id" field.
func (m *OrderHeaderMutation) ResetWebSiteID() {
	m.web_site_id = nil
	m.addweb_site_id = nil
	delete(m.clearedFields, orderheader.FieldWebSiteID)
}

// SetAgreementID sets the "agreement_id" field.
func (m *OrderHeaderMutation) SetAgreementID(i int) {
	m.agreement_id = &i
	m.addagreement_id = nil
}

// AgreementID returns the value of the "agreement_id" field in the mutation.
func (m *OrderHeaderMutation) AgreementID() (r int, exists bool) {
	v := m.agreement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementID returns the old "agreement_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldAgreementID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgreementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgreementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementID: %w", err)
	}
	return oldValue.AgreementID, nil
}

// AddAgreementID adds i to the "agreement_id" field.
func (m *OrderHeaderMutation) AddAgreementID(i int) {
	if m.addagreement_id != nil {
		*m.addagreement_id += i
	} else {
		m.addagreement_id = &i
	}
}

// AddedAgreementID returns the value that was added to the "agreement_id" field in this mutation.
func (m *OrderHeaderMutation) AddedAgreementID() (r int, exists bool) {
	v := m.addagreement_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAgreementID clears the value of the "agreement_id" field.
func (m *OrderHeaderMutation) ClearAgreementID() {
	m.agreement_id = nil
	m.addagreement_id = nil
	m.clearedFields[orderheader.FieldAgreementID] = struct{}{}
}

// AgreementIDCleared returns if the "agreement_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) AgreementIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldAgreementID]
	return ok
}

// ResetAgreementID resets all changes to the "agreement_id" field.
func (m *OrderHeaderMutation) ResetAgreementID() {
	m.agreement_id = nil
	m.addagreement_id = nil
	delete(m.clearedFields, orderheader.FieldAgreementID)
}

// SetTerminalID sets the "terminal_id" field.
func (m *OrderHeaderMutation) SetTerminalID(s string) {
	m.terminal_id = &s
}

// TerminalID returns the value of the "terminal_id" field in the mutation.
func (m *OrderHeaderMutation) TerminalID() (r string, exists bool) {
	v := m.terminal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminalID returns the old "terminal_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldTerminalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTerminalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTerminalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminalID: %w", err)
	}
	return oldValue.TerminalID, nil
}

// ClearTerminalID clears the value of the "terminal_id" field.
func (m *OrderHeaderMutation) ClearTerminalID() {
	m.terminal_id = nil
	m.clearedFields[orderheader.FieldTerminalID] = struct{}{}
}

// TerminalIDCleared returns if the "terminal_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) TerminalIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldTerminalID]
	return ok
}

// ResetTerminalID resets all changes to the "terminal_id" field.
func (m *OrderHeaderMutation) ResetTerminalID() {
	m.terminal_id = nil
	delete(m.clearedFields, orderheader.FieldTerminalID)
}

// SetTransactionID sets the "transaction_id" field.
func (m *OrderHeaderMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *OrderHeaderMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *OrderHeaderMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[orderheader.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *OrderHeaderMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, orderheader.FieldTransactionID)
}

// SetAutoOrderShoppingListID sets the "auto_order_shopping_list_id" field.
func (m *OrderHeaderMutation) SetAutoOrderShoppingListID(i int) {
	m.auto_order_shopping_list_id = &i
	m.addauto_order_shopping_list_id = nil
}

// AutoOrderShoppingListID returns the value of the "auto_order_shopping_list_id" field in the mutation.
func (m *OrderHeaderMutation) AutoOrderShoppingListID() (r int, exists bool) {
	v := m.auto_order_shopping_list_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoOrderShoppingListID returns the old "auto_order_shopping_list_id" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldAutoOrderShoppingListID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoOrderShoppingListID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoOrderShoppingListID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoOrderShoppingListID: %w", err)
	}
	return oldValue.AutoOrderShoppingListID, nil
}

// AddAutoOrderShoppingListID adds i to the "auto_order_shopping_list_id" field.
func (m *OrderHeaderMutation) AddAutoOrderShoppingListID(i int) {
	if m.addauto_order_shopping_list_id != nil {
		*m.addauto_order_shopping_list_id += i
	} else {
		m.addauto_order_shopping_list_id = &i
	}
}

// AddedAutoOrderShoppingListID returns the value that was added to the "auto_order_shopping_list_id" field in this mutation.
func (m *OrderHeaderMutation) AddedAutoOrderShoppingListID() (r int, exists bool) {
	v := m.addauto_order_shopping_list_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAutoOrderShoppingListID clears the value of the "auto_order_shopping_list_id" field.
func (m *OrderHeaderMutation) ClearAutoOrderShoppingListID() {
	m.auto_order_shopping_list_id = nil
	m.addauto_order_shopping_list_id = nil
	m.clearedFields[orderheader.FieldAutoOrderShoppingListID] = struct{}{}
}

// AutoOrderShoppingListIDCleared returns if the "auto_order_shopping_list_id" field was cleared in this mutation.
func (m *OrderHeaderMutation) AutoOrderShoppingListIDCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldAutoOrderShoppingListID]
	return ok
}

// ResetAutoOrderShoppingListID resets all changes to the "auto_order_shopping_list_id" field.
func (m *OrderHeaderMutation) ResetAutoOrderShoppingListID() {
	m.auto_order_shopping_list_id = nil
	m.addauto_order_shopping_list_id = nil
	delete(m.clearedFields, orderheader.FieldAutoOrderShoppingListID)
}

// SetNeedsInventoryIssuance sets the "needs_inventory_issuance" field.
func (m *OrderHeaderMutation) SetNeedsInventoryIssuance(oii orderheader.NeedsInventoryIssuance) {
	m.needs_inventory_issuance = &oii
}

// NeedsInventoryIssuance returns the value of the "needs_inventory_issuance" field in the mutation.
func (m *OrderHeaderMutation) NeedsInventoryIssuance() (r orderheader.NeedsInventoryIssuance, exists bool) {
	v := m.needs_inventory_issuance
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsInventoryIssuance returns the old "needs_inventory_issuance" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldNeedsInventoryIssuance(ctx context.Context) (v orderheader.NeedsInventoryIssuance, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedsInventoryIssuance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedsInventoryIssuance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsInventoryIssuance: %w", err)
	}
	return oldValue.NeedsInventoryIssuance, nil
}

// ClearNeedsInventoryIssuance clears the value of the "needs_inventory_issuance" field.
func (m *OrderHeaderMutation) ClearNeedsInventoryIssuance() {
	m.needs_inventory_issuance = nil
	m.clearedFields[orderheader.FieldNeedsInventoryIssuance] = struct{}{}
}

// NeedsInventoryIssuanceCleared returns if the "needs_inventory_issuance" field was cleared in this mutation.
func (m *OrderHeaderMutation) NeedsInventoryIssuanceCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldNeedsInventoryIssuance]
	return ok
}

// ResetNeedsInventoryIssuance resets all changes to the "needs_inventory_issuance" field.
func (m *OrderHeaderMutation) ResetNeedsInventoryIssuance() {
	m.needs_inventory_issuance = nil
	delete(m.clearedFields, orderheader.FieldNeedsInventoryIssuance)
}

// SetIsRushOrder sets the "is_rush_order" field.
func (m *OrderHeaderMutation) SetIsRushOrder(oro orderheader.IsRushOrder) {
	m.is_rush_order = &oro
}

// IsRushOrder returns the value of the "is_rush_order" field in the mutation.
func (m *OrderHeaderMutation) IsRushOrder() (r orderheader.IsRushOrder, exists bool) {
	v := m.is_rush_order
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRushOrder returns the old "is_rush_order" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldIsRushOrder(ctx context.Context) (v orderheader.IsRushOrder, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRushOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRushOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRushOrder: %w", err)
	}
	return oldValue.IsRushOrder, nil
}

// ClearIsRushOrder clears the value of the "is_rush_order" field.
func (m *OrderHeaderMutation) ClearIsRushOrder() {
	m.is_rush_order = nil
	m.clearedFields[orderheader.FieldIsRushOrder] = struct{}{}
}

// IsRushOrderCleared returns if the "is_rush_order" field was cleared in this mutation.
func (m *OrderHeaderMutation) IsRushOrderCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldIsRushOrder]
	return ok
}

// ResetIsRushOrder resets all changes to the "is_rush_order" field.
func (m *OrderHeaderMutation) ResetIsRushOrder() {
	m.is_rush_order = nil
	delete(m.clearedFields, orderheader.FieldIsRushOrder)
}

// SetInternalCode sets the "internal_code" field.
func (m *OrderHeaderMutation) SetInternalCode(s string) {
	m.internal_code = &s
}

// InternalCode returns the value of the "internal_code" field in the mutation.
func (m *OrderHeaderMutation) InternalCode() (r string, exists bool) {
	v := m.internal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalCode returns the old "internal_code" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldInternalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalCode: %w", err)
	}
	return oldValue.InternalCode, nil
}

// ClearInternalCode clears the value of the "internal_code" field.
func (m *OrderHeaderMutation) ClearInternalCode() {
	m.internal_code = nil
	m.clearedFields[orderheader.FieldInternalCode] = struct{}{}
}

// InternalCodeCleared returns if the "internal_code" field was cleared in this mutation.
func (m *OrderHeaderMutation) InternalCodeCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldInternalCode]
	return ok
}

// ResetInternalCode resets all changes to the "internal_code" field.
func (m *OrderHeaderMutation) ResetInternalCode() {
	m.internal_code = nil
	delete(m.clearedFields, orderheader.FieldInternalCode)
}

// SetRemainingSubTotal sets the "remaining_sub_total" field.
func (m *OrderHeaderMutation) SetRemainingSubTotal(f float64) {
	m.remaining_sub_total = &f
	m.addremaining_sub_total = nil
}

// RemainingSubTotal returns the value of the "remaining_sub_total" field in the mutation.
func (m *OrderHeaderMutation) RemainingSubTotal() (r float64, exists bool) {
	v := m.remaining_sub_total
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingSubTotal returns the old "remaining_sub_total" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldRemainingSubTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemainingSubTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemainingSubTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingSubTotal: %w", err)
	}
	return oldValue.RemainingSubTotal, nil
}

// AddRemainingSubTotal adds f to the "remaining_sub_total" field.
func (m *OrderHeaderMutation) AddRemainingSubTotal(f float64) {
	if m.addremaining_sub_total != nil {
		*m.addremaining_sub_total += f
	} else {
		m.addremaining_sub_total = &f
	}
}

// AddedRemainingSubTotal returns the value that was added to the "remaining_sub_total" field in this mutation.
func (m *OrderHeaderMutation) AddedRemainingSubTotal() (r float64, exists bool) {
	v := m.addremaining_sub_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRemainingSubTotal clears the value of the "remaining_sub_total" field.
func (m *OrderHeaderMutation) ClearRemainingSubTotal() {
	m.remaining_sub_total = nil
	m.addremaining_sub_total = nil
	m.clearedFields[orderheader.FieldRemainingSubTotal] = struct{}{}
}

// RemainingSubTotalCleared returns if the "remaining_sub_total" field was cleared in this mutation.
func (m *OrderHeaderMutation) RemainingSubTotalCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldRemainingSubTotal]
	return ok
}

// ResetRemainingSubTotal resets all changes to the "remaining_sub_total" field.
func (m *OrderHeaderMutation) ResetRemainingSubTotal() {
	m.remaining_sub_total = nil
	m.addremaining_sub_total = nil
	delete(m.clearedFields, orderheader.FieldRemainingSubTotal)
}

// SetGrandTotal sets the "grand_total" field.
func (m *OrderHeaderMutation) SetGrandTotal(f float64) {
	m.grand_total = &f
	m.addgrand_total = nil
}

// GrandTotal returns the value of the "grand_total" field in the mutation.
func (m *OrderHeaderMutation) GrandTotal() (r float64, exists bool) {
	v := m.grand_total
	if v == nil {
		return
	}
	return *v, true
}

// OldGrandTotal returns the old "grand_total" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldGrandTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGrandTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGrandTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrandTotal: %w", err)
	}
	return oldValue.GrandTotal, nil
}

// AddGrandTotal adds f to the "grand_total" field.
func (m *OrderHeaderMutation) AddGrandTotal(f float64) {
	if m.addgrand_total != nil {
		*m.addgrand_total += f
	} else {
		m.addgrand_total = &f
	}
}

// AddedGrandTotal returns the value that was added to the "grand_total" field in this mutation.
func (m *OrderHeaderMutation) AddedGrandTotal() (r float64, exists bool) {
	v := m.addgrand_total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGrandTotal clears the value of the "grand_total" field.
func (m *OrderHeaderMutation) ClearGrandTotal() {
	m.grand_total = nil
	m.addgrand_total = nil
	m.clearedFields[orderheader.FieldGrandTotal] = struct{}{}
}

// GrandTotalCleared returns if the "grand_total" field was cleared in this mutation.
func (m *OrderHeaderMutation) GrandTotalCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldGrandTotal]
	return ok
}

// ResetGrandTotal resets all changes to the "grand_total" field.
func (m *OrderHeaderMutation) ResetGrandTotal() {
	m.grand_total = nil
	m.addgrand_total = nil
	delete(m.clearedFields, orderheader.FieldGrandTotal)
}

// SetIsViewed sets the "is_viewed" field.
func (m *OrderHeaderMutation) SetIsViewed(ov orderheader.IsViewed) {
	m.is_viewed = &ov
}

// IsViewed returns the value of the "is_viewed" field in the mutation.
func (m *OrderHeaderMutation) IsViewed() (r orderheader.IsViewed, exists bool) {
	v := m.is_viewed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsViewed returns the old "is_viewed" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldIsViewed(ctx context.Context) (v orderheader.IsViewed, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsViewed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsViewed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsViewed: %w", err)
	}
	return oldValue.IsViewed, nil
}

// ClearIsViewed clears the value of the "is_viewed" field.
func (m *OrderHeaderMutation) ClearIsViewed() {
	m.is_viewed = nil
	m.clearedFields[orderheader.FieldIsViewed] = struct{}{}
}

// IsViewedCleared returns if the "is_viewed" field was cleared in this mutation.
func (m *OrderHeaderMutation) IsViewedCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldIsViewed]
	return ok
}

// ResetIsViewed resets all changes to the "is_viewed" field.
func (m *OrderHeaderMutation) ResetIsViewed() {
	m.is_viewed = nil
	delete(m.clearedFields, orderheader.FieldIsViewed)
}

// SetInvoicePerShipment sets the "invoice_per_shipment" field.
func (m *OrderHeaderMutation) SetInvoicePerShipment(ops orderheader.InvoicePerShipment) {
	m.invoice_per_shipment = &ops
}

// InvoicePerShipment returns the value of the "invoice_per_shipment" field in the mutation.
func (m *OrderHeaderMutation) InvoicePerShipment() (r orderheader.InvoicePerShipment, exists bool) {
	v := m.invoice_per_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicePerShipment returns the old "invoice_per_shipment" field's value of the OrderHeader entity.
// If the OrderHeader object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHeaderMutation) OldInvoicePerShipment(ctx context.Context) (v orderheader.InvoicePerShipment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInvoicePerShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInvoicePerShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicePerShipment: %w", err)
	}
	return oldValue.InvoicePerShipment, nil
}

// ClearInvoicePerShipment clears the value of the "invoice_per_shipment" field.
func (m *OrderHeaderMutation) ClearInvoicePerShipment() {
	m.invoice_per_shipment = nil
	m.clearedFields[orderheader.FieldInvoicePerShipment] = struct{}{}
}

// InvoicePerShipmentCleared returns if the "invoice_per_shipment" field was cleared in this mutation.
func (m *OrderHeaderMutation) InvoicePerShipmentCleared() bool {
	_, ok := m.clearedFields[orderheader.FieldInvoicePerShipment]
	return ok
}

// ResetInvoicePerShipment resets all changes to the "invoice_per_shipment" field.
func (m *OrderHeaderMutation) ResetInvoicePerShipment() {
	m.invoice_per_shipment = nil
	delete(m.clearedFields, orderheader.FieldInvoicePerShipment)
}

// SetSalesChannelEnumerationID sets the "sales_channel_enumeration" edge to the Enumeration entity by id.
func (m *OrderHeaderMutation) SetSalesChannelEnumerationID(id int) {
	m.sales_channel_enumeration = &id
}

// ClearSalesChannelEnumeration clears the "sales_channel_enumeration" edge to the Enumeration entity.
func (m *OrderHeaderMutation) ClearSalesChannelEnumeration() {
	m.clearedsales_channel_enumeration = true
}

// SalesChannelEnumerationCleared reports if the "sales_channel_enumeration" edge to the Enumeration entity was cleared.
func (m *OrderHeaderMutation) SalesChannelEnumerationCleared() bool {
	return m.clearedsales_channel_enumeration
}

// SalesChannelEnumerationID returns the "sales_channel_enumeration" edge ID in the mutation.
func (m *OrderHeaderMutation) SalesChannelEnumerationID() (id int, exists bool) {
	if m.sales_channel_enumeration != nil {
		return *m.sales_channel_enumeration, true
	}
	return
}

// SalesChannelEnumerationIDs returns the "sales_channel_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesChannelEnumerationID instead. It exists only for internal usage by the builders.
func (m *OrderHeaderMutation) SalesChannelEnumerationIDs() (ids []int) {
	if id := m.sales_channel_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSalesChannelEnumeration resets all changes to the "sales_channel_enumeration" edge.
func (m *OrderHeaderMutation) ResetSalesChannelEnumeration() {
	m.sales_channel_enumeration = nil
	m.clearedsales_channel_enumeration = false
}

// SetProductStoreID sets the "product_store" edge to the ProductStore entity by id.
func (m *OrderHeaderMutation) SetProductStoreID(id int) {
	m.product_store = &id
}

// ClearProductStore clears the "product_store" edge to the ProductStore entity.
func (m *OrderHeaderMutation) ClearProductStore() {
	m.clearedproduct_store = true
}

// ProductStoreCleared reports if the "product_store" edge to the ProductStore entity was cleared.
func (m *OrderHeaderMutation) ProductStoreCleared() bool {
	return m.clearedproduct_store
}

// ProductStoreID returns the "product_store" edge ID in the mutation.
func (m *OrderHeaderMutation) ProductStoreID() (id int, exists bool) {
	if m.product_store != nil {
		return *m.product_store, true
	}
	return
}

// ProductStoreIDs returns the "product_store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductStoreID instead. It exists only for internal usage by the builders.
func (m *OrderHeaderMutation) ProductStoreIDs() (ids []int) {
	if id := m.product_store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductStore resets all changes to the "product_store" edge.
func (m *OrderHeaderMutation) ResetProductStore() {
	m.product_store = nil
	m.clearedproduct_store = false
}

// SetStatusItemID sets the "status_item" edge to the StatusItem entity by id.
func (m *OrderHeaderMutation) SetStatusItemID(id int) {
	m.status_item = &id
}

// ClearStatusItem clears the "status_item" edge to the StatusItem entity.
func (m *OrderHeaderMutation) ClearStatusItem() {
	m.clearedstatus_item = true
}

// StatusItemCleared reports if the "status_item" edge to the StatusItem entity was cleared.
func (m *OrderHeaderMutation) StatusItemCleared() bool {
	return m.clearedstatus_item
}

// StatusItemID returns the "status_item" edge ID in the mutation.
func (m *OrderHeaderMutation) StatusItemID() (id int, exists bool) {
	if m.status_item != nil {
		return *m.status_item, true
	}
	return
}

// StatusItemIDs returns the "status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusItemID instead. It exists only for internal usage by the builders.
func (m *OrderHeaderMutation) StatusItemIDs() (ids []int) {
	if id := m.status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusItem resets all changes to the "status_item" edge.
func (m *OrderHeaderMutation) ResetStatusItem() {
	m.status_item = nil
	m.clearedstatus_item = false
}

// SetSyncStatusItemID sets the "sync_status_item" edge to the StatusItem entity by id.
func (m *OrderHeaderMutation) SetSyncStatusItemID(id int) {
	m.sync_status_item = &id
}

// ClearSyncStatusItem clears the "sync_status_item" edge to the StatusItem entity.
func (m *OrderHeaderMutation) ClearSyncStatusItem() {
	m.clearedsync_status_item = true
}

// SyncStatusItemCleared reports if the "sync_status_item" edge to the StatusItem entity was cleared.
func (m *OrderHeaderMutation) SyncStatusItemCleared() bool {
	return m.clearedsync_status_item
}

// SyncStatusItemID returns the "sync_status_item" edge ID in the mutation.
func (m *OrderHeaderMutation) SyncStatusItemID() (id int, exists bool) {
	if m.sync_status_item != nil {
		return *m.sync_status_item, true
	}
	return
}

// SyncStatusItemIDs returns the "sync_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SyncStatusItemID instead. It exists only for internal usage by the builders.
func (m *OrderHeaderMutation) SyncStatusItemIDs() (ids []int) {
	if id := m.sync_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSyncStatusItem resets all changes to the "sync_status_item" edge.
func (m *OrderHeaderMutation) ResetSyncStatusItem() {
	m.sync_status_item = nil
	m.clearedsync_status_item = false
}

// AddOrderAdjustmentIDs adds the "order_adjustments" edge to the OrderAdjustment entity by ids.
func (m *OrderHeaderMutation) AddOrderAdjustmentIDs(ids ...int) {
	if m.order_adjustments == nil {
		m.order_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.order_adjustments[ids[i]] = struct{}{}
	}
}

// ClearOrderAdjustments clears the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderHeaderMutation) ClearOrderAdjustments() {
	m.clearedorder_adjustments = true
}

// OrderAdjustmentsCleared reports if the "order_adjustments" edge to the OrderAdjustment entity was cleared.
func (m *OrderHeaderMutation) OrderAdjustmentsCleared() bool {
	return m.clearedorder_adjustments
}

// RemoveOrderAdjustmentIDs removes the "order_adjustments" edge to the OrderAdjustment entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderAdjustmentIDs(ids ...int) {
	if m.removedorder_adjustments == nil {
		m.removedorder_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_adjustments[ids[i]] = struct{}{}
	}
}

// RemovedOrderAdjustments returns the removed IDs of the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderHeaderMutation) RemovedOrderAdjustmentsIDs() (ids []int) {
	for id := range m.removedorder_adjustments {
		ids = append(ids, id)
	}
	return
}

// OrderAdjustmentsIDs returns the "order_adjustments" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderAdjustmentsIDs() (ids []int) {
	for id := range m.order_adjustments {
		ids = append(ids, id)
	}
	return
}

// ResetOrderAdjustments resets all changes to the "order_adjustments" edge.
func (m *OrderHeaderMutation) ResetOrderAdjustments() {
	m.order_adjustments = nil
	m.clearedorder_adjustments = false
	m.removedorder_adjustments = nil
}

// AddOrderContactMechIDs adds the "order_contact_meches" edge to the OrderContactMech entity by ids.
func (m *OrderHeaderMutation) AddOrderContactMechIDs(ids ...int) {
	if m.order_contact_meches == nil {
		m.order_contact_meches = make(map[int]struct{})
	}
	for i := range ids {
		m.order_contact_meches[ids[i]] = struct{}{}
	}
}

// ClearOrderContactMeches clears the "order_contact_meches" edge to the OrderContactMech entity.
func (m *OrderHeaderMutation) ClearOrderContactMeches() {
	m.clearedorder_contact_meches = true
}

// OrderContactMechesCleared reports if the "order_contact_meches" edge to the OrderContactMech entity was cleared.
func (m *OrderHeaderMutation) OrderContactMechesCleared() bool {
	return m.clearedorder_contact_meches
}

// RemoveOrderContactMechIDs removes the "order_contact_meches" edge to the OrderContactMech entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderContactMechIDs(ids ...int) {
	if m.removedorder_contact_meches == nil {
		m.removedorder_contact_meches = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_contact_meches[ids[i]] = struct{}{}
	}
}

// RemovedOrderContactMeches returns the removed IDs of the "order_contact_meches" edge to the OrderContactMech entity.
func (m *OrderHeaderMutation) RemovedOrderContactMechesIDs() (ids []int) {
	for id := range m.removedorder_contact_meches {
		ids = append(ids, id)
	}
	return
}

// OrderContactMechesIDs returns the "order_contact_meches" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderContactMechesIDs() (ids []int) {
	for id := range m.order_contact_meches {
		ids = append(ids, id)
	}
	return
}

// ResetOrderContactMeches resets all changes to the "order_contact_meches" edge.
func (m *OrderHeaderMutation) ResetOrderContactMeches() {
	m.order_contact_meches = nil
	m.clearedorder_contact_meches = false
	m.removedorder_contact_meches = nil
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderHeaderMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderHeaderMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderHeaderMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderHeaderMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderHeaderMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddOrderItemShipGroupIDs adds the "order_item_ship_groups" edge to the OrderItemShipGroup entity by ids.
func (m *OrderHeaderMutation) AddOrderItemShipGroupIDs(ids ...int) {
	if m.order_item_ship_groups == nil {
		m.order_item_ship_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_groups[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGroups clears the "order_item_ship_groups" edge to the OrderItemShipGroup entity.
func (m *OrderHeaderMutation) ClearOrderItemShipGroups() {
	m.clearedorder_item_ship_groups = true
}

// OrderItemShipGroupsCleared reports if the "order_item_ship_groups" edge to the OrderItemShipGroup entity was cleared.
func (m *OrderHeaderMutation) OrderItemShipGroupsCleared() bool {
	return m.clearedorder_item_ship_groups
}

// RemoveOrderItemShipGroupIDs removes the "order_item_ship_groups" edge to the OrderItemShipGroup entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderItemShipGroupIDs(ids ...int) {
	if m.removedorder_item_ship_groups == nil {
		m.removedorder_item_ship_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_groups[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGroups returns the removed IDs of the "order_item_ship_groups" edge to the OrderItemShipGroup entity.
func (m *OrderHeaderMutation) RemovedOrderItemShipGroupsIDs() (ids []int) {
	for id := range m.removedorder_item_ship_groups {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGroupsIDs returns the "order_item_ship_groups" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderItemShipGroupsIDs() (ids []int) {
	for id := range m.order_item_ship_groups {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGroups resets all changes to the "order_item_ship_groups" edge.
func (m *OrderHeaderMutation) ResetOrderItemShipGroups() {
	m.order_item_ship_groups = nil
	m.clearedorder_item_ship_groups = false
	m.removedorder_item_ship_groups = nil
}

// AddOrderItemShipGroupAssocIDs adds the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity by ids.
func (m *OrderHeaderMutation) AddOrderItemShipGroupAssocIDs(ids ...int) {
	if m.order_item_ship_group_assocs == nil {
		m.order_item_ship_group_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_group_assocs[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGroupAssocs clears the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderHeaderMutation) ClearOrderItemShipGroupAssocs() {
	m.clearedorder_item_ship_group_assocs = true
}

// OrderItemShipGroupAssocsCleared reports if the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity was cleared.
func (m *OrderHeaderMutation) OrderItemShipGroupAssocsCleared() bool {
	return m.clearedorder_item_ship_group_assocs
}

// RemoveOrderItemShipGroupAssocIDs removes the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderItemShipGroupAssocIDs(ids ...int) {
	if m.removedorder_item_ship_group_assocs == nil {
		m.removedorder_item_ship_group_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_group_assocs[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGroupAssocs returns the removed IDs of the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderHeaderMutation) RemovedOrderItemShipGroupAssocsIDs() (ids []int) {
	for id := range m.removedorder_item_ship_group_assocs {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGroupAssocsIDs returns the "order_item_ship_group_assocs" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderItemShipGroupAssocsIDs() (ids []int) {
	for id := range m.order_item_ship_group_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGroupAssocs resets all changes to the "order_item_ship_group_assocs" edge.
func (m *OrderHeaderMutation) ResetOrderItemShipGroupAssocs() {
	m.order_item_ship_group_assocs = nil
	m.clearedorder_item_ship_group_assocs = false
	m.removedorder_item_ship_group_assocs = nil
}

// AddOrderItemShipGrpInvReIDs adds the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by ids.
func (m *OrderHeaderMutation) AddOrderItemShipGrpInvReIDs(ids ...int) {
	if m.order_item_ship_grp_inv_res == nil {
		m.order_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGrpInvRes clears the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderHeaderMutation) ClearOrderItemShipGrpInvRes() {
	m.clearedorder_item_ship_grp_inv_res = true
}

// OrderItemShipGrpInvResCleared reports if the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity was cleared.
func (m *OrderHeaderMutation) OrderItemShipGrpInvResCleared() bool {
	return m.clearedorder_item_ship_grp_inv_res
}

// RemoveOrderItemShipGrpInvReIDs removes the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderItemShipGrpInvReIDs(ids ...int) {
	if m.removedorder_item_ship_grp_inv_res == nil {
		m.removedorder_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGrpInvRes returns the removed IDs of the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderHeaderMutation) RemovedOrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.removedorder_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGrpInvResIDs returns the "order_item_ship_grp_inv_res" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.order_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGrpInvRes resets all changes to the "order_item_ship_grp_inv_res" edge.
func (m *OrderHeaderMutation) ResetOrderItemShipGrpInvRes() {
	m.order_item_ship_grp_inv_res = nil
	m.clearedorder_item_ship_grp_inv_res = false
	m.removedorder_item_ship_grp_inv_res = nil
}

// AddOrderPaymentPreferenceIDs adds the "order_payment_preferences" edge to the OrderPaymentPreference entity by ids.
func (m *OrderHeaderMutation) AddOrderPaymentPreferenceIDs(ids ...int) {
	if m.order_payment_preferences == nil {
		m.order_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.order_payment_preferences[ids[i]] = struct{}{}
	}
}

// ClearOrderPaymentPreferences clears the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *OrderHeaderMutation) ClearOrderPaymentPreferences() {
	m.clearedorder_payment_preferences = true
}

// OrderPaymentPreferencesCleared reports if the "order_payment_preferences" edge to the OrderPaymentPreference entity was cleared.
func (m *OrderHeaderMutation) OrderPaymentPreferencesCleared() bool {
	return m.clearedorder_payment_preferences
}

// RemoveOrderPaymentPreferenceIDs removes the "order_payment_preferences" edge to the OrderPaymentPreference entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderPaymentPreferenceIDs(ids ...int) {
	if m.removedorder_payment_preferences == nil {
		m.removedorder_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_payment_preferences[ids[i]] = struct{}{}
	}
}

// RemovedOrderPaymentPreferences returns the removed IDs of the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *OrderHeaderMutation) RemovedOrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.removedorder_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// OrderPaymentPreferencesIDs returns the "order_payment_preferences" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.order_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// ResetOrderPaymentPreferences resets all changes to the "order_payment_preferences" edge.
func (m *OrderHeaderMutation) ResetOrderPaymentPreferences() {
	m.order_payment_preferences = nil
	m.clearedorder_payment_preferences = false
	m.removedorder_payment_preferences = nil
}

// AddOrderRoleIDs adds the "order_roles" edge to the OrderRole entity by ids.
func (m *OrderHeaderMutation) AddOrderRoleIDs(ids ...int) {
	if m.order_roles == nil {
		m.order_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.order_roles[ids[i]] = struct{}{}
	}
}

// ClearOrderRoles clears the "order_roles" edge to the OrderRole entity.
func (m *OrderHeaderMutation) ClearOrderRoles() {
	m.clearedorder_roles = true
}

// OrderRolesCleared reports if the "order_roles" edge to the OrderRole entity was cleared.
func (m *OrderHeaderMutation) OrderRolesCleared() bool {
	return m.clearedorder_roles
}

// RemoveOrderRoleIDs removes the "order_roles" edge to the OrderRole entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderRoleIDs(ids ...int) {
	if m.removedorder_roles == nil {
		m.removedorder_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_roles[ids[i]] = struct{}{}
	}
}

// RemovedOrderRoles returns the removed IDs of the "order_roles" edge to the OrderRole entity.
func (m *OrderHeaderMutation) RemovedOrderRolesIDs() (ids []int) {
	for id := range m.removedorder_roles {
		ids = append(ids, id)
	}
	return
}

// OrderRolesIDs returns the "order_roles" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderRolesIDs() (ids []int) {
	for id := range m.order_roles {
		ids = append(ids, id)
	}
	return
}

// ResetOrderRoles resets all changes to the "order_roles" edge.
func (m *OrderHeaderMutation) ResetOrderRoles() {
	m.order_roles = nil
	m.clearedorder_roles = false
	m.removedorder_roles = nil
}

// AddOrderStatusIDs adds the "order_statuses" edge to the OrderStatus entity by ids.
func (m *OrderHeaderMutation) AddOrderStatusIDs(ids ...int) {
	if m.order_statuses == nil {
		m.order_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.order_statuses[ids[i]] = struct{}{}
	}
}

// ClearOrderStatuses clears the "order_statuses" edge to the OrderStatus entity.
func (m *OrderHeaderMutation) ClearOrderStatuses() {
	m.clearedorder_statuses = true
}

// OrderStatusesCleared reports if the "order_statuses" edge to the OrderStatus entity was cleared.
func (m *OrderHeaderMutation) OrderStatusesCleared() bool {
	return m.clearedorder_statuses
}

// RemoveOrderStatusIDs removes the "order_statuses" edge to the OrderStatus entity by IDs.
func (m *OrderHeaderMutation) RemoveOrderStatusIDs(ids ...int) {
	if m.removedorder_statuses == nil {
		m.removedorder_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_statuses[ids[i]] = struct{}{}
	}
}

// RemovedOrderStatuses returns the removed IDs of the "order_statuses" edge to the OrderStatus entity.
func (m *OrderHeaderMutation) RemovedOrderStatusesIDs() (ids []int) {
	for id := range m.removedorder_statuses {
		ids = append(ids, id)
	}
	return
}

// OrderStatusesIDs returns the "order_statuses" edge IDs in the mutation.
func (m *OrderHeaderMutation) OrderStatusesIDs() (ids []int) {
	for id := range m.order_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetOrderStatuses resets all changes to the "order_statuses" edge.
func (m *OrderHeaderMutation) ResetOrderStatuses() {
	m.order_statuses = nil
	m.clearedorder_statuses = false
	m.removedorder_statuses = nil
}

// Op returns the operation name.
func (m *OrderHeaderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderHeader).
func (m *OrderHeaderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderHeaderMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.create_time != nil {
		fields = append(fields, orderheader.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderheader.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderheader.FieldStringRef)
	}
	if m.order_type_id != nil {
		fields = append(fields, orderheader.FieldOrderTypeID)
	}
	if m.order_name != nil {
		fields = append(fields, orderheader.FieldOrderName)
	}
	if m.external_id != nil {
		fields = append(fields, orderheader.FieldExternalID)
	}
	if m.order_date != nil {
		fields = append(fields, orderheader.FieldOrderDate)
	}
	if m.priority != nil {
		fields = append(fields, orderheader.FieldPriority)
	}
	if m.entry_date != nil {
		fields = append(fields, orderheader.FieldEntryDate)
	}
	if m.pick_sheet_printed_date != nil {
		fields = append(fields, orderheader.FieldPickSheetPrintedDate)
	}
	if m.visit_id != nil {
		fields = append(fields, orderheader.FieldVisitID)
	}
	if m.created_by != nil {
		fields = append(fields, orderheader.FieldCreatedBy)
	}
	if m.first_attempt_order_id != nil {
		fields = append(fields, orderheader.FieldFirstAttemptOrderID)
	}
	if m.currency_uom != nil {
		fields = append(fields, orderheader.FieldCurrencyUom)
	}
	if m.billing_account_id != nil {
		fields = append(fields, orderheader.FieldBillingAccountID)
	}
	if m.origin_facility_id != nil {
		fields = append(fields, orderheader.FieldOriginFacilityID)
	}
	if m.web_site_id != nil {
		fields = append(fields, orderheader.FieldWebSiteID)
	}
	if m.agreement_id != nil {
		fields = append(fields, orderheader.FieldAgreementID)
	}
	if m.terminal_id != nil {
		fields = append(fields, orderheader.FieldTerminalID)
	}
	if m.transaction_id != nil {
		fields = append(fields, orderheader.FieldTransactionID)
	}
	if m.auto_order_shopping_list_id != nil {
		fields = append(fields, orderheader.FieldAutoOrderShoppingListID)
	}
	if m.needs_inventory_issuance != nil {
		fields = append(fields, orderheader.FieldNeedsInventoryIssuance)
	}
	if m.is_rush_order != nil {
		fields = append(fields, orderheader.FieldIsRushOrder)
	}
	if m.internal_code != nil {
		fields = append(fields, orderheader.FieldInternalCode)
	}
	if m.remaining_sub_total != nil {
		fields = append(fields, orderheader.FieldRemainingSubTotal)
	}
	if m.grand_total != nil {
		fields = append(fields, orderheader.FieldGrandTotal)
	}
	if m.is_viewed != nil {
		fields = append(fields, orderheader.FieldIsViewed)
	}
	if m.invoice_per_shipment != nil {
		fields = append(fields, orderheader.FieldInvoicePerShipment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderHeaderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderheader.FieldCreateTime:
		return m.CreateTime()
	case orderheader.FieldUpdateTime:
		return m.UpdateTime()
	case orderheader.FieldStringRef:
		return m.StringRef()
	case orderheader.FieldOrderTypeID:
		return m.OrderTypeID()
	case orderheader.FieldOrderName:
		return m.OrderName()
	case orderheader.FieldExternalID:
		return m.ExternalID()
	case orderheader.FieldOrderDate:
		return m.OrderDate()
	case orderheader.FieldPriority:
		return m.Priority()
	case orderheader.FieldEntryDate:
		return m.EntryDate()
	case orderheader.FieldPickSheetPrintedDate:
		return m.PickSheetPrintedDate()
	case orderheader.FieldVisitID:
		return m.VisitID()
	case orderheader.FieldCreatedBy:
		return m.CreatedBy()
	case orderheader.FieldFirstAttemptOrderID:
		return m.FirstAttemptOrderID()
	case orderheader.FieldCurrencyUom:
		return m.CurrencyUom()
	case orderheader.FieldBillingAccountID:
		return m.BillingAccountID()
	case orderheader.FieldOriginFacilityID:
		return m.OriginFacilityID()
	case orderheader.FieldWebSiteID:
		return m.WebSiteID()
	case orderheader.FieldAgreementID:
		return m.AgreementID()
	case orderheader.FieldTerminalID:
		return m.TerminalID()
	case orderheader.FieldTransactionID:
		return m.TransactionID()
	case orderheader.FieldAutoOrderShoppingListID:
		return m.AutoOrderShoppingListID()
	case orderheader.FieldNeedsInventoryIssuance:
		return m.NeedsInventoryIssuance()
	case orderheader.FieldIsRushOrder:
		return m.IsRushOrder()
	case orderheader.FieldInternalCode:
		return m.InternalCode()
	case orderheader.FieldRemainingSubTotal:
		return m.RemainingSubTotal()
	case orderheader.FieldGrandTotal:
		return m.GrandTotal()
	case orderheader.FieldIsViewed:
		return m.IsViewed()
	case orderheader.FieldInvoicePerShipment:
		return m.InvoicePerShipment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderHeaderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderheader.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderheader.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderheader.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderheader.FieldOrderTypeID:
		return m.OldOrderTypeID(ctx)
	case orderheader.FieldOrderName:
		return m.OldOrderName(ctx)
	case orderheader.FieldExternalID:
		return m.OldExternalID(ctx)
	case orderheader.FieldOrderDate:
		return m.OldOrderDate(ctx)
	case orderheader.FieldPriority:
		return m.OldPriority(ctx)
	case orderheader.FieldEntryDate:
		return m.OldEntryDate(ctx)
	case orderheader.FieldPickSheetPrintedDate:
		return m.OldPickSheetPrintedDate(ctx)
	case orderheader.FieldVisitID:
		return m.OldVisitID(ctx)
	case orderheader.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case orderheader.FieldFirstAttemptOrderID:
		return m.OldFirstAttemptOrderID(ctx)
	case orderheader.FieldCurrencyUom:
		return m.OldCurrencyUom(ctx)
	case orderheader.FieldBillingAccountID:
		return m.OldBillingAccountID(ctx)
	case orderheader.FieldOriginFacilityID:
		return m.OldOriginFacilityID(ctx)
	case orderheader.FieldWebSiteID:
		return m.OldWebSiteID(ctx)
	case orderheader.FieldAgreementID:
		return m.OldAgreementID(ctx)
	case orderheader.FieldTerminalID:
		return m.OldTerminalID(ctx)
	case orderheader.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case orderheader.FieldAutoOrderShoppingListID:
		return m.OldAutoOrderShoppingListID(ctx)
	case orderheader.FieldNeedsInventoryIssuance:
		return m.OldNeedsInventoryIssuance(ctx)
	case orderheader.FieldIsRushOrder:
		return m.OldIsRushOrder(ctx)
	case orderheader.FieldInternalCode:
		return m.OldInternalCode(ctx)
	case orderheader.FieldRemainingSubTotal:
		return m.OldRemainingSubTotal(ctx)
	case orderheader.FieldGrandTotal:
		return m.OldGrandTotal(ctx)
	case orderheader.FieldIsViewed:
		return m.OldIsViewed(ctx)
	case orderheader.FieldInvoicePerShipment:
		return m.OldInvoicePerShipment(ctx)
	}
	return nil, fmt.Errorf("unknown OrderHeader field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHeaderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderheader.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderheader.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderheader.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderheader.FieldOrderTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderTypeID(v)
		return nil
	case orderheader.FieldOrderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderName(v)
		return nil
	case orderheader.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case orderheader.FieldOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDate(v)
		return nil
	case orderheader.FieldPriority:
		v, ok := value.(orderheader.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case orderheader.FieldEntryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryDate(v)
		return nil
	case orderheader.FieldPickSheetPrintedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickSheetPrintedDate(v)
		return nil
	case orderheader.FieldVisitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisitID(v)
		return nil
	case orderheader.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case orderheader.FieldFirstAttemptOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstAttemptOrderID(v)
		return nil
	case orderheader.FieldCurrencyUom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyUom(v)
		return nil
	case orderheader.FieldBillingAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingAccountID(v)
		return nil
	case orderheader.FieldOriginFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginFacilityID(v)
		return nil
	case orderheader.FieldWebSiteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebSiteID(v)
		return nil
	case orderheader.FieldAgreementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementID(v)
		return nil
	case orderheader.FieldTerminalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminalID(v)
		return nil
	case orderheader.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case orderheader.FieldAutoOrderShoppingListID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoOrderShoppingListID(v)
		return nil
	case orderheader.FieldNeedsInventoryIssuance:
		v, ok := value.(orderheader.NeedsInventoryIssuance)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsInventoryIssuance(v)
		return nil
	case orderheader.FieldIsRushOrder:
		v, ok := value.(orderheader.IsRushOrder)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRushOrder(v)
		return nil
	case orderheader.FieldInternalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalCode(v)
		return nil
	case orderheader.FieldRemainingSubTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingSubTotal(v)
		return nil
	case orderheader.FieldGrandTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrandTotal(v)
		return nil
	case orderheader.FieldIsViewed:
		v, ok := value.(orderheader.IsViewed)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsViewed(v)
		return nil
	case orderheader.FieldInvoicePerShipment:
		v, ok := value.(orderheader.InvoicePerShipment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicePerShipment(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHeader field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderHeaderMutation) AddedFields() []string {
	var fields []string
	if m.addorder_type_id != nil {
		fields = append(fields, orderheader.FieldOrderTypeID)
	}
	if m.addexternal_id != nil {
		fields = append(fields, orderheader.FieldExternalID)
	}
	if m.addvisit_id != nil {
		fields = append(fields, orderheader.FieldVisitID)
	}
	if m.addfirst_attempt_order_id != nil {
		fields = append(fields, orderheader.FieldFirstAttemptOrderID)
	}
	if m.addcurrency_uom != nil {
		fields = append(fields, orderheader.FieldCurrencyUom)
	}
	if m.addbilling_account_id != nil {
		fields = append(fields, orderheader.FieldBillingAccountID)
	}
	if m.addorigin_facility_id != nil {
		fields = append(fields, orderheader.FieldOriginFacilityID)
	}
	if m.addweb_site_id != nil {
		fields = append(fields, orderheader.FieldWebSiteID)
	}
	if m.addagreement_id != nil {
		fields = append(fields, orderheader.FieldAgreementID)
	}
	if m.addauto_order_shopping_list_id != nil {
		fields = append(fields, orderheader.FieldAutoOrderShoppingListID)
	}
	if m.addremaining_sub_total != nil {
		fields = append(fields, orderheader.FieldRemainingSubTotal)
	}
	if m.addgrand_total != nil {
		fields = append(fields, orderheader.FieldGrandTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderHeaderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderheader.FieldOrderTypeID:
		return m.AddedOrderTypeID()
	case orderheader.FieldExternalID:
		return m.AddedExternalID()
	case orderheader.FieldVisitID:
		return m.AddedVisitID()
	case orderheader.FieldFirstAttemptOrderID:
		return m.AddedFirstAttemptOrderID()
	case orderheader.FieldCurrencyUom:
		return m.AddedCurrencyUom()
	case orderheader.FieldBillingAccountID:
		return m.AddedBillingAccountID()
	case orderheader.FieldOriginFacilityID:
		return m.AddedOriginFacilityID()
	case orderheader.FieldWebSiteID:
		return m.AddedWebSiteID()
	case orderheader.FieldAgreementID:
		return m.AddedAgreementID()
	case orderheader.FieldAutoOrderShoppingListID:
		return m.AddedAutoOrderShoppingListID()
	case orderheader.FieldRemainingSubTotal:
		return m.AddedRemainingSubTotal()
	case orderheader.FieldGrandTotal:
		return m.AddedGrandTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHeaderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderheader.FieldOrderTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderTypeID(v)
		return nil
	case orderheader.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExternalID(v)
		return nil
	case orderheader.FieldVisitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisitID(v)
		return nil
	case orderheader.FieldFirstAttemptOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstAttemptOrderID(v)
		return nil
	case orderheader.FieldCurrencyUom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrencyUom(v)
		return nil
	case orderheader.FieldBillingAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBillingAccountID(v)
		return nil
	case orderheader.FieldOriginFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginFacilityID(v)
		return nil
	case orderheader.FieldWebSiteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWebSiteID(v)
		return nil
	case orderheader.FieldAgreementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgreementID(v)
		return nil
	case orderheader.FieldAutoOrderShoppingListID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAutoOrderShoppingListID(v)
		return nil
	case orderheader.FieldRemainingSubTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemainingSubTotal(v)
		return nil
	case orderheader.FieldGrandTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrandTotal(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHeader numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderHeaderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderheader.FieldStringRef) {
		fields = append(fields, orderheader.FieldStringRef)
	}
	if m.FieldCleared(orderheader.FieldOrderTypeID) {
		fields = append(fields, orderheader.FieldOrderTypeID)
	}
	if m.FieldCleared(orderheader.FieldOrderName) {
		fields = append(fields, orderheader.FieldOrderName)
	}
	if m.FieldCleared(orderheader.FieldExternalID) {
		fields = append(fields, orderheader.FieldExternalID)
	}
	if m.FieldCleared(orderheader.FieldOrderDate) {
		fields = append(fields, orderheader.FieldOrderDate)
	}
	if m.FieldCleared(orderheader.FieldPriority) {
		fields = append(fields, orderheader.FieldPriority)
	}
	if m.FieldCleared(orderheader.FieldEntryDate) {
		fields = append(fields, orderheader.FieldEntryDate)
	}
	if m.FieldCleared(orderheader.FieldPickSheetPrintedDate) {
		fields = append(fields, orderheader.FieldPickSheetPrintedDate)
	}
	if m.FieldCleared(orderheader.FieldVisitID) {
		fields = append(fields, orderheader.FieldVisitID)
	}
	if m.FieldCleared(orderheader.FieldCreatedBy) {
		fields = append(fields, orderheader.FieldCreatedBy)
	}
	if m.FieldCleared(orderheader.FieldFirstAttemptOrderID) {
		fields = append(fields, orderheader.FieldFirstAttemptOrderID)
	}
	if m.FieldCleared(orderheader.FieldCurrencyUom) {
		fields = append(fields, orderheader.FieldCurrencyUom)
	}
	if m.FieldCleared(orderheader.FieldBillingAccountID) {
		fields = append(fields, orderheader.FieldBillingAccountID)
	}
	if m.FieldCleared(orderheader.FieldOriginFacilityID) {
		fields = append(fields, orderheader.FieldOriginFacilityID)
	}
	if m.FieldCleared(orderheader.FieldWebSiteID) {
		fields = append(fields, orderheader.FieldWebSiteID)
	}
	if m.FieldCleared(orderheader.FieldAgreementID) {
		fields = append(fields, orderheader.FieldAgreementID)
	}
	if m.FieldCleared(orderheader.FieldTerminalID) {
		fields = append(fields, orderheader.FieldTerminalID)
	}
	if m.FieldCleared(orderheader.FieldTransactionID) {
		fields = append(fields, orderheader.FieldTransactionID)
	}
	if m.FieldCleared(orderheader.FieldAutoOrderShoppingListID) {
		fields = append(fields, orderheader.FieldAutoOrderShoppingListID)
	}
	if m.FieldCleared(orderheader.FieldNeedsInventoryIssuance) {
		fields = append(fields, orderheader.FieldNeedsInventoryIssuance)
	}
	if m.FieldCleared(orderheader.FieldIsRushOrder) {
		fields = append(fields, orderheader.FieldIsRushOrder)
	}
	if m.FieldCleared(orderheader.FieldInternalCode) {
		fields = append(fields, orderheader.FieldInternalCode)
	}
	if m.FieldCleared(orderheader.FieldRemainingSubTotal) {
		fields = append(fields, orderheader.FieldRemainingSubTotal)
	}
	if m.FieldCleared(orderheader.FieldGrandTotal) {
		fields = append(fields, orderheader.FieldGrandTotal)
	}
	if m.FieldCleared(orderheader.FieldIsViewed) {
		fields = append(fields, orderheader.FieldIsViewed)
	}
	if m.FieldCleared(orderheader.FieldInvoicePerShipment) {
		fields = append(fields, orderheader.FieldInvoicePerShipment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderHeaderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderHeaderMutation) ClearField(name string) error {
	switch name {
	case orderheader.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderheader.FieldOrderTypeID:
		m.ClearOrderTypeID()
		return nil
	case orderheader.FieldOrderName:
		m.ClearOrderName()
		return nil
	case orderheader.FieldExternalID:
		m.ClearExternalID()
		return nil
	case orderheader.FieldOrderDate:
		m.ClearOrderDate()
		return nil
	case orderheader.FieldPriority:
		m.ClearPriority()
		return nil
	case orderheader.FieldEntryDate:
		m.ClearEntryDate()
		return nil
	case orderheader.FieldPickSheetPrintedDate:
		m.ClearPickSheetPrintedDate()
		return nil
	case orderheader.FieldVisitID:
		m.ClearVisitID()
		return nil
	case orderheader.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case orderheader.FieldFirstAttemptOrderID:
		m.ClearFirstAttemptOrderID()
		return nil
	case orderheader.FieldCurrencyUom:
		m.ClearCurrencyUom()
		return nil
	case orderheader.FieldBillingAccountID:
		m.ClearBillingAccountID()
		return nil
	case orderheader.FieldOriginFacilityID:
		m.ClearOriginFacilityID()
		return nil
	case orderheader.FieldWebSiteID:
		m.ClearWebSiteID()
		return nil
	case orderheader.FieldAgreementID:
		m.ClearAgreementID()
		return nil
	case orderheader.FieldTerminalID:
		m.ClearTerminalID()
		return nil
	case orderheader.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	case orderheader.FieldAutoOrderShoppingListID:
		m.ClearAutoOrderShoppingListID()
		return nil
	case orderheader.FieldNeedsInventoryIssuance:
		m.ClearNeedsInventoryIssuance()
		return nil
	case orderheader.FieldIsRushOrder:
		m.ClearIsRushOrder()
		return nil
	case orderheader.FieldInternalCode:
		m.ClearInternalCode()
		return nil
	case orderheader.FieldRemainingSubTotal:
		m.ClearRemainingSubTotal()
		return nil
	case orderheader.FieldGrandTotal:
		m.ClearGrandTotal()
		return nil
	case orderheader.FieldIsViewed:
		m.ClearIsViewed()
		return nil
	case orderheader.FieldInvoicePerShipment:
		m.ClearInvoicePerShipment()
		return nil
	}
	return fmt.Errorf("unknown OrderHeader nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderHeaderMutation) ResetField(name string) error {
	switch name {
	case orderheader.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderheader.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderheader.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderheader.FieldOrderTypeID:
		m.ResetOrderTypeID()
		return nil
	case orderheader.FieldOrderName:
		m.ResetOrderName()
		return nil
	case orderheader.FieldExternalID:
		m.ResetExternalID()
		return nil
	case orderheader.FieldOrderDate:
		m.ResetOrderDate()
		return nil
	case orderheader.FieldPriority:
		m.ResetPriority()
		return nil
	case orderheader.FieldEntryDate:
		m.ResetEntryDate()
		return nil
	case orderheader.FieldPickSheetPrintedDate:
		m.ResetPickSheetPrintedDate()
		return nil
	case orderheader.FieldVisitID:
		m.ResetVisitID()
		return nil
	case orderheader.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case orderheader.FieldFirstAttemptOrderID:
		m.ResetFirstAttemptOrderID()
		return nil
	case orderheader.FieldCurrencyUom:
		m.ResetCurrencyUom()
		return nil
	case orderheader.FieldBillingAccountID:
		m.ResetBillingAccountID()
		return nil
	case orderheader.FieldOriginFacilityID:
		m.ResetOriginFacilityID()
		return nil
	case orderheader.FieldWebSiteID:
		m.ResetWebSiteID()
		return nil
	case orderheader.FieldAgreementID:
		m.ResetAgreementID()
		return nil
	case orderheader.FieldTerminalID:
		m.ResetTerminalID()
		return nil
	case orderheader.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case orderheader.FieldAutoOrderShoppingListID:
		m.ResetAutoOrderShoppingListID()
		return nil
	case orderheader.FieldNeedsInventoryIssuance:
		m.ResetNeedsInventoryIssuance()
		return nil
	case orderheader.FieldIsRushOrder:
		m.ResetIsRushOrder()
		return nil
	case orderheader.FieldInternalCode:
		m.ResetInternalCode()
		return nil
	case orderheader.FieldRemainingSubTotal:
		m.ResetRemainingSubTotal()
		return nil
	case orderheader.FieldGrandTotal:
		m.ResetGrandTotal()
		return nil
	case orderheader.FieldIsViewed:
		m.ResetIsViewed()
		return nil
	case orderheader.FieldInvoicePerShipment:
		m.ResetInvoicePerShipment()
		return nil
	}
	return fmt.Errorf("unknown OrderHeader field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderHeaderMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.sales_channel_enumeration != nil {
		edges = append(edges, orderheader.EdgeSalesChannelEnumeration)
	}
	if m.product_store != nil {
		edges = append(edges, orderheader.EdgeProductStore)
	}
	if m.status_item != nil {
		edges = append(edges, orderheader.EdgeStatusItem)
	}
	if m.sync_status_item != nil {
		edges = append(edges, orderheader.EdgeSyncStatusItem)
	}
	if m.order_adjustments != nil {
		edges = append(edges, orderheader.EdgeOrderAdjustments)
	}
	if m.order_contact_meches != nil {
		edges = append(edges, orderheader.EdgeOrderContactMeches)
	}
	if m.order_items != nil {
		edges = append(edges, orderheader.EdgeOrderItems)
	}
	if m.order_item_ship_groups != nil {
		edges = append(edges, orderheader.EdgeOrderItemShipGroups)
	}
	if m.order_item_ship_group_assocs != nil {
		edges = append(edges, orderheader.EdgeOrderItemShipGroupAssocs)
	}
	if m.order_item_ship_grp_inv_res != nil {
		edges = append(edges, orderheader.EdgeOrderItemShipGrpInvRes)
	}
	if m.order_payment_preferences != nil {
		edges = append(edges, orderheader.EdgeOrderPaymentPreferences)
	}
	if m.order_roles != nil {
		edges = append(edges, orderheader.EdgeOrderRoles)
	}
	if m.order_statuses != nil {
		edges = append(edges, orderheader.EdgeOrderStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderHeaderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderheader.EdgeSalesChannelEnumeration:
		if id := m.sales_channel_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case orderheader.EdgeProductStore:
		if id := m.product_store; id != nil {
			return []ent.Value{*id}
		}
	case orderheader.EdgeStatusItem:
		if id := m.status_item; id != nil {
			return []ent.Value{*id}
		}
	case orderheader.EdgeSyncStatusItem:
		if id := m.sync_status_item; id != nil {
			return []ent.Value{*id}
		}
	case orderheader.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.order_adjustments))
		for id := range m.order_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderContactMeches:
		ids := make([]ent.Value, 0, len(m.order_contact_meches))
		for id := range m.order_contact_meches {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItemShipGroups:
		ids := make([]ent.Value, 0, len(m.order_item_ship_groups))
		for id := range m.order_item_ship_groups {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItemShipGroupAssocs:
		ids := make([]ent.Value, 0, len(m.order_item_ship_group_assocs))
		for id := range m.order_item_ship_group_assocs {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.order_item_ship_grp_inv_res))
		for id := range m.order_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.order_payment_preferences))
		for id := range m.order_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderRoles:
		ids := make([]ent.Value, 0, len(m.order_roles))
		for id := range m.order_roles {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.order_statuses))
		for id := range m.order_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderHeaderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedorder_adjustments != nil {
		edges = append(edges, orderheader.EdgeOrderAdjustments)
	}
	if m.removedorder_contact_meches != nil {
		edges = append(edges, orderheader.EdgeOrderContactMeches)
	}
	if m.removedorder_items != nil {
		edges = append(edges, orderheader.EdgeOrderItems)
	}
	if m.removedorder_item_ship_groups != nil {
		edges = append(edges, orderheader.EdgeOrderItemShipGroups)
	}
	if m.removedorder_item_ship_group_assocs != nil {
		edges = append(edges, orderheader.EdgeOrderItemShipGroupAssocs)
	}
	if m.removedorder_item_ship_grp_inv_res != nil {
		edges = append(edges, orderheader.EdgeOrderItemShipGrpInvRes)
	}
	if m.removedorder_payment_preferences != nil {
		edges = append(edges, orderheader.EdgeOrderPaymentPreferences)
	}
	if m.removedorder_roles != nil {
		edges = append(edges, orderheader.EdgeOrderRoles)
	}
	if m.removedorder_statuses != nil {
		edges = append(edges, orderheader.EdgeOrderStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderHeaderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderheader.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.removedorder_adjustments))
		for id := range m.removedorder_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderContactMeches:
		ids := make([]ent.Value, 0, len(m.removedorder_contact_meches))
		for id := range m.removedorder_contact_meches {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItemShipGroups:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_groups))
		for id := range m.removedorder_item_ship_groups {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItemShipGroupAssocs:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_group_assocs))
		for id := range m.removedorder_item_ship_group_assocs {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_grp_inv_res))
		for id := range m.removedorder_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.removedorder_payment_preferences))
		for id := range m.removedorder_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderRoles:
		ids := make([]ent.Value, 0, len(m.removedorder_roles))
		for id := range m.removedorder_roles {
			ids = append(ids, id)
		}
		return ids
	case orderheader.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.removedorder_statuses))
		for id := range m.removedorder_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderHeaderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedsales_channel_enumeration {
		edges = append(edges, orderheader.EdgeSalesChannelEnumeration)
	}
	if m.clearedproduct_store {
		edges = append(edges, orderheader.EdgeProductStore)
	}
	if m.clearedstatus_item {
		edges = append(edges, orderheader.EdgeStatusItem)
	}
	if m.clearedsync_status_item {
		edges = append(edges, orderheader.EdgeSyncStatusItem)
	}
	if m.clearedorder_adjustments {
		edges = append(edges, orderheader.EdgeOrderAdjustments)
	}
	if m.clearedorder_contact_meches {
		edges = append(edges, orderheader.EdgeOrderContactMeches)
	}
	if m.clearedorder_items {
		edges = append(edges, orderheader.EdgeOrderItems)
	}
	if m.clearedorder_item_ship_groups {
		edges = append(edges, orderheader.EdgeOrderItemShipGroups)
	}
	if m.clearedorder_item_ship_group_assocs {
		edges = append(edges, orderheader.EdgeOrderItemShipGroupAssocs)
	}
	if m.clearedorder_item_ship_grp_inv_res {
		edges = append(edges, orderheader.EdgeOrderItemShipGrpInvRes)
	}
	if m.clearedorder_payment_preferences {
		edges = append(edges, orderheader.EdgeOrderPaymentPreferences)
	}
	if m.clearedorder_roles {
		edges = append(edges, orderheader.EdgeOrderRoles)
	}
	if m.clearedorder_statuses {
		edges = append(edges, orderheader.EdgeOrderStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderHeaderMutation) EdgeCleared(name string) bool {
	switch name {
	case orderheader.EdgeSalesChannelEnumeration:
		return m.clearedsales_channel_enumeration
	case orderheader.EdgeProductStore:
		return m.clearedproduct_store
	case orderheader.EdgeStatusItem:
		return m.clearedstatus_item
	case orderheader.EdgeSyncStatusItem:
		return m.clearedsync_status_item
	case orderheader.EdgeOrderAdjustments:
		return m.clearedorder_adjustments
	case orderheader.EdgeOrderContactMeches:
		return m.clearedorder_contact_meches
	case orderheader.EdgeOrderItems:
		return m.clearedorder_items
	case orderheader.EdgeOrderItemShipGroups:
		return m.clearedorder_item_ship_groups
	case orderheader.EdgeOrderItemShipGroupAssocs:
		return m.clearedorder_item_ship_group_assocs
	case orderheader.EdgeOrderItemShipGrpInvRes:
		return m.clearedorder_item_ship_grp_inv_res
	case orderheader.EdgeOrderPaymentPreferences:
		return m.clearedorder_payment_preferences
	case orderheader.EdgeOrderRoles:
		return m.clearedorder_roles
	case orderheader.EdgeOrderStatuses:
		return m.clearedorder_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderHeaderMutation) ClearEdge(name string) error {
	switch name {
	case orderheader.EdgeSalesChannelEnumeration:
		m.ClearSalesChannelEnumeration()
		return nil
	case orderheader.EdgeProductStore:
		m.ClearProductStore()
		return nil
	case orderheader.EdgeStatusItem:
		m.ClearStatusItem()
		return nil
	case orderheader.EdgeSyncStatusItem:
		m.ClearSyncStatusItem()
		return nil
	}
	return fmt.Errorf("unknown OrderHeader unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderHeaderMutation) ResetEdge(name string) error {
	switch name {
	case orderheader.EdgeSalesChannelEnumeration:
		m.ResetSalesChannelEnumeration()
		return nil
	case orderheader.EdgeProductStore:
		m.ResetProductStore()
		return nil
	case orderheader.EdgeStatusItem:
		m.ResetStatusItem()
		return nil
	case orderheader.EdgeSyncStatusItem:
		m.ResetSyncStatusItem()
		return nil
	case orderheader.EdgeOrderAdjustments:
		m.ResetOrderAdjustments()
		return nil
	case orderheader.EdgeOrderContactMeches:
		m.ResetOrderContactMeches()
		return nil
	case orderheader.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case orderheader.EdgeOrderItemShipGroups:
		m.ResetOrderItemShipGroups()
		return nil
	case orderheader.EdgeOrderItemShipGroupAssocs:
		m.ResetOrderItemShipGroupAssocs()
		return nil
	case orderheader.EdgeOrderItemShipGrpInvRes:
		m.ResetOrderItemShipGrpInvRes()
		return nil
	case orderheader.EdgeOrderPaymentPreferences:
		m.ResetOrderPaymentPreferences()
		return nil
	case orderheader.EdgeOrderRoles:
		m.ResetOrderRoles()
		return nil
	case orderheader.EdgeOrderStatuses:
		m.ResetOrderStatuses()
		return nil
	}
	return fmt.Errorf("unknown OrderHeader edge %s", name)
}

// OrderItemMutation represents an operation that mutates the OrderItem nodes in the graph.
type OrderItemMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	update_time                         *time.Time
	string_ref                          *string
	order_item_seq_id                   *int
	addorder_item_seq_id                *int
	external_id                         *int
	addexternal_id                      *int
	order_item_type_id                  *int
	addorder_item_type_id               *int
	order_item_group_seq_id             *int
	addorder_item_group_seq_id          *int
	is_item_group_primary               *orderitem.IsItemGroupPrimary
	from_inventory_item_id              *int
	addfrom_inventory_item_id           *int
	budget_id                           *int
	addbudget_id                        *int
	budget_item_seq_id                  *int
	addbudget_item_seq_id               *int
	supplier_product_id                 *string
	product_feature_id                  *int
	addproduct_feature_id               *int
	prod_catalog_id                     *int
	addprod_catalog_id                  *int
	product_category_id                 *int
	addproduct_category_id              *int
	is_promo                            *orderitem.IsPromo
	quote_id                            *int
	addquote_id                         *int
	quote_item_seq_id                   *int
	addquote_item_seq_id                *int
	shopping_list_id                    *int
	addshopping_list_id                 *int
	shopping_list_item_seq_id           *int
	addshopping_list_item_seq_id        *int
	subscription_id                     *int
	addsubscription_id                  *int
	deployment_id                       *int
	adddeployment_id                    *int
	quantity                            *float64
	addquantity                         *float64
	cancel_quantity                     *float64
	addcancel_quantity                  *float64
	selected_amount                     *float64
	addselected_amount                  *float64
	unit_price                          *float64
	addunit_price                       *float64
	unit_list_price                     *float64
	addunit_list_price                  *float64
	unit_average_cost                   *float64
	addunit_average_cost                *float64
	unit_recurring_price                *float64
	addunit_recurring_price             *float64
	is_modified_price                   *orderitem.IsModifiedPrice
	recurring_freq_uom_id               *int
	addrecurring_freq_uom_id            *int
	item_description                    *string
	comments                            *string
	corresponding_po_id                 *int
	addcorresponding_po_id              *int
	estimated_ship_date                 *time.Time
	estimated_delivery_date             *time.Time
	auto_cancel_date                    *time.Time
	dont_cancel_set_date                *time.Time
	dont_cancel_set_user_login          *string
	ship_before_date                    *time.Time
	ship_after_date                     *time.Time
	reserve_after_date                  *time.Time
	cancel_back_order_date              *time.Time
	override_gl_account_id              *int
	addoverride_gl_account_id           *int
	sales_opportunity_id                *int
	addsales_opportunity_id             *int
	change_by_user_login_id             *string
	clearedFields                       map[string]struct{}
	order_header                        *int
	clearedorder_header                 bool
	product                             *int
	clearedproduct                      bool
	status_item                         *int
	clearedstatus_item                  bool
	status_valid_changes                map[int]struct{}
	removedstatus_valid_changes         map[int]struct{}
	clearedstatus_valid_changes         bool
	sync_status_item                    *int
	clearedsync_status_item             bool
	order_adjustments                   map[int]struct{}
	removedorder_adjustments            map[int]struct{}
	clearedorder_adjustments            bool
	order_item_ship_group_assocs        map[int]struct{}
	removedorder_item_ship_group_assocs map[int]struct{}
	clearedorder_item_ship_group_assocs bool
	order_item_ship_grp_inv_res         map[int]struct{}
	removedorder_item_ship_grp_inv_res  map[int]struct{}
	clearedorder_item_ship_grp_inv_res  bool
	order_payment_preferences           map[int]struct{}
	removedorder_payment_preferences    map[int]struct{}
	clearedorder_payment_preferences    bool
	order_statuses                      map[int]struct{}
	removedorder_statuses               map[int]struct{}
	clearedorder_statuses               bool
	done                                bool
	oldValue                            func(context.Context) (*OrderItem, error)
	predicates                          []predicate.OrderItem
}

var _ ent.Mutation = (*OrderItemMutation)(nil)

// orderitemOption allows management of the mutation configuration using functional options.
type orderitemOption func(*OrderItemMutation)

// newOrderItemMutation creates new mutation for the OrderItem entity.
func newOrderItemMutation(c config, op Op, opts ...orderitemOption) *OrderItemMutation {
	m := &OrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemID sets the ID field of the mutation.
func withOrderItemID(id int) orderitemOption {
	return func(m *OrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItem
		)
		m.oldValue = func(ctx context.Context) (*OrderItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItem sets the old OrderItem of the mutation.
func withOrderItem(node *OrderItem) orderitemOption {
	return func(m *OrderItemMutation) {
		m.oldValue = func(context.Context) (*OrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderItemMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderItemMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderItemMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderitem.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderItemMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderItemMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderitem.FieldStringRef)
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *OrderItemMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *OrderItemMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *OrderItemMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *OrderItemMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *OrderItemMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
}

// SetExternalID sets the "external_id" field.
func (m *OrderItemMutation) SetExternalID(i int) {
	m.external_id = &i
	m.addexternal_id = nil
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OrderItemMutation) ExternalID() (r int, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldExternalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// AddExternalID adds i to the "external_id" field.
func (m *OrderItemMutation) AddExternalID(i int) {
	if m.addexternal_id != nil {
		*m.addexternal_id += i
	} else {
		m.addexternal_id = &i
	}
}

// AddedExternalID returns the value that was added to the "external_id" field in this mutation.
func (m *OrderItemMutation) AddedExternalID() (r int, exists bool) {
	v := m.addexternal_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OrderItemMutation) ClearExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	m.clearedFields[orderitem.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OrderItemMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OrderItemMutation) ResetExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	delete(m.clearedFields, orderitem.FieldExternalID)
}

// SetOrderItemTypeID sets the "order_item_type_id" field.
func (m *OrderItemMutation) SetOrderItemTypeID(i int) {
	m.order_item_type_id = &i
	m.addorder_item_type_id = nil
}

// OrderItemTypeID returns the value of the "order_item_type_id" field in the mutation.
func (m *OrderItemMutation) OrderItemTypeID() (r int, exists bool) {
	v := m.order_item_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemTypeID returns the old "order_item_type_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderItemTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemTypeID: %w", err)
	}
	return oldValue.OrderItemTypeID, nil
}

// AddOrderItemTypeID adds i to the "order_item_type_id" field.
func (m *OrderItemMutation) AddOrderItemTypeID(i int) {
	if m.addorder_item_type_id != nil {
		*m.addorder_item_type_id += i
	} else {
		m.addorder_item_type_id = &i
	}
}

// AddedOrderItemTypeID returns the value that was added to the "order_item_type_id" field in this mutation.
func (m *OrderItemMutation) AddedOrderItemTypeID() (r int, exists bool) {
	v := m.addorder_item_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemTypeID clears the value of the "order_item_type_id" field.
func (m *OrderItemMutation) ClearOrderItemTypeID() {
	m.order_item_type_id = nil
	m.addorder_item_type_id = nil
	m.clearedFields[orderitem.FieldOrderItemTypeID] = struct{}{}
}

// OrderItemTypeIDCleared returns if the "order_item_type_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderItemTypeIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderItemTypeID]
	return ok
}

// ResetOrderItemTypeID resets all changes to the "order_item_type_id" field.
func (m *OrderItemMutation) ResetOrderItemTypeID() {
	m.order_item_type_id = nil
	m.addorder_item_type_id = nil
	delete(m.clearedFields, orderitem.FieldOrderItemTypeID)
}

// SetOrderItemGroupSeqID sets the "order_item_group_seq_id" field.
func (m *OrderItemMutation) SetOrderItemGroupSeqID(i int) {
	m.order_item_group_seq_id = &i
	m.addorder_item_group_seq_id = nil
}

// OrderItemGroupSeqID returns the value of the "order_item_group_seq_id" field in the mutation.
func (m *OrderItemMutation) OrderItemGroupSeqID() (r int, exists bool) {
	v := m.order_item_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemGroupSeqID returns the old "order_item_group_seq_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOrderItemGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemGroupSeqID: %w", err)
	}
	return oldValue.OrderItemGroupSeqID, nil
}

// AddOrderItemGroupSeqID adds i to the "order_item_group_seq_id" field.
func (m *OrderItemMutation) AddOrderItemGroupSeqID(i int) {
	if m.addorder_item_group_seq_id != nil {
		*m.addorder_item_group_seq_id += i
	} else {
		m.addorder_item_group_seq_id = &i
	}
}

// AddedOrderItemGroupSeqID returns the value that was added to the "order_item_group_seq_id" field in this mutation.
func (m *OrderItemMutation) AddedOrderItemGroupSeqID() (r int, exists bool) {
	v := m.addorder_item_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemGroupSeqID clears the value of the "order_item_group_seq_id" field.
func (m *OrderItemMutation) ClearOrderItemGroupSeqID() {
	m.order_item_group_seq_id = nil
	m.addorder_item_group_seq_id = nil
	m.clearedFields[orderitem.FieldOrderItemGroupSeqID] = struct{}{}
}

// OrderItemGroupSeqIDCleared returns if the "order_item_group_seq_id" field was cleared in this mutation.
func (m *OrderItemMutation) OrderItemGroupSeqIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOrderItemGroupSeqID]
	return ok
}

// ResetOrderItemGroupSeqID resets all changes to the "order_item_group_seq_id" field.
func (m *OrderItemMutation) ResetOrderItemGroupSeqID() {
	m.order_item_group_seq_id = nil
	m.addorder_item_group_seq_id = nil
	delete(m.clearedFields, orderitem.FieldOrderItemGroupSeqID)
}

// SetIsItemGroupPrimary sets the "is_item_group_primary" field.
func (m *OrderItemMutation) SetIsItemGroupPrimary(oigp orderitem.IsItemGroupPrimary) {
	m.is_item_group_primary = &oigp
}

// IsItemGroupPrimary returns the value of the "is_item_group_primary" field in the mutation.
func (m *OrderItemMutation) IsItemGroupPrimary() (r orderitem.IsItemGroupPrimary, exists bool) {
	v := m.is_item_group_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsItemGroupPrimary returns the old "is_item_group_primary" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldIsItemGroupPrimary(ctx context.Context) (v orderitem.IsItemGroupPrimary, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsItemGroupPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsItemGroupPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsItemGroupPrimary: %w", err)
	}
	return oldValue.IsItemGroupPrimary, nil
}

// ClearIsItemGroupPrimary clears the value of the "is_item_group_primary" field.
func (m *OrderItemMutation) ClearIsItemGroupPrimary() {
	m.is_item_group_primary = nil
	m.clearedFields[orderitem.FieldIsItemGroupPrimary] = struct{}{}
}

// IsItemGroupPrimaryCleared returns if the "is_item_group_primary" field was cleared in this mutation.
func (m *OrderItemMutation) IsItemGroupPrimaryCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldIsItemGroupPrimary]
	return ok
}

// ResetIsItemGroupPrimary resets all changes to the "is_item_group_primary" field.
func (m *OrderItemMutation) ResetIsItemGroupPrimary() {
	m.is_item_group_primary = nil
	delete(m.clearedFields, orderitem.FieldIsItemGroupPrimary)
}

// SetFromInventoryItemID sets the "from_inventory_item_id" field.
func (m *OrderItemMutation) SetFromInventoryItemID(i int) {
	m.from_inventory_item_id = &i
	m.addfrom_inventory_item_id = nil
}

// FromInventoryItemID returns the value of the "from_inventory_item_id" field in the mutation.
func (m *OrderItemMutation) FromInventoryItemID() (r int, exists bool) {
	v := m.from_inventory_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFromInventoryItemID returns the old "from_inventory_item_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldFromInventoryItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromInventoryItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromInventoryItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromInventoryItemID: %w", err)
	}
	return oldValue.FromInventoryItemID, nil
}

// AddFromInventoryItemID adds i to the "from_inventory_item_id" field.
func (m *OrderItemMutation) AddFromInventoryItemID(i int) {
	if m.addfrom_inventory_item_id != nil {
		*m.addfrom_inventory_item_id += i
	} else {
		m.addfrom_inventory_item_id = &i
	}
}

// AddedFromInventoryItemID returns the value that was added to the "from_inventory_item_id" field in this mutation.
func (m *OrderItemMutation) AddedFromInventoryItemID() (r int, exists bool) {
	v := m.addfrom_inventory_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFromInventoryItemID clears the value of the "from_inventory_item_id" field.
func (m *OrderItemMutation) ClearFromInventoryItemID() {
	m.from_inventory_item_id = nil
	m.addfrom_inventory_item_id = nil
	m.clearedFields[orderitem.FieldFromInventoryItemID] = struct{}{}
}

// FromInventoryItemIDCleared returns if the "from_inventory_item_id" field was cleared in this mutation.
func (m *OrderItemMutation) FromInventoryItemIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldFromInventoryItemID]
	return ok
}

// ResetFromInventoryItemID resets all changes to the "from_inventory_item_id" field.
func (m *OrderItemMutation) ResetFromInventoryItemID() {
	m.from_inventory_item_id = nil
	m.addfrom_inventory_item_id = nil
	delete(m.clearedFields, orderitem.FieldFromInventoryItemID)
}

// SetBudgetID sets the "budget_id" field.
func (m *OrderItemMutation) SetBudgetID(i int) {
	m.budget_id = &i
	m.addbudget_id = nil
}

// BudgetID returns the value of the "budget_id" field in the mutation.
func (m *OrderItemMutation) BudgetID() (r int, exists bool) {
	v := m.budget_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetID returns the old "budget_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldBudgetID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBudgetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBudgetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetID: %w", err)
	}
	return oldValue.BudgetID, nil
}

// AddBudgetID adds i to the "budget_id" field.
func (m *OrderItemMutation) AddBudgetID(i int) {
	if m.addbudget_id != nil {
		*m.addbudget_id += i
	} else {
		m.addbudget_id = &i
	}
}

// AddedBudgetID returns the value that was added to the "budget_id" field in this mutation.
func (m *OrderItemMutation) AddedBudgetID() (r int, exists bool) {
	v := m.addbudget_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudgetID clears the value of the "budget_id" field.
func (m *OrderItemMutation) ClearBudgetID() {
	m.budget_id = nil
	m.addbudget_id = nil
	m.clearedFields[orderitem.FieldBudgetID] = struct{}{}
}

// BudgetIDCleared returns if the "budget_id" field was cleared in this mutation.
func (m *OrderItemMutation) BudgetIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldBudgetID]
	return ok
}

// ResetBudgetID resets all changes to the "budget_id" field.
func (m *OrderItemMutation) ResetBudgetID() {
	m.budget_id = nil
	m.addbudget_id = nil
	delete(m.clearedFields, orderitem.FieldBudgetID)
}

// SetBudgetItemSeqID sets the "budget_item_seq_id" field.
func (m *OrderItemMutation) SetBudgetItemSeqID(i int) {
	m.budget_item_seq_id = &i
	m.addbudget_item_seq_id = nil
}

// BudgetItemSeqID returns the value of the "budget_item_seq_id" field in the mutation.
func (m *OrderItemMutation) BudgetItemSeqID() (r int, exists bool) {
	v := m.budget_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBudgetItemSeqID returns the old "budget_item_seq_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldBudgetItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBudgetItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBudgetItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudgetItemSeqID: %w", err)
	}
	return oldValue.BudgetItemSeqID, nil
}

// AddBudgetItemSeqID adds i to the "budget_item_seq_id" field.
func (m *OrderItemMutation) AddBudgetItemSeqID(i int) {
	if m.addbudget_item_seq_id != nil {
		*m.addbudget_item_seq_id += i
	} else {
		m.addbudget_item_seq_id = &i
	}
}

// AddedBudgetItemSeqID returns the value that was added to the "budget_item_seq_id" field in this mutation.
func (m *OrderItemMutation) AddedBudgetItemSeqID() (r int, exists bool) {
	v := m.addbudget_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudgetItemSeqID clears the value of the "budget_item_seq_id" field.
func (m *OrderItemMutation) ClearBudgetItemSeqID() {
	m.budget_item_seq_id = nil
	m.addbudget_item_seq_id = nil
	m.clearedFields[orderitem.FieldBudgetItemSeqID] = struct{}{}
}

// BudgetItemSeqIDCleared returns if the "budget_item_seq_id" field was cleared in this mutation.
func (m *OrderItemMutation) BudgetItemSeqIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldBudgetItemSeqID]
	return ok
}

// ResetBudgetItemSeqID resets all changes to the "budget_item_seq_id" field.
func (m *OrderItemMutation) ResetBudgetItemSeqID() {
	m.budget_item_seq_id = nil
	m.addbudget_item_seq_id = nil
	delete(m.clearedFields, orderitem.FieldBudgetItemSeqID)
}

// SetSupplierProductID sets the "supplier_product_id" field.
func (m *OrderItemMutation) SetSupplierProductID(s string) {
	m.supplier_product_id = &s
}

// SupplierProductID returns the value of the "supplier_product_id" field in the mutation.
func (m *OrderItemMutation) SupplierProductID() (r string, exists bool) {
	v := m.supplier_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierProductID returns the old "supplier_product_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSupplierProductID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSupplierProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSupplierProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierProductID: %w", err)
	}
	return oldValue.SupplierProductID, nil
}

// ClearSupplierProductID clears the value of the "supplier_product_id" field.
func (m *OrderItemMutation) ClearSupplierProductID() {
	m.supplier_product_id = nil
	m.clearedFields[orderitem.FieldSupplierProductID] = struct{}{}
}

// SupplierProductIDCleared returns if the "supplier_product_id" field was cleared in this mutation.
func (m *OrderItemMutation) SupplierProductIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSupplierProductID]
	return ok
}

// ResetSupplierProductID resets all changes to the "supplier_product_id" field.
func (m *OrderItemMutation) ResetSupplierProductID() {
	m.supplier_product_id = nil
	delete(m.clearedFields, orderitem.FieldSupplierProductID)
}

// SetProductFeatureID sets the "product_feature_id" field.
func (m *OrderItemMutation) SetProductFeatureID(i int) {
	m.product_feature_id = &i
	m.addproduct_feature_id = nil
}

// ProductFeatureID returns the value of the "product_feature_id" field in the mutation.
func (m *OrderItemMutation) ProductFeatureID() (r int, exists bool) {
	v := m.product_feature_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductFeatureID returns the old "product_feature_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductFeatureID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductFeatureID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductFeatureID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductFeatureID: %w", err)
	}
	return oldValue.ProductFeatureID, nil
}

// AddProductFeatureID adds i to the "product_feature_id" field.
func (m *OrderItemMutation) AddProductFeatureID(i int) {
	if m.addproduct_feature_id != nil {
		*m.addproduct_feature_id += i
	} else {
		m.addproduct_feature_id = &i
	}
}

// AddedProductFeatureID returns the value that was added to the "product_feature_id" field in this mutation.
func (m *OrderItemMutation) AddedProductFeatureID() (r int, exists bool) {
	v := m.addproduct_feature_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductFeatureID clears the value of the "product_feature_id" field.
func (m *OrderItemMutation) ClearProductFeatureID() {
	m.product_feature_id = nil
	m.addproduct_feature_id = nil
	m.clearedFields[orderitem.FieldProductFeatureID] = struct{}{}
}

// ProductFeatureIDCleared returns if the "product_feature_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductFeatureIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductFeatureID]
	return ok
}

// ResetProductFeatureID resets all changes to the "product_feature_id" field.
func (m *OrderItemMutation) ResetProductFeatureID() {
	m.product_feature_id = nil
	m.addproduct_feature_id = nil
	delete(m.clearedFields, orderitem.FieldProductFeatureID)
}

// SetProdCatalogID sets the "prod_catalog_id" field.
func (m *OrderItemMutation) SetProdCatalogID(i int) {
	m.prod_catalog_id = &i
	m.addprod_catalog_id = nil
}

// ProdCatalogID returns the value of the "prod_catalog_id" field in the mutation.
func (m *OrderItemMutation) ProdCatalogID() (r int, exists bool) {
	v := m.prod_catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProdCatalogID returns the old "prod_catalog_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProdCatalogID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProdCatalogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProdCatalogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProdCatalogID: %w", err)
	}
	return oldValue.ProdCatalogID, nil
}

// AddProdCatalogID adds i to the "prod_catalog_id" field.
func (m *OrderItemMutation) AddProdCatalogID(i int) {
	if m.addprod_catalog_id != nil {
		*m.addprod_catalog_id += i
	} else {
		m.addprod_catalog_id = &i
	}
}

// AddedProdCatalogID returns the value that was added to the "prod_catalog_id" field in this mutation.
func (m *OrderItemMutation) AddedProdCatalogID() (r int, exists bool) {
	v := m.addprod_catalog_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProdCatalogID clears the value of the "prod_catalog_id" field.
func (m *OrderItemMutation) ClearProdCatalogID() {
	m.prod_catalog_id = nil
	m.addprod_catalog_id = nil
	m.clearedFields[orderitem.FieldProdCatalogID] = struct{}{}
}

// ProdCatalogIDCleared returns if the "prod_catalog_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProdCatalogIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProdCatalogID]
	return ok
}

// ResetProdCatalogID resets all changes to the "prod_catalog_id" field.
func (m *OrderItemMutation) ResetProdCatalogID() {
	m.prod_catalog_id = nil
	m.addprod_catalog_id = nil
	delete(m.clearedFields, orderitem.FieldProdCatalogID)
}

// SetProductCategoryID sets the "product_category_id" field.
func (m *OrderItemMutation) SetProductCategoryID(i int) {
	m.product_category_id = &i
	m.addproduct_category_id = nil
}

// ProductCategoryID returns the value of the "product_category_id" field in the mutation.
func (m *OrderItemMutation) ProductCategoryID() (r int, exists bool) {
	v := m.product_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCategoryID returns the old "product_category_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldProductCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCategoryID: %w", err)
	}
	return oldValue.ProductCategoryID, nil
}

// AddProductCategoryID adds i to the "product_category_id" field.
func (m *OrderItemMutation) AddProductCategoryID(i int) {
	if m.addproduct_category_id != nil {
		*m.addproduct_category_id += i
	} else {
		m.addproduct_category_id = &i
	}
}

// AddedProductCategoryID returns the value that was added to the "product_category_id" field in this mutation.
func (m *OrderItemMutation) AddedProductCategoryID() (r int, exists bool) {
	v := m.addproduct_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductCategoryID clears the value of the "product_category_id" field.
func (m *OrderItemMutation) ClearProductCategoryID() {
	m.product_category_id = nil
	m.addproduct_category_id = nil
	m.clearedFields[orderitem.FieldProductCategoryID] = struct{}{}
}

// ProductCategoryIDCleared returns if the "product_category_id" field was cleared in this mutation.
func (m *OrderItemMutation) ProductCategoryIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldProductCategoryID]
	return ok
}

// ResetProductCategoryID resets all changes to the "product_category_id" field.
func (m *OrderItemMutation) ResetProductCategoryID() {
	m.product_category_id = nil
	m.addproduct_category_id = nil
	delete(m.clearedFields, orderitem.FieldProductCategoryID)
}

// SetIsPromo sets the "is_promo" field.
func (m *OrderItemMutation) SetIsPromo(op orderitem.IsPromo) {
	m.is_promo = &op
}

// IsPromo returns the value of the "is_promo" field in the mutation.
func (m *OrderItemMutation) IsPromo() (r orderitem.IsPromo, exists bool) {
	v := m.is_promo
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPromo returns the old "is_promo" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldIsPromo(ctx context.Context) (v orderitem.IsPromo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsPromo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsPromo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPromo: %w", err)
	}
	return oldValue.IsPromo, nil
}

// ClearIsPromo clears the value of the "is_promo" field.
func (m *OrderItemMutation) ClearIsPromo() {
	m.is_promo = nil
	m.clearedFields[orderitem.FieldIsPromo] = struct{}{}
}

// IsPromoCleared returns if the "is_promo" field was cleared in this mutation.
func (m *OrderItemMutation) IsPromoCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldIsPromo]
	return ok
}

// ResetIsPromo resets all changes to the "is_promo" field.
func (m *OrderItemMutation) ResetIsPromo() {
	m.is_promo = nil
	delete(m.clearedFields, orderitem.FieldIsPromo)
}

// SetQuoteID sets the "quote_id" field.
func (m *OrderItemMutation) SetQuoteID(i int) {
	m.quote_id = &i
	m.addquote_id = nil
}

// QuoteID returns the value of the "quote_id" field in the mutation.
func (m *OrderItemMutation) QuoteID() (r int, exists bool) {
	v := m.quote_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuoteID returns the old "quote_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuoteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuoteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuoteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuoteID: %w", err)
	}
	return oldValue.QuoteID, nil
}

// AddQuoteID adds i to the "quote_id" field.
func (m *OrderItemMutation) AddQuoteID(i int) {
	if m.addquote_id != nil {
		*m.addquote_id += i
	} else {
		m.addquote_id = &i
	}
}

// AddedQuoteID returns the value that was added to the "quote_id" field in this mutation.
func (m *OrderItemMutation) AddedQuoteID() (r int, exists bool) {
	v := m.addquote_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuoteID clears the value of the "quote_id" field.
func (m *OrderItemMutation) ClearQuoteID() {
	m.quote_id = nil
	m.addquote_id = nil
	m.clearedFields[orderitem.FieldQuoteID] = struct{}{}
}

// QuoteIDCleared returns if the "quote_id" field was cleared in this mutation.
func (m *OrderItemMutation) QuoteIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldQuoteID]
	return ok
}

// ResetQuoteID resets all changes to the "quote_id" field.
func (m *OrderItemMutation) ResetQuoteID() {
	m.quote_id = nil
	m.addquote_id = nil
	delete(m.clearedFields, orderitem.FieldQuoteID)
}

// SetQuoteItemSeqID sets the "quote_item_seq_id" field.
func (m *OrderItemMutation) SetQuoteItemSeqID(i int) {
	m.quote_item_seq_id = &i
	m.addquote_item_seq_id = nil
}

// QuoteItemSeqID returns the value of the "quote_item_seq_id" field in the mutation.
func (m *OrderItemMutation) QuoteItemSeqID() (r int, exists bool) {
	v := m.quote_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuoteItemSeqID returns the old "quote_item_seq_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuoteItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuoteItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuoteItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuoteItemSeqID: %w", err)
	}
	return oldValue.QuoteItemSeqID, nil
}

// AddQuoteItemSeqID adds i to the "quote_item_seq_id" field.
func (m *OrderItemMutation) AddQuoteItemSeqID(i int) {
	if m.addquote_item_seq_id != nil {
		*m.addquote_item_seq_id += i
	} else {
		m.addquote_item_seq_id = &i
	}
}

// AddedQuoteItemSeqID returns the value that was added to the "quote_item_seq_id" field in this mutation.
func (m *OrderItemMutation) AddedQuoteItemSeqID() (r int, exists bool) {
	v := m.addquote_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuoteItemSeqID clears the value of the "quote_item_seq_id" field.
func (m *OrderItemMutation) ClearQuoteItemSeqID() {
	m.quote_item_seq_id = nil
	m.addquote_item_seq_id = nil
	m.clearedFields[orderitem.FieldQuoteItemSeqID] = struct{}{}
}

// QuoteItemSeqIDCleared returns if the "quote_item_seq_id" field was cleared in this mutation.
func (m *OrderItemMutation) QuoteItemSeqIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldQuoteItemSeqID]
	return ok
}

// ResetQuoteItemSeqID resets all changes to the "quote_item_seq_id" field.
func (m *OrderItemMutation) ResetQuoteItemSeqID() {
	m.quote_item_seq_id = nil
	m.addquote_item_seq_id = nil
	delete(m.clearedFields, orderitem.FieldQuoteItemSeqID)
}

// SetShoppingListID sets the "shopping_list_id" field.
func (m *OrderItemMutation) SetShoppingListID(i int) {
	m.shopping_list_id = &i
	m.addshopping_list_id = nil
}

// ShoppingListID returns the value of the "shopping_list_id" field in the mutation.
func (m *OrderItemMutation) ShoppingListID() (r int, exists bool) {
	v := m.shopping_list_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShoppingListID returns the old "shopping_list_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldShoppingListID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShoppingListID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShoppingListID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShoppingListID: %w", err)
	}
	return oldValue.ShoppingListID, nil
}

// AddShoppingListID adds i to the "shopping_list_id" field.
func (m *OrderItemMutation) AddShoppingListID(i int) {
	if m.addshopping_list_id != nil {
		*m.addshopping_list_id += i
	} else {
		m.addshopping_list_id = &i
	}
}

// AddedShoppingListID returns the value that was added to the "shopping_list_id" field in this mutation.
func (m *OrderItemMutation) AddedShoppingListID() (r int, exists bool) {
	v := m.addshopping_list_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShoppingListID clears the value of the "shopping_list_id" field.
func (m *OrderItemMutation) ClearShoppingListID() {
	m.shopping_list_id = nil
	m.addshopping_list_id = nil
	m.clearedFields[orderitem.FieldShoppingListID] = struct{}{}
}

// ShoppingListIDCleared returns if the "shopping_list_id" field was cleared in this mutation.
func (m *OrderItemMutation) ShoppingListIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldShoppingListID]
	return ok
}

// ResetShoppingListID resets all changes to the "shopping_list_id" field.
func (m *OrderItemMutation) ResetShoppingListID() {
	m.shopping_list_id = nil
	m.addshopping_list_id = nil
	delete(m.clearedFields, orderitem.FieldShoppingListID)
}

// SetShoppingListItemSeqID sets the "shopping_list_item_seq_id" field.
func (m *OrderItemMutation) SetShoppingListItemSeqID(i int) {
	m.shopping_list_item_seq_id = &i
	m.addshopping_list_item_seq_id = nil
}

// ShoppingListItemSeqID returns the value of the "shopping_list_item_seq_id" field in the mutation.
func (m *OrderItemMutation) ShoppingListItemSeqID() (r int, exists bool) {
	v := m.shopping_list_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShoppingListItemSeqID returns the old "shopping_list_item_seq_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldShoppingListItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShoppingListItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShoppingListItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShoppingListItemSeqID: %w", err)
	}
	return oldValue.ShoppingListItemSeqID, nil
}

// AddShoppingListItemSeqID adds i to the "shopping_list_item_seq_id" field.
func (m *OrderItemMutation) AddShoppingListItemSeqID(i int) {
	if m.addshopping_list_item_seq_id != nil {
		*m.addshopping_list_item_seq_id += i
	} else {
		m.addshopping_list_item_seq_id = &i
	}
}

// AddedShoppingListItemSeqID returns the value that was added to the "shopping_list_item_seq_id" field in this mutation.
func (m *OrderItemMutation) AddedShoppingListItemSeqID() (r int, exists bool) {
	v := m.addshopping_list_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShoppingListItemSeqID clears the value of the "shopping_list_item_seq_id" field.
func (m *OrderItemMutation) ClearShoppingListItemSeqID() {
	m.shopping_list_item_seq_id = nil
	m.addshopping_list_item_seq_id = nil
	m.clearedFields[orderitem.FieldShoppingListItemSeqID] = struct{}{}
}

// ShoppingListItemSeqIDCleared returns if the "shopping_list_item_seq_id" field was cleared in this mutation.
func (m *OrderItemMutation) ShoppingListItemSeqIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldShoppingListItemSeqID]
	return ok
}

// ResetShoppingListItemSeqID resets all changes to the "shopping_list_item_seq_id" field.
func (m *OrderItemMutation) ResetShoppingListItemSeqID() {
	m.shopping_list_item_seq_id = nil
	m.addshopping_list_item_seq_id = nil
	delete(m.clearedFields, orderitem.FieldShoppingListItemSeqID)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *OrderItemMutation) SetSubscriptionID(i int) {
	m.subscription_id = &i
	m.addsubscription_id = nil
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *OrderItemMutation) SubscriptionID() (r int, exists bool) {
	v := m.subscription_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSubscriptionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// AddSubscriptionID adds i to the "subscription_id" field.
func (m *OrderItemMutation) AddSubscriptionID(i int) {
	if m.addsubscription_id != nil {
		*m.addsubscription_id += i
	} else {
		m.addsubscription_id = &i
	}
}

// AddedSubscriptionID returns the value that was added to the "subscription_id" field in this mutation.
func (m *OrderItemMutation) AddedSubscriptionID() (r int, exists bool) {
	v := m.addsubscription_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *OrderItemMutation) ClearSubscriptionID() {
	m.subscription_id = nil
	m.addsubscription_id = nil
	m.clearedFields[orderitem.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *OrderItemMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *OrderItemMutation) ResetSubscriptionID() {
	m.subscription_id = nil
	m.addsubscription_id = nil
	delete(m.clearedFields, orderitem.FieldSubscriptionID)
}

// SetDeploymentID sets the "deployment_id" field.
func (m *OrderItemMutation) SetDeploymentID(i int) {
	m.deployment_id = &i
	m.adddeployment_id = nil
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *OrderItemMutation) DeploymentID() (r int, exists bool) {
	v := m.deployment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDeploymentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// AddDeploymentID adds i to the "deployment_id" field.
func (m *OrderItemMutation) AddDeploymentID(i int) {
	if m.adddeployment_id != nil {
		*m.adddeployment_id += i
	} else {
		m.adddeployment_id = &i
	}
}

// AddedDeploymentID returns the value that was added to the "deployment_id" field in this mutation.
func (m *OrderItemMutation) AddedDeploymentID() (r int, exists bool) {
	v := m.adddeployment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeploymentID clears the value of the "deployment_id" field.
func (m *OrderItemMutation) ClearDeploymentID() {
	m.deployment_id = nil
	m.adddeployment_id = nil
	m.clearedFields[orderitem.FieldDeploymentID] = struct{}{}
}

// DeploymentIDCleared returns if the "deployment_id" field was cleared in this mutation.
func (m *OrderItemMutation) DeploymentIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDeploymentID]
	return ok
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *OrderItemMutation) ResetDeploymentID() {
	m.deployment_id = nil
	m.adddeployment_id = nil
	delete(m.clearedFields, orderitem.FieldDeploymentID)
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *OrderItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *OrderItemMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[orderitem.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *OrderItemMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, orderitem.FieldQuantity)
}

// SetCancelQuantity sets the "cancel_quantity" field.
func (m *OrderItemMutation) SetCancelQuantity(f float64) {
	m.cancel_quantity = &f
	m.addcancel_quantity = nil
}

// CancelQuantity returns the value of the "cancel_quantity" field in the mutation.
func (m *OrderItemMutation) CancelQuantity() (r float64, exists bool) {
	v := m.cancel_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelQuantity returns the old "cancel_quantity" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCancelQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCancelQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCancelQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelQuantity: %w", err)
	}
	return oldValue.CancelQuantity, nil
}

// AddCancelQuantity adds f to the "cancel_quantity" field.
func (m *OrderItemMutation) AddCancelQuantity(f float64) {
	if m.addcancel_quantity != nil {
		*m.addcancel_quantity += f
	} else {
		m.addcancel_quantity = &f
	}
}

// AddedCancelQuantity returns the value that was added to the "cancel_quantity" field in this mutation.
func (m *OrderItemMutation) AddedCancelQuantity() (r float64, exists bool) {
	v := m.addcancel_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelQuantity clears the value of the "cancel_quantity" field.
func (m *OrderItemMutation) ClearCancelQuantity() {
	m.cancel_quantity = nil
	m.addcancel_quantity = nil
	m.clearedFields[orderitem.FieldCancelQuantity] = struct{}{}
}

// CancelQuantityCleared returns if the "cancel_quantity" field was cleared in this mutation.
func (m *OrderItemMutation) CancelQuantityCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCancelQuantity]
	return ok
}

// ResetCancelQuantity resets all changes to the "cancel_quantity" field.
func (m *OrderItemMutation) ResetCancelQuantity() {
	m.cancel_quantity = nil
	m.addcancel_quantity = nil
	delete(m.clearedFields, orderitem.FieldCancelQuantity)
}

// SetSelectedAmount sets the "selected_amount" field.
func (m *OrderItemMutation) SetSelectedAmount(f float64) {
	m.selected_amount = &f
	m.addselected_amount = nil
}

// SelectedAmount returns the value of the "selected_amount" field in the mutation.
func (m *OrderItemMutation) SelectedAmount() (r float64, exists bool) {
	v := m.selected_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedAmount returns the old "selected_amount" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSelectedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelectedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelectedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedAmount: %w", err)
	}
	return oldValue.SelectedAmount, nil
}

// AddSelectedAmount adds f to the "selected_amount" field.
func (m *OrderItemMutation) AddSelectedAmount(f float64) {
	if m.addselected_amount != nil {
		*m.addselected_amount += f
	} else {
		m.addselected_amount = &f
	}
}

// AddedSelectedAmount returns the value that was added to the "selected_amount" field in this mutation.
func (m *OrderItemMutation) AddedSelectedAmount() (r float64, exists bool) {
	v := m.addselected_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearSelectedAmount clears the value of the "selected_amount" field.
func (m *OrderItemMutation) ClearSelectedAmount() {
	m.selected_amount = nil
	m.addselected_amount = nil
	m.clearedFields[orderitem.FieldSelectedAmount] = struct{}{}
}

// SelectedAmountCleared returns if the "selected_amount" field was cleared in this mutation.
func (m *OrderItemMutation) SelectedAmountCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSelectedAmount]
	return ok
}

// ResetSelectedAmount resets all changes to the "selected_amount" field.
func (m *OrderItemMutation) ResetSelectedAmount() {
	m.selected_amount = nil
	m.addselected_amount = nil
	delete(m.clearedFields, orderitem.FieldSelectedAmount)
}

// SetUnitPrice sets the "unit_price" field.
func (m *OrderItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *OrderItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *OrderItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *OrderItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitPrice clears the value of the "unit_price" field.
func (m *OrderItemMutation) ClearUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
	m.clearedFields[orderitem.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "unit_price" field was cleared in this mutation.
func (m *OrderItemMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *OrderItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
	delete(m.clearedFields, orderitem.FieldUnitPrice)
}

// SetUnitListPrice sets the "unit_list_price" field.
func (m *OrderItemMutation) SetUnitListPrice(f float64) {
	m.unit_list_price = &f
	m.addunit_list_price = nil
}

// UnitListPrice returns the value of the "unit_list_price" field in the mutation.
func (m *OrderItemMutation) UnitListPrice() (r float64, exists bool) {
	v := m.unit_list_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitListPrice returns the old "unit_list_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUnitListPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnitListPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnitListPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitListPrice: %w", err)
	}
	return oldValue.UnitListPrice, nil
}

// AddUnitListPrice adds f to the "unit_list_price" field.
func (m *OrderItemMutation) AddUnitListPrice(f float64) {
	if m.addunit_list_price != nil {
		*m.addunit_list_price += f
	} else {
		m.addunit_list_price = &f
	}
}

// AddedUnitListPrice returns the value that was added to the "unit_list_price" field in this mutation.
func (m *OrderItemMutation) AddedUnitListPrice() (r float64, exists bool) {
	v := m.addunit_list_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitListPrice clears the value of the "unit_list_price" field.
func (m *OrderItemMutation) ClearUnitListPrice() {
	m.unit_list_price = nil
	m.addunit_list_price = nil
	m.clearedFields[orderitem.FieldUnitListPrice] = struct{}{}
}

// UnitListPriceCleared returns if the "unit_list_price" field was cleared in this mutation.
func (m *OrderItemMutation) UnitListPriceCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUnitListPrice]
	return ok
}

// ResetUnitListPrice resets all changes to the "unit_list_price" field.
func (m *OrderItemMutation) ResetUnitListPrice() {
	m.unit_list_price = nil
	m.addunit_list_price = nil
	delete(m.clearedFields, orderitem.FieldUnitListPrice)
}

// SetUnitAverageCost sets the "unit_average_cost" field.
func (m *OrderItemMutation) SetUnitAverageCost(f float64) {
	m.unit_average_cost = &f
	m.addunit_average_cost = nil
}

// UnitAverageCost returns the value of the "unit_average_cost" field in the mutation.
func (m *OrderItemMutation) UnitAverageCost() (r float64, exists bool) {
	v := m.unit_average_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitAverageCost returns the old "unit_average_cost" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUnitAverageCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnitAverageCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnitAverageCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitAverageCost: %w", err)
	}
	return oldValue.UnitAverageCost, nil
}

// AddUnitAverageCost adds f to the "unit_average_cost" field.
func (m *OrderItemMutation) AddUnitAverageCost(f float64) {
	if m.addunit_average_cost != nil {
		*m.addunit_average_cost += f
	} else {
		m.addunit_average_cost = &f
	}
}

// AddedUnitAverageCost returns the value that was added to the "unit_average_cost" field in this mutation.
func (m *OrderItemMutation) AddedUnitAverageCost() (r float64, exists bool) {
	v := m.addunit_average_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitAverageCost clears the value of the "unit_average_cost" field.
func (m *OrderItemMutation) ClearUnitAverageCost() {
	m.unit_average_cost = nil
	m.addunit_average_cost = nil
	m.clearedFields[orderitem.FieldUnitAverageCost] = struct{}{}
}

// UnitAverageCostCleared returns if the "unit_average_cost" field was cleared in this mutation.
func (m *OrderItemMutation) UnitAverageCostCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUnitAverageCost]
	return ok
}

// ResetUnitAverageCost resets all changes to the "unit_average_cost" field.
func (m *OrderItemMutation) ResetUnitAverageCost() {
	m.unit_average_cost = nil
	m.addunit_average_cost = nil
	delete(m.clearedFields, orderitem.FieldUnitAverageCost)
}

// SetUnitRecurringPrice sets the "unit_recurring_price" field.
func (m *OrderItemMutation) SetUnitRecurringPrice(f float64) {
	m.unit_recurring_price = &f
	m.addunit_recurring_price = nil
}

// UnitRecurringPrice returns the value of the "unit_recurring_price" field in the mutation.
func (m *OrderItemMutation) UnitRecurringPrice() (r float64, exists bool) {
	v := m.unit_recurring_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitRecurringPrice returns the old "unit_recurring_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldUnitRecurringPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnitRecurringPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnitRecurringPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitRecurringPrice: %w", err)
	}
	return oldValue.UnitRecurringPrice, nil
}

// AddUnitRecurringPrice adds f to the "unit_recurring_price" field.
func (m *OrderItemMutation) AddUnitRecurringPrice(f float64) {
	if m.addunit_recurring_price != nil {
		*m.addunit_recurring_price += f
	} else {
		m.addunit_recurring_price = &f
	}
}

// AddedUnitRecurringPrice returns the value that was added to the "unit_recurring_price" field in this mutation.
func (m *OrderItemMutation) AddedUnitRecurringPrice() (r float64, exists bool) {
	v := m.addunit_recurring_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitRecurringPrice clears the value of the "unit_recurring_price" field.
func (m *OrderItemMutation) ClearUnitRecurringPrice() {
	m.unit_recurring_price = nil
	m.addunit_recurring_price = nil
	m.clearedFields[orderitem.FieldUnitRecurringPrice] = struct{}{}
}

// UnitRecurringPriceCleared returns if the "unit_recurring_price" field was cleared in this mutation.
func (m *OrderItemMutation) UnitRecurringPriceCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldUnitRecurringPrice]
	return ok
}

// ResetUnitRecurringPrice resets all changes to the "unit_recurring_price" field.
func (m *OrderItemMutation) ResetUnitRecurringPrice() {
	m.unit_recurring_price = nil
	m.addunit_recurring_price = nil
	delete(m.clearedFields, orderitem.FieldUnitRecurringPrice)
}

// SetIsModifiedPrice sets the "is_modified_price" field.
func (m *OrderItemMutation) SetIsModifiedPrice(omp orderitem.IsModifiedPrice) {
	m.is_modified_price = &omp
}

// IsModifiedPrice returns the value of the "is_modified_price" field in the mutation.
func (m *OrderItemMutation) IsModifiedPrice() (r orderitem.IsModifiedPrice, exists bool) {
	v := m.is_modified_price
	if v == nil {
		return
	}
	return *v, true
}

// OldIsModifiedPrice returns the old "is_modified_price" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldIsModifiedPrice(ctx context.Context) (v orderitem.IsModifiedPrice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsModifiedPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsModifiedPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsModifiedPrice: %w", err)
	}
	return oldValue.IsModifiedPrice, nil
}

// ClearIsModifiedPrice clears the value of the "is_modified_price" field.
func (m *OrderItemMutation) ClearIsModifiedPrice() {
	m.is_modified_price = nil
	m.clearedFields[orderitem.FieldIsModifiedPrice] = struct{}{}
}

// IsModifiedPriceCleared returns if the "is_modified_price" field was cleared in this mutation.
func (m *OrderItemMutation) IsModifiedPriceCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldIsModifiedPrice]
	return ok
}

// ResetIsModifiedPrice resets all changes to the "is_modified_price" field.
func (m *OrderItemMutation) ResetIsModifiedPrice() {
	m.is_modified_price = nil
	delete(m.clearedFields, orderitem.FieldIsModifiedPrice)
}

// SetRecurringFreqUomID sets the "recurring_freq_uom_id" field.
func (m *OrderItemMutation) SetRecurringFreqUomID(i int) {
	m.recurring_freq_uom_id = &i
	m.addrecurring_freq_uom_id = nil
}

// RecurringFreqUomID returns the value of the "recurring_freq_uom_id" field in the mutation.
func (m *OrderItemMutation) RecurringFreqUomID() (r int, exists bool) {
	v := m.recurring_freq_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurringFreqUomID returns the old "recurring_freq_uom_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldRecurringFreqUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecurringFreqUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecurringFreqUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurringFreqUomID: %w", err)
	}
	return oldValue.RecurringFreqUomID, nil
}

// AddRecurringFreqUomID adds i to the "recurring_freq_uom_id" field.
func (m *OrderItemMutation) AddRecurringFreqUomID(i int) {
	if m.addrecurring_freq_uom_id != nil {
		*m.addrecurring_freq_uom_id += i
	} else {
		m.addrecurring_freq_uom_id = &i
	}
}

// AddedRecurringFreqUomID returns the value that was added to the "recurring_freq_uom_id" field in this mutation.
func (m *OrderItemMutation) AddedRecurringFreqUomID() (r int, exists bool) {
	v := m.addrecurring_freq_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecurringFreqUomID clears the value of the "recurring_freq_uom_id" field.
func (m *OrderItemMutation) ClearRecurringFreqUomID() {
	m.recurring_freq_uom_id = nil
	m.addrecurring_freq_uom_id = nil
	m.clearedFields[orderitem.FieldRecurringFreqUomID] = struct{}{}
}

// RecurringFreqUomIDCleared returns if the "recurring_freq_uom_id" field was cleared in this mutation.
func (m *OrderItemMutation) RecurringFreqUomIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldRecurringFreqUomID]
	return ok
}

// ResetRecurringFreqUomID resets all changes to the "recurring_freq_uom_id" field.
func (m *OrderItemMutation) ResetRecurringFreqUomID() {
	m.recurring_freq_uom_id = nil
	m.addrecurring_freq_uom_id = nil
	delete(m.clearedFields, orderitem.FieldRecurringFreqUomID)
}

// SetItemDescription sets the "item_description" field.
func (m *OrderItemMutation) SetItemDescription(s string) {
	m.item_description = &s
}

// ItemDescription returns the value of the "item_description" field in the mutation.
func (m *OrderItemMutation) ItemDescription() (r string, exists bool) {
	v := m.item_description
	if v == nil {
		return
	}
	return *v, true
}

// OldItemDescription returns the old "item_description" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldItemDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemDescription: %w", err)
	}
	return oldValue.ItemDescription, nil
}

// ClearItemDescription clears the value of the "item_description" field.
func (m *OrderItemMutation) ClearItemDescription() {
	m.item_description = nil
	m.clearedFields[orderitem.FieldItemDescription] = struct{}{}
}

// ItemDescriptionCleared returns if the "item_description" field was cleared in this mutation.
func (m *OrderItemMutation) ItemDescriptionCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldItemDescription]
	return ok
}

// ResetItemDescription resets all changes to the "item_description" field.
func (m *OrderItemMutation) ResetItemDescription() {
	m.item_description = nil
	delete(m.clearedFields, orderitem.FieldItemDescription)
}

// SetComments sets the "comments" field.
func (m *OrderItemMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *OrderItemMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *OrderItemMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[orderitem.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *OrderItemMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *OrderItemMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, orderitem.FieldComments)
}

// SetCorrespondingPoID sets the "corresponding_po_id" field.
func (m *OrderItemMutation) SetCorrespondingPoID(i int) {
	m.corresponding_po_id = &i
	m.addcorresponding_po_id = nil
}

// CorrespondingPoID returns the value of the "corresponding_po_id" field in the mutation.
func (m *OrderItemMutation) CorrespondingPoID() (r int, exists bool) {
	v := m.corresponding_po_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrespondingPoID returns the old "corresponding_po_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCorrespondingPoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCorrespondingPoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCorrespondingPoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrespondingPoID: %w", err)
	}
	return oldValue.CorrespondingPoID, nil
}

// AddCorrespondingPoID adds i to the "corresponding_po_id" field.
func (m *OrderItemMutation) AddCorrespondingPoID(i int) {
	if m.addcorresponding_po_id != nil {
		*m.addcorresponding_po_id += i
	} else {
		m.addcorresponding_po_id = &i
	}
}

// AddedCorrespondingPoID returns the value that was added to the "corresponding_po_id" field in this mutation.
func (m *OrderItemMutation) AddedCorrespondingPoID() (r int, exists bool) {
	v := m.addcorresponding_po_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCorrespondingPoID clears the value of the "corresponding_po_id" field.
func (m *OrderItemMutation) ClearCorrespondingPoID() {
	m.corresponding_po_id = nil
	m.addcorresponding_po_id = nil
	m.clearedFields[orderitem.FieldCorrespondingPoID] = struct{}{}
}

// CorrespondingPoIDCleared returns if the "corresponding_po_id" field was cleared in this mutation.
func (m *OrderItemMutation) CorrespondingPoIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCorrespondingPoID]
	return ok
}

// ResetCorrespondingPoID resets all changes to the "corresponding_po_id" field.
func (m *OrderItemMutation) ResetCorrespondingPoID() {
	m.corresponding_po_id = nil
	m.addcorresponding_po_id = nil
	delete(m.clearedFields, orderitem.FieldCorrespondingPoID)
}

// SetEstimatedShipDate sets the "estimated_ship_date" field.
func (m *OrderItemMutation) SetEstimatedShipDate(t time.Time) {
	m.estimated_ship_date = &t
}

// EstimatedShipDate returns the value of the "estimated_ship_date" field in the mutation.
func (m *OrderItemMutation) EstimatedShipDate() (r time.Time, exists bool) {
	v := m.estimated_ship_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedShipDate returns the old "estimated_ship_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldEstimatedShipDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedShipDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedShipDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedShipDate: %w", err)
	}
	return oldValue.EstimatedShipDate, nil
}

// ClearEstimatedShipDate clears the value of the "estimated_ship_date" field.
func (m *OrderItemMutation) ClearEstimatedShipDate() {
	m.estimated_ship_date = nil
	m.clearedFields[orderitem.FieldEstimatedShipDate] = struct{}{}
}

// EstimatedShipDateCleared returns if the "estimated_ship_date" field was cleared in this mutation.
func (m *OrderItemMutation) EstimatedShipDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldEstimatedShipDate]
	return ok
}

// ResetEstimatedShipDate resets all changes to the "estimated_ship_date" field.
func (m *OrderItemMutation) ResetEstimatedShipDate() {
	m.estimated_ship_date = nil
	delete(m.clearedFields, orderitem.FieldEstimatedShipDate)
}

// SetEstimatedDeliveryDate sets the "estimated_delivery_date" field.
func (m *OrderItemMutation) SetEstimatedDeliveryDate(t time.Time) {
	m.estimated_delivery_date = &t
}

// EstimatedDeliveryDate returns the value of the "estimated_delivery_date" field in the mutation.
func (m *OrderItemMutation) EstimatedDeliveryDate() (r time.Time, exists bool) {
	v := m.estimated_delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedDeliveryDate returns the old "estimated_delivery_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldEstimatedDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedDeliveryDate: %w", err)
	}
	return oldValue.EstimatedDeliveryDate, nil
}

// ClearEstimatedDeliveryDate clears the value of the "estimated_delivery_date" field.
func (m *OrderItemMutation) ClearEstimatedDeliveryDate() {
	m.estimated_delivery_date = nil
	m.clearedFields[orderitem.FieldEstimatedDeliveryDate] = struct{}{}
}

// EstimatedDeliveryDateCleared returns if the "estimated_delivery_date" field was cleared in this mutation.
func (m *OrderItemMutation) EstimatedDeliveryDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldEstimatedDeliveryDate]
	return ok
}

// ResetEstimatedDeliveryDate resets all changes to the "estimated_delivery_date" field.
func (m *OrderItemMutation) ResetEstimatedDeliveryDate() {
	m.estimated_delivery_date = nil
	delete(m.clearedFields, orderitem.FieldEstimatedDeliveryDate)
}

// SetAutoCancelDate sets the "auto_cancel_date" field.
func (m *OrderItemMutation) SetAutoCancelDate(t time.Time) {
	m.auto_cancel_date = &t
}

// AutoCancelDate returns the value of the "auto_cancel_date" field in the mutation.
func (m *OrderItemMutation) AutoCancelDate() (r time.Time, exists bool) {
	v := m.auto_cancel_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoCancelDate returns the old "auto_cancel_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldAutoCancelDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoCancelDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoCancelDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoCancelDate: %w", err)
	}
	return oldValue.AutoCancelDate, nil
}

// ClearAutoCancelDate clears the value of the "auto_cancel_date" field.
func (m *OrderItemMutation) ClearAutoCancelDate() {
	m.auto_cancel_date = nil
	m.clearedFields[orderitem.FieldAutoCancelDate] = struct{}{}
}

// AutoCancelDateCleared returns if the "auto_cancel_date" field was cleared in this mutation.
func (m *OrderItemMutation) AutoCancelDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldAutoCancelDate]
	return ok
}

// ResetAutoCancelDate resets all changes to the "auto_cancel_date" field.
func (m *OrderItemMutation) ResetAutoCancelDate() {
	m.auto_cancel_date = nil
	delete(m.clearedFields, orderitem.FieldAutoCancelDate)
}

// SetDontCancelSetDate sets the "dont_cancel_set_date" field.
func (m *OrderItemMutation) SetDontCancelSetDate(t time.Time) {
	m.dont_cancel_set_date = &t
}

// DontCancelSetDate returns the value of the "dont_cancel_set_date" field in the mutation.
func (m *OrderItemMutation) DontCancelSetDate() (r time.Time, exists bool) {
	v := m.dont_cancel_set_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDontCancelSetDate returns the old "dont_cancel_set_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDontCancelSetDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDontCancelSetDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDontCancelSetDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDontCancelSetDate: %w", err)
	}
	return oldValue.DontCancelSetDate, nil
}

// ClearDontCancelSetDate clears the value of the "dont_cancel_set_date" field.
func (m *OrderItemMutation) ClearDontCancelSetDate() {
	m.dont_cancel_set_date = nil
	m.clearedFields[orderitem.FieldDontCancelSetDate] = struct{}{}
}

// DontCancelSetDateCleared returns if the "dont_cancel_set_date" field was cleared in this mutation.
func (m *OrderItemMutation) DontCancelSetDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDontCancelSetDate]
	return ok
}

// ResetDontCancelSetDate resets all changes to the "dont_cancel_set_date" field.
func (m *OrderItemMutation) ResetDontCancelSetDate() {
	m.dont_cancel_set_date = nil
	delete(m.clearedFields, orderitem.FieldDontCancelSetDate)
}

// SetDontCancelSetUserLogin sets the "dont_cancel_set_user_login" field.
func (m *OrderItemMutation) SetDontCancelSetUserLogin(s string) {
	m.dont_cancel_set_user_login = &s
}

// DontCancelSetUserLogin returns the value of the "dont_cancel_set_user_login" field in the mutation.
func (m *OrderItemMutation) DontCancelSetUserLogin() (r string, exists bool) {
	v := m.dont_cancel_set_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldDontCancelSetUserLogin returns the old "dont_cancel_set_user_login" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldDontCancelSetUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDontCancelSetUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDontCancelSetUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDontCancelSetUserLogin: %w", err)
	}
	return oldValue.DontCancelSetUserLogin, nil
}

// ClearDontCancelSetUserLogin clears the value of the "dont_cancel_set_user_login" field.
func (m *OrderItemMutation) ClearDontCancelSetUserLogin() {
	m.dont_cancel_set_user_login = nil
	m.clearedFields[orderitem.FieldDontCancelSetUserLogin] = struct{}{}
}

// DontCancelSetUserLoginCleared returns if the "dont_cancel_set_user_login" field was cleared in this mutation.
func (m *OrderItemMutation) DontCancelSetUserLoginCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldDontCancelSetUserLogin]
	return ok
}

// ResetDontCancelSetUserLogin resets all changes to the "dont_cancel_set_user_login" field.
func (m *OrderItemMutation) ResetDontCancelSetUserLogin() {
	m.dont_cancel_set_user_login = nil
	delete(m.clearedFields, orderitem.FieldDontCancelSetUserLogin)
}

// SetShipBeforeDate sets the "ship_before_date" field.
func (m *OrderItemMutation) SetShipBeforeDate(t time.Time) {
	m.ship_before_date = &t
}

// ShipBeforeDate returns the value of the "ship_before_date" field in the mutation.
func (m *OrderItemMutation) ShipBeforeDate() (r time.Time, exists bool) {
	v := m.ship_before_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipBeforeDate returns the old "ship_before_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldShipBeforeDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipBeforeDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipBeforeDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipBeforeDate: %w", err)
	}
	return oldValue.ShipBeforeDate, nil
}

// ClearShipBeforeDate clears the value of the "ship_before_date" field.
func (m *OrderItemMutation) ClearShipBeforeDate() {
	m.ship_before_date = nil
	m.clearedFields[orderitem.FieldShipBeforeDate] = struct{}{}
}

// ShipBeforeDateCleared returns if the "ship_before_date" field was cleared in this mutation.
func (m *OrderItemMutation) ShipBeforeDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldShipBeforeDate]
	return ok
}

// ResetShipBeforeDate resets all changes to the "ship_before_date" field.
func (m *OrderItemMutation) ResetShipBeforeDate() {
	m.ship_before_date = nil
	delete(m.clearedFields, orderitem.FieldShipBeforeDate)
}

// SetShipAfterDate sets the "ship_after_date" field.
func (m *OrderItemMutation) SetShipAfterDate(t time.Time) {
	m.ship_after_date = &t
}

// ShipAfterDate returns the value of the "ship_after_date" field in the mutation.
func (m *OrderItemMutation) ShipAfterDate() (r time.Time, exists bool) {
	v := m.ship_after_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipAfterDate returns the old "ship_after_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldShipAfterDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipAfterDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipAfterDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipAfterDate: %w", err)
	}
	return oldValue.ShipAfterDate, nil
}

// ClearShipAfterDate clears the value of the "ship_after_date" field.
func (m *OrderItemMutation) ClearShipAfterDate() {
	m.ship_after_date = nil
	m.clearedFields[orderitem.FieldShipAfterDate] = struct{}{}
}

// ShipAfterDateCleared returns if the "ship_after_date" field was cleared in this mutation.
func (m *OrderItemMutation) ShipAfterDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldShipAfterDate]
	return ok
}

// ResetShipAfterDate resets all changes to the "ship_after_date" field.
func (m *OrderItemMutation) ResetShipAfterDate() {
	m.ship_after_date = nil
	delete(m.clearedFields, orderitem.FieldShipAfterDate)
}

// SetReserveAfterDate sets the "reserve_after_date" field.
func (m *OrderItemMutation) SetReserveAfterDate(t time.Time) {
	m.reserve_after_date = &t
}

// ReserveAfterDate returns the value of the "reserve_after_date" field in the mutation.
func (m *OrderItemMutation) ReserveAfterDate() (r time.Time, exists bool) {
	v := m.reserve_after_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReserveAfterDate returns the old "reserve_after_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldReserveAfterDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReserveAfterDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReserveAfterDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserveAfterDate: %w", err)
	}
	return oldValue.ReserveAfterDate, nil
}

// ClearReserveAfterDate clears the value of the "reserve_after_date" field.
func (m *OrderItemMutation) ClearReserveAfterDate() {
	m.reserve_after_date = nil
	m.clearedFields[orderitem.FieldReserveAfterDate] = struct{}{}
}

// ReserveAfterDateCleared returns if the "reserve_after_date" field was cleared in this mutation.
func (m *OrderItemMutation) ReserveAfterDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldReserveAfterDate]
	return ok
}

// ResetReserveAfterDate resets all changes to the "reserve_after_date" field.
func (m *OrderItemMutation) ResetReserveAfterDate() {
	m.reserve_after_date = nil
	delete(m.clearedFields, orderitem.FieldReserveAfterDate)
}

// SetCancelBackOrderDate sets the "cancel_back_order_date" field.
func (m *OrderItemMutation) SetCancelBackOrderDate(t time.Time) {
	m.cancel_back_order_date = &t
}

// CancelBackOrderDate returns the value of the "cancel_back_order_date" field in the mutation.
func (m *OrderItemMutation) CancelBackOrderDate() (r time.Time, exists bool) {
	v := m.cancel_back_order_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelBackOrderDate returns the old "cancel_back_order_date" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldCancelBackOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCancelBackOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCancelBackOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelBackOrderDate: %w", err)
	}
	return oldValue.CancelBackOrderDate, nil
}

// ClearCancelBackOrderDate clears the value of the "cancel_back_order_date" field.
func (m *OrderItemMutation) ClearCancelBackOrderDate() {
	m.cancel_back_order_date = nil
	m.clearedFields[orderitem.FieldCancelBackOrderDate] = struct{}{}
}

// CancelBackOrderDateCleared returns if the "cancel_back_order_date" field was cleared in this mutation.
func (m *OrderItemMutation) CancelBackOrderDateCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldCancelBackOrderDate]
	return ok
}

// ResetCancelBackOrderDate resets all changes to the "cancel_back_order_date" field.
func (m *OrderItemMutation) ResetCancelBackOrderDate() {
	m.cancel_back_order_date = nil
	delete(m.clearedFields, orderitem.FieldCancelBackOrderDate)
}

// SetOverrideGlAccountID sets the "override_gl_account_id" field.
func (m *OrderItemMutation) SetOverrideGlAccountID(i int) {
	m.override_gl_account_id = &i
	m.addoverride_gl_account_id = nil
}

// OverrideGlAccountID returns the value of the "override_gl_account_id" field in the mutation.
func (m *OrderItemMutation) OverrideGlAccountID() (r int, exists bool) {
	v := m.override_gl_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideGlAccountID returns the old "override_gl_account_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldOverrideGlAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOverrideGlAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOverrideGlAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideGlAccountID: %w", err)
	}
	return oldValue.OverrideGlAccountID, nil
}

// AddOverrideGlAccountID adds i to the "override_gl_account_id" field.
func (m *OrderItemMutation) AddOverrideGlAccountID(i int) {
	if m.addoverride_gl_account_id != nil {
		*m.addoverride_gl_account_id += i
	} else {
		m.addoverride_gl_account_id = &i
	}
}

// AddedOverrideGlAccountID returns the value that was added to the "override_gl_account_id" field in this mutation.
func (m *OrderItemMutation) AddedOverrideGlAccountID() (r int, exists bool) {
	v := m.addoverride_gl_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOverrideGlAccountID clears the value of the "override_gl_account_id" field.
func (m *OrderItemMutation) ClearOverrideGlAccountID() {
	m.override_gl_account_id = nil
	m.addoverride_gl_account_id = nil
	m.clearedFields[orderitem.FieldOverrideGlAccountID] = struct{}{}
}

// OverrideGlAccountIDCleared returns if the "override_gl_account_id" field was cleared in this mutation.
func (m *OrderItemMutation) OverrideGlAccountIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldOverrideGlAccountID]
	return ok
}

// ResetOverrideGlAccountID resets all changes to the "override_gl_account_id" field.
func (m *OrderItemMutation) ResetOverrideGlAccountID() {
	m.override_gl_account_id = nil
	m.addoverride_gl_account_id = nil
	delete(m.clearedFields, orderitem.FieldOverrideGlAccountID)
}

// SetSalesOpportunityID sets the "sales_opportunity_id" field.
func (m *OrderItemMutation) SetSalesOpportunityID(i int) {
	m.sales_opportunity_id = &i
	m.addsales_opportunity_id = nil
}

// SalesOpportunityID returns the value of the "sales_opportunity_id" field in the mutation.
func (m *OrderItemMutation) SalesOpportunityID() (r int, exists bool) {
	v := m.sales_opportunity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesOpportunityID returns the old "sales_opportunity_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldSalesOpportunityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalesOpportunityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalesOpportunityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesOpportunityID: %w", err)
	}
	return oldValue.SalesOpportunityID, nil
}

// AddSalesOpportunityID adds i to the "sales_opportunity_id" field.
func (m *OrderItemMutation) AddSalesOpportunityID(i int) {
	if m.addsales_opportunity_id != nil {
		*m.addsales_opportunity_id += i
	} else {
		m.addsales_opportunity_id = &i
	}
}

// AddedSalesOpportunityID returns the value that was added to the "sales_opportunity_id" field in this mutation.
func (m *OrderItemMutation) AddedSalesOpportunityID() (r int, exists bool) {
	v := m.addsales_opportunity_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesOpportunityID clears the value of the "sales_opportunity_id" field.
func (m *OrderItemMutation) ClearSalesOpportunityID() {
	m.sales_opportunity_id = nil
	m.addsales_opportunity_id = nil
	m.clearedFields[orderitem.FieldSalesOpportunityID] = struct{}{}
}

// SalesOpportunityIDCleared returns if the "sales_opportunity_id" field was cleared in this mutation.
func (m *OrderItemMutation) SalesOpportunityIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldSalesOpportunityID]
	return ok
}

// ResetSalesOpportunityID resets all changes to the "sales_opportunity_id" field.
func (m *OrderItemMutation) ResetSalesOpportunityID() {
	m.sales_opportunity_id = nil
	m.addsales_opportunity_id = nil
	delete(m.clearedFields, orderitem.FieldSalesOpportunityID)
}

// SetChangeByUserLoginID sets the "change_by_user_login_id" field.
func (m *OrderItemMutation) SetChangeByUserLoginID(s string) {
	m.change_by_user_login_id = &s
}

// ChangeByUserLoginID returns the value of the "change_by_user_login_id" field in the mutation.
func (m *OrderItemMutation) ChangeByUserLoginID() (r string, exists bool) {
	v := m.change_by_user_login_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeByUserLoginID returns the old "change_by_user_login_id" field's value of the OrderItem entity.
// If the OrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemMutation) OldChangeByUserLoginID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChangeByUserLoginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChangeByUserLoginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeByUserLoginID: %w", err)
	}
	return oldValue.ChangeByUserLoginID, nil
}

// ClearChangeByUserLoginID clears the value of the "change_by_user_login_id" field.
func (m *OrderItemMutation) ClearChangeByUserLoginID() {
	m.change_by_user_login_id = nil
	m.clearedFields[orderitem.FieldChangeByUserLoginID] = struct{}{}
}

// ChangeByUserLoginIDCleared returns if the "change_by_user_login_id" field was cleared in this mutation.
func (m *OrderItemMutation) ChangeByUserLoginIDCleared() bool {
	_, ok := m.clearedFields[orderitem.FieldChangeByUserLoginID]
	return ok
}

// ResetChangeByUserLoginID resets all changes to the "change_by_user_login_id" field.
func (m *OrderItemMutation) ResetChangeByUserLoginID() {
	m.change_by_user_login_id = nil
	delete(m.clearedFields, orderitem.FieldChangeByUserLoginID)
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderItemMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderItemMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderItemMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderItemMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderItemMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *OrderItemMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *OrderItemMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *OrderItemMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *OrderItemMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *OrderItemMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetStatusItemID sets the "status_item" edge to the StatusItem entity by id.
func (m *OrderItemMutation) SetStatusItemID(id int) {
	m.status_item = &id
}

// ClearStatusItem clears the "status_item" edge to the StatusItem entity.
func (m *OrderItemMutation) ClearStatusItem() {
	m.clearedstatus_item = true
}

// StatusItemCleared reports if the "status_item" edge to the StatusItem entity was cleared.
func (m *OrderItemMutation) StatusItemCleared() bool {
	return m.clearedstatus_item
}

// StatusItemID returns the "status_item" edge ID in the mutation.
func (m *OrderItemMutation) StatusItemID() (id int, exists bool) {
	if m.status_item != nil {
		return *m.status_item, true
	}
	return
}

// StatusItemIDs returns the "status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) StatusItemIDs() (ids []int) {
	if id := m.status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusItem resets all changes to the "status_item" edge.
func (m *OrderItemMutation) ResetStatusItem() {
	m.status_item = nil
	m.clearedstatus_item = false
}

// AddStatusValidChangeIDs adds the "status_valid_changes" edge to the StatusValidChange entity by ids.
func (m *OrderItemMutation) AddStatusValidChangeIDs(ids ...int) {
	if m.status_valid_changes == nil {
		m.status_valid_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.status_valid_changes[ids[i]] = struct{}{}
	}
}

// ClearStatusValidChanges clears the "status_valid_changes" edge to the StatusValidChange entity.
func (m *OrderItemMutation) ClearStatusValidChanges() {
	m.clearedstatus_valid_changes = true
}

// StatusValidChangesCleared reports if the "status_valid_changes" edge to the StatusValidChange entity was cleared.
func (m *OrderItemMutation) StatusValidChangesCleared() bool {
	return m.clearedstatus_valid_changes
}

// RemoveStatusValidChangeIDs removes the "status_valid_changes" edge to the StatusValidChange entity by IDs.
func (m *OrderItemMutation) RemoveStatusValidChangeIDs(ids ...int) {
	if m.removedstatus_valid_changes == nil {
		m.removedstatus_valid_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatus_valid_changes[ids[i]] = struct{}{}
	}
}

// RemovedStatusValidChanges returns the removed IDs of the "status_valid_changes" edge to the StatusValidChange entity.
func (m *OrderItemMutation) RemovedStatusValidChangesIDs() (ids []int) {
	for id := range m.removedstatus_valid_changes {
		ids = append(ids, id)
	}
	return
}

// StatusValidChangesIDs returns the "status_valid_changes" edge IDs in the mutation.
func (m *OrderItemMutation) StatusValidChangesIDs() (ids []int) {
	for id := range m.status_valid_changes {
		ids = append(ids, id)
	}
	return
}

// ResetStatusValidChanges resets all changes to the "status_valid_changes" edge.
func (m *OrderItemMutation) ResetStatusValidChanges() {
	m.status_valid_changes = nil
	m.clearedstatus_valid_changes = false
	m.removedstatus_valid_changes = nil
}

// SetSyncStatusItemID sets the "sync_status_item" edge to the StatusItem entity by id.
func (m *OrderItemMutation) SetSyncStatusItemID(id int) {
	m.sync_status_item = &id
}

// ClearSyncStatusItem clears the "sync_status_item" edge to the StatusItem entity.
func (m *OrderItemMutation) ClearSyncStatusItem() {
	m.clearedsync_status_item = true
}

// SyncStatusItemCleared reports if the "sync_status_item" edge to the StatusItem entity was cleared.
func (m *OrderItemMutation) SyncStatusItemCleared() bool {
	return m.clearedsync_status_item
}

// SyncStatusItemID returns the "sync_status_item" edge ID in the mutation.
func (m *OrderItemMutation) SyncStatusItemID() (id int, exists bool) {
	if m.sync_status_item != nil {
		return *m.sync_status_item, true
	}
	return
}

// SyncStatusItemIDs returns the "sync_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SyncStatusItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemMutation) SyncStatusItemIDs() (ids []int) {
	if id := m.sync_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSyncStatusItem resets all changes to the "sync_status_item" edge.
func (m *OrderItemMutation) ResetSyncStatusItem() {
	m.sync_status_item = nil
	m.clearedsync_status_item = false
}

// AddOrderAdjustmentIDs adds the "order_adjustments" edge to the OrderAdjustment entity by ids.
func (m *OrderItemMutation) AddOrderAdjustmentIDs(ids ...int) {
	if m.order_adjustments == nil {
		m.order_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.order_adjustments[ids[i]] = struct{}{}
	}
}

// ClearOrderAdjustments clears the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderItemMutation) ClearOrderAdjustments() {
	m.clearedorder_adjustments = true
}

// OrderAdjustmentsCleared reports if the "order_adjustments" edge to the OrderAdjustment entity was cleared.
func (m *OrderItemMutation) OrderAdjustmentsCleared() bool {
	return m.clearedorder_adjustments
}

// RemoveOrderAdjustmentIDs removes the "order_adjustments" edge to the OrderAdjustment entity by IDs.
func (m *OrderItemMutation) RemoveOrderAdjustmentIDs(ids ...int) {
	if m.removedorder_adjustments == nil {
		m.removedorder_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_adjustments[ids[i]] = struct{}{}
	}
}

// RemovedOrderAdjustments returns the removed IDs of the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderItemMutation) RemovedOrderAdjustmentsIDs() (ids []int) {
	for id := range m.removedorder_adjustments {
		ids = append(ids, id)
	}
	return
}

// OrderAdjustmentsIDs returns the "order_adjustments" edge IDs in the mutation.
func (m *OrderItemMutation) OrderAdjustmentsIDs() (ids []int) {
	for id := range m.order_adjustments {
		ids = append(ids, id)
	}
	return
}

// ResetOrderAdjustments resets all changes to the "order_adjustments" edge.
func (m *OrderItemMutation) ResetOrderAdjustments() {
	m.order_adjustments = nil
	m.clearedorder_adjustments = false
	m.removedorder_adjustments = nil
}

// AddOrderItemShipGroupAssocIDs adds the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity by ids.
func (m *OrderItemMutation) AddOrderItemShipGroupAssocIDs(ids ...int) {
	if m.order_item_ship_group_assocs == nil {
		m.order_item_ship_group_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_group_assocs[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGroupAssocs clears the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderItemMutation) ClearOrderItemShipGroupAssocs() {
	m.clearedorder_item_ship_group_assocs = true
}

// OrderItemShipGroupAssocsCleared reports if the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity was cleared.
func (m *OrderItemMutation) OrderItemShipGroupAssocsCleared() bool {
	return m.clearedorder_item_ship_group_assocs
}

// RemoveOrderItemShipGroupAssocIDs removes the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity by IDs.
func (m *OrderItemMutation) RemoveOrderItemShipGroupAssocIDs(ids ...int) {
	if m.removedorder_item_ship_group_assocs == nil {
		m.removedorder_item_ship_group_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_group_assocs[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGroupAssocs returns the removed IDs of the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderItemMutation) RemovedOrderItemShipGroupAssocsIDs() (ids []int) {
	for id := range m.removedorder_item_ship_group_assocs {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGroupAssocsIDs returns the "order_item_ship_group_assocs" edge IDs in the mutation.
func (m *OrderItemMutation) OrderItemShipGroupAssocsIDs() (ids []int) {
	for id := range m.order_item_ship_group_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGroupAssocs resets all changes to the "order_item_ship_group_assocs" edge.
func (m *OrderItemMutation) ResetOrderItemShipGroupAssocs() {
	m.order_item_ship_group_assocs = nil
	m.clearedorder_item_ship_group_assocs = false
	m.removedorder_item_ship_group_assocs = nil
}

// AddOrderItemShipGrpInvReIDs adds the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by ids.
func (m *OrderItemMutation) AddOrderItemShipGrpInvReIDs(ids ...int) {
	if m.order_item_ship_grp_inv_res == nil {
		m.order_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGrpInvRes clears the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderItemMutation) ClearOrderItemShipGrpInvRes() {
	m.clearedorder_item_ship_grp_inv_res = true
}

// OrderItemShipGrpInvResCleared reports if the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity was cleared.
func (m *OrderItemMutation) OrderItemShipGrpInvResCleared() bool {
	return m.clearedorder_item_ship_grp_inv_res
}

// RemoveOrderItemShipGrpInvReIDs removes the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by IDs.
func (m *OrderItemMutation) RemoveOrderItemShipGrpInvReIDs(ids ...int) {
	if m.removedorder_item_ship_grp_inv_res == nil {
		m.removedorder_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGrpInvRes returns the removed IDs of the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderItemMutation) RemovedOrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.removedorder_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGrpInvResIDs returns the "order_item_ship_grp_inv_res" edge IDs in the mutation.
func (m *OrderItemMutation) OrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.order_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGrpInvRes resets all changes to the "order_item_ship_grp_inv_res" edge.
func (m *OrderItemMutation) ResetOrderItemShipGrpInvRes() {
	m.order_item_ship_grp_inv_res = nil
	m.clearedorder_item_ship_grp_inv_res = false
	m.removedorder_item_ship_grp_inv_res = nil
}

// AddOrderPaymentPreferenceIDs adds the "order_payment_preferences" edge to the OrderPaymentPreference entity by ids.
func (m *OrderItemMutation) AddOrderPaymentPreferenceIDs(ids ...int) {
	if m.order_payment_preferences == nil {
		m.order_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.order_payment_preferences[ids[i]] = struct{}{}
	}
}

// ClearOrderPaymentPreferences clears the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *OrderItemMutation) ClearOrderPaymentPreferences() {
	m.clearedorder_payment_preferences = true
}

// OrderPaymentPreferencesCleared reports if the "order_payment_preferences" edge to the OrderPaymentPreference entity was cleared.
func (m *OrderItemMutation) OrderPaymentPreferencesCleared() bool {
	return m.clearedorder_payment_preferences
}

// RemoveOrderPaymentPreferenceIDs removes the "order_payment_preferences" edge to the OrderPaymentPreference entity by IDs.
func (m *OrderItemMutation) RemoveOrderPaymentPreferenceIDs(ids ...int) {
	if m.removedorder_payment_preferences == nil {
		m.removedorder_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_payment_preferences[ids[i]] = struct{}{}
	}
}

// RemovedOrderPaymentPreferences returns the removed IDs of the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *OrderItemMutation) RemovedOrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.removedorder_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// OrderPaymentPreferencesIDs returns the "order_payment_preferences" edge IDs in the mutation.
func (m *OrderItemMutation) OrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.order_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// ResetOrderPaymentPreferences resets all changes to the "order_payment_preferences" edge.
func (m *OrderItemMutation) ResetOrderPaymentPreferences() {
	m.order_payment_preferences = nil
	m.clearedorder_payment_preferences = false
	m.removedorder_payment_preferences = nil
}

// AddOrderStatusIDs adds the "order_statuses" edge to the OrderStatus entity by ids.
func (m *OrderItemMutation) AddOrderStatusIDs(ids ...int) {
	if m.order_statuses == nil {
		m.order_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.order_statuses[ids[i]] = struct{}{}
	}
}

// ClearOrderStatuses clears the "order_statuses" edge to the OrderStatus entity.
func (m *OrderItemMutation) ClearOrderStatuses() {
	m.clearedorder_statuses = true
}

// OrderStatusesCleared reports if the "order_statuses" edge to the OrderStatus entity was cleared.
func (m *OrderItemMutation) OrderStatusesCleared() bool {
	return m.clearedorder_statuses
}

// RemoveOrderStatusIDs removes the "order_statuses" edge to the OrderStatus entity by IDs.
func (m *OrderItemMutation) RemoveOrderStatusIDs(ids ...int) {
	if m.removedorder_statuses == nil {
		m.removedorder_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_statuses[ids[i]] = struct{}{}
	}
}

// RemovedOrderStatuses returns the removed IDs of the "order_statuses" edge to the OrderStatus entity.
func (m *OrderItemMutation) RemovedOrderStatusesIDs() (ids []int) {
	for id := range m.removedorder_statuses {
		ids = append(ids, id)
	}
	return
}

// OrderStatusesIDs returns the "order_statuses" edge IDs in the mutation.
func (m *OrderItemMutation) OrderStatusesIDs() (ids []int) {
	for id := range m.order_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetOrderStatuses resets all changes to the "order_statuses" edge.
func (m *OrderItemMutation) ResetOrderStatuses() {
	m.order_statuses = nil
	m.clearedorder_statuses = false
	m.removedorder_statuses = nil
}

// Op returns the operation name.
func (m *OrderItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItem).
func (m *OrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemMutation) Fields() []string {
	fields := make([]string, 0, 46)
	if m.create_time != nil {
		fields = append(fields, orderitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderitem.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderitem.FieldStringRef)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, orderitem.FieldOrderItemSeqID)
	}
	if m.external_id != nil {
		fields = append(fields, orderitem.FieldExternalID)
	}
	if m.order_item_type_id != nil {
		fields = append(fields, orderitem.FieldOrderItemTypeID)
	}
	if m.order_item_group_seq_id != nil {
		fields = append(fields, orderitem.FieldOrderItemGroupSeqID)
	}
	if m.is_item_group_primary != nil {
		fields = append(fields, orderitem.FieldIsItemGroupPrimary)
	}
	if m.from_inventory_item_id != nil {
		fields = append(fields, orderitem.FieldFromInventoryItemID)
	}
	if m.budget_id != nil {
		fields = append(fields, orderitem.FieldBudgetID)
	}
	if m.budget_item_seq_id != nil {
		fields = append(fields, orderitem.FieldBudgetItemSeqID)
	}
	if m.supplier_product_id != nil {
		fields = append(fields, orderitem.FieldSupplierProductID)
	}
	if m.product_feature_id != nil {
		fields = append(fields, orderitem.FieldProductFeatureID)
	}
	if m.prod_catalog_id != nil {
		fields = append(fields, orderitem.FieldProdCatalogID)
	}
	if m.product_category_id != nil {
		fields = append(fields, orderitem.FieldProductCategoryID)
	}
	if m.is_promo != nil {
		fields = append(fields, orderitem.FieldIsPromo)
	}
	if m.quote_id != nil {
		fields = append(fields, orderitem.FieldQuoteID)
	}
	if m.quote_item_seq_id != nil {
		fields = append(fields, orderitem.FieldQuoteItemSeqID)
	}
	if m.shopping_list_id != nil {
		fields = append(fields, orderitem.FieldShoppingListID)
	}
	if m.shopping_list_item_seq_id != nil {
		fields = append(fields, orderitem.FieldShoppingListItemSeqID)
	}
	if m.subscription_id != nil {
		fields = append(fields, orderitem.FieldSubscriptionID)
	}
	if m.deployment_id != nil {
		fields = append(fields, orderitem.FieldDeploymentID)
	}
	if m.quantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.cancel_quantity != nil {
		fields = append(fields, orderitem.FieldCancelQuantity)
	}
	if m.selected_amount != nil {
		fields = append(fields, orderitem.FieldSelectedAmount)
	}
	if m.unit_price != nil {
		fields = append(fields, orderitem.FieldUnitPrice)
	}
	if m.unit_list_price != nil {
		fields = append(fields, orderitem.FieldUnitListPrice)
	}
	if m.unit_average_cost != nil {
		fields = append(fields, orderitem.FieldUnitAverageCost)
	}
	if m.unit_recurring_price != nil {
		fields = append(fields, orderitem.FieldUnitRecurringPrice)
	}
	if m.is_modified_price != nil {
		fields = append(fields, orderitem.FieldIsModifiedPrice)
	}
	if m.recurring_freq_uom_id != nil {
		fields = append(fields, orderitem.FieldRecurringFreqUomID)
	}
	if m.item_description != nil {
		fields = append(fields, orderitem.FieldItemDescription)
	}
	if m.comments != nil {
		fields = append(fields, orderitem.FieldComments)
	}
	if m.corresponding_po_id != nil {
		fields = append(fields, orderitem.FieldCorrespondingPoID)
	}
	if m.estimated_ship_date != nil {
		fields = append(fields, orderitem.FieldEstimatedShipDate)
	}
	if m.estimated_delivery_date != nil {
		fields = append(fields, orderitem.FieldEstimatedDeliveryDate)
	}
	if m.auto_cancel_date != nil {
		fields = append(fields, orderitem.FieldAutoCancelDate)
	}
	if m.dont_cancel_set_date != nil {
		fields = append(fields, orderitem.FieldDontCancelSetDate)
	}
	if m.dont_cancel_set_user_login != nil {
		fields = append(fields, orderitem.FieldDontCancelSetUserLogin)
	}
	if m.ship_before_date != nil {
		fields = append(fields, orderitem.FieldShipBeforeDate)
	}
	if m.ship_after_date != nil {
		fields = append(fields, orderitem.FieldShipAfterDate)
	}
	if m.reserve_after_date != nil {
		fields = append(fields, orderitem.FieldReserveAfterDate)
	}
	if m.cancel_back_order_date != nil {
		fields = append(fields, orderitem.FieldCancelBackOrderDate)
	}
	if m.override_gl_account_id != nil {
		fields = append(fields, orderitem.FieldOverrideGlAccountID)
	}
	if m.sales_opportunity_id != nil {
		fields = append(fields, orderitem.FieldSalesOpportunityID)
	}
	if m.change_by_user_login_id != nil {
		fields = append(fields, orderitem.FieldChangeByUserLoginID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldCreateTime:
		return m.CreateTime()
	case orderitem.FieldUpdateTime:
		return m.UpdateTime()
	case orderitem.FieldStringRef:
		return m.StringRef()
	case orderitem.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case orderitem.FieldExternalID:
		return m.ExternalID()
	case orderitem.FieldOrderItemTypeID:
		return m.OrderItemTypeID()
	case orderitem.FieldOrderItemGroupSeqID:
		return m.OrderItemGroupSeqID()
	case orderitem.FieldIsItemGroupPrimary:
		return m.IsItemGroupPrimary()
	case orderitem.FieldFromInventoryItemID:
		return m.FromInventoryItemID()
	case orderitem.FieldBudgetID:
		return m.BudgetID()
	case orderitem.FieldBudgetItemSeqID:
		return m.BudgetItemSeqID()
	case orderitem.FieldSupplierProductID:
		return m.SupplierProductID()
	case orderitem.FieldProductFeatureID:
		return m.ProductFeatureID()
	case orderitem.FieldProdCatalogID:
		return m.ProdCatalogID()
	case orderitem.FieldProductCategoryID:
		return m.ProductCategoryID()
	case orderitem.FieldIsPromo:
		return m.IsPromo()
	case orderitem.FieldQuoteID:
		return m.QuoteID()
	case orderitem.FieldQuoteItemSeqID:
		return m.QuoteItemSeqID()
	case orderitem.FieldShoppingListID:
		return m.ShoppingListID()
	case orderitem.FieldShoppingListItemSeqID:
		return m.ShoppingListItemSeqID()
	case orderitem.FieldSubscriptionID:
		return m.SubscriptionID()
	case orderitem.FieldDeploymentID:
		return m.DeploymentID()
	case orderitem.FieldQuantity:
		return m.Quantity()
	case orderitem.FieldCancelQuantity:
		return m.CancelQuantity()
	case orderitem.FieldSelectedAmount:
		return m.SelectedAmount()
	case orderitem.FieldUnitPrice:
		return m.UnitPrice()
	case orderitem.FieldUnitListPrice:
		return m.UnitListPrice()
	case orderitem.FieldUnitAverageCost:
		return m.UnitAverageCost()
	case orderitem.FieldUnitRecurringPrice:
		return m.UnitRecurringPrice()
	case orderitem.FieldIsModifiedPrice:
		return m.IsModifiedPrice()
	case orderitem.FieldRecurringFreqUomID:
		return m.RecurringFreqUomID()
	case orderitem.FieldItemDescription:
		return m.ItemDescription()
	case orderitem.FieldComments:
		return m.Comments()
	case orderitem.FieldCorrespondingPoID:
		return m.CorrespondingPoID()
	case orderitem.FieldEstimatedShipDate:
		return m.EstimatedShipDate()
	case orderitem.FieldEstimatedDeliveryDate:
		return m.EstimatedDeliveryDate()
	case orderitem.FieldAutoCancelDate:
		return m.AutoCancelDate()
	case orderitem.FieldDontCancelSetDate:
		return m.DontCancelSetDate()
	case orderitem.FieldDontCancelSetUserLogin:
		return m.DontCancelSetUserLogin()
	case orderitem.FieldShipBeforeDate:
		return m.ShipBeforeDate()
	case orderitem.FieldShipAfterDate:
		return m.ShipAfterDate()
	case orderitem.FieldReserveAfterDate:
		return m.ReserveAfterDate()
	case orderitem.FieldCancelBackOrderDate:
		return m.CancelBackOrderDate()
	case orderitem.FieldOverrideGlAccountID:
		return m.OverrideGlAccountID()
	case orderitem.FieldSalesOpportunityID:
		return m.SalesOpportunityID()
	case orderitem.FieldChangeByUserLoginID:
		return m.ChangeByUserLoginID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderitem.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderitem.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case orderitem.FieldExternalID:
		return m.OldExternalID(ctx)
	case orderitem.FieldOrderItemTypeID:
		return m.OldOrderItemTypeID(ctx)
	case orderitem.FieldOrderItemGroupSeqID:
		return m.OldOrderItemGroupSeqID(ctx)
	case orderitem.FieldIsItemGroupPrimary:
		return m.OldIsItemGroupPrimary(ctx)
	case orderitem.FieldFromInventoryItemID:
		return m.OldFromInventoryItemID(ctx)
	case orderitem.FieldBudgetID:
		return m.OldBudgetID(ctx)
	case orderitem.FieldBudgetItemSeqID:
		return m.OldBudgetItemSeqID(ctx)
	case orderitem.FieldSupplierProductID:
		return m.OldSupplierProductID(ctx)
	case orderitem.FieldProductFeatureID:
		return m.OldProductFeatureID(ctx)
	case orderitem.FieldProdCatalogID:
		return m.OldProdCatalogID(ctx)
	case orderitem.FieldProductCategoryID:
		return m.OldProductCategoryID(ctx)
	case orderitem.FieldIsPromo:
		return m.OldIsPromo(ctx)
	case orderitem.FieldQuoteID:
		return m.OldQuoteID(ctx)
	case orderitem.FieldQuoteItemSeqID:
		return m.OldQuoteItemSeqID(ctx)
	case orderitem.FieldShoppingListID:
		return m.OldShoppingListID(ctx)
	case orderitem.FieldShoppingListItemSeqID:
		return m.OldShoppingListItemSeqID(ctx)
	case orderitem.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case orderitem.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case orderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitem.FieldCancelQuantity:
		return m.OldCancelQuantity(ctx)
	case orderitem.FieldSelectedAmount:
		return m.OldSelectedAmount(ctx)
	case orderitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case orderitem.FieldUnitListPrice:
		return m.OldUnitListPrice(ctx)
	case orderitem.FieldUnitAverageCost:
		return m.OldUnitAverageCost(ctx)
	case orderitem.FieldUnitRecurringPrice:
		return m.OldUnitRecurringPrice(ctx)
	case orderitem.FieldIsModifiedPrice:
		return m.OldIsModifiedPrice(ctx)
	case orderitem.FieldRecurringFreqUomID:
		return m.OldRecurringFreqUomID(ctx)
	case orderitem.FieldItemDescription:
		return m.OldItemDescription(ctx)
	case orderitem.FieldComments:
		return m.OldComments(ctx)
	case orderitem.FieldCorrespondingPoID:
		return m.OldCorrespondingPoID(ctx)
	case orderitem.FieldEstimatedShipDate:
		return m.OldEstimatedShipDate(ctx)
	case orderitem.FieldEstimatedDeliveryDate:
		return m.OldEstimatedDeliveryDate(ctx)
	case orderitem.FieldAutoCancelDate:
		return m.OldAutoCancelDate(ctx)
	case orderitem.FieldDontCancelSetDate:
		return m.OldDontCancelSetDate(ctx)
	case orderitem.FieldDontCancelSetUserLogin:
		return m.OldDontCancelSetUserLogin(ctx)
	case orderitem.FieldShipBeforeDate:
		return m.OldShipBeforeDate(ctx)
	case orderitem.FieldShipAfterDate:
		return m.OldShipAfterDate(ctx)
	case orderitem.FieldReserveAfterDate:
		return m.OldReserveAfterDate(ctx)
	case orderitem.FieldCancelBackOrderDate:
		return m.OldCancelBackOrderDate(ctx)
	case orderitem.FieldOverrideGlAccountID:
		return m.OldOverrideGlAccountID(ctx)
	case orderitem.FieldSalesOpportunityID:
		return m.OldSalesOpportunityID(ctx)
	case orderitem.FieldChangeByUserLoginID:
		return m.OldChangeByUserLoginID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderitem.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderitem.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case orderitem.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case orderitem.FieldOrderItemTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemTypeID(v)
		return nil
	case orderitem.FieldOrderItemGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemGroupSeqID(v)
		return nil
	case orderitem.FieldIsItemGroupPrimary:
		v, ok := value.(orderitem.IsItemGroupPrimary)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsItemGroupPrimary(v)
		return nil
	case orderitem.FieldFromInventoryItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromInventoryItemID(v)
		return nil
	case orderitem.FieldBudgetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetID(v)
		return nil
	case orderitem.FieldBudgetItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudgetItemSeqID(v)
		return nil
	case orderitem.FieldSupplierProductID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierProductID(v)
		return nil
	case orderitem.FieldProductFeatureID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductFeatureID(v)
		return nil
	case orderitem.FieldProdCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProdCatalogID(v)
		return nil
	case orderitem.FieldProductCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCategoryID(v)
		return nil
	case orderitem.FieldIsPromo:
		v, ok := value.(orderitem.IsPromo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPromo(v)
		return nil
	case orderitem.FieldQuoteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuoteID(v)
		return nil
	case orderitem.FieldQuoteItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuoteItemSeqID(v)
		return nil
	case orderitem.FieldShoppingListID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShoppingListID(v)
		return nil
	case orderitem.FieldShoppingListItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShoppingListItemSeqID(v)
		return nil
	case orderitem.FieldSubscriptionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case orderitem.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitem.FieldCancelQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelQuantity(v)
		return nil
	case orderitem.FieldSelectedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedAmount(v)
		return nil
	case orderitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case orderitem.FieldUnitListPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitListPrice(v)
		return nil
	case orderitem.FieldUnitAverageCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitAverageCost(v)
		return nil
	case orderitem.FieldUnitRecurringPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitRecurringPrice(v)
		return nil
	case orderitem.FieldIsModifiedPrice:
		v, ok := value.(orderitem.IsModifiedPrice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsModifiedPrice(v)
		return nil
	case orderitem.FieldRecurringFreqUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurringFreqUomID(v)
		return nil
	case orderitem.FieldItemDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemDescription(v)
		return nil
	case orderitem.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case orderitem.FieldCorrespondingPoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrespondingPoID(v)
		return nil
	case orderitem.FieldEstimatedShipDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedShipDate(v)
		return nil
	case orderitem.FieldEstimatedDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedDeliveryDate(v)
		return nil
	case orderitem.FieldAutoCancelDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoCancelDate(v)
		return nil
	case orderitem.FieldDontCancelSetDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDontCancelSetDate(v)
		return nil
	case orderitem.FieldDontCancelSetUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDontCancelSetUserLogin(v)
		return nil
	case orderitem.FieldShipBeforeDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipBeforeDate(v)
		return nil
	case orderitem.FieldShipAfterDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipAfterDate(v)
		return nil
	case orderitem.FieldReserveAfterDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserveAfterDate(v)
		return nil
	case orderitem.FieldCancelBackOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelBackOrderDate(v)
		return nil
	case orderitem.FieldOverrideGlAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideGlAccountID(v)
		return nil
	case orderitem.FieldSalesOpportunityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesOpportunityID(v)
		return nil
	case orderitem.FieldChangeByUserLoginID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeByUserLoginID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addorder_item_seq_id != nil {
		fields = append(fields, orderitem.FieldOrderItemSeqID)
	}
	if m.addexternal_id != nil {
		fields = append(fields, orderitem.FieldExternalID)
	}
	if m.addorder_item_type_id != nil {
		fields = append(fields, orderitem.FieldOrderItemTypeID)
	}
	if m.addorder_item_group_seq_id != nil {
		fields = append(fields, orderitem.FieldOrderItemGroupSeqID)
	}
	if m.addfrom_inventory_item_id != nil {
		fields = append(fields, orderitem.FieldFromInventoryItemID)
	}
	if m.addbudget_id != nil {
		fields = append(fields, orderitem.FieldBudgetID)
	}
	if m.addbudget_item_seq_id != nil {
		fields = append(fields, orderitem.FieldBudgetItemSeqID)
	}
	if m.addproduct_feature_id != nil {
		fields = append(fields, orderitem.FieldProductFeatureID)
	}
	if m.addprod_catalog_id != nil {
		fields = append(fields, orderitem.FieldProdCatalogID)
	}
	if m.addproduct_category_id != nil {
		fields = append(fields, orderitem.FieldProductCategoryID)
	}
	if m.addquote_id != nil {
		fields = append(fields, orderitem.FieldQuoteID)
	}
	if m.addquote_item_seq_id != nil {
		fields = append(fields, orderitem.FieldQuoteItemSeqID)
	}
	if m.addshopping_list_id != nil {
		fields = append(fields, orderitem.FieldShoppingListID)
	}
	if m.addshopping_list_item_seq_id != nil {
		fields = append(fields, orderitem.FieldShoppingListItemSeqID)
	}
	if m.addsubscription_id != nil {
		fields = append(fields, orderitem.FieldSubscriptionID)
	}
	if m.adddeployment_id != nil {
		fields = append(fields, orderitem.FieldDeploymentID)
	}
	if m.addquantity != nil {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.addcancel_quantity != nil {
		fields = append(fields, orderitem.FieldCancelQuantity)
	}
	if m.addselected_amount != nil {
		fields = append(fields, orderitem.FieldSelectedAmount)
	}
	if m.addunit_price != nil {
		fields = append(fields, orderitem.FieldUnitPrice)
	}
	if m.addunit_list_price != nil {
		fields = append(fields, orderitem.FieldUnitListPrice)
	}
	if m.addunit_average_cost != nil {
		fields = append(fields, orderitem.FieldUnitAverageCost)
	}
	if m.addunit_recurring_price != nil {
		fields = append(fields, orderitem.FieldUnitRecurringPrice)
	}
	if m.addrecurring_freq_uom_id != nil {
		fields = append(fields, orderitem.FieldRecurringFreqUomID)
	}
	if m.addcorresponding_po_id != nil {
		fields = append(fields, orderitem.FieldCorrespondingPoID)
	}
	if m.addoverride_gl_account_id != nil {
		fields = append(fields, orderitem.FieldOverrideGlAccountID)
	}
	if m.addsales_opportunity_id != nil {
		fields = append(fields, orderitem.FieldSalesOpportunityID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitem.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	case orderitem.FieldExternalID:
		return m.AddedExternalID()
	case orderitem.FieldOrderItemTypeID:
		return m.AddedOrderItemTypeID()
	case orderitem.FieldOrderItemGroupSeqID:
		return m.AddedOrderItemGroupSeqID()
	case orderitem.FieldFromInventoryItemID:
		return m.AddedFromInventoryItemID()
	case orderitem.FieldBudgetID:
		return m.AddedBudgetID()
	case orderitem.FieldBudgetItemSeqID:
		return m.AddedBudgetItemSeqID()
	case orderitem.FieldProductFeatureID:
		return m.AddedProductFeatureID()
	case orderitem.FieldProdCatalogID:
		return m.AddedProdCatalogID()
	case orderitem.FieldProductCategoryID:
		return m.AddedProductCategoryID()
	case orderitem.FieldQuoteID:
		return m.AddedQuoteID()
	case orderitem.FieldQuoteItemSeqID:
		return m.AddedQuoteItemSeqID()
	case orderitem.FieldShoppingListID:
		return m.AddedShoppingListID()
	case orderitem.FieldShoppingListItemSeqID:
		return m.AddedShoppingListItemSeqID()
	case orderitem.FieldSubscriptionID:
		return m.AddedSubscriptionID()
	case orderitem.FieldDeploymentID:
		return m.AddedDeploymentID()
	case orderitem.FieldQuantity:
		return m.AddedQuantity()
	case orderitem.FieldCancelQuantity:
		return m.AddedCancelQuantity()
	case orderitem.FieldSelectedAmount:
		return m.AddedSelectedAmount()
	case orderitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case orderitem.FieldUnitListPrice:
		return m.AddedUnitListPrice()
	case orderitem.FieldUnitAverageCost:
		return m.AddedUnitAverageCost()
	case orderitem.FieldUnitRecurringPrice:
		return m.AddedUnitRecurringPrice()
	case orderitem.FieldRecurringFreqUomID:
		return m.AddedRecurringFreqUomID()
	case orderitem.FieldCorrespondingPoID:
		return m.AddedCorrespondingPoID()
	case orderitem.FieldOverrideGlAccountID:
		return m.AddedOverrideGlAccountID()
	case orderitem.FieldSalesOpportunityID:
		return m.AddedSalesOpportunityID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitem.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	case orderitem.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExternalID(v)
		return nil
	case orderitem.FieldOrderItemTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemTypeID(v)
		return nil
	case orderitem.FieldOrderItemGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemGroupSeqID(v)
		return nil
	case orderitem.FieldFromInventoryItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromInventoryItemID(v)
		return nil
	case orderitem.FieldBudgetID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetID(v)
		return nil
	case orderitem.FieldBudgetItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudgetItemSeqID(v)
		return nil
	case orderitem.FieldProductFeatureID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductFeatureID(v)
		return nil
	case orderitem.FieldProdCatalogID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProdCatalogID(v)
		return nil
	case orderitem.FieldProductCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductCategoryID(v)
		return nil
	case orderitem.FieldQuoteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuoteID(v)
		return nil
	case orderitem.FieldQuoteItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuoteItemSeqID(v)
		return nil
	case orderitem.FieldShoppingListID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShoppingListID(v)
		return nil
	case orderitem.FieldShoppingListItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShoppingListItemSeqID(v)
		return nil
	case orderitem.FieldSubscriptionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubscriptionID(v)
		return nil
	case orderitem.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeploymentID(v)
		return nil
	case orderitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderitem.FieldCancelQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelQuantity(v)
		return nil
	case orderitem.FieldSelectedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSelectedAmount(v)
		return nil
	case orderitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case orderitem.FieldUnitListPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitListPrice(v)
		return nil
	case orderitem.FieldUnitAverageCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitAverageCost(v)
		return nil
	case orderitem.FieldUnitRecurringPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitRecurringPrice(v)
		return nil
	case orderitem.FieldRecurringFreqUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecurringFreqUomID(v)
		return nil
	case orderitem.FieldCorrespondingPoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCorrespondingPoID(v)
		return nil
	case orderitem.FieldOverrideGlAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverrideGlAccountID(v)
		return nil
	case orderitem.FieldSalesOpportunityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesOpportunityID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitem.FieldStringRef) {
		fields = append(fields, orderitem.FieldStringRef)
	}
	if m.FieldCleared(orderitem.FieldExternalID) {
		fields = append(fields, orderitem.FieldExternalID)
	}
	if m.FieldCleared(orderitem.FieldOrderItemTypeID) {
		fields = append(fields, orderitem.FieldOrderItemTypeID)
	}
	if m.FieldCleared(orderitem.FieldOrderItemGroupSeqID) {
		fields = append(fields, orderitem.FieldOrderItemGroupSeqID)
	}
	if m.FieldCleared(orderitem.FieldIsItemGroupPrimary) {
		fields = append(fields, orderitem.FieldIsItemGroupPrimary)
	}
	if m.FieldCleared(orderitem.FieldFromInventoryItemID) {
		fields = append(fields, orderitem.FieldFromInventoryItemID)
	}
	if m.FieldCleared(orderitem.FieldBudgetID) {
		fields = append(fields, orderitem.FieldBudgetID)
	}
	if m.FieldCleared(orderitem.FieldBudgetItemSeqID) {
		fields = append(fields, orderitem.FieldBudgetItemSeqID)
	}
	if m.FieldCleared(orderitem.FieldSupplierProductID) {
		fields = append(fields, orderitem.FieldSupplierProductID)
	}
	if m.FieldCleared(orderitem.FieldProductFeatureID) {
		fields = append(fields, orderitem.FieldProductFeatureID)
	}
	if m.FieldCleared(orderitem.FieldProdCatalogID) {
		fields = append(fields, orderitem.FieldProdCatalogID)
	}
	if m.FieldCleared(orderitem.FieldProductCategoryID) {
		fields = append(fields, orderitem.FieldProductCategoryID)
	}
	if m.FieldCleared(orderitem.FieldIsPromo) {
		fields = append(fields, orderitem.FieldIsPromo)
	}
	if m.FieldCleared(orderitem.FieldQuoteID) {
		fields = append(fields, orderitem.FieldQuoteID)
	}
	if m.FieldCleared(orderitem.FieldQuoteItemSeqID) {
		fields = append(fields, orderitem.FieldQuoteItemSeqID)
	}
	if m.FieldCleared(orderitem.FieldShoppingListID) {
		fields = append(fields, orderitem.FieldShoppingListID)
	}
	if m.FieldCleared(orderitem.FieldShoppingListItemSeqID) {
		fields = append(fields, orderitem.FieldShoppingListItemSeqID)
	}
	if m.FieldCleared(orderitem.FieldSubscriptionID) {
		fields = append(fields, orderitem.FieldSubscriptionID)
	}
	if m.FieldCleared(orderitem.FieldDeploymentID) {
		fields = append(fields, orderitem.FieldDeploymentID)
	}
	if m.FieldCleared(orderitem.FieldQuantity) {
		fields = append(fields, orderitem.FieldQuantity)
	}
	if m.FieldCleared(orderitem.FieldCancelQuantity) {
		fields = append(fields, orderitem.FieldCancelQuantity)
	}
	if m.FieldCleared(orderitem.FieldSelectedAmount) {
		fields = append(fields, orderitem.FieldSelectedAmount)
	}
	if m.FieldCleared(orderitem.FieldUnitPrice) {
		fields = append(fields, orderitem.FieldUnitPrice)
	}
	if m.FieldCleared(orderitem.FieldUnitListPrice) {
		fields = append(fields, orderitem.FieldUnitListPrice)
	}
	if m.FieldCleared(orderitem.FieldUnitAverageCost) {
		fields = append(fields, orderitem.FieldUnitAverageCost)
	}
	if m.FieldCleared(orderitem.FieldUnitRecurringPrice) {
		fields = append(fields, orderitem.FieldUnitRecurringPrice)
	}
	if m.FieldCleared(orderitem.FieldIsModifiedPrice) {
		fields = append(fields, orderitem.FieldIsModifiedPrice)
	}
	if m.FieldCleared(orderitem.FieldRecurringFreqUomID) {
		fields = append(fields, orderitem.FieldRecurringFreqUomID)
	}
	if m.FieldCleared(orderitem.FieldItemDescription) {
		fields = append(fields, orderitem.FieldItemDescription)
	}
	if m.FieldCleared(orderitem.FieldComments) {
		fields = append(fields, orderitem.FieldComments)
	}
	if m.FieldCleared(orderitem.FieldCorrespondingPoID) {
		fields = append(fields, orderitem.FieldCorrespondingPoID)
	}
	if m.FieldCleared(orderitem.FieldEstimatedShipDate) {
		fields = append(fields, orderitem.FieldEstimatedShipDate)
	}
	if m.FieldCleared(orderitem.FieldEstimatedDeliveryDate) {
		fields = append(fields, orderitem.FieldEstimatedDeliveryDate)
	}
	if m.FieldCleared(orderitem.FieldAutoCancelDate) {
		fields = append(fields, orderitem.FieldAutoCancelDate)
	}
	if m.FieldCleared(orderitem.FieldDontCancelSetDate) {
		fields = append(fields, orderitem.FieldDontCancelSetDate)
	}
	if m.FieldCleared(orderitem.FieldDontCancelSetUserLogin) {
		fields = append(fields, orderitem.FieldDontCancelSetUserLogin)
	}
	if m.FieldCleared(orderitem.FieldShipBeforeDate) {
		fields = append(fields, orderitem.FieldShipBeforeDate)
	}
	if m.FieldCleared(orderitem.FieldShipAfterDate) {
		fields = append(fields, orderitem.FieldShipAfterDate)
	}
	if m.FieldCleared(orderitem.FieldReserveAfterDate) {
		fields = append(fields, orderitem.FieldReserveAfterDate)
	}
	if m.FieldCleared(orderitem.FieldCancelBackOrderDate) {
		fields = append(fields, orderitem.FieldCancelBackOrderDate)
	}
	if m.FieldCleared(orderitem.FieldOverrideGlAccountID) {
		fields = append(fields, orderitem.FieldOverrideGlAccountID)
	}
	if m.FieldCleared(orderitem.FieldSalesOpportunityID) {
		fields = append(fields, orderitem.FieldSalesOpportunityID)
	}
	if m.FieldCleared(orderitem.FieldChangeByUserLoginID) {
		fields = append(fields, orderitem.FieldChangeByUserLoginID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemMutation) ClearField(name string) error {
	switch name {
	case orderitem.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderitem.FieldExternalID:
		m.ClearExternalID()
		return nil
	case orderitem.FieldOrderItemTypeID:
		m.ClearOrderItemTypeID()
		return nil
	case orderitem.FieldOrderItemGroupSeqID:
		m.ClearOrderItemGroupSeqID()
		return nil
	case orderitem.FieldIsItemGroupPrimary:
		m.ClearIsItemGroupPrimary()
		return nil
	case orderitem.FieldFromInventoryItemID:
		m.ClearFromInventoryItemID()
		return nil
	case orderitem.FieldBudgetID:
		m.ClearBudgetID()
		return nil
	case orderitem.FieldBudgetItemSeqID:
		m.ClearBudgetItemSeqID()
		return nil
	case orderitem.FieldSupplierProductID:
		m.ClearSupplierProductID()
		return nil
	case orderitem.FieldProductFeatureID:
		m.ClearProductFeatureID()
		return nil
	case orderitem.FieldProdCatalogID:
		m.ClearProdCatalogID()
		return nil
	case orderitem.FieldProductCategoryID:
		m.ClearProductCategoryID()
		return nil
	case orderitem.FieldIsPromo:
		m.ClearIsPromo()
		return nil
	case orderitem.FieldQuoteID:
		m.ClearQuoteID()
		return nil
	case orderitem.FieldQuoteItemSeqID:
		m.ClearQuoteItemSeqID()
		return nil
	case orderitem.FieldShoppingListID:
		m.ClearShoppingListID()
		return nil
	case orderitem.FieldShoppingListItemSeqID:
		m.ClearShoppingListItemSeqID()
		return nil
	case orderitem.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case orderitem.FieldDeploymentID:
		m.ClearDeploymentID()
		return nil
	case orderitem.FieldQuantity:
		m.ClearQuantity()
		return nil
	case orderitem.FieldCancelQuantity:
		m.ClearCancelQuantity()
		return nil
	case orderitem.FieldSelectedAmount:
		m.ClearSelectedAmount()
		return nil
	case orderitem.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	case orderitem.FieldUnitListPrice:
		m.ClearUnitListPrice()
		return nil
	case orderitem.FieldUnitAverageCost:
		m.ClearUnitAverageCost()
		return nil
	case orderitem.FieldUnitRecurringPrice:
		m.ClearUnitRecurringPrice()
		return nil
	case orderitem.FieldIsModifiedPrice:
		m.ClearIsModifiedPrice()
		return nil
	case orderitem.FieldRecurringFreqUomID:
		m.ClearRecurringFreqUomID()
		return nil
	case orderitem.FieldItemDescription:
		m.ClearItemDescription()
		return nil
	case orderitem.FieldComments:
		m.ClearComments()
		return nil
	case orderitem.FieldCorrespondingPoID:
		m.ClearCorrespondingPoID()
		return nil
	case orderitem.FieldEstimatedShipDate:
		m.ClearEstimatedShipDate()
		return nil
	case orderitem.FieldEstimatedDeliveryDate:
		m.ClearEstimatedDeliveryDate()
		return nil
	case orderitem.FieldAutoCancelDate:
		m.ClearAutoCancelDate()
		return nil
	case orderitem.FieldDontCancelSetDate:
		m.ClearDontCancelSetDate()
		return nil
	case orderitem.FieldDontCancelSetUserLogin:
		m.ClearDontCancelSetUserLogin()
		return nil
	case orderitem.FieldShipBeforeDate:
		m.ClearShipBeforeDate()
		return nil
	case orderitem.FieldShipAfterDate:
		m.ClearShipAfterDate()
		return nil
	case orderitem.FieldReserveAfterDate:
		m.ClearReserveAfterDate()
		return nil
	case orderitem.FieldCancelBackOrderDate:
		m.ClearCancelBackOrderDate()
		return nil
	case orderitem.FieldOverrideGlAccountID:
		m.ClearOverrideGlAccountID()
		return nil
	case orderitem.FieldSalesOpportunityID:
		m.ClearSalesOpportunityID()
		return nil
	case orderitem.FieldChangeByUserLoginID:
		m.ClearChangeByUserLoginID()
		return nil
	}
	return fmt.Errorf("unknown OrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemMutation) ResetField(name string) error {
	switch name {
	case orderitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderitem.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderitem.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case orderitem.FieldExternalID:
		m.ResetExternalID()
		return nil
	case orderitem.FieldOrderItemTypeID:
		m.ResetOrderItemTypeID()
		return nil
	case orderitem.FieldOrderItemGroupSeqID:
		m.ResetOrderItemGroupSeqID()
		return nil
	case orderitem.FieldIsItemGroupPrimary:
		m.ResetIsItemGroupPrimary()
		return nil
	case orderitem.FieldFromInventoryItemID:
		m.ResetFromInventoryItemID()
		return nil
	case orderitem.FieldBudgetID:
		m.ResetBudgetID()
		return nil
	case orderitem.FieldBudgetItemSeqID:
		m.ResetBudgetItemSeqID()
		return nil
	case orderitem.FieldSupplierProductID:
		m.ResetSupplierProductID()
		return nil
	case orderitem.FieldProductFeatureID:
		m.ResetProductFeatureID()
		return nil
	case orderitem.FieldProdCatalogID:
		m.ResetProdCatalogID()
		return nil
	case orderitem.FieldProductCategoryID:
		m.ResetProductCategoryID()
		return nil
	case orderitem.FieldIsPromo:
		m.ResetIsPromo()
		return nil
	case orderitem.FieldQuoteID:
		m.ResetQuoteID()
		return nil
	case orderitem.FieldQuoteItemSeqID:
		m.ResetQuoteItemSeqID()
		return nil
	case orderitem.FieldShoppingListID:
		m.ResetShoppingListID()
		return nil
	case orderitem.FieldShoppingListItemSeqID:
		m.ResetShoppingListItemSeqID()
		return nil
	case orderitem.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case orderitem.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case orderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitem.FieldCancelQuantity:
		m.ResetCancelQuantity()
		return nil
	case orderitem.FieldSelectedAmount:
		m.ResetSelectedAmount()
		return nil
	case orderitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case orderitem.FieldUnitListPrice:
		m.ResetUnitListPrice()
		return nil
	case orderitem.FieldUnitAverageCost:
		m.ResetUnitAverageCost()
		return nil
	case orderitem.FieldUnitRecurringPrice:
		m.ResetUnitRecurringPrice()
		return nil
	case orderitem.FieldIsModifiedPrice:
		m.ResetIsModifiedPrice()
		return nil
	case orderitem.FieldRecurringFreqUomID:
		m.ResetRecurringFreqUomID()
		return nil
	case orderitem.FieldItemDescription:
		m.ResetItemDescription()
		return nil
	case orderitem.FieldComments:
		m.ResetComments()
		return nil
	case orderitem.FieldCorrespondingPoID:
		m.ResetCorrespondingPoID()
		return nil
	case orderitem.FieldEstimatedShipDate:
		m.ResetEstimatedShipDate()
		return nil
	case orderitem.FieldEstimatedDeliveryDate:
		m.ResetEstimatedDeliveryDate()
		return nil
	case orderitem.FieldAutoCancelDate:
		m.ResetAutoCancelDate()
		return nil
	case orderitem.FieldDontCancelSetDate:
		m.ResetDontCancelSetDate()
		return nil
	case orderitem.FieldDontCancelSetUserLogin:
		m.ResetDontCancelSetUserLogin()
		return nil
	case orderitem.FieldShipBeforeDate:
		m.ResetShipBeforeDate()
		return nil
	case orderitem.FieldShipAfterDate:
		m.ResetShipAfterDate()
		return nil
	case orderitem.FieldReserveAfterDate:
		m.ResetReserveAfterDate()
		return nil
	case orderitem.FieldCancelBackOrderDate:
		m.ResetCancelBackOrderDate()
		return nil
	case orderitem.FieldOverrideGlAccountID:
		m.ResetOverrideGlAccountID()
		return nil
	case orderitem.FieldSalesOpportunityID:
		m.ResetSalesOpportunityID()
		return nil
	case orderitem.FieldChangeByUserLoginID:
		m.ResetChangeByUserLoginID()
		return nil
	}
	return fmt.Errorf("unknown OrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.order_header != nil {
		edges = append(edges, orderitem.EdgeOrderHeader)
	}
	if m.product != nil {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m.status_item != nil {
		edges = append(edges, orderitem.EdgeStatusItem)
	}
	if m.status_valid_changes != nil {
		edges = append(edges, orderitem.EdgeStatusValidChanges)
	}
	if m.sync_status_item != nil {
		edges = append(edges, orderitem.EdgeSyncStatusItem)
	}
	if m.order_adjustments != nil {
		edges = append(edges, orderitem.EdgeOrderAdjustments)
	}
	if m.order_item_ship_group_assocs != nil {
		edges = append(edges, orderitem.EdgeOrderItemShipGroupAssocs)
	}
	if m.order_item_ship_grp_inv_res != nil {
		edges = append(edges, orderitem.EdgeOrderItemShipGrpInvRes)
	}
	if m.order_payment_preferences != nil {
		edges = append(edges, orderitem.EdgeOrderPaymentPreferences)
	}
	if m.order_statuses != nil {
		edges = append(edges, orderitem.EdgeOrderStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeStatusItem:
		if id := m.status_item; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeStatusValidChanges:
		ids := make([]ent.Value, 0, len(m.status_valid_changes))
		for id := range m.status_valid_changes {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeSyncStatusItem:
		if id := m.sync_status_item; id != nil {
			return []ent.Value{*id}
		}
	case orderitem.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.order_adjustments))
		for id := range m.order_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderItemShipGroupAssocs:
		ids := make([]ent.Value, 0, len(m.order_item_ship_group_assocs))
		for id := range m.order_item_ship_group_assocs {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.order_item_ship_grp_inv_res))
		for id := range m.order_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.order_payment_preferences))
		for id := range m.order_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.order_statuses))
		for id := range m.order_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedstatus_valid_changes != nil {
		edges = append(edges, orderitem.EdgeStatusValidChanges)
	}
	if m.removedorder_adjustments != nil {
		edges = append(edges, orderitem.EdgeOrderAdjustments)
	}
	if m.removedorder_item_ship_group_assocs != nil {
		edges = append(edges, orderitem.EdgeOrderItemShipGroupAssocs)
	}
	if m.removedorder_item_ship_grp_inv_res != nil {
		edges = append(edges, orderitem.EdgeOrderItemShipGrpInvRes)
	}
	if m.removedorder_payment_preferences != nil {
		edges = append(edges, orderitem.EdgeOrderPaymentPreferences)
	}
	if m.removedorder_statuses != nil {
		edges = append(edges, orderitem.EdgeOrderStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitem.EdgeStatusValidChanges:
		ids := make([]ent.Value, 0, len(m.removedstatus_valid_changes))
		for id := range m.removedstatus_valid_changes {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.removedorder_adjustments))
		for id := range m.removedorder_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderItemShipGroupAssocs:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_group_assocs))
		for id := range m.removedorder_item_ship_group_assocs {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_grp_inv_res))
		for id := range m.removedorder_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.removedorder_payment_preferences))
		for id := range m.removedorder_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case orderitem.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.removedorder_statuses))
		for id := range m.removedorder_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedorder_header {
		edges = append(edges, orderitem.EdgeOrderHeader)
	}
	if m.clearedproduct {
		edges = append(edges, orderitem.EdgeProduct)
	}
	if m.clearedstatus_item {
		edges = append(edges, orderitem.EdgeStatusItem)
	}
	if m.clearedstatus_valid_changes {
		edges = append(edges, orderitem.EdgeStatusValidChanges)
	}
	if m.clearedsync_status_item {
		edges = append(edges, orderitem.EdgeSyncStatusItem)
	}
	if m.clearedorder_adjustments {
		edges = append(edges, orderitem.EdgeOrderAdjustments)
	}
	if m.clearedorder_item_ship_group_assocs {
		edges = append(edges, orderitem.EdgeOrderItemShipGroupAssocs)
	}
	if m.clearedorder_item_ship_grp_inv_res {
		edges = append(edges, orderitem.EdgeOrderItemShipGrpInvRes)
	}
	if m.clearedorder_payment_preferences {
		edges = append(edges, orderitem.EdgeOrderPaymentPreferences)
	}
	if m.clearedorder_statuses {
		edges = append(edges, orderitem.EdgeOrderStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitem.EdgeOrderHeader:
		return m.clearedorder_header
	case orderitem.EdgeProduct:
		return m.clearedproduct
	case orderitem.EdgeStatusItem:
		return m.clearedstatus_item
	case orderitem.EdgeStatusValidChanges:
		return m.clearedstatus_valid_changes
	case orderitem.EdgeSyncStatusItem:
		return m.clearedsync_status_item
	case orderitem.EdgeOrderAdjustments:
		return m.clearedorder_adjustments
	case orderitem.EdgeOrderItemShipGroupAssocs:
		return m.clearedorder_item_ship_group_assocs
	case orderitem.EdgeOrderItemShipGrpInvRes:
		return m.clearedorder_item_ship_grp_inv_res
	case orderitem.EdgeOrderPaymentPreferences:
		return m.clearedorder_payment_preferences
	case orderitem.EdgeOrderStatuses:
		return m.clearedorder_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemMutation) ClearEdge(name string) error {
	switch name {
	case orderitem.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderitem.EdgeProduct:
		m.ClearProduct()
		return nil
	case orderitem.EdgeStatusItem:
		m.ClearStatusItem()
		return nil
	case orderitem.EdgeSyncStatusItem:
		m.ClearSyncStatusItem()
		return nil
	}
	return fmt.Errorf("unknown OrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemMutation) ResetEdge(name string) error {
	switch name {
	case orderitem.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderitem.EdgeProduct:
		m.ResetProduct()
		return nil
	case orderitem.EdgeStatusItem:
		m.ResetStatusItem()
		return nil
	case orderitem.EdgeStatusValidChanges:
		m.ResetStatusValidChanges()
		return nil
	case orderitem.EdgeSyncStatusItem:
		m.ResetSyncStatusItem()
		return nil
	case orderitem.EdgeOrderAdjustments:
		m.ResetOrderAdjustments()
		return nil
	case orderitem.EdgeOrderItemShipGroupAssocs:
		m.ResetOrderItemShipGroupAssocs()
		return nil
	case orderitem.EdgeOrderItemShipGrpInvRes:
		m.ResetOrderItemShipGrpInvRes()
		return nil
	case orderitem.EdgeOrderPaymentPreferences:
		m.ResetOrderPaymentPreferences()
		return nil
	case orderitem.EdgeOrderStatuses:
		m.ResetOrderStatuses()
		return nil
	}
	return fmt.Errorf("unknown OrderItem edge %s", name)
}

// OrderItemShipGroupMutation represents an operation that mutates the OrderItemShipGroup nodes in the graph.
type OrderItemShipGroupMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	update_time                         *time.Time
	string_ref                          *string
	ship_group_seq_id                   *int
	addship_group_seq_id                *int
	shipment_method_type_id             *int
	addshipment_method_type_id          *int
	supplier_party_id                   *int
	addsupplier_party_id                *int
	supplier_agreement_id               *int
	addsupplier_agreement_id            *int
	vendor_party_id                     *int
	addvendor_party_id                  *int
	carrier_party_id                    *int
	addcarrier_party_id                 *int
	carrier_role_type_id                *int
	addcarrier_role_type_id             *int
	facility_id                         *int
	addfacility_id                      *int
	contact_mech_id                     *int
	addcontact_mech_id                  *int
	telecom_contact_mech_id             *int
	addtelecom_contact_mech_id          *int
	tracking_number                     *string
	shipping_instructions               *string
	may_split                           *orderitemshipgroup.MaySplit
	gift_message                        *string
	is_gift                             *orderitemshipgroup.IsGift
	ship_after_date                     *time.Time
	ship_by_date                        *time.Time
	estimated_ship_date                 *time.Time
	estimated_delivery_date             *time.Time
	clearedFields                       map[string]struct{}
	order_header                        *int
	clearedorder_header                 bool
	order_adjustments                   map[int]struct{}
	removedorder_adjustments            map[int]struct{}
	clearedorder_adjustments            bool
	order_item_ship_group_assocs        map[int]struct{}
	removedorder_item_ship_group_assocs map[int]struct{}
	clearedorder_item_ship_group_assocs bool
	order_item_ship_grp_inv_res         map[int]struct{}
	removedorder_item_ship_grp_inv_res  map[int]struct{}
	clearedorder_item_ship_grp_inv_res  bool
	order_payment_preferences           map[int]struct{}
	removedorder_payment_preferences    map[int]struct{}
	clearedorder_payment_preferences    bool
	done                                bool
	oldValue                            func(context.Context) (*OrderItemShipGroup, error)
	predicates                          []predicate.OrderItemShipGroup
}

var _ ent.Mutation = (*OrderItemShipGroupMutation)(nil)

// orderitemshipgroupOption allows management of the mutation configuration using functional options.
type orderitemshipgroupOption func(*OrderItemShipGroupMutation)

// newOrderItemShipGroupMutation creates new mutation for the OrderItemShipGroup entity.
func newOrderItemShipGroupMutation(c config, op Op, opts ...orderitemshipgroupOption) *OrderItemShipGroupMutation {
	m := &OrderItemShipGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItemShipGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemShipGroupID sets the ID field of the mutation.
func withOrderItemShipGroupID(id int) orderitemshipgroupOption {
	return func(m *OrderItemShipGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItemShipGroup
		)
		m.oldValue = func(ctx context.Context) (*OrderItemShipGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItemShipGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItemShipGroup sets the old OrderItemShipGroup of the mutation.
func withOrderItemShipGroup(node *OrderItemShipGroup) orderitemshipgroupOption {
	return func(m *OrderItemShipGroupMutation) {
		m.oldValue = func(context.Context) (*OrderItemShipGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemShipGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemShipGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemShipGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderItemShipGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderItemShipGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderItemShipGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderItemShipGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderItemShipGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderItemShipGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderItemShipGroupMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderItemShipGroupMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderItemShipGroupMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderitemshipgroup.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderItemShipGroupMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderitemshipgroup.FieldStringRef)
}

// SetShipGroupSeqID sets the "ship_group_seq_id" field.
func (m *OrderItemShipGroupMutation) SetShipGroupSeqID(i int) {
	m.ship_group_seq_id = &i
	m.addship_group_seq_id = nil
}

// ShipGroupSeqID returns the value of the "ship_group_seq_id" field in the mutation.
func (m *OrderItemShipGroupMutation) ShipGroupSeqID() (r int, exists bool) {
	v := m.ship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipGroupSeqID returns the old "ship_group_seq_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldShipGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipGroupSeqID: %w", err)
	}
	return oldValue.ShipGroupSeqID, nil
}

// AddShipGroupSeqID adds i to the "ship_group_seq_id" field.
func (m *OrderItemShipGroupMutation) AddShipGroupSeqID(i int) {
	if m.addship_group_seq_id != nil {
		*m.addship_group_seq_id += i
	} else {
		m.addship_group_seq_id = &i
	}
}

// AddedShipGroupSeqID returns the value that was added to the "ship_group_seq_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedShipGroupSeqID() (r int, exists bool) {
	v := m.addship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetShipGroupSeqID resets all changes to the "ship_group_seq_id" field.
func (m *OrderItemShipGroupMutation) ResetShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
}

// SetShipmentMethodTypeID sets the "shipment_method_type_id" field.
func (m *OrderItemShipGroupMutation) SetShipmentMethodTypeID(i int) {
	m.shipment_method_type_id = &i
	m.addshipment_method_type_id = nil
}

// ShipmentMethodTypeID returns the value of the "shipment_method_type_id" field in the mutation.
func (m *OrderItemShipGroupMutation) ShipmentMethodTypeID() (r int, exists bool) {
	v := m.shipment_method_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentMethodTypeID returns the old "shipment_method_type_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldShipmentMethodTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipmentMethodTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipmentMethodTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentMethodTypeID: %w", err)
	}
	return oldValue.ShipmentMethodTypeID, nil
}

// AddShipmentMethodTypeID adds i to the "shipment_method_type_id" field.
func (m *OrderItemShipGroupMutation) AddShipmentMethodTypeID(i int) {
	if m.addshipment_method_type_id != nil {
		*m.addshipment_method_type_id += i
	} else {
		m.addshipment_method_type_id = &i
	}
}

// AddedShipmentMethodTypeID returns the value that was added to the "shipment_method_type_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedShipmentMethodTypeID() (r int, exists bool) {
	v := m.addshipment_method_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentMethodTypeID clears the value of the "shipment_method_type_id" field.
func (m *OrderItemShipGroupMutation) ClearShipmentMethodTypeID() {
	m.shipment_method_type_id = nil
	m.addshipment_method_type_id = nil
	m.clearedFields[orderitemshipgroup.FieldShipmentMethodTypeID] = struct{}{}
}

// ShipmentMethodTypeIDCleared returns if the "shipment_method_type_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) ShipmentMethodTypeIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldShipmentMethodTypeID]
	return ok
}

// ResetShipmentMethodTypeID resets all changes to the "shipment_method_type_id" field.
func (m *OrderItemShipGroupMutation) ResetShipmentMethodTypeID() {
	m.shipment_method_type_id = nil
	m.addshipment_method_type_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldShipmentMethodTypeID)
}

// SetSupplierPartyID sets the "supplier_party_id" field.
func (m *OrderItemShipGroupMutation) SetSupplierPartyID(i int) {
	m.supplier_party_id = &i
	m.addsupplier_party_id = nil
}

// SupplierPartyID returns the value of the "supplier_party_id" field in the mutation.
func (m *OrderItemShipGroupMutation) SupplierPartyID() (r int, exists bool) {
	v := m.supplier_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierPartyID returns the old "supplier_party_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldSupplierPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSupplierPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSupplierPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierPartyID: %w", err)
	}
	return oldValue.SupplierPartyID, nil
}

// AddSupplierPartyID adds i to the "supplier_party_id" field.
func (m *OrderItemShipGroupMutation) AddSupplierPartyID(i int) {
	if m.addsupplier_party_id != nil {
		*m.addsupplier_party_id += i
	} else {
		m.addsupplier_party_id = &i
	}
}

// AddedSupplierPartyID returns the value that was added to the "supplier_party_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedSupplierPartyID() (r int, exists bool) {
	v := m.addsupplier_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSupplierPartyID clears the value of the "supplier_party_id" field.
func (m *OrderItemShipGroupMutation) ClearSupplierPartyID() {
	m.supplier_party_id = nil
	m.addsupplier_party_id = nil
	m.clearedFields[orderitemshipgroup.FieldSupplierPartyID] = struct{}{}
}

// SupplierPartyIDCleared returns if the "supplier_party_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) SupplierPartyIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldSupplierPartyID]
	return ok
}

// ResetSupplierPartyID resets all changes to the "supplier_party_id" field.
func (m *OrderItemShipGroupMutation) ResetSupplierPartyID() {
	m.supplier_party_id = nil
	m.addsupplier_party_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldSupplierPartyID)
}

// SetSupplierAgreementID sets the "supplier_agreement_id" field.
func (m *OrderItemShipGroupMutation) SetSupplierAgreementID(i int) {
	m.supplier_agreement_id = &i
	m.addsupplier_agreement_id = nil
}

// SupplierAgreementID returns the value of the "supplier_agreement_id" field in the mutation.
func (m *OrderItemShipGroupMutation) SupplierAgreementID() (r int, exists bool) {
	v := m.supplier_agreement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierAgreementID returns the old "supplier_agreement_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldSupplierAgreementID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSupplierAgreementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSupplierAgreementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierAgreementID: %w", err)
	}
	return oldValue.SupplierAgreementID, nil
}

// AddSupplierAgreementID adds i to the "supplier_agreement_id" field.
func (m *OrderItemShipGroupMutation) AddSupplierAgreementID(i int) {
	if m.addsupplier_agreement_id != nil {
		*m.addsupplier_agreement_id += i
	} else {
		m.addsupplier_agreement_id = &i
	}
}

// AddedSupplierAgreementID returns the value that was added to the "supplier_agreement_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedSupplierAgreementID() (r int, exists bool) {
	v := m.addsupplier_agreement_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSupplierAgreementID clears the value of the "supplier_agreement_id" field.
func (m *OrderItemShipGroupMutation) ClearSupplierAgreementID() {
	m.supplier_agreement_id = nil
	m.addsupplier_agreement_id = nil
	m.clearedFields[orderitemshipgroup.FieldSupplierAgreementID] = struct{}{}
}

// SupplierAgreementIDCleared returns if the "supplier_agreement_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) SupplierAgreementIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldSupplierAgreementID]
	return ok
}

// ResetSupplierAgreementID resets all changes to the "supplier_agreement_id" field.
func (m *OrderItemShipGroupMutation) ResetSupplierAgreementID() {
	m.supplier_agreement_id = nil
	m.addsupplier_agreement_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldSupplierAgreementID)
}

// SetVendorPartyID sets the "vendor_party_id" field.
func (m *OrderItemShipGroupMutation) SetVendorPartyID(i int) {
	m.vendor_party_id = &i
	m.addvendor_party_id = nil
}

// VendorPartyID returns the value of the "vendor_party_id" field in the mutation.
func (m *OrderItemShipGroupMutation) VendorPartyID() (r int, exists bool) {
	v := m.vendor_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorPartyID returns the old "vendor_party_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldVendorPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVendorPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVendorPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorPartyID: %w", err)
	}
	return oldValue.VendorPartyID, nil
}

// AddVendorPartyID adds i to the "vendor_party_id" field.
func (m *OrderItemShipGroupMutation) AddVendorPartyID(i int) {
	if m.addvendor_party_id != nil {
		*m.addvendor_party_id += i
	} else {
		m.addvendor_party_id = &i
	}
}

// AddedVendorPartyID returns the value that was added to the "vendor_party_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedVendorPartyID() (r int, exists bool) {
	v := m.addvendor_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVendorPartyID clears the value of the "vendor_party_id" field.
func (m *OrderItemShipGroupMutation) ClearVendorPartyID() {
	m.vendor_party_id = nil
	m.addvendor_party_id = nil
	m.clearedFields[orderitemshipgroup.FieldVendorPartyID] = struct{}{}
}

// VendorPartyIDCleared returns if the "vendor_party_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) VendorPartyIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldVendorPartyID]
	return ok
}

// ResetVendorPartyID resets all changes to the "vendor_party_id" field.
func (m *OrderItemShipGroupMutation) ResetVendorPartyID() {
	m.vendor_party_id = nil
	m.addvendor_party_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldVendorPartyID)
}

// SetCarrierPartyID sets the "carrier_party_id" field.
func (m *OrderItemShipGroupMutation) SetCarrierPartyID(i int) {
	m.carrier_party_id = &i
	m.addcarrier_party_id = nil
}

// CarrierPartyID returns the value of the "carrier_party_id" field in the mutation.
func (m *OrderItemShipGroupMutation) CarrierPartyID() (r int, exists bool) {
	v := m.carrier_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarrierPartyID returns the old "carrier_party_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldCarrierPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCarrierPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCarrierPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarrierPartyID: %w", err)
	}
	return oldValue.CarrierPartyID, nil
}

// AddCarrierPartyID adds i to the "carrier_party_id" field.
func (m *OrderItemShipGroupMutation) AddCarrierPartyID(i int) {
	if m.addcarrier_party_id != nil {
		*m.addcarrier_party_id += i
	} else {
		m.addcarrier_party_id = &i
	}
}

// AddedCarrierPartyID returns the value that was added to the "carrier_party_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedCarrierPartyID() (r int, exists bool) {
	v := m.addcarrier_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarrierPartyID clears the value of the "carrier_party_id" field.
func (m *OrderItemShipGroupMutation) ClearCarrierPartyID() {
	m.carrier_party_id = nil
	m.addcarrier_party_id = nil
	m.clearedFields[orderitemshipgroup.FieldCarrierPartyID] = struct{}{}
}

// CarrierPartyIDCleared returns if the "carrier_party_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) CarrierPartyIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldCarrierPartyID]
	return ok
}

// ResetCarrierPartyID resets all changes to the "carrier_party_id" field.
func (m *OrderItemShipGroupMutation) ResetCarrierPartyID() {
	m.carrier_party_id = nil
	m.addcarrier_party_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldCarrierPartyID)
}

// SetCarrierRoleTypeID sets the "carrier_role_type_id" field.
func (m *OrderItemShipGroupMutation) SetCarrierRoleTypeID(i int) {
	m.carrier_role_type_id = &i
	m.addcarrier_role_type_id = nil
}

// CarrierRoleTypeID returns the value of the "carrier_role_type_id" field in the mutation.
func (m *OrderItemShipGroupMutation) CarrierRoleTypeID() (r int, exists bool) {
	v := m.carrier_role_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarrierRoleTypeID returns the old "carrier_role_type_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldCarrierRoleTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCarrierRoleTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCarrierRoleTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarrierRoleTypeID: %w", err)
	}
	return oldValue.CarrierRoleTypeID, nil
}

// AddCarrierRoleTypeID adds i to the "carrier_role_type_id" field.
func (m *OrderItemShipGroupMutation) AddCarrierRoleTypeID(i int) {
	if m.addcarrier_role_type_id != nil {
		*m.addcarrier_role_type_id += i
	} else {
		m.addcarrier_role_type_id = &i
	}
}

// AddedCarrierRoleTypeID returns the value that was added to the "carrier_role_type_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedCarrierRoleTypeID() (r int, exists bool) {
	v := m.addcarrier_role_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCarrierRoleTypeID clears the value of the "carrier_role_type_id" field.
func (m *OrderItemShipGroupMutation) ClearCarrierRoleTypeID() {
	m.carrier_role_type_id = nil
	m.addcarrier_role_type_id = nil
	m.clearedFields[orderitemshipgroup.FieldCarrierRoleTypeID] = struct{}{}
}

// CarrierRoleTypeIDCleared returns if the "carrier_role_type_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) CarrierRoleTypeIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldCarrierRoleTypeID]
	return ok
}

// ResetCarrierRoleTypeID resets all changes to the "carrier_role_type_id" field.
func (m *OrderItemShipGroupMutation) ResetCarrierRoleTypeID() {
	m.carrier_role_type_id = nil
	m.addcarrier_role_type_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldCarrierRoleTypeID)
}

// SetFacilityID sets the "facility_id" field.
func (m *OrderItemShipGroupMutation) SetFacilityID(i int) {
	m.facility_id = &i
	m.addfacility_id = nil
}

// FacilityID returns the value of the "facility_id" field in the mutation.
func (m *OrderItemShipGroupMutation) FacilityID() (r int, exists bool) {
	v := m.facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "facility_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// AddFacilityID adds i to the "facility_id" field.
func (m *OrderItemShipGroupMutation) AddFacilityID(i int) {
	if m.addfacility_id != nil {
		*m.addfacility_id += i
	} else {
		m.addfacility_id = &i
	}
}

// AddedFacilityID returns the value that was added to the "facility_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedFacilityID() (r int, exists bool) {
	v := m.addfacility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFacilityID clears the value of the "facility_id" field.
func (m *OrderItemShipGroupMutation) ClearFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	m.clearedFields[orderitemshipgroup.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "facility_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "facility_id" field.
func (m *OrderItemShipGroupMutation) ResetFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldFacilityID)
}

// SetContactMechID sets the "contact_mech_id" field.
func (m *OrderItemShipGroupMutation) SetContactMechID(i int) {
	m.contact_mech_id = &i
	m.addcontact_mech_id = nil
}

// ContactMechID returns the value of the "contact_mech_id" field in the mutation.
func (m *OrderItemShipGroupMutation) ContactMechID() (r int, exists bool) {
	v := m.contact_mech_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContactMechID returns the old "contact_mech_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldContactMechID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactMechID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactMechID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactMechID: %w", err)
	}
	return oldValue.ContactMechID, nil
}

// AddContactMechID adds i to the "contact_mech_id" field.
func (m *OrderItemShipGroupMutation) AddContactMechID(i int) {
	if m.addcontact_mech_id != nil {
		*m.addcontact_mech_id += i
	} else {
		m.addcontact_mech_id = &i
	}
}

// AddedContactMechID returns the value that was added to the "contact_mech_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedContactMechID() (r int, exists bool) {
	v := m.addcontact_mech_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearContactMechID clears the value of the "contact_mech_id" field.
func (m *OrderItemShipGroupMutation) ClearContactMechID() {
	m.contact_mech_id = nil
	m.addcontact_mech_id = nil
	m.clearedFields[orderitemshipgroup.FieldContactMechID] = struct{}{}
}

// ContactMechIDCleared returns if the "contact_mech_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) ContactMechIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldContactMechID]
	return ok
}

// ResetContactMechID resets all changes to the "contact_mech_id" field.
func (m *OrderItemShipGroupMutation) ResetContactMechID() {
	m.contact_mech_id = nil
	m.addcontact_mech_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldContactMechID)
}

// SetTelecomContactMechID sets the "telecom_contact_mech_id" field.
func (m *OrderItemShipGroupMutation) SetTelecomContactMechID(i int) {
	m.telecom_contact_mech_id = &i
	m.addtelecom_contact_mech_id = nil
}

// TelecomContactMechID returns the value of the "telecom_contact_mech_id" field in the mutation.
func (m *OrderItemShipGroupMutation) TelecomContactMechID() (r int, exists bool) {
	v := m.telecom_contact_mech_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTelecomContactMechID returns the old "telecom_contact_mech_id" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldTelecomContactMechID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTelecomContactMechID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTelecomContactMechID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelecomContactMechID: %w", err)
	}
	return oldValue.TelecomContactMechID, nil
}

// AddTelecomContactMechID adds i to the "telecom_contact_mech_id" field.
func (m *OrderItemShipGroupMutation) AddTelecomContactMechID(i int) {
	if m.addtelecom_contact_mech_id != nil {
		*m.addtelecom_contact_mech_id += i
	} else {
		m.addtelecom_contact_mech_id = &i
	}
}

// AddedTelecomContactMechID returns the value that was added to the "telecom_contact_mech_id" field in this mutation.
func (m *OrderItemShipGroupMutation) AddedTelecomContactMechID() (r int, exists bool) {
	v := m.addtelecom_contact_mech_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTelecomContactMechID clears the value of the "telecom_contact_mech_id" field.
func (m *OrderItemShipGroupMutation) ClearTelecomContactMechID() {
	m.telecom_contact_mech_id = nil
	m.addtelecom_contact_mech_id = nil
	m.clearedFields[orderitemshipgroup.FieldTelecomContactMechID] = struct{}{}
}

// TelecomContactMechIDCleared returns if the "telecom_contact_mech_id" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) TelecomContactMechIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldTelecomContactMechID]
	return ok
}

// ResetTelecomContactMechID resets all changes to the "telecom_contact_mech_id" field.
func (m *OrderItemShipGroupMutation) ResetTelecomContactMechID() {
	m.telecom_contact_mech_id = nil
	m.addtelecom_contact_mech_id = nil
	delete(m.clearedFields, orderitemshipgroup.FieldTelecomContactMechID)
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *OrderItemShipGroupMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *OrderItemShipGroupMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ClearTrackingNumber clears the value of the "tracking_number" field.
func (m *OrderItemShipGroupMutation) ClearTrackingNumber() {
	m.tracking_number = nil
	m.clearedFields[orderitemshipgroup.FieldTrackingNumber] = struct{}{}
}

// TrackingNumberCleared returns if the "tracking_number" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) TrackingNumberCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldTrackingNumber]
	return ok
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *OrderItemShipGroupMutation) ResetTrackingNumber() {
	m.tracking_number = nil
	delete(m.clearedFields, orderitemshipgroup.FieldTrackingNumber)
}

// SetShippingInstructions sets the "shipping_instructions" field.
func (m *OrderItemShipGroupMutation) SetShippingInstructions(s string) {
	m.shipping_instructions = &s
}

// ShippingInstructions returns the value of the "shipping_instructions" field in the mutation.
func (m *OrderItemShipGroupMutation) ShippingInstructions() (r string, exists bool) {
	v := m.shipping_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingInstructions returns the old "shipping_instructions" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldShippingInstructions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingInstructions: %w", err)
	}
	return oldValue.ShippingInstructions, nil
}

// ClearShippingInstructions clears the value of the "shipping_instructions" field.
func (m *OrderItemShipGroupMutation) ClearShippingInstructions() {
	m.shipping_instructions = nil
	m.clearedFields[orderitemshipgroup.FieldShippingInstructions] = struct{}{}
}

// ShippingInstructionsCleared returns if the "shipping_instructions" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) ShippingInstructionsCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldShippingInstructions]
	return ok
}

// ResetShippingInstructions resets all changes to the "shipping_instructions" field.
func (m *OrderItemShipGroupMutation) ResetShippingInstructions() {
	m.shipping_instructions = nil
	delete(m.clearedFields, orderitemshipgroup.FieldShippingInstructions)
}

// SetMaySplit sets the "may_split" field.
func (m *OrderItemShipGroupMutation) SetMaySplit(os orderitemshipgroup.MaySplit) {
	m.may_split = &os
}

// MaySplit returns the value of the "may_split" field in the mutation.
func (m *OrderItemShipGroupMutation) MaySplit() (r orderitemshipgroup.MaySplit, exists bool) {
	v := m.may_split
	if v == nil {
		return
	}
	return *v, true
}

// OldMaySplit returns the old "may_split" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldMaySplit(ctx context.Context) (v orderitemshipgroup.MaySplit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaySplit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaySplit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaySplit: %w", err)
	}
	return oldValue.MaySplit, nil
}

// ClearMaySplit clears the value of the "may_split" field.
func (m *OrderItemShipGroupMutation) ClearMaySplit() {
	m.may_split = nil
	m.clearedFields[orderitemshipgroup.FieldMaySplit] = struct{}{}
}

// MaySplitCleared returns if the "may_split" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) MaySplitCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldMaySplit]
	return ok
}

// ResetMaySplit resets all changes to the "may_split" field.
func (m *OrderItemShipGroupMutation) ResetMaySplit() {
	m.may_split = nil
	delete(m.clearedFields, orderitemshipgroup.FieldMaySplit)
}

// SetGiftMessage sets the "gift_message" field.
func (m *OrderItemShipGroupMutation) SetGiftMessage(s string) {
	m.gift_message = &s
}

// GiftMessage returns the value of the "gift_message" field in the mutation.
func (m *OrderItemShipGroupMutation) GiftMessage() (r string, exists bool) {
	v := m.gift_message
	if v == nil {
		return
	}
	return *v, true
}

// OldGiftMessage returns the old "gift_message" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldGiftMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGiftMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGiftMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGiftMessage: %w", err)
	}
	return oldValue.GiftMessage, nil
}

// ClearGiftMessage clears the value of the "gift_message" field.
func (m *OrderItemShipGroupMutation) ClearGiftMessage() {
	m.gift_message = nil
	m.clearedFields[orderitemshipgroup.FieldGiftMessage] = struct{}{}
}

// GiftMessageCleared returns if the "gift_message" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) GiftMessageCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldGiftMessage]
	return ok
}

// ResetGiftMessage resets all changes to the "gift_message" field.
func (m *OrderItemShipGroupMutation) ResetGiftMessage() {
	m.gift_message = nil
	delete(m.clearedFields, orderitemshipgroup.FieldGiftMessage)
}

// SetIsGift sets the "is_gift" field.
func (m *OrderItemShipGroupMutation) SetIsGift(og orderitemshipgroup.IsGift) {
	m.is_gift = &og
}

// IsGift returns the value of the "is_gift" field in the mutation.
func (m *OrderItemShipGroupMutation) IsGift() (r orderitemshipgroup.IsGift, exists bool) {
	v := m.is_gift
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGift returns the old "is_gift" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldIsGift(ctx context.Context) (v orderitemshipgroup.IsGift, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsGift is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsGift requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGift: %w", err)
	}
	return oldValue.IsGift, nil
}

// ClearIsGift clears the value of the "is_gift" field.
func (m *OrderItemShipGroupMutation) ClearIsGift() {
	m.is_gift = nil
	m.clearedFields[orderitemshipgroup.FieldIsGift] = struct{}{}
}

// IsGiftCleared returns if the "is_gift" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) IsGiftCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldIsGift]
	return ok
}

// ResetIsGift resets all changes to the "is_gift" field.
func (m *OrderItemShipGroupMutation) ResetIsGift() {
	m.is_gift = nil
	delete(m.clearedFields, orderitemshipgroup.FieldIsGift)
}

// SetShipAfterDate sets the "ship_after_date" field.
func (m *OrderItemShipGroupMutation) SetShipAfterDate(t time.Time) {
	m.ship_after_date = &t
}

// ShipAfterDate returns the value of the "ship_after_date" field in the mutation.
func (m *OrderItemShipGroupMutation) ShipAfterDate() (r time.Time, exists bool) {
	v := m.ship_after_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipAfterDate returns the old "ship_after_date" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldShipAfterDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipAfterDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipAfterDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipAfterDate: %w", err)
	}
	return oldValue.ShipAfterDate, nil
}

// ClearShipAfterDate clears the value of the "ship_after_date" field.
func (m *OrderItemShipGroupMutation) ClearShipAfterDate() {
	m.ship_after_date = nil
	m.clearedFields[orderitemshipgroup.FieldShipAfterDate] = struct{}{}
}

// ShipAfterDateCleared returns if the "ship_after_date" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) ShipAfterDateCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldShipAfterDate]
	return ok
}

// ResetShipAfterDate resets all changes to the "ship_after_date" field.
func (m *OrderItemShipGroupMutation) ResetShipAfterDate() {
	m.ship_after_date = nil
	delete(m.clearedFields, orderitemshipgroup.FieldShipAfterDate)
}

// SetShipByDate sets the "ship_by_date" field.
func (m *OrderItemShipGroupMutation) SetShipByDate(t time.Time) {
	m.ship_by_date = &t
}

// ShipByDate returns the value of the "ship_by_date" field in the mutation.
func (m *OrderItemShipGroupMutation) ShipByDate() (r time.Time, exists bool) {
	v := m.ship_by_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipByDate returns the old "ship_by_date" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldShipByDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipByDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipByDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipByDate: %w", err)
	}
	return oldValue.ShipByDate, nil
}

// ClearShipByDate clears the value of the "ship_by_date" field.
func (m *OrderItemShipGroupMutation) ClearShipByDate() {
	m.ship_by_date = nil
	m.clearedFields[orderitemshipgroup.FieldShipByDate] = struct{}{}
}

// ShipByDateCleared returns if the "ship_by_date" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) ShipByDateCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldShipByDate]
	return ok
}

// ResetShipByDate resets all changes to the "ship_by_date" field.
func (m *OrderItemShipGroupMutation) ResetShipByDate() {
	m.ship_by_date = nil
	delete(m.clearedFields, orderitemshipgroup.FieldShipByDate)
}

// SetEstimatedShipDate sets the "estimated_ship_date" field.
func (m *OrderItemShipGroupMutation) SetEstimatedShipDate(t time.Time) {
	m.estimated_ship_date = &t
}

// EstimatedShipDate returns the value of the "estimated_ship_date" field in the mutation.
func (m *OrderItemShipGroupMutation) EstimatedShipDate() (r time.Time, exists bool) {
	v := m.estimated_ship_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedShipDate returns the old "estimated_ship_date" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldEstimatedShipDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedShipDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedShipDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedShipDate: %w", err)
	}
	return oldValue.EstimatedShipDate, nil
}

// ClearEstimatedShipDate clears the value of the "estimated_ship_date" field.
func (m *OrderItemShipGroupMutation) ClearEstimatedShipDate() {
	m.estimated_ship_date = nil
	m.clearedFields[orderitemshipgroup.FieldEstimatedShipDate] = struct{}{}
}

// EstimatedShipDateCleared returns if the "estimated_ship_date" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) EstimatedShipDateCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldEstimatedShipDate]
	return ok
}

// ResetEstimatedShipDate resets all changes to the "estimated_ship_date" field.
func (m *OrderItemShipGroupMutation) ResetEstimatedShipDate() {
	m.estimated_ship_date = nil
	delete(m.clearedFields, orderitemshipgroup.FieldEstimatedShipDate)
}

// SetEstimatedDeliveryDate sets the "estimated_delivery_date" field.
func (m *OrderItemShipGroupMutation) SetEstimatedDeliveryDate(t time.Time) {
	m.estimated_delivery_date = &t
}

// EstimatedDeliveryDate returns the value of the "estimated_delivery_date" field in the mutation.
func (m *OrderItemShipGroupMutation) EstimatedDeliveryDate() (r time.Time, exists bool) {
	v := m.estimated_delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedDeliveryDate returns the old "estimated_delivery_date" field's value of the OrderItemShipGroup entity.
// If the OrderItemShipGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupMutation) OldEstimatedDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedDeliveryDate: %w", err)
	}
	return oldValue.EstimatedDeliveryDate, nil
}

// ClearEstimatedDeliveryDate clears the value of the "estimated_delivery_date" field.
func (m *OrderItemShipGroupMutation) ClearEstimatedDeliveryDate() {
	m.estimated_delivery_date = nil
	m.clearedFields[orderitemshipgroup.FieldEstimatedDeliveryDate] = struct{}{}
}

// EstimatedDeliveryDateCleared returns if the "estimated_delivery_date" field was cleared in this mutation.
func (m *OrderItemShipGroupMutation) EstimatedDeliveryDateCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroup.FieldEstimatedDeliveryDate]
	return ok
}

// ResetEstimatedDeliveryDate resets all changes to the "estimated_delivery_date" field.
func (m *OrderItemShipGroupMutation) ResetEstimatedDeliveryDate() {
	m.estimated_delivery_date = nil
	delete(m.clearedFields, orderitemshipgroup.FieldEstimatedDeliveryDate)
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderItemShipGroupMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderItemShipGroupMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderItemShipGroupMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderItemShipGroupMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGroupMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderItemShipGroupMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// AddOrderAdjustmentIDs adds the "order_adjustments" edge to the OrderAdjustment entity by ids.
func (m *OrderItemShipGroupMutation) AddOrderAdjustmentIDs(ids ...int) {
	if m.order_adjustments == nil {
		m.order_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.order_adjustments[ids[i]] = struct{}{}
	}
}

// ClearOrderAdjustments clears the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderItemShipGroupMutation) ClearOrderAdjustments() {
	m.clearedorder_adjustments = true
}

// OrderAdjustmentsCleared reports if the "order_adjustments" edge to the OrderAdjustment entity was cleared.
func (m *OrderItemShipGroupMutation) OrderAdjustmentsCleared() bool {
	return m.clearedorder_adjustments
}

// RemoveOrderAdjustmentIDs removes the "order_adjustments" edge to the OrderAdjustment entity by IDs.
func (m *OrderItemShipGroupMutation) RemoveOrderAdjustmentIDs(ids ...int) {
	if m.removedorder_adjustments == nil {
		m.removedorder_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_adjustments[ids[i]] = struct{}{}
	}
}

// RemovedOrderAdjustments returns the removed IDs of the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderItemShipGroupMutation) RemovedOrderAdjustmentsIDs() (ids []int) {
	for id := range m.removedorder_adjustments {
		ids = append(ids, id)
	}
	return
}

// OrderAdjustmentsIDs returns the "order_adjustments" edge IDs in the mutation.
func (m *OrderItemShipGroupMutation) OrderAdjustmentsIDs() (ids []int) {
	for id := range m.order_adjustments {
		ids = append(ids, id)
	}
	return
}

// ResetOrderAdjustments resets all changes to the "order_adjustments" edge.
func (m *OrderItemShipGroupMutation) ResetOrderAdjustments() {
	m.order_adjustments = nil
	m.clearedorder_adjustments = false
	m.removedorder_adjustments = nil
}

// AddOrderItemShipGroupAssocIDs adds the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity by ids.
func (m *OrderItemShipGroupMutation) AddOrderItemShipGroupAssocIDs(ids ...int) {
	if m.order_item_ship_group_assocs == nil {
		m.order_item_ship_group_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_group_assocs[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGroupAssocs clears the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderItemShipGroupMutation) ClearOrderItemShipGroupAssocs() {
	m.clearedorder_item_ship_group_assocs = true
}

// OrderItemShipGroupAssocsCleared reports if the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity was cleared.
func (m *OrderItemShipGroupMutation) OrderItemShipGroupAssocsCleared() bool {
	return m.clearedorder_item_ship_group_assocs
}

// RemoveOrderItemShipGroupAssocIDs removes the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity by IDs.
func (m *OrderItemShipGroupMutation) RemoveOrderItemShipGroupAssocIDs(ids ...int) {
	if m.removedorder_item_ship_group_assocs == nil {
		m.removedorder_item_ship_group_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_group_assocs[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGroupAssocs returns the removed IDs of the "order_item_ship_group_assocs" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderItemShipGroupMutation) RemovedOrderItemShipGroupAssocsIDs() (ids []int) {
	for id := range m.removedorder_item_ship_group_assocs {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGroupAssocsIDs returns the "order_item_ship_group_assocs" edge IDs in the mutation.
func (m *OrderItemShipGroupMutation) OrderItemShipGroupAssocsIDs() (ids []int) {
	for id := range m.order_item_ship_group_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGroupAssocs resets all changes to the "order_item_ship_group_assocs" edge.
func (m *OrderItemShipGroupMutation) ResetOrderItemShipGroupAssocs() {
	m.order_item_ship_group_assocs = nil
	m.clearedorder_item_ship_group_assocs = false
	m.removedorder_item_ship_group_assocs = nil
}

// AddOrderItemShipGrpInvReIDs adds the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by ids.
func (m *OrderItemShipGroupMutation) AddOrderItemShipGrpInvReIDs(ids ...int) {
	if m.order_item_ship_grp_inv_res == nil {
		m.order_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGrpInvRes clears the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderItemShipGroupMutation) ClearOrderItemShipGrpInvRes() {
	m.clearedorder_item_ship_grp_inv_res = true
}

// OrderItemShipGrpInvResCleared reports if the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity was cleared.
func (m *OrderItemShipGroupMutation) OrderItemShipGrpInvResCleared() bool {
	return m.clearedorder_item_ship_grp_inv_res
}

// RemoveOrderItemShipGrpInvReIDs removes the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by IDs.
func (m *OrderItemShipGroupMutation) RemoveOrderItemShipGrpInvReIDs(ids ...int) {
	if m.removedorder_item_ship_grp_inv_res == nil {
		m.removedorder_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGrpInvRes returns the removed IDs of the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderItemShipGroupMutation) RemovedOrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.removedorder_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGrpInvResIDs returns the "order_item_ship_grp_inv_res" edge IDs in the mutation.
func (m *OrderItemShipGroupMutation) OrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.order_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGrpInvRes resets all changes to the "order_item_ship_grp_inv_res" edge.
func (m *OrderItemShipGroupMutation) ResetOrderItemShipGrpInvRes() {
	m.order_item_ship_grp_inv_res = nil
	m.clearedorder_item_ship_grp_inv_res = false
	m.removedorder_item_ship_grp_inv_res = nil
}

// AddOrderPaymentPreferenceIDs adds the "order_payment_preferences" edge to the OrderPaymentPreference entity by ids.
func (m *OrderItemShipGroupMutation) AddOrderPaymentPreferenceIDs(ids ...int) {
	if m.order_payment_preferences == nil {
		m.order_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.order_payment_preferences[ids[i]] = struct{}{}
	}
}

// ClearOrderPaymentPreferences clears the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *OrderItemShipGroupMutation) ClearOrderPaymentPreferences() {
	m.clearedorder_payment_preferences = true
}

// OrderPaymentPreferencesCleared reports if the "order_payment_preferences" edge to the OrderPaymentPreference entity was cleared.
func (m *OrderItemShipGroupMutation) OrderPaymentPreferencesCleared() bool {
	return m.clearedorder_payment_preferences
}

// RemoveOrderPaymentPreferenceIDs removes the "order_payment_preferences" edge to the OrderPaymentPreference entity by IDs.
func (m *OrderItemShipGroupMutation) RemoveOrderPaymentPreferenceIDs(ids ...int) {
	if m.removedorder_payment_preferences == nil {
		m.removedorder_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_payment_preferences[ids[i]] = struct{}{}
	}
}

// RemovedOrderPaymentPreferences returns the removed IDs of the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *OrderItemShipGroupMutation) RemovedOrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.removedorder_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// OrderPaymentPreferencesIDs returns the "order_payment_preferences" edge IDs in the mutation.
func (m *OrderItemShipGroupMutation) OrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.order_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// ResetOrderPaymentPreferences resets all changes to the "order_payment_preferences" edge.
func (m *OrderItemShipGroupMutation) ResetOrderPaymentPreferences() {
	m.order_payment_preferences = nil
	m.clearedorder_payment_preferences = false
	m.removedorder_payment_preferences = nil
}

// Op returns the operation name.
func (m *OrderItemShipGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItemShipGroup).
func (m *OrderItemShipGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemShipGroupMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, orderitemshipgroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderitemshipgroup.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderitemshipgroup.FieldStringRef)
	}
	if m.ship_group_seq_id != nil {
		fields = append(fields, orderitemshipgroup.FieldShipGroupSeqID)
	}
	if m.shipment_method_type_id != nil {
		fields = append(fields, orderitemshipgroup.FieldShipmentMethodTypeID)
	}
	if m.supplier_party_id != nil {
		fields = append(fields, orderitemshipgroup.FieldSupplierPartyID)
	}
	if m.supplier_agreement_id != nil {
		fields = append(fields, orderitemshipgroup.FieldSupplierAgreementID)
	}
	if m.vendor_party_id != nil {
		fields = append(fields, orderitemshipgroup.FieldVendorPartyID)
	}
	if m.carrier_party_id != nil {
		fields = append(fields, orderitemshipgroup.FieldCarrierPartyID)
	}
	if m.carrier_role_type_id != nil {
		fields = append(fields, orderitemshipgroup.FieldCarrierRoleTypeID)
	}
	if m.facility_id != nil {
		fields = append(fields, orderitemshipgroup.FieldFacilityID)
	}
	if m.contact_mech_id != nil {
		fields = append(fields, orderitemshipgroup.FieldContactMechID)
	}
	if m.telecom_contact_mech_id != nil {
		fields = append(fields, orderitemshipgroup.FieldTelecomContactMechID)
	}
	if m.tracking_number != nil {
		fields = append(fields, orderitemshipgroup.FieldTrackingNumber)
	}
	if m.shipping_instructions != nil {
		fields = append(fields, orderitemshipgroup.FieldShippingInstructions)
	}
	if m.may_split != nil {
		fields = append(fields, orderitemshipgroup.FieldMaySplit)
	}
	if m.gift_message != nil {
		fields = append(fields, orderitemshipgroup.FieldGiftMessage)
	}
	if m.is_gift != nil {
		fields = append(fields, orderitemshipgroup.FieldIsGift)
	}
	if m.ship_after_date != nil {
		fields = append(fields, orderitemshipgroup.FieldShipAfterDate)
	}
	if m.ship_by_date != nil {
		fields = append(fields, orderitemshipgroup.FieldShipByDate)
	}
	if m.estimated_ship_date != nil {
		fields = append(fields, orderitemshipgroup.FieldEstimatedShipDate)
	}
	if m.estimated_delivery_date != nil {
		fields = append(fields, orderitemshipgroup.FieldEstimatedDeliveryDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemShipGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitemshipgroup.FieldCreateTime:
		return m.CreateTime()
	case orderitemshipgroup.FieldUpdateTime:
		return m.UpdateTime()
	case orderitemshipgroup.FieldStringRef:
		return m.StringRef()
	case orderitemshipgroup.FieldShipGroupSeqID:
		return m.ShipGroupSeqID()
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		return m.ShipmentMethodTypeID()
	case orderitemshipgroup.FieldSupplierPartyID:
		return m.SupplierPartyID()
	case orderitemshipgroup.FieldSupplierAgreementID:
		return m.SupplierAgreementID()
	case orderitemshipgroup.FieldVendorPartyID:
		return m.VendorPartyID()
	case orderitemshipgroup.FieldCarrierPartyID:
		return m.CarrierPartyID()
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		return m.CarrierRoleTypeID()
	case orderitemshipgroup.FieldFacilityID:
		return m.FacilityID()
	case orderitemshipgroup.FieldContactMechID:
		return m.ContactMechID()
	case orderitemshipgroup.FieldTelecomContactMechID:
		return m.TelecomContactMechID()
	case orderitemshipgroup.FieldTrackingNumber:
		return m.TrackingNumber()
	case orderitemshipgroup.FieldShippingInstructions:
		return m.ShippingInstructions()
	case orderitemshipgroup.FieldMaySplit:
		return m.MaySplit()
	case orderitemshipgroup.FieldGiftMessage:
		return m.GiftMessage()
	case orderitemshipgroup.FieldIsGift:
		return m.IsGift()
	case orderitemshipgroup.FieldShipAfterDate:
		return m.ShipAfterDate()
	case orderitemshipgroup.FieldShipByDate:
		return m.ShipByDate()
	case orderitemshipgroup.FieldEstimatedShipDate:
		return m.EstimatedShipDate()
	case orderitemshipgroup.FieldEstimatedDeliveryDate:
		return m.EstimatedDeliveryDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemShipGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitemshipgroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderitemshipgroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderitemshipgroup.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderitemshipgroup.FieldShipGroupSeqID:
		return m.OldShipGroupSeqID(ctx)
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		return m.OldShipmentMethodTypeID(ctx)
	case orderitemshipgroup.FieldSupplierPartyID:
		return m.OldSupplierPartyID(ctx)
	case orderitemshipgroup.FieldSupplierAgreementID:
		return m.OldSupplierAgreementID(ctx)
	case orderitemshipgroup.FieldVendorPartyID:
		return m.OldVendorPartyID(ctx)
	case orderitemshipgroup.FieldCarrierPartyID:
		return m.OldCarrierPartyID(ctx)
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		return m.OldCarrierRoleTypeID(ctx)
	case orderitemshipgroup.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case orderitemshipgroup.FieldContactMechID:
		return m.OldContactMechID(ctx)
	case orderitemshipgroup.FieldTelecomContactMechID:
		return m.OldTelecomContactMechID(ctx)
	case orderitemshipgroup.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case orderitemshipgroup.FieldShippingInstructions:
		return m.OldShippingInstructions(ctx)
	case orderitemshipgroup.FieldMaySplit:
		return m.OldMaySplit(ctx)
	case orderitemshipgroup.FieldGiftMessage:
		return m.OldGiftMessage(ctx)
	case orderitemshipgroup.FieldIsGift:
		return m.OldIsGift(ctx)
	case orderitemshipgroup.FieldShipAfterDate:
		return m.OldShipAfterDate(ctx)
	case orderitemshipgroup.FieldShipByDate:
		return m.OldShipByDate(ctx)
	case orderitemshipgroup.FieldEstimatedShipDate:
		return m.OldEstimatedShipDate(ctx)
	case orderitemshipgroup.FieldEstimatedDeliveryDate:
		return m.OldEstimatedDeliveryDate(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItemShipGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemShipGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitemshipgroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderitemshipgroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderitemshipgroup.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderitemshipgroup.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipGroupSeqID(v)
		return nil
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentMethodTypeID(v)
		return nil
	case orderitemshipgroup.FieldSupplierPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierPartyID(v)
		return nil
	case orderitemshipgroup.FieldSupplierAgreementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierAgreementID(v)
		return nil
	case orderitemshipgroup.FieldVendorPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorPartyID(v)
		return nil
	case orderitemshipgroup.FieldCarrierPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarrierPartyID(v)
		return nil
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarrierRoleTypeID(v)
		return nil
	case orderitemshipgroup.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case orderitemshipgroup.FieldContactMechID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactMechID(v)
		return nil
	case orderitemshipgroup.FieldTelecomContactMechID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelecomContactMechID(v)
		return nil
	case orderitemshipgroup.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case orderitemshipgroup.FieldShippingInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingInstructions(v)
		return nil
	case orderitemshipgroup.FieldMaySplit:
		v, ok := value.(orderitemshipgroup.MaySplit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaySplit(v)
		return nil
	case orderitemshipgroup.FieldGiftMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGiftMessage(v)
		return nil
	case orderitemshipgroup.FieldIsGift:
		v, ok := value.(orderitemshipgroup.IsGift)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGift(v)
		return nil
	case orderitemshipgroup.FieldShipAfterDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipAfterDate(v)
		return nil
	case orderitemshipgroup.FieldShipByDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipByDate(v)
		return nil
	case orderitemshipgroup.FieldEstimatedShipDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedShipDate(v)
		return nil
	case orderitemshipgroup.FieldEstimatedDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedDeliveryDate(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemShipGroupMutation) AddedFields() []string {
	var fields []string
	if m.addship_group_seq_id != nil {
		fields = append(fields, orderitemshipgroup.FieldShipGroupSeqID)
	}
	if m.addshipment_method_type_id != nil {
		fields = append(fields, orderitemshipgroup.FieldShipmentMethodTypeID)
	}
	if m.addsupplier_party_id != nil {
		fields = append(fields, orderitemshipgroup.FieldSupplierPartyID)
	}
	if m.addsupplier_agreement_id != nil {
		fields = append(fields, orderitemshipgroup.FieldSupplierAgreementID)
	}
	if m.addvendor_party_id != nil {
		fields = append(fields, orderitemshipgroup.FieldVendorPartyID)
	}
	if m.addcarrier_party_id != nil {
		fields = append(fields, orderitemshipgroup.FieldCarrierPartyID)
	}
	if m.addcarrier_role_type_id != nil {
		fields = append(fields, orderitemshipgroup.FieldCarrierRoleTypeID)
	}
	if m.addfacility_id != nil {
		fields = append(fields, orderitemshipgroup.FieldFacilityID)
	}
	if m.addcontact_mech_id != nil {
		fields = append(fields, orderitemshipgroup.FieldContactMechID)
	}
	if m.addtelecom_contact_mech_id != nil {
		fields = append(fields, orderitemshipgroup.FieldTelecomContactMechID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemShipGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitemshipgroup.FieldShipGroupSeqID:
		return m.AddedShipGroupSeqID()
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		return m.AddedShipmentMethodTypeID()
	case orderitemshipgroup.FieldSupplierPartyID:
		return m.AddedSupplierPartyID()
	case orderitemshipgroup.FieldSupplierAgreementID:
		return m.AddedSupplierAgreementID()
	case orderitemshipgroup.FieldVendorPartyID:
		return m.AddedVendorPartyID()
	case orderitemshipgroup.FieldCarrierPartyID:
		return m.AddedCarrierPartyID()
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		return m.AddedCarrierRoleTypeID()
	case orderitemshipgroup.FieldFacilityID:
		return m.AddedFacilityID()
	case orderitemshipgroup.FieldContactMechID:
		return m.AddedContactMechID()
	case orderitemshipgroup.FieldTelecomContactMechID:
		return m.AddedTelecomContactMechID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemShipGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitemshipgroup.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipGroupSeqID(v)
		return nil
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentMethodTypeID(v)
		return nil
	case orderitemshipgroup.FieldSupplierPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupplierPartyID(v)
		return nil
	case orderitemshipgroup.FieldSupplierAgreementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupplierAgreementID(v)
		return nil
	case orderitemshipgroup.FieldVendorPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVendorPartyID(v)
		return nil
	case orderitemshipgroup.FieldCarrierPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarrierPartyID(v)
		return nil
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarrierRoleTypeID(v)
		return nil
	case orderitemshipgroup.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFacilityID(v)
		return nil
	case orderitemshipgroup.FieldContactMechID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContactMechID(v)
		return nil
	case orderitemshipgroup.FieldTelecomContactMechID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTelecomContactMechID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemShipGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitemshipgroup.FieldStringRef) {
		fields = append(fields, orderitemshipgroup.FieldStringRef)
	}
	if m.FieldCleared(orderitemshipgroup.FieldShipmentMethodTypeID) {
		fields = append(fields, orderitemshipgroup.FieldShipmentMethodTypeID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldSupplierPartyID) {
		fields = append(fields, orderitemshipgroup.FieldSupplierPartyID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldSupplierAgreementID) {
		fields = append(fields, orderitemshipgroup.FieldSupplierAgreementID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldVendorPartyID) {
		fields = append(fields, orderitemshipgroup.FieldVendorPartyID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldCarrierPartyID) {
		fields = append(fields, orderitemshipgroup.FieldCarrierPartyID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldCarrierRoleTypeID) {
		fields = append(fields, orderitemshipgroup.FieldCarrierRoleTypeID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldFacilityID) {
		fields = append(fields, orderitemshipgroup.FieldFacilityID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldContactMechID) {
		fields = append(fields, orderitemshipgroup.FieldContactMechID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldTelecomContactMechID) {
		fields = append(fields, orderitemshipgroup.FieldTelecomContactMechID)
	}
	if m.FieldCleared(orderitemshipgroup.FieldTrackingNumber) {
		fields = append(fields, orderitemshipgroup.FieldTrackingNumber)
	}
	if m.FieldCleared(orderitemshipgroup.FieldShippingInstructions) {
		fields = append(fields, orderitemshipgroup.FieldShippingInstructions)
	}
	if m.FieldCleared(orderitemshipgroup.FieldMaySplit) {
		fields = append(fields, orderitemshipgroup.FieldMaySplit)
	}
	if m.FieldCleared(orderitemshipgroup.FieldGiftMessage) {
		fields = append(fields, orderitemshipgroup.FieldGiftMessage)
	}
	if m.FieldCleared(orderitemshipgroup.FieldIsGift) {
		fields = append(fields, orderitemshipgroup.FieldIsGift)
	}
	if m.FieldCleared(orderitemshipgroup.FieldShipAfterDate) {
		fields = append(fields, orderitemshipgroup.FieldShipAfterDate)
	}
	if m.FieldCleared(orderitemshipgroup.FieldShipByDate) {
		fields = append(fields, orderitemshipgroup.FieldShipByDate)
	}
	if m.FieldCleared(orderitemshipgroup.FieldEstimatedShipDate) {
		fields = append(fields, orderitemshipgroup.FieldEstimatedShipDate)
	}
	if m.FieldCleared(orderitemshipgroup.FieldEstimatedDeliveryDate) {
		fields = append(fields, orderitemshipgroup.FieldEstimatedDeliveryDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemShipGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemShipGroupMutation) ClearField(name string) error {
	switch name {
	case orderitemshipgroup.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		m.ClearShipmentMethodTypeID()
		return nil
	case orderitemshipgroup.FieldSupplierPartyID:
		m.ClearSupplierPartyID()
		return nil
	case orderitemshipgroup.FieldSupplierAgreementID:
		m.ClearSupplierAgreementID()
		return nil
	case orderitemshipgroup.FieldVendorPartyID:
		m.ClearVendorPartyID()
		return nil
	case orderitemshipgroup.FieldCarrierPartyID:
		m.ClearCarrierPartyID()
		return nil
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		m.ClearCarrierRoleTypeID()
		return nil
	case orderitemshipgroup.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case orderitemshipgroup.FieldContactMechID:
		m.ClearContactMechID()
		return nil
	case orderitemshipgroup.FieldTelecomContactMechID:
		m.ClearTelecomContactMechID()
		return nil
	case orderitemshipgroup.FieldTrackingNumber:
		m.ClearTrackingNumber()
		return nil
	case orderitemshipgroup.FieldShippingInstructions:
		m.ClearShippingInstructions()
		return nil
	case orderitemshipgroup.FieldMaySplit:
		m.ClearMaySplit()
		return nil
	case orderitemshipgroup.FieldGiftMessage:
		m.ClearGiftMessage()
		return nil
	case orderitemshipgroup.FieldIsGift:
		m.ClearIsGift()
		return nil
	case orderitemshipgroup.FieldShipAfterDate:
		m.ClearShipAfterDate()
		return nil
	case orderitemshipgroup.FieldShipByDate:
		m.ClearShipByDate()
		return nil
	case orderitemshipgroup.FieldEstimatedShipDate:
		m.ClearEstimatedShipDate()
		return nil
	case orderitemshipgroup.FieldEstimatedDeliveryDate:
		m.ClearEstimatedDeliveryDate()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemShipGroupMutation) ResetField(name string) error {
	switch name {
	case orderitemshipgroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderitemshipgroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderitemshipgroup.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderitemshipgroup.FieldShipGroupSeqID:
		m.ResetShipGroupSeqID()
		return nil
	case orderitemshipgroup.FieldShipmentMethodTypeID:
		m.ResetShipmentMethodTypeID()
		return nil
	case orderitemshipgroup.FieldSupplierPartyID:
		m.ResetSupplierPartyID()
		return nil
	case orderitemshipgroup.FieldSupplierAgreementID:
		m.ResetSupplierAgreementID()
		return nil
	case orderitemshipgroup.FieldVendorPartyID:
		m.ResetVendorPartyID()
		return nil
	case orderitemshipgroup.FieldCarrierPartyID:
		m.ResetCarrierPartyID()
		return nil
	case orderitemshipgroup.FieldCarrierRoleTypeID:
		m.ResetCarrierRoleTypeID()
		return nil
	case orderitemshipgroup.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case orderitemshipgroup.FieldContactMechID:
		m.ResetContactMechID()
		return nil
	case orderitemshipgroup.FieldTelecomContactMechID:
		m.ResetTelecomContactMechID()
		return nil
	case orderitemshipgroup.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case orderitemshipgroup.FieldShippingInstructions:
		m.ResetShippingInstructions()
		return nil
	case orderitemshipgroup.FieldMaySplit:
		m.ResetMaySplit()
		return nil
	case orderitemshipgroup.FieldGiftMessage:
		m.ResetGiftMessage()
		return nil
	case orderitemshipgroup.FieldIsGift:
		m.ResetIsGift()
		return nil
	case orderitemshipgroup.FieldShipAfterDate:
		m.ResetShipAfterDate()
		return nil
	case orderitemshipgroup.FieldShipByDate:
		m.ResetShipByDate()
		return nil
	case orderitemshipgroup.FieldEstimatedShipDate:
		m.ResetEstimatedShipDate()
		return nil
	case orderitemshipgroup.FieldEstimatedDeliveryDate:
		m.ResetEstimatedDeliveryDate()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemShipGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.order_header != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderHeader)
	}
	if m.order_adjustments != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderAdjustments)
	}
	if m.order_item_ship_group_assocs != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderItemShipGroupAssocs)
	}
	if m.order_item_ship_grp_inv_res != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderItemShipGrpInvRes)
	}
	if m.order_payment_preferences != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderPaymentPreferences)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemShipGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitemshipgroup.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgroup.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.order_adjustments))
		for id := range m.order_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroup.EdgeOrderItemShipGroupAssocs:
		ids := make([]ent.Value, 0, len(m.order_item_ship_group_assocs))
		for id := range m.order_item_ship_group_assocs {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroup.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.order_item_ship_grp_inv_res))
		for id := range m.order_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroup.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.order_payment_preferences))
		for id := range m.order_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemShipGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedorder_adjustments != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderAdjustments)
	}
	if m.removedorder_item_ship_group_assocs != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderItemShipGroupAssocs)
	}
	if m.removedorder_item_ship_grp_inv_res != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderItemShipGrpInvRes)
	}
	if m.removedorder_payment_preferences != nil {
		edges = append(edges, orderitemshipgroup.EdgeOrderPaymentPreferences)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemShipGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitemshipgroup.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.removedorder_adjustments))
		for id := range m.removedorder_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroup.EdgeOrderItemShipGroupAssocs:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_group_assocs))
		for id := range m.removedorder_item_ship_group_assocs {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroup.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_grp_inv_res))
		for id := range m.removedorder_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroup.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.removedorder_payment_preferences))
		for id := range m.removedorder_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemShipGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedorder_header {
		edges = append(edges, orderitemshipgroup.EdgeOrderHeader)
	}
	if m.clearedorder_adjustments {
		edges = append(edges, orderitemshipgroup.EdgeOrderAdjustments)
	}
	if m.clearedorder_item_ship_group_assocs {
		edges = append(edges, orderitemshipgroup.EdgeOrderItemShipGroupAssocs)
	}
	if m.clearedorder_item_ship_grp_inv_res {
		edges = append(edges, orderitemshipgroup.EdgeOrderItemShipGrpInvRes)
	}
	if m.clearedorder_payment_preferences {
		edges = append(edges, orderitemshipgroup.EdgeOrderPaymentPreferences)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemShipGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitemshipgroup.EdgeOrderHeader:
		return m.clearedorder_header
	case orderitemshipgroup.EdgeOrderAdjustments:
		return m.clearedorder_adjustments
	case orderitemshipgroup.EdgeOrderItemShipGroupAssocs:
		return m.clearedorder_item_ship_group_assocs
	case orderitemshipgroup.EdgeOrderItemShipGrpInvRes:
		return m.clearedorder_item_ship_grp_inv_res
	case orderitemshipgroup.EdgeOrderPaymentPreferences:
		return m.clearedorder_payment_preferences
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemShipGroupMutation) ClearEdge(name string) error {
	switch name {
	case orderitemshipgroup.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemShipGroupMutation) ResetEdge(name string) error {
	switch name {
	case orderitemshipgroup.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderitemshipgroup.EdgeOrderAdjustments:
		m.ResetOrderAdjustments()
		return nil
	case orderitemshipgroup.EdgeOrderItemShipGroupAssocs:
		m.ResetOrderItemShipGroupAssocs()
		return nil
	case orderitemshipgroup.EdgeOrderItemShipGrpInvRes:
		m.ResetOrderItemShipGrpInvRes()
		return nil
	case orderitemshipgroup.EdgeOrderPaymentPreferences:
		m.ResetOrderPaymentPreferences()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroup edge %s", name)
}

// OrderItemShipGroupAssocMutation represents an operation that mutates the OrderItemShipGroupAssoc nodes in the graph.
type OrderItemShipGroupAssocMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	string_ref                         *string
	order_item_seq_id                  *int
	addorder_item_seq_id               *int
	ship_group_seq_id                  *int
	addship_group_seq_id               *int
	quantity                           *float64
	addquantity                        *float64
	cancel_quantity                    *float64
	addcancel_quantity                 *float64
	clearedFields                      map[string]struct{}
	order_header                       *int
	clearedorder_header                bool
	order_item                         *int
	clearedorder_item                  bool
	order_item_ship_group              *int
	clearedorder_item_ship_group       bool
	order_adjustments                  map[int]struct{}
	removedorder_adjustments           map[int]struct{}
	clearedorder_adjustments           bool
	order_item_ship_grp_inv_res        map[int]struct{}
	removedorder_item_ship_grp_inv_res map[int]struct{}
	clearedorder_item_ship_grp_inv_res bool
	done                               bool
	oldValue                           func(context.Context) (*OrderItemShipGroupAssoc, error)
	predicates                         []predicate.OrderItemShipGroupAssoc
}

var _ ent.Mutation = (*OrderItemShipGroupAssocMutation)(nil)

// orderitemshipgroupassocOption allows management of the mutation configuration using functional options.
type orderitemshipgroupassocOption func(*OrderItemShipGroupAssocMutation)

// newOrderItemShipGroupAssocMutation creates new mutation for the OrderItemShipGroupAssoc entity.
func newOrderItemShipGroupAssocMutation(c config, op Op, opts ...orderitemshipgroupassocOption) *OrderItemShipGroupAssocMutation {
	m := &OrderItemShipGroupAssocMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItemShipGroupAssoc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemShipGroupAssocID sets the ID field of the mutation.
func withOrderItemShipGroupAssocID(id int) orderitemshipgroupassocOption {
	return func(m *OrderItemShipGroupAssocMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItemShipGroupAssoc
		)
		m.oldValue = func(ctx context.Context) (*OrderItemShipGroupAssoc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItemShipGroupAssoc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItemShipGroupAssoc sets the old OrderItemShipGroupAssoc of the mutation.
func withOrderItemShipGroupAssoc(node *OrderItemShipGroupAssoc) orderitemshipgroupassocOption {
	return func(m *OrderItemShipGroupAssocMutation) {
		m.oldValue = func(context.Context) (*OrderItemShipGroupAssoc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemShipGroupAssocMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemShipGroupAssocMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemShipGroupAssocMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderItemShipGroupAssocMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderItemShipGroupAssocMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderItemShipGroupAssocMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderItemShipGroupAssocMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderItemShipGroupAssocMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderItemShipGroupAssocMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderitemshipgroupassoc.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderItemShipGroupAssocMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroupassoc.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderItemShipGroupAssocMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderitemshipgroupassoc.FieldStringRef)
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *OrderItemShipGroupAssocMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *OrderItemShipGroupAssocMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *OrderItemShipGroupAssocMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
}

// SetShipGroupSeqID sets the "ship_group_seq_id" field.
func (m *OrderItemShipGroupAssocMutation) SetShipGroupSeqID(i int) {
	m.ship_group_seq_id = &i
	m.addship_group_seq_id = nil
}

// ShipGroupSeqID returns the value of the "ship_group_seq_id" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) ShipGroupSeqID() (r int, exists bool) {
	v := m.ship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipGroupSeqID returns the old "ship_group_seq_id" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldShipGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipGroupSeqID: %w", err)
	}
	return oldValue.ShipGroupSeqID, nil
}

// AddShipGroupSeqID adds i to the "ship_group_seq_id" field.
func (m *OrderItemShipGroupAssocMutation) AddShipGroupSeqID(i int) {
	if m.addship_group_seq_id != nil {
		*m.addship_group_seq_id += i
	} else {
		m.addship_group_seq_id = &i
	}
}

// AddedShipGroupSeqID returns the value that was added to the "ship_group_seq_id" field in this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedShipGroupSeqID() (r int, exists bool) {
	v := m.addship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetShipGroupSeqID resets all changes to the "ship_group_seq_id" field.
func (m *OrderItemShipGroupAssocMutation) ResetShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemShipGroupAssocMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *OrderItemShipGroupAssocMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *OrderItemShipGroupAssocMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[orderitemshipgroupassoc.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *OrderItemShipGroupAssocMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroupassoc.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemShipGroupAssocMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, orderitemshipgroupassoc.FieldQuantity)
}

// SetCancelQuantity sets the "cancel_quantity" field.
func (m *OrderItemShipGroupAssocMutation) SetCancelQuantity(f float64) {
	m.cancel_quantity = &f
	m.addcancel_quantity = nil
}

// CancelQuantity returns the value of the "cancel_quantity" field in the mutation.
func (m *OrderItemShipGroupAssocMutation) CancelQuantity() (r float64, exists bool) {
	v := m.cancel_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelQuantity returns the old "cancel_quantity" field's value of the OrderItemShipGroupAssoc entity.
// If the OrderItemShipGroupAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGroupAssocMutation) OldCancelQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCancelQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCancelQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelQuantity: %w", err)
	}
	return oldValue.CancelQuantity, nil
}

// AddCancelQuantity adds f to the "cancel_quantity" field.
func (m *OrderItemShipGroupAssocMutation) AddCancelQuantity(f float64) {
	if m.addcancel_quantity != nil {
		*m.addcancel_quantity += f
	} else {
		m.addcancel_quantity = &f
	}
}

// AddedCancelQuantity returns the value that was added to the "cancel_quantity" field in this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedCancelQuantity() (r float64, exists bool) {
	v := m.addcancel_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearCancelQuantity clears the value of the "cancel_quantity" field.
func (m *OrderItemShipGroupAssocMutation) ClearCancelQuantity() {
	m.cancel_quantity = nil
	m.addcancel_quantity = nil
	m.clearedFields[orderitemshipgroupassoc.FieldCancelQuantity] = struct{}{}
}

// CancelQuantityCleared returns if the "cancel_quantity" field was cleared in this mutation.
func (m *OrderItemShipGroupAssocMutation) CancelQuantityCleared() bool {
	_, ok := m.clearedFields[orderitemshipgroupassoc.FieldCancelQuantity]
	return ok
}

// ResetCancelQuantity resets all changes to the "cancel_quantity" field.
func (m *OrderItemShipGroupAssocMutation) ResetCancelQuantity() {
	m.cancel_quantity = nil
	m.addcancel_quantity = nil
	delete(m.clearedFields, orderitemshipgroupassoc.FieldCancelQuantity)
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderItemShipGroupAssocMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderItemShipGroupAssocMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderItemShipGroupAssocMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderItemShipGroupAssocMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGroupAssocMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderItemShipGroupAssocMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetOrderItemID sets the "order_item" edge to the OrderItem entity by id.
func (m *OrderItemShipGroupAssocMutation) SetOrderItemID(id int) {
	m.order_item = &id
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *OrderItemShipGroupAssocMutation) ClearOrderItem() {
	m.clearedorder_item = true
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *OrderItemShipGroupAssocMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemID returns the "order_item" edge ID in the mutation.
func (m *OrderItemShipGroupAssocMutation) OrderItemID() (id int, exists bool) {
	if m.order_item != nil {
		return *m.order_item, true
	}
	return
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGroupAssocMutation) OrderItemIDs() (ids []int) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *OrderItemShipGroupAssocMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// SetOrderItemShipGroupID sets the "order_item_ship_group" edge to the OrderItemShipGroup entity by id.
func (m *OrderItemShipGroupAssocMutation) SetOrderItemShipGroupID(id int) {
	m.order_item_ship_group = &id
}

// ClearOrderItemShipGroup clears the "order_item_ship_group" edge to the OrderItemShipGroup entity.
func (m *OrderItemShipGroupAssocMutation) ClearOrderItemShipGroup() {
	m.clearedorder_item_ship_group = true
}

// OrderItemShipGroupCleared reports if the "order_item_ship_group" edge to the OrderItemShipGroup entity was cleared.
func (m *OrderItemShipGroupAssocMutation) OrderItemShipGroupCleared() bool {
	return m.clearedorder_item_ship_group
}

// OrderItemShipGroupID returns the "order_item_ship_group" edge ID in the mutation.
func (m *OrderItemShipGroupAssocMutation) OrderItemShipGroupID() (id int, exists bool) {
	if m.order_item_ship_group != nil {
		return *m.order_item_ship_group, true
	}
	return
}

// OrderItemShipGroupIDs returns the "order_item_ship_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGroupID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGroupAssocMutation) OrderItemShipGroupIDs() (ids []int) {
	if id := m.order_item_ship_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGroup resets all changes to the "order_item_ship_group" edge.
func (m *OrderItemShipGroupAssocMutation) ResetOrderItemShipGroup() {
	m.order_item_ship_group = nil
	m.clearedorder_item_ship_group = false
}

// AddOrderAdjustmentIDs adds the "order_adjustments" edge to the OrderAdjustment entity by ids.
func (m *OrderItemShipGroupAssocMutation) AddOrderAdjustmentIDs(ids ...int) {
	if m.order_adjustments == nil {
		m.order_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.order_adjustments[ids[i]] = struct{}{}
	}
}

// ClearOrderAdjustments clears the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderItemShipGroupAssocMutation) ClearOrderAdjustments() {
	m.clearedorder_adjustments = true
}

// OrderAdjustmentsCleared reports if the "order_adjustments" edge to the OrderAdjustment entity was cleared.
func (m *OrderItemShipGroupAssocMutation) OrderAdjustmentsCleared() bool {
	return m.clearedorder_adjustments
}

// RemoveOrderAdjustmentIDs removes the "order_adjustments" edge to the OrderAdjustment entity by IDs.
func (m *OrderItemShipGroupAssocMutation) RemoveOrderAdjustmentIDs(ids ...int) {
	if m.removedorder_adjustments == nil {
		m.removedorder_adjustments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_adjustments[ids[i]] = struct{}{}
	}
}

// RemovedOrderAdjustments returns the removed IDs of the "order_adjustments" edge to the OrderAdjustment entity.
func (m *OrderItemShipGroupAssocMutation) RemovedOrderAdjustmentsIDs() (ids []int) {
	for id := range m.removedorder_adjustments {
		ids = append(ids, id)
	}
	return
}

// OrderAdjustmentsIDs returns the "order_adjustments" edge IDs in the mutation.
func (m *OrderItemShipGroupAssocMutation) OrderAdjustmentsIDs() (ids []int) {
	for id := range m.order_adjustments {
		ids = append(ids, id)
	}
	return
}

// ResetOrderAdjustments resets all changes to the "order_adjustments" edge.
func (m *OrderItemShipGroupAssocMutation) ResetOrderAdjustments() {
	m.order_adjustments = nil
	m.clearedorder_adjustments = false
	m.removedorder_adjustments = nil
}

// AddOrderItemShipGrpInvReIDs adds the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by ids.
func (m *OrderItemShipGroupAssocMutation) AddOrderItemShipGrpInvReIDs(ids ...int) {
	if m.order_item_ship_grp_inv_res == nil {
		m.order_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.order_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// ClearOrderItemShipGrpInvRes clears the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderItemShipGroupAssocMutation) ClearOrderItemShipGrpInvRes() {
	m.clearedorder_item_ship_grp_inv_res = true
}

// OrderItemShipGrpInvResCleared reports if the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity was cleared.
func (m *OrderItemShipGroupAssocMutation) OrderItemShipGrpInvResCleared() bool {
	return m.clearedorder_item_ship_grp_inv_res
}

// RemoveOrderItemShipGrpInvReIDs removes the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity by IDs.
func (m *OrderItemShipGroupAssocMutation) RemoveOrderItemShipGrpInvReIDs(ids ...int) {
	if m.removedorder_item_ship_grp_inv_res == nil {
		m.removedorder_item_ship_grp_inv_res = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_item_ship_grp_inv_res[ids[i]] = struct{}{}
	}
}

// RemovedOrderItemShipGrpInvRes returns the removed IDs of the "order_item_ship_grp_inv_res" edge to the OrderItemShipGrpInvRes entity.
func (m *OrderItemShipGroupAssocMutation) RemovedOrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.removedorder_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// OrderItemShipGrpInvResIDs returns the "order_item_ship_grp_inv_res" edge IDs in the mutation.
func (m *OrderItemShipGroupAssocMutation) OrderItemShipGrpInvResIDs() (ids []int) {
	for id := range m.order_item_ship_grp_inv_res {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItemShipGrpInvRes resets all changes to the "order_item_ship_grp_inv_res" edge.
func (m *OrderItemShipGroupAssocMutation) ResetOrderItemShipGrpInvRes() {
	m.order_item_ship_grp_inv_res = nil
	m.clearedorder_item_ship_grp_inv_res = false
	m.removedorder_item_ship_grp_inv_res = nil
}

// Op returns the operation name.
func (m *OrderItemShipGroupAssocMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItemShipGroupAssoc).
func (m *OrderItemShipGroupAssocMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemShipGroupAssocMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldStringRef)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldOrderItemSeqID)
	}
	if m.ship_group_seq_id != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldShipGroupSeqID)
	}
	if m.quantity != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldQuantity)
	}
	if m.cancel_quantity != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldCancelQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemShipGroupAssocMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitemshipgroupassoc.FieldCreateTime:
		return m.CreateTime()
	case orderitemshipgroupassoc.FieldUpdateTime:
		return m.UpdateTime()
	case orderitemshipgroupassoc.FieldStringRef:
		return m.StringRef()
	case orderitemshipgroupassoc.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case orderitemshipgroupassoc.FieldShipGroupSeqID:
		return m.ShipGroupSeqID()
	case orderitemshipgroupassoc.FieldQuantity:
		return m.Quantity()
	case orderitemshipgroupassoc.FieldCancelQuantity:
		return m.CancelQuantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemShipGroupAssocMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitemshipgroupassoc.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderitemshipgroupassoc.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderitemshipgroupassoc.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderitemshipgroupassoc.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case orderitemshipgroupassoc.FieldShipGroupSeqID:
		return m.OldShipGroupSeqID(ctx)
	case orderitemshipgroupassoc.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitemshipgroupassoc.FieldCancelQuantity:
		return m.OldCancelQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItemShipGroupAssoc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemShipGroupAssocMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitemshipgroupassoc.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderitemshipgroupassoc.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderitemshipgroupassoc.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderitemshipgroupassoc.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case orderitemshipgroupassoc.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipGroupSeqID(v)
		return nil
	case orderitemshipgroupassoc.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitemshipgroupassoc.FieldCancelQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroupAssoc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedFields() []string {
	var fields []string
	if m.addorder_item_seq_id != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldOrderItemSeqID)
	}
	if m.addship_group_seq_id != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldShipGroupSeqID)
	}
	if m.addquantity != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldQuantity)
	}
	if m.addcancel_quantity != nil {
		fields = append(fields, orderitemshipgroupassoc.FieldCancelQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemShipGroupAssocMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitemshipgroupassoc.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	case orderitemshipgroupassoc.FieldShipGroupSeqID:
		return m.AddedShipGroupSeqID()
	case orderitemshipgroupassoc.FieldQuantity:
		return m.AddedQuantity()
	case orderitemshipgroupassoc.FieldCancelQuantity:
		return m.AddedCancelQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemShipGroupAssocMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitemshipgroupassoc.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	case orderitemshipgroupassoc.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipGroupSeqID(v)
		return nil
	case orderitemshipgroupassoc.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderitemshipgroupassoc.FieldCancelQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCancelQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroupAssoc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemShipGroupAssocMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitemshipgroupassoc.FieldStringRef) {
		fields = append(fields, orderitemshipgroupassoc.FieldStringRef)
	}
	if m.FieldCleared(orderitemshipgroupassoc.FieldQuantity) {
		fields = append(fields, orderitemshipgroupassoc.FieldQuantity)
	}
	if m.FieldCleared(orderitemshipgroupassoc.FieldCancelQuantity) {
		fields = append(fields, orderitemshipgroupassoc.FieldCancelQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemShipGroupAssocMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemShipGroupAssocMutation) ClearField(name string) error {
	switch name {
	case orderitemshipgroupassoc.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderitemshipgroupassoc.FieldQuantity:
		m.ClearQuantity()
		return nil
	case orderitemshipgroupassoc.FieldCancelQuantity:
		m.ClearCancelQuantity()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroupAssoc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemShipGroupAssocMutation) ResetField(name string) error {
	switch name {
	case orderitemshipgroupassoc.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderitemshipgroupassoc.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderitemshipgroupassoc.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderitemshipgroupassoc.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case orderitemshipgroupassoc.FieldShipGroupSeqID:
		m.ResetShipGroupSeqID()
		return nil
	case orderitemshipgroupassoc.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitemshipgroupassoc.FieldCancelQuantity:
		m.ResetCancelQuantity()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroupAssoc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.order_header != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderHeader)
	}
	if m.order_item != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItem)
	}
	if m.order_item_ship_group != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItemShipGroup)
	}
	if m.order_adjustments != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderAdjustments)
	}
	if m.order_item_ship_grp_inv_res != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemShipGroupAssocMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitemshipgroupassoc.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgroupassoc.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgroupassoc.EdgeOrderItemShipGroup:
		if id := m.order_item_ship_group; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgroupassoc.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.order_adjustments))
		for id := range m.order_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.order_item_ship_grp_inv_res))
		for id := range m.order_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemShipGroupAssocMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedorder_adjustments != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderAdjustments)
	}
	if m.removedorder_item_ship_grp_inv_res != nil {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemShipGroupAssocMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitemshipgroupassoc.EdgeOrderAdjustments:
		ids := make([]ent.Value, 0, len(m.removedorder_adjustments))
		for id := range m.removedorder_adjustments {
			ids = append(ids, id)
		}
		return ids
	case orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes:
		ids := make([]ent.Value, 0, len(m.removedorder_item_ship_grp_inv_res))
		for id := range m.removedorder_item_ship_grp_inv_res {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemShipGroupAssocMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedorder_header {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderHeader)
	}
	if m.clearedorder_item {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItem)
	}
	if m.clearedorder_item_ship_group {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItemShipGroup)
	}
	if m.clearedorder_adjustments {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderAdjustments)
	}
	if m.clearedorder_item_ship_grp_inv_res {
		edges = append(edges, orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemShipGroupAssocMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitemshipgroupassoc.EdgeOrderHeader:
		return m.clearedorder_header
	case orderitemshipgroupassoc.EdgeOrderItem:
		return m.clearedorder_item
	case orderitemshipgroupassoc.EdgeOrderItemShipGroup:
		return m.clearedorder_item_ship_group
	case orderitemshipgroupassoc.EdgeOrderAdjustments:
		return m.clearedorder_adjustments
	case orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes:
		return m.clearedorder_item_ship_grp_inv_res
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemShipGroupAssocMutation) ClearEdge(name string) error {
	switch name {
	case orderitemshipgroupassoc.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderitemshipgroupassoc.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	case orderitemshipgroupassoc.EdgeOrderItemShipGroup:
		m.ClearOrderItemShipGroup()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroupAssoc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemShipGroupAssocMutation) ResetEdge(name string) error {
	switch name {
	case orderitemshipgroupassoc.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderitemshipgroupassoc.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	case orderitemshipgroupassoc.EdgeOrderItemShipGroup:
		m.ResetOrderItemShipGroup()
		return nil
	case orderitemshipgroupassoc.EdgeOrderAdjustments:
		m.ResetOrderAdjustments()
		return nil
	case orderitemshipgroupassoc.EdgeOrderItemShipGrpInvRes:
		m.ResetOrderItemShipGrpInvRes()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGroupAssoc edge %s", name)
}

// OrderItemShipGrpInvResMutation represents an operation that mutates the OrderItemShipGrpInvRes nodes in the graph.
type OrderItemShipGrpInvResMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	string_ref                         *string
	ship_group_seq_id                  *int
	addship_group_seq_id               *int
	order_item_seq_id                  *int
	addorder_item_seq_id               *int
	inventory_item_id                  *int
	addinventory_item_id               *int
	reserve_order_enum_id              *int
	addreserve_order_enum_id           *int
	quantity                           *float64
	addquantity                        *float64
	quantity_not_available             *float64
	addquantity_not_available          *float64
	reserved_datetime                  *time.Time
	created_datetime                   *time.Time
	promised_datetime                  *time.Time
	current_promised_date              *time.Time
	priority                           *orderitemshipgrpinvres.Priority
	sequence_id                        *int
	addsequence_id                     *int
	old_pick_start_date                *time.Time
	clearedFields                      map[string]struct{}
	order_header                       *int
	clearedorder_header                bool
	order_item                         *int
	clearedorder_item                  bool
	order_item_ship_group              *int
	clearedorder_item_ship_group       bool
	order_item_ship_group_assoc        *int
	clearedorder_item_ship_group_assoc bool
	inventory_item_details             map[int]struct{}
	removedinventory_item_details      map[int]struct{}
	clearedinventory_item_details      bool
	done                               bool
	oldValue                           func(context.Context) (*OrderItemShipGrpInvRes, error)
	predicates                         []predicate.OrderItemShipGrpInvRes
}

var _ ent.Mutation = (*OrderItemShipGrpInvResMutation)(nil)

// orderitemshipgrpinvresOption allows management of the mutation configuration using functional options.
type orderitemshipgrpinvresOption func(*OrderItemShipGrpInvResMutation)

// newOrderItemShipGrpInvResMutation creates new mutation for the OrderItemShipGrpInvRes entity.
func newOrderItemShipGrpInvResMutation(c config, op Op, opts ...orderitemshipgrpinvresOption) *OrderItemShipGrpInvResMutation {
	m := &OrderItemShipGrpInvResMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderItemShipGrpInvRes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderItemShipGrpInvResID sets the ID field of the mutation.
func withOrderItemShipGrpInvResID(id int) orderitemshipgrpinvresOption {
	return func(m *OrderItemShipGrpInvResMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderItemShipGrpInvRes
		)
		m.oldValue = func(ctx context.Context) (*OrderItemShipGrpInvRes, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderItemShipGrpInvRes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderItemShipGrpInvRes sets the old OrderItemShipGrpInvRes of the mutation.
func withOrderItemShipGrpInvRes(node *OrderItemShipGrpInvRes) orderitemshipgrpinvresOption {
	return func(m *OrderItemShipGrpInvResMutation) {
		m.oldValue = func(context.Context) (*OrderItemShipGrpInvRes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderItemShipGrpInvResMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderItemShipGrpInvResMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderItemShipGrpInvResMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderItemShipGrpInvResMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderItemShipGrpInvResMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderItemShipGrpInvResMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderItemShipGrpInvResMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderItemShipGrpInvResMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderItemShipGrpInvResMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderitemshipgrpinvres.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderItemShipGrpInvResMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldStringRef)
}

// SetShipGroupSeqID sets the "ship_group_seq_id" field.
func (m *OrderItemShipGrpInvResMutation) SetShipGroupSeqID(i int) {
	m.ship_group_seq_id = &i
	m.addship_group_seq_id = nil
}

// ShipGroupSeqID returns the value of the "ship_group_seq_id" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) ShipGroupSeqID() (r int, exists bool) {
	v := m.ship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipGroupSeqID returns the old "ship_group_seq_id" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldShipGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipGroupSeqID: %w", err)
	}
	return oldValue.ShipGroupSeqID, nil
}

// AddShipGroupSeqID adds i to the "ship_group_seq_id" field.
func (m *OrderItemShipGrpInvResMutation) AddShipGroupSeqID(i int) {
	if m.addship_group_seq_id != nil {
		*m.addship_group_seq_id += i
	} else {
		m.addship_group_seq_id = &i
	}
}

// AddedShipGroupSeqID returns the value that was added to the "ship_group_seq_id" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedShipGroupSeqID() (r int, exists bool) {
	v := m.addship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetShipGroupSeqID resets all changes to the "ship_group_seq_id" field.
func (m *OrderItemShipGrpInvResMutation) ResetShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *OrderItemShipGrpInvResMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *OrderItemShipGrpInvResMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *OrderItemShipGrpInvResMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
}

// SetInventoryItemID sets the "inventory_item_id" field.
func (m *OrderItemShipGrpInvResMutation) SetInventoryItemID(i int) {
	m.inventory_item_id = &i
	m.addinventory_item_id = nil
}

// InventoryItemID returns the value of the "inventory_item_id" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) InventoryItemID() (r int, exists bool) {
	v := m.inventory_item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryItemID returns the old "inventory_item_id" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldInventoryItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventoryItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventoryItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryItemID: %w", err)
	}
	return oldValue.InventoryItemID, nil
}

// AddInventoryItemID adds i to the "inventory_item_id" field.
func (m *OrderItemShipGrpInvResMutation) AddInventoryItemID(i int) {
	if m.addinventory_item_id != nil {
		*m.addinventory_item_id += i
	} else {
		m.addinventory_item_id = &i
	}
}

// AddedInventoryItemID returns the value that was added to the "inventory_item_id" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedInventoryItemID() (r int, exists bool) {
	v := m.addinventory_item_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetInventoryItemID resets all changes to the "inventory_item_id" field.
func (m *OrderItemShipGrpInvResMutation) ResetInventoryItemID() {
	m.inventory_item_id = nil
	m.addinventory_item_id = nil
}

// SetReserveOrderEnumID sets the "reserve_order_enum_id" field.
func (m *OrderItemShipGrpInvResMutation) SetReserveOrderEnumID(i int) {
	m.reserve_order_enum_id = &i
	m.addreserve_order_enum_id = nil
}

// ReserveOrderEnumID returns the value of the "reserve_order_enum_id" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) ReserveOrderEnumID() (r int, exists bool) {
	v := m.reserve_order_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReserveOrderEnumID returns the old "reserve_order_enum_id" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldReserveOrderEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReserveOrderEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReserveOrderEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserveOrderEnumID: %w", err)
	}
	return oldValue.ReserveOrderEnumID, nil
}

// AddReserveOrderEnumID adds i to the "reserve_order_enum_id" field.
func (m *OrderItemShipGrpInvResMutation) AddReserveOrderEnumID(i int) {
	if m.addreserve_order_enum_id != nil {
		*m.addreserve_order_enum_id += i
	} else {
		m.addreserve_order_enum_id = &i
	}
}

// AddedReserveOrderEnumID returns the value that was added to the "reserve_order_enum_id" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedReserveOrderEnumID() (r int, exists bool) {
	v := m.addreserve_order_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReserveOrderEnumID clears the value of the "reserve_order_enum_id" field.
func (m *OrderItemShipGrpInvResMutation) ClearReserveOrderEnumID() {
	m.reserve_order_enum_id = nil
	m.addreserve_order_enum_id = nil
	m.clearedFields[orderitemshipgrpinvres.FieldReserveOrderEnumID] = struct{}{}
}

// ReserveOrderEnumIDCleared returns if the "reserve_order_enum_id" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) ReserveOrderEnumIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldReserveOrderEnumID]
	return ok
}

// ResetReserveOrderEnumID resets all changes to the "reserve_order_enum_id" field.
func (m *OrderItemShipGrpInvResMutation) ResetReserveOrderEnumID() {
	m.reserve_order_enum_id = nil
	m.addreserve_order_enum_id = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldReserveOrderEnumID)
}

// SetQuantity sets the "quantity" field.
func (m *OrderItemShipGrpInvResMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *OrderItemShipGrpInvResMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *OrderItemShipGrpInvResMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[orderitemshipgrpinvres.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderItemShipGrpInvResMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldQuantity)
}

// SetQuantityNotAvailable sets the "quantity_not_available" field.
func (m *OrderItemShipGrpInvResMutation) SetQuantityNotAvailable(f float64) {
	m.quantity_not_available = &f
	m.addquantity_not_available = nil
}

// QuantityNotAvailable returns the value of the "quantity_not_available" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) QuantityNotAvailable() (r float64, exists bool) {
	v := m.quantity_not_available
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityNotAvailable returns the old "quantity_not_available" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldQuantityNotAvailable(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityNotAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityNotAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityNotAvailable: %w", err)
	}
	return oldValue.QuantityNotAvailable, nil
}

// AddQuantityNotAvailable adds f to the "quantity_not_available" field.
func (m *OrderItemShipGrpInvResMutation) AddQuantityNotAvailable(f float64) {
	if m.addquantity_not_available != nil {
		*m.addquantity_not_available += f
	} else {
		m.addquantity_not_available = &f
	}
}

// AddedQuantityNotAvailable returns the value that was added to the "quantity_not_available" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedQuantityNotAvailable() (r float64, exists bool) {
	v := m.addquantity_not_available
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityNotAvailable clears the value of the "quantity_not_available" field.
func (m *OrderItemShipGrpInvResMutation) ClearQuantityNotAvailable() {
	m.quantity_not_available = nil
	m.addquantity_not_available = nil
	m.clearedFields[orderitemshipgrpinvres.FieldQuantityNotAvailable] = struct{}{}
}

// QuantityNotAvailableCleared returns if the "quantity_not_available" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) QuantityNotAvailableCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldQuantityNotAvailable]
	return ok
}

// ResetQuantityNotAvailable resets all changes to the "quantity_not_available" field.
func (m *OrderItemShipGrpInvResMutation) ResetQuantityNotAvailable() {
	m.quantity_not_available = nil
	m.addquantity_not_available = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldQuantityNotAvailable)
}

// SetReservedDatetime sets the "reserved_datetime" field.
func (m *OrderItemShipGrpInvResMutation) SetReservedDatetime(t time.Time) {
	m.reserved_datetime = &t
}

// ReservedDatetime returns the value of the "reserved_datetime" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) ReservedDatetime() (r time.Time, exists bool) {
	v := m.reserved_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldReservedDatetime returns the old "reserved_datetime" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldReservedDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReservedDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReservedDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservedDatetime: %w", err)
	}
	return oldValue.ReservedDatetime, nil
}

// ClearReservedDatetime clears the value of the "reserved_datetime" field.
func (m *OrderItemShipGrpInvResMutation) ClearReservedDatetime() {
	m.reserved_datetime = nil
	m.clearedFields[orderitemshipgrpinvres.FieldReservedDatetime] = struct{}{}
}

// ReservedDatetimeCleared returns if the "reserved_datetime" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) ReservedDatetimeCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldReservedDatetime]
	return ok
}

// ResetReservedDatetime resets all changes to the "reserved_datetime" field.
func (m *OrderItemShipGrpInvResMutation) ResetReservedDatetime() {
	m.reserved_datetime = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldReservedDatetime)
}

// SetCreatedDatetime sets the "created_datetime" field.
func (m *OrderItemShipGrpInvResMutation) SetCreatedDatetime(t time.Time) {
	m.created_datetime = &t
}

// CreatedDatetime returns the value of the "created_datetime" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) CreatedDatetime() (r time.Time, exists bool) {
	v := m.created_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDatetime returns the old "created_datetime" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldCreatedDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDatetime: %w", err)
	}
	return oldValue.CreatedDatetime, nil
}

// ClearCreatedDatetime clears the value of the "created_datetime" field.
func (m *OrderItemShipGrpInvResMutation) ClearCreatedDatetime() {
	m.created_datetime = nil
	m.clearedFields[orderitemshipgrpinvres.FieldCreatedDatetime] = struct{}{}
}

// CreatedDatetimeCleared returns if the "created_datetime" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) CreatedDatetimeCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldCreatedDatetime]
	return ok
}

// ResetCreatedDatetime resets all changes to the "created_datetime" field.
func (m *OrderItemShipGrpInvResMutation) ResetCreatedDatetime() {
	m.created_datetime = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldCreatedDatetime)
}

// SetPromisedDatetime sets the "promised_datetime" field.
func (m *OrderItemShipGrpInvResMutation) SetPromisedDatetime(t time.Time) {
	m.promised_datetime = &t
}

// PromisedDatetime returns the value of the "promised_datetime" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) PromisedDatetime() (r time.Time, exists bool) {
	v := m.promised_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldPromisedDatetime returns the old "promised_datetime" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldPromisedDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPromisedDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPromisedDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromisedDatetime: %w", err)
	}
	return oldValue.PromisedDatetime, nil
}

// ClearPromisedDatetime clears the value of the "promised_datetime" field.
func (m *OrderItemShipGrpInvResMutation) ClearPromisedDatetime() {
	m.promised_datetime = nil
	m.clearedFields[orderitemshipgrpinvres.FieldPromisedDatetime] = struct{}{}
}

// PromisedDatetimeCleared returns if the "promised_datetime" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) PromisedDatetimeCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldPromisedDatetime]
	return ok
}

// ResetPromisedDatetime resets all changes to the "promised_datetime" field.
func (m *OrderItemShipGrpInvResMutation) ResetPromisedDatetime() {
	m.promised_datetime = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldPromisedDatetime)
}

// SetCurrentPromisedDate sets the "current_promised_date" field.
func (m *OrderItemShipGrpInvResMutation) SetCurrentPromisedDate(t time.Time) {
	m.current_promised_date = &t
}

// CurrentPromisedDate returns the value of the "current_promised_date" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) CurrentPromisedDate() (r time.Time, exists bool) {
	v := m.current_promised_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPromisedDate returns the old "current_promised_date" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldCurrentPromisedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrentPromisedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrentPromisedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPromisedDate: %w", err)
	}
	return oldValue.CurrentPromisedDate, nil
}

// ClearCurrentPromisedDate clears the value of the "current_promised_date" field.
func (m *OrderItemShipGrpInvResMutation) ClearCurrentPromisedDate() {
	m.current_promised_date = nil
	m.clearedFields[orderitemshipgrpinvres.FieldCurrentPromisedDate] = struct{}{}
}

// CurrentPromisedDateCleared returns if the "current_promised_date" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) CurrentPromisedDateCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldCurrentPromisedDate]
	return ok
}

// ResetCurrentPromisedDate resets all changes to the "current_promised_date" field.
func (m *OrderItemShipGrpInvResMutation) ResetCurrentPromisedDate() {
	m.current_promised_date = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldCurrentPromisedDate)
}

// SetPriority sets the "priority" field.
func (m *OrderItemShipGrpInvResMutation) SetPriority(o orderitemshipgrpinvres.Priority) {
	m.priority = &o
}

// Priority returns the value of the "priority" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) Priority() (r orderitemshipgrpinvres.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldPriority(ctx context.Context) (v orderitemshipgrpinvres.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ClearPriority clears the value of the "priority" field.
func (m *OrderItemShipGrpInvResMutation) ClearPriority() {
	m.priority = nil
	m.clearedFields[orderitemshipgrpinvres.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *OrderItemShipGrpInvResMutation) ResetPriority() {
	m.priority = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldPriority)
}

// SetSequenceID sets the "sequence_id" field.
func (m *OrderItemShipGrpInvResMutation) SetSequenceID(i int) {
	m.sequence_id = &i
	m.addsequence_id = nil
}

// SequenceID returns the value of the "sequence_id" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) SequenceID() (r int, exists bool) {
	v := m.sequence_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "sequence_id" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldSequenceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// AddSequenceID adds i to the "sequence_id" field.
func (m *OrderItemShipGrpInvResMutation) AddSequenceID(i int) {
	if m.addsequence_id != nil {
		*m.addsequence_id += i
	} else {
		m.addsequence_id = &i
	}
}

// AddedSequenceID returns the value that was added to the "sequence_id" field in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedSequenceID() (r int, exists bool) {
	v := m.addsequence_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceID clears the value of the "sequence_id" field.
func (m *OrderItemShipGrpInvResMutation) ClearSequenceID() {
	m.sequence_id = nil
	m.addsequence_id = nil
	m.clearedFields[orderitemshipgrpinvres.FieldSequenceID] = struct{}{}
}

// SequenceIDCleared returns if the "sequence_id" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) SequenceIDCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldSequenceID]
	return ok
}

// ResetSequenceID resets all changes to the "sequence_id" field.
func (m *OrderItemShipGrpInvResMutation) ResetSequenceID() {
	m.sequence_id = nil
	m.addsequence_id = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldSequenceID)
}

// SetOldPickStartDate sets the "old_pick_start_date" field.
func (m *OrderItemShipGrpInvResMutation) SetOldPickStartDate(t time.Time) {
	m.old_pick_start_date = &t
}

// OldPickStartDate returns the value of the "old_pick_start_date" field in the mutation.
func (m *OrderItemShipGrpInvResMutation) OldPickStartDate() (r time.Time, exists bool) {
	v := m.old_pick_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOldPickStartDate returns the old "old_pick_start_date" field's value of the OrderItemShipGrpInvRes entity.
// If the OrderItemShipGrpInvRes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderItemShipGrpInvResMutation) OldOldPickStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOldPickStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOldPickStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldPickStartDate: %w", err)
	}
	return oldValue.OldPickStartDate, nil
}

// ClearOldPickStartDate clears the value of the "old_pick_start_date" field.
func (m *OrderItemShipGrpInvResMutation) ClearOldPickStartDate() {
	m.old_pick_start_date = nil
	m.clearedFields[orderitemshipgrpinvres.FieldOldPickStartDate] = struct{}{}
}

// OldPickStartDateCleared returns if the "old_pick_start_date" field was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) OldPickStartDateCleared() bool {
	_, ok := m.clearedFields[orderitemshipgrpinvres.FieldOldPickStartDate]
	return ok
}

// ResetOldPickStartDate resets all changes to the "old_pick_start_date" field.
func (m *OrderItemShipGrpInvResMutation) ResetOldPickStartDate() {
	m.old_pick_start_date = nil
	delete(m.clearedFields, orderitemshipgrpinvres.FieldOldPickStartDate)
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderItemShipGrpInvResMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderItemShipGrpInvResMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderItemShipGrpInvResMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderItemShipGrpInvResMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGrpInvResMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderItemShipGrpInvResMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetOrderItemID sets the "order_item" edge to the OrderItem entity by id.
func (m *OrderItemShipGrpInvResMutation) SetOrderItemID(id int) {
	m.order_item = &id
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *OrderItemShipGrpInvResMutation) ClearOrderItem() {
	m.clearedorder_item = true
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *OrderItemShipGrpInvResMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemID returns the "order_item" edge ID in the mutation.
func (m *OrderItemShipGrpInvResMutation) OrderItemID() (id int, exists bool) {
	if m.order_item != nil {
		return *m.order_item, true
	}
	return
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGrpInvResMutation) OrderItemIDs() (ids []int) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *OrderItemShipGrpInvResMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// SetOrderItemShipGroupID sets the "order_item_ship_group" edge to the OrderItemShipGroup entity by id.
func (m *OrderItemShipGrpInvResMutation) SetOrderItemShipGroupID(id int) {
	m.order_item_ship_group = &id
}

// ClearOrderItemShipGroup clears the "order_item_ship_group" edge to the OrderItemShipGroup entity.
func (m *OrderItemShipGrpInvResMutation) ClearOrderItemShipGroup() {
	m.clearedorder_item_ship_group = true
}

// OrderItemShipGroupCleared reports if the "order_item_ship_group" edge to the OrderItemShipGroup entity was cleared.
func (m *OrderItemShipGrpInvResMutation) OrderItemShipGroupCleared() bool {
	return m.clearedorder_item_ship_group
}

// OrderItemShipGroupID returns the "order_item_ship_group" edge ID in the mutation.
func (m *OrderItemShipGrpInvResMutation) OrderItemShipGroupID() (id int, exists bool) {
	if m.order_item_ship_group != nil {
		return *m.order_item_ship_group, true
	}
	return
}

// OrderItemShipGroupIDs returns the "order_item_ship_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGroupID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGrpInvResMutation) OrderItemShipGroupIDs() (ids []int) {
	if id := m.order_item_ship_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGroup resets all changes to the "order_item_ship_group" edge.
func (m *OrderItemShipGrpInvResMutation) ResetOrderItemShipGroup() {
	m.order_item_ship_group = nil
	m.clearedorder_item_ship_group = false
}

// SetOrderItemShipGroupAssocID sets the "order_item_ship_group_assoc" edge to the OrderItemShipGroupAssoc entity by id.
func (m *OrderItemShipGrpInvResMutation) SetOrderItemShipGroupAssocID(id int) {
	m.order_item_ship_group_assoc = &id
}

// ClearOrderItemShipGroupAssoc clears the "order_item_ship_group_assoc" edge to the OrderItemShipGroupAssoc entity.
func (m *OrderItemShipGrpInvResMutation) ClearOrderItemShipGroupAssoc() {
	m.clearedorder_item_ship_group_assoc = true
}

// OrderItemShipGroupAssocCleared reports if the "order_item_ship_group_assoc" edge to the OrderItemShipGroupAssoc entity was cleared.
func (m *OrderItemShipGrpInvResMutation) OrderItemShipGroupAssocCleared() bool {
	return m.clearedorder_item_ship_group_assoc
}

// OrderItemShipGroupAssocID returns the "order_item_ship_group_assoc" edge ID in the mutation.
func (m *OrderItemShipGrpInvResMutation) OrderItemShipGroupAssocID() (id int, exists bool) {
	if m.order_item_ship_group_assoc != nil {
		return *m.order_item_ship_group_assoc, true
	}
	return
}

// OrderItemShipGroupAssocIDs returns the "order_item_ship_group_assoc" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGroupAssocID instead. It exists only for internal usage by the builders.
func (m *OrderItemShipGrpInvResMutation) OrderItemShipGroupAssocIDs() (ids []int) {
	if id := m.order_item_ship_group_assoc; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGroupAssoc resets all changes to the "order_item_ship_group_assoc" edge.
func (m *OrderItemShipGrpInvResMutation) ResetOrderItemShipGroupAssoc() {
	m.order_item_ship_group_assoc = nil
	m.clearedorder_item_ship_group_assoc = false
}

// AddInventoryItemDetailIDs adds the "inventory_item_details" edge to the InventoryItemDetail entity by ids.
func (m *OrderItemShipGrpInvResMutation) AddInventoryItemDetailIDs(ids ...int) {
	if m.inventory_item_details == nil {
		m.inventory_item_details = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_item_details[ids[i]] = struct{}{}
	}
}

// ClearInventoryItemDetails clears the "inventory_item_details" edge to the InventoryItemDetail entity.
func (m *OrderItemShipGrpInvResMutation) ClearInventoryItemDetails() {
	m.clearedinventory_item_details = true
}

// InventoryItemDetailsCleared reports if the "inventory_item_details" edge to the InventoryItemDetail entity was cleared.
func (m *OrderItemShipGrpInvResMutation) InventoryItemDetailsCleared() bool {
	return m.clearedinventory_item_details
}

// RemoveInventoryItemDetailIDs removes the "inventory_item_details" edge to the InventoryItemDetail entity by IDs.
func (m *OrderItemShipGrpInvResMutation) RemoveInventoryItemDetailIDs(ids ...int) {
	if m.removedinventory_item_details == nil {
		m.removedinventory_item_details = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinventory_item_details[ids[i]] = struct{}{}
	}
}

// RemovedInventoryItemDetails returns the removed IDs of the "inventory_item_details" edge to the InventoryItemDetail entity.
func (m *OrderItemShipGrpInvResMutation) RemovedInventoryItemDetailsIDs() (ids []int) {
	for id := range m.removedinventory_item_details {
		ids = append(ids, id)
	}
	return
}

// InventoryItemDetailsIDs returns the "inventory_item_details" edge IDs in the mutation.
func (m *OrderItemShipGrpInvResMutation) InventoryItemDetailsIDs() (ids []int) {
	for id := range m.inventory_item_details {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryItemDetails resets all changes to the "inventory_item_details" edge.
func (m *OrderItemShipGrpInvResMutation) ResetInventoryItemDetails() {
	m.inventory_item_details = nil
	m.clearedinventory_item_details = false
	m.removedinventory_item_details = nil
}

// Op returns the operation name.
func (m *OrderItemShipGrpInvResMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderItemShipGrpInvRes).
func (m *OrderItemShipGrpInvResMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderItemShipGrpInvResMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldStringRef)
	}
	if m.ship_group_seq_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldShipGroupSeqID)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldOrderItemSeqID)
	}
	if m.inventory_item_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldInventoryItemID)
	}
	if m.reserve_order_enum_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldReserveOrderEnumID)
	}
	if m.quantity != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldQuantity)
	}
	if m.quantity_not_available != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldQuantityNotAvailable)
	}
	if m.reserved_datetime != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldReservedDatetime)
	}
	if m.created_datetime != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldCreatedDatetime)
	}
	if m.promised_datetime != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldPromisedDatetime)
	}
	if m.current_promised_date != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldCurrentPromisedDate)
	}
	if m.priority != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldPriority)
	}
	if m.sequence_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldSequenceID)
	}
	if m.old_pick_start_date != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldOldPickStartDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderItemShipGrpInvResMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderitemshipgrpinvres.FieldCreateTime:
		return m.CreateTime()
	case orderitemshipgrpinvres.FieldUpdateTime:
		return m.UpdateTime()
	case orderitemshipgrpinvres.FieldStringRef:
		return m.StringRef()
	case orderitemshipgrpinvres.FieldShipGroupSeqID:
		return m.ShipGroupSeqID()
	case orderitemshipgrpinvres.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case orderitemshipgrpinvres.FieldInventoryItemID:
		return m.InventoryItemID()
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		return m.ReserveOrderEnumID()
	case orderitemshipgrpinvres.FieldQuantity:
		return m.Quantity()
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		return m.QuantityNotAvailable()
	case orderitemshipgrpinvres.FieldReservedDatetime:
		return m.ReservedDatetime()
	case orderitemshipgrpinvres.FieldCreatedDatetime:
		return m.CreatedDatetime()
	case orderitemshipgrpinvres.FieldPromisedDatetime:
		return m.PromisedDatetime()
	case orderitemshipgrpinvres.FieldCurrentPromisedDate:
		return m.CurrentPromisedDate()
	case orderitemshipgrpinvres.FieldPriority:
		return m.Priority()
	case orderitemshipgrpinvres.FieldSequenceID:
		return m.SequenceID()
	case orderitemshipgrpinvres.FieldOldPickStartDate:
		return m.OldPickStartDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderItemShipGrpInvResMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderitemshipgrpinvres.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderitemshipgrpinvres.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderitemshipgrpinvres.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderitemshipgrpinvres.FieldShipGroupSeqID:
		return m.OldShipGroupSeqID(ctx)
	case orderitemshipgrpinvres.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case orderitemshipgrpinvres.FieldInventoryItemID:
		return m.OldInventoryItemID(ctx)
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		return m.OldReserveOrderEnumID(ctx)
	case orderitemshipgrpinvres.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		return m.OldQuantityNotAvailable(ctx)
	case orderitemshipgrpinvres.FieldReservedDatetime:
		return m.OldReservedDatetime(ctx)
	case orderitemshipgrpinvres.FieldCreatedDatetime:
		return m.OldCreatedDatetime(ctx)
	case orderitemshipgrpinvres.FieldPromisedDatetime:
		return m.OldPromisedDatetime(ctx)
	case orderitemshipgrpinvres.FieldCurrentPromisedDate:
		return m.OldCurrentPromisedDate(ctx)
	case orderitemshipgrpinvres.FieldPriority:
		return m.OldPriority(ctx)
	case orderitemshipgrpinvres.FieldSequenceID:
		return m.OldSequenceID(ctx)
	case orderitemshipgrpinvres.FieldOldPickStartDate:
		return m.OldOldPickStartDate(ctx)
	}
	return nil, fmt.Errorf("unknown OrderItemShipGrpInvRes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemShipGrpInvResMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderitemshipgrpinvres.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderitemshipgrpinvres.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderitemshipgrpinvres.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderitemshipgrpinvres.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipGroupSeqID(v)
		return nil
	case orderitemshipgrpinvres.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case orderitemshipgrpinvres.FieldInventoryItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryItemID(v)
		return nil
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserveOrderEnumID(v)
		return nil
	case orderitemshipgrpinvres.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityNotAvailable(v)
		return nil
	case orderitemshipgrpinvres.FieldReservedDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservedDatetime(v)
		return nil
	case orderitemshipgrpinvres.FieldCreatedDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDatetime(v)
		return nil
	case orderitemshipgrpinvres.FieldPromisedDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromisedDatetime(v)
		return nil
	case orderitemshipgrpinvres.FieldCurrentPromisedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPromisedDate(v)
		return nil
	case orderitemshipgrpinvres.FieldPriority:
		v, ok := value.(orderitemshipgrpinvres.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case orderitemshipgrpinvres.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	case orderitemshipgrpinvres.FieldOldPickStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldPickStartDate(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGrpInvRes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedFields() []string {
	var fields []string
	if m.addship_group_seq_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldShipGroupSeqID)
	}
	if m.addorder_item_seq_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldOrderItemSeqID)
	}
	if m.addinventory_item_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldInventoryItemID)
	}
	if m.addreserve_order_enum_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldReserveOrderEnumID)
	}
	if m.addquantity != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldQuantity)
	}
	if m.addquantity_not_available != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldQuantityNotAvailable)
	}
	if m.addsequence_id != nil {
		fields = append(fields, orderitemshipgrpinvres.FieldSequenceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderItemShipGrpInvResMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderitemshipgrpinvres.FieldShipGroupSeqID:
		return m.AddedShipGroupSeqID()
	case orderitemshipgrpinvres.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	case orderitemshipgrpinvres.FieldInventoryItemID:
		return m.AddedInventoryItemID()
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		return m.AddedReserveOrderEnumID()
	case orderitemshipgrpinvres.FieldQuantity:
		return m.AddedQuantity()
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		return m.AddedQuantityNotAvailable()
	case orderitemshipgrpinvres.FieldSequenceID:
		return m.AddedSequenceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderItemShipGrpInvResMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderitemshipgrpinvres.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipGroupSeqID(v)
		return nil
	case orderitemshipgrpinvres.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	case orderitemshipgrpinvres.FieldInventoryItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInventoryItemID(v)
		return nil
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReserveOrderEnumID(v)
		return nil
	case orderitemshipgrpinvres.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityNotAvailable(v)
		return nil
	case orderitemshipgrpinvres.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGrpInvRes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderItemShipGrpInvResMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderitemshipgrpinvres.FieldStringRef) {
		fields = append(fields, orderitemshipgrpinvres.FieldStringRef)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldReserveOrderEnumID) {
		fields = append(fields, orderitemshipgrpinvres.FieldReserveOrderEnumID)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldQuantity) {
		fields = append(fields, orderitemshipgrpinvres.FieldQuantity)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldQuantityNotAvailable) {
		fields = append(fields, orderitemshipgrpinvres.FieldQuantityNotAvailable)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldReservedDatetime) {
		fields = append(fields, orderitemshipgrpinvres.FieldReservedDatetime)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldCreatedDatetime) {
		fields = append(fields, orderitemshipgrpinvres.FieldCreatedDatetime)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldPromisedDatetime) {
		fields = append(fields, orderitemshipgrpinvres.FieldPromisedDatetime)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldCurrentPromisedDate) {
		fields = append(fields, orderitemshipgrpinvres.FieldCurrentPromisedDate)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldPriority) {
		fields = append(fields, orderitemshipgrpinvres.FieldPriority)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldSequenceID) {
		fields = append(fields, orderitemshipgrpinvres.FieldSequenceID)
	}
	if m.FieldCleared(orderitemshipgrpinvres.FieldOldPickStartDate) {
		fields = append(fields, orderitemshipgrpinvres.FieldOldPickStartDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderItemShipGrpInvResMutation) ClearField(name string) error {
	switch name {
	case orderitemshipgrpinvres.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		m.ClearReserveOrderEnumID()
		return nil
	case orderitemshipgrpinvres.FieldQuantity:
		m.ClearQuantity()
		return nil
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		m.ClearQuantityNotAvailable()
		return nil
	case orderitemshipgrpinvres.FieldReservedDatetime:
		m.ClearReservedDatetime()
		return nil
	case orderitemshipgrpinvres.FieldCreatedDatetime:
		m.ClearCreatedDatetime()
		return nil
	case orderitemshipgrpinvres.FieldPromisedDatetime:
		m.ClearPromisedDatetime()
		return nil
	case orderitemshipgrpinvres.FieldCurrentPromisedDate:
		m.ClearCurrentPromisedDate()
		return nil
	case orderitemshipgrpinvres.FieldPriority:
		m.ClearPriority()
		return nil
	case orderitemshipgrpinvres.FieldSequenceID:
		m.ClearSequenceID()
		return nil
	case orderitemshipgrpinvres.FieldOldPickStartDate:
		m.ClearOldPickStartDate()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGrpInvRes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderItemShipGrpInvResMutation) ResetField(name string) error {
	switch name {
	case orderitemshipgrpinvres.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderitemshipgrpinvres.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderitemshipgrpinvres.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderitemshipgrpinvres.FieldShipGroupSeqID:
		m.ResetShipGroupSeqID()
		return nil
	case orderitemshipgrpinvres.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case orderitemshipgrpinvres.FieldInventoryItemID:
		m.ResetInventoryItemID()
		return nil
	case orderitemshipgrpinvres.FieldReserveOrderEnumID:
		m.ResetReserveOrderEnumID()
		return nil
	case orderitemshipgrpinvres.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderitemshipgrpinvres.FieldQuantityNotAvailable:
		m.ResetQuantityNotAvailable()
		return nil
	case orderitemshipgrpinvres.FieldReservedDatetime:
		m.ResetReservedDatetime()
		return nil
	case orderitemshipgrpinvres.FieldCreatedDatetime:
		m.ResetCreatedDatetime()
		return nil
	case orderitemshipgrpinvres.FieldPromisedDatetime:
		m.ResetPromisedDatetime()
		return nil
	case orderitemshipgrpinvres.FieldCurrentPromisedDate:
		m.ResetCurrentPromisedDate()
		return nil
	case orderitemshipgrpinvres.FieldPriority:
		m.ResetPriority()
		return nil
	case orderitemshipgrpinvres.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	case orderitemshipgrpinvres.FieldOldPickStartDate:
		m.ResetOldPickStartDate()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGrpInvRes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.order_header != nil {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderHeader)
	}
	if m.order_item != nil {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderItem)
	}
	if m.order_item_ship_group != nil {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderItemShipGroup)
	}
	if m.order_item_ship_group_assoc != nil {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderItemShipGroupAssoc)
	}
	if m.inventory_item_details != nil {
		edges = append(edges, orderitemshipgrpinvres.EdgeInventoryItemDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderItemShipGrpInvResMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderitemshipgrpinvres.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgrpinvres.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgrpinvres.EdgeOrderItemShipGroup:
		if id := m.order_item_ship_group; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgrpinvres.EdgeOrderItemShipGroupAssoc:
		if id := m.order_item_ship_group_assoc; id != nil {
			return []ent.Value{*id}
		}
	case orderitemshipgrpinvres.EdgeInventoryItemDetails:
		ids := make([]ent.Value, 0, len(m.inventory_item_details))
		for id := range m.inventory_item_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderItemShipGrpInvResMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedinventory_item_details != nil {
		edges = append(edges, orderitemshipgrpinvres.EdgeInventoryItemDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderItemShipGrpInvResMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderitemshipgrpinvres.EdgeInventoryItemDetails:
		ids := make([]ent.Value, 0, len(m.removedinventory_item_details))
		for id := range m.removedinventory_item_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedorder_header {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderHeader)
	}
	if m.clearedorder_item {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderItem)
	}
	if m.clearedorder_item_ship_group {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderItemShipGroup)
	}
	if m.clearedorder_item_ship_group_assoc {
		edges = append(edges, orderitemshipgrpinvres.EdgeOrderItemShipGroupAssoc)
	}
	if m.clearedinventory_item_details {
		edges = append(edges, orderitemshipgrpinvres.EdgeInventoryItemDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderItemShipGrpInvResMutation) EdgeCleared(name string) bool {
	switch name {
	case orderitemshipgrpinvres.EdgeOrderHeader:
		return m.clearedorder_header
	case orderitemshipgrpinvres.EdgeOrderItem:
		return m.clearedorder_item
	case orderitemshipgrpinvres.EdgeOrderItemShipGroup:
		return m.clearedorder_item_ship_group
	case orderitemshipgrpinvres.EdgeOrderItemShipGroupAssoc:
		return m.clearedorder_item_ship_group_assoc
	case orderitemshipgrpinvres.EdgeInventoryItemDetails:
		return m.clearedinventory_item_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderItemShipGrpInvResMutation) ClearEdge(name string) error {
	switch name {
	case orderitemshipgrpinvres.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderitemshipgrpinvres.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	case orderitemshipgrpinvres.EdgeOrderItemShipGroup:
		m.ClearOrderItemShipGroup()
		return nil
	case orderitemshipgrpinvres.EdgeOrderItemShipGroupAssoc:
		m.ClearOrderItemShipGroupAssoc()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGrpInvRes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderItemShipGrpInvResMutation) ResetEdge(name string) error {
	switch name {
	case orderitemshipgrpinvres.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderitemshipgrpinvres.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	case orderitemshipgrpinvres.EdgeOrderItemShipGroup:
		m.ResetOrderItemShipGroup()
		return nil
	case orderitemshipgrpinvres.EdgeOrderItemShipGroupAssoc:
		m.ResetOrderItemShipGroupAssoc()
		return nil
	case orderitemshipgrpinvres.EdgeInventoryItemDetails:
		m.ResetInventoryItemDetails()
		return nil
	}
	return fmt.Errorf("unknown OrderItemShipGrpInvRes edge %s", name)
}

// OrderPaymentPreferenceMutation represents an operation that mutates the OrderPaymentPreference nodes in the graph.
type OrderPaymentPreferenceMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	string_ref                   *string
	order_item_seq_id            *int
	addorder_item_seq_id         *int
	ship_group_seq_id            *int
	addship_group_seq_id         *int
	payment_method_type_id       *int
	addpayment_method_type_id    *int
	payment_method_id            *int
	addpayment_method_id         *int
	fin_account_id               *int
	addfin_account_id            *int
	security_code                *string
	track_2                      *string
	present_flag                 *orderpaymentpreference.PresentFlag
	swiped_flag                  *orderpaymentpreference.SwipedFlag
	overflow_flag                *orderpaymentpreference.OverflowFlag
	max_amount                   *float64
	addmax_amount                *float64
	process_attempt              *int
	addprocess_attempt           *int
	billing_postal_code          *string
	manual_auth_code             *string
	manual_ref_num               *string
	needs_nsf_retry              *orderpaymentpreference.NeedsNsfRetry
	created_date                 *time.Time
	created_by_user_login        *string
	last_modified_date           *time.Time
	last_modified_by_user_login  *string
	clearedFields                map[string]struct{}
	order_header                 *int
	clearedorder_header          bool
	order_item                   *int
	clearedorder_item            bool
	order_item_ship_group        *int
	clearedorder_item_ship_group bool
	product_price_purpose        *int
	clearedproduct_price_purpose bool
	status_item                  *int
	clearedstatus_item           bool
	order_statuses               map[int]struct{}
	removedorder_statuses        map[int]struct{}
	clearedorder_statuses        bool
	done                         bool
	oldValue                     func(context.Context) (*OrderPaymentPreference, error)
	predicates                   []predicate.OrderPaymentPreference
}

var _ ent.Mutation = (*OrderPaymentPreferenceMutation)(nil)

// orderpaymentpreferenceOption allows management of the mutation configuration using functional options.
type orderpaymentpreferenceOption func(*OrderPaymentPreferenceMutation)

// newOrderPaymentPreferenceMutation creates new mutation for the OrderPaymentPreference entity.
func newOrderPaymentPreferenceMutation(c config, op Op, opts ...orderpaymentpreferenceOption) *OrderPaymentPreferenceMutation {
	m := &OrderPaymentPreferenceMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderPaymentPreference,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderPaymentPreferenceID sets the ID field of the mutation.
func withOrderPaymentPreferenceID(id int) orderpaymentpreferenceOption {
	return func(m *OrderPaymentPreferenceMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderPaymentPreference
		)
		m.oldValue = func(ctx context.Context) (*OrderPaymentPreference, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderPaymentPreference.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderPaymentPreference sets the old OrderPaymentPreference of the mutation.
func withOrderPaymentPreference(node *OrderPaymentPreference) orderpaymentpreferenceOption {
	return func(m *OrderPaymentPreferenceMutation) {
		m.oldValue = func(context.Context) (*OrderPaymentPreference, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderPaymentPreferenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderPaymentPreferenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderPaymentPreferenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderPaymentPreferenceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderPaymentPreferenceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderPaymentPreferenceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderPaymentPreferenceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderPaymentPreferenceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderPaymentPreferenceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderPaymentPreferenceMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderPaymentPreferenceMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderPaymentPreferenceMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderpaymentpreference.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderPaymentPreferenceMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderpaymentpreference.FieldStringRef)
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *OrderPaymentPreferenceMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *OrderPaymentPreferenceMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *OrderPaymentPreferenceMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemSeqID clears the value of the "order_item_seq_id" field.
func (m *OrderPaymentPreferenceMutation) ClearOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	m.clearedFields[orderpaymentpreference.FieldOrderItemSeqID] = struct{}{}
}

// OrderItemSeqIDCleared returns if the "order_item_seq_id" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) OrderItemSeqIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldOrderItemSeqID]
	return ok
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *OrderPaymentPreferenceMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	delete(m.clearedFields, orderpaymentpreference.FieldOrderItemSeqID)
}

// SetShipGroupSeqID sets the "ship_group_seq_id" field.
func (m *OrderPaymentPreferenceMutation) SetShipGroupSeqID(i int) {
	m.ship_group_seq_id = &i
	m.addship_group_seq_id = nil
}

// ShipGroupSeqID returns the value of the "ship_group_seq_id" field in the mutation.
func (m *OrderPaymentPreferenceMutation) ShipGroupSeqID() (r int, exists bool) {
	v := m.ship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipGroupSeqID returns the old "ship_group_seq_id" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldShipGroupSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipGroupSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipGroupSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipGroupSeqID: %w", err)
	}
	return oldValue.ShipGroupSeqID, nil
}

// AddShipGroupSeqID adds i to the "ship_group_seq_id" field.
func (m *OrderPaymentPreferenceMutation) AddShipGroupSeqID(i int) {
	if m.addship_group_seq_id != nil {
		*m.addship_group_seq_id += i
	} else {
		m.addship_group_seq_id = &i
	}
}

// AddedShipGroupSeqID returns the value that was added to the "ship_group_seq_id" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedShipGroupSeqID() (r int, exists bool) {
	v := m.addship_group_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipGroupSeqID clears the value of the "ship_group_seq_id" field.
func (m *OrderPaymentPreferenceMutation) ClearShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
	m.clearedFields[orderpaymentpreference.FieldShipGroupSeqID] = struct{}{}
}

// ShipGroupSeqIDCleared returns if the "ship_group_seq_id" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) ShipGroupSeqIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldShipGroupSeqID]
	return ok
}

// ResetShipGroupSeqID resets all changes to the "ship_group_seq_id" field.
func (m *OrderPaymentPreferenceMutation) ResetShipGroupSeqID() {
	m.ship_group_seq_id = nil
	m.addship_group_seq_id = nil
	delete(m.clearedFields, orderpaymentpreference.FieldShipGroupSeqID)
}

// SetPaymentMethodTypeID sets the "payment_method_type_id" field.
func (m *OrderPaymentPreferenceMutation) SetPaymentMethodTypeID(i int) {
	m.payment_method_type_id = &i
	m.addpayment_method_type_id = nil
}

// PaymentMethodTypeID returns the value of the "payment_method_type_id" field in the mutation.
func (m *OrderPaymentPreferenceMutation) PaymentMethodTypeID() (r int, exists bool) {
	v := m.payment_method_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethodTypeID returns the old "payment_method_type_id" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldPaymentMethodTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentMethodTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentMethodTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethodTypeID: %w", err)
	}
	return oldValue.PaymentMethodTypeID, nil
}

// AddPaymentMethodTypeID adds i to the "payment_method_type_id" field.
func (m *OrderPaymentPreferenceMutation) AddPaymentMethodTypeID(i int) {
	if m.addpayment_method_type_id != nil {
		*m.addpayment_method_type_id += i
	} else {
		m.addpayment_method_type_id = &i
	}
}

// AddedPaymentMethodTypeID returns the value that was added to the "payment_method_type_id" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedPaymentMethodTypeID() (r int, exists bool) {
	v := m.addpayment_method_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentMethodTypeID clears the value of the "payment_method_type_id" field.
func (m *OrderPaymentPreferenceMutation) ClearPaymentMethodTypeID() {
	m.payment_method_type_id = nil
	m.addpayment_method_type_id = nil
	m.clearedFields[orderpaymentpreference.FieldPaymentMethodTypeID] = struct{}{}
}

// PaymentMethodTypeIDCleared returns if the "payment_method_type_id" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) PaymentMethodTypeIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldPaymentMethodTypeID]
	return ok
}

// ResetPaymentMethodTypeID resets all changes to the "payment_method_type_id" field.
func (m *OrderPaymentPreferenceMutation) ResetPaymentMethodTypeID() {
	m.payment_method_type_id = nil
	m.addpayment_method_type_id = nil
	delete(m.clearedFields, orderpaymentpreference.FieldPaymentMethodTypeID)
}

// SetPaymentMethodID sets the "payment_method_id" field.
func (m *OrderPaymentPreferenceMutation) SetPaymentMethodID(i int) {
	m.payment_method_id = &i
	m.addpayment_method_id = nil
}

// PaymentMethodID returns the value of the "payment_method_id" field in the mutation.
func (m *OrderPaymentPreferenceMutation) PaymentMethodID() (r int, exists bool) {
	v := m.payment_method_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethodID returns the old "payment_method_id" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldPaymentMethodID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentMethodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentMethodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethodID: %w", err)
	}
	return oldValue.PaymentMethodID, nil
}

// AddPaymentMethodID adds i to the "payment_method_id" field.
func (m *OrderPaymentPreferenceMutation) AddPaymentMethodID(i int) {
	if m.addpayment_method_id != nil {
		*m.addpayment_method_id += i
	} else {
		m.addpayment_method_id = &i
	}
}

// AddedPaymentMethodID returns the value that was added to the "payment_method_id" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedPaymentMethodID() (r int, exists bool) {
	v := m.addpayment_method_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentMethodID clears the value of the "payment_method_id" field.
func (m *OrderPaymentPreferenceMutation) ClearPaymentMethodID() {
	m.payment_method_id = nil
	m.addpayment_method_id = nil
	m.clearedFields[orderpaymentpreference.FieldPaymentMethodID] = struct{}{}
}

// PaymentMethodIDCleared returns if the "payment_method_id" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) PaymentMethodIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldPaymentMethodID]
	return ok
}

// ResetPaymentMethodID resets all changes to the "payment_method_id" field.
func (m *OrderPaymentPreferenceMutation) ResetPaymentMethodID() {
	m.payment_method_id = nil
	m.addpayment_method_id = nil
	delete(m.clearedFields, orderpaymentpreference.FieldPaymentMethodID)
}

// SetFinAccountID sets the "fin_account_id" field.
func (m *OrderPaymentPreferenceMutation) SetFinAccountID(i int) {
	m.fin_account_id = &i
	m.addfin_account_id = nil
}

// FinAccountID returns the value of the "fin_account_id" field in the mutation.
func (m *OrderPaymentPreferenceMutation) FinAccountID() (r int, exists bool) {
	v := m.fin_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFinAccountID returns the old "fin_account_id" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldFinAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinAccountID: %w", err)
	}
	return oldValue.FinAccountID, nil
}

// AddFinAccountID adds i to the "fin_account_id" field.
func (m *OrderPaymentPreferenceMutation) AddFinAccountID(i int) {
	if m.addfin_account_id != nil {
		*m.addfin_account_id += i
	} else {
		m.addfin_account_id = &i
	}
}

// AddedFinAccountID returns the value that was added to the "fin_account_id" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedFinAccountID() (r int, exists bool) {
	v := m.addfin_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFinAccountID clears the value of the "fin_account_id" field.
func (m *OrderPaymentPreferenceMutation) ClearFinAccountID() {
	m.fin_account_id = nil
	m.addfin_account_id = nil
	m.clearedFields[orderpaymentpreference.FieldFinAccountID] = struct{}{}
}

// FinAccountIDCleared returns if the "fin_account_id" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) FinAccountIDCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldFinAccountID]
	return ok
}

// ResetFinAccountID resets all changes to the "fin_account_id" field.
func (m *OrderPaymentPreferenceMutation) ResetFinAccountID() {
	m.fin_account_id = nil
	m.addfin_account_id = nil
	delete(m.clearedFields, orderpaymentpreference.FieldFinAccountID)
}

// SetSecurityCode sets the "security_code" field.
func (m *OrderPaymentPreferenceMutation) SetSecurityCode(s string) {
	m.security_code = &s
}

// SecurityCode returns the value of the "security_code" field in the mutation.
func (m *OrderPaymentPreferenceMutation) SecurityCode() (r string, exists bool) {
	v := m.security_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityCode returns the old "security_code" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldSecurityCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSecurityCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSecurityCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityCode: %w", err)
	}
	return oldValue.SecurityCode, nil
}

// ClearSecurityCode clears the value of the "security_code" field.
func (m *OrderPaymentPreferenceMutation) ClearSecurityCode() {
	m.security_code = nil
	m.clearedFields[orderpaymentpreference.FieldSecurityCode] = struct{}{}
}

// SecurityCodeCleared returns if the "security_code" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) SecurityCodeCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldSecurityCode]
	return ok
}

// ResetSecurityCode resets all changes to the "security_code" field.
func (m *OrderPaymentPreferenceMutation) ResetSecurityCode() {
	m.security_code = nil
	delete(m.clearedFields, orderpaymentpreference.FieldSecurityCode)
}

// SetTrack2 sets the "track_2" field.
func (m *OrderPaymentPreferenceMutation) SetTrack2(s string) {
	m.track_2 = &s
}

// Track2 returns the value of the "track_2" field in the mutation.
func (m *OrderPaymentPreferenceMutation) Track2() (r string, exists bool) {
	v := m.track_2
	if v == nil {
		return
	}
	return *v, true
}

// OldTrack2 returns the old "track_2" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldTrack2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTrack2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTrack2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrack2: %w", err)
	}
	return oldValue.Track2, nil
}

// ClearTrack2 clears the value of the "track_2" field.
func (m *OrderPaymentPreferenceMutation) ClearTrack2() {
	m.track_2 = nil
	m.clearedFields[orderpaymentpreference.FieldTrack2] = struct{}{}
}

// Track2Cleared returns if the "track_2" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) Track2Cleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldTrack2]
	return ok
}

// ResetTrack2 resets all changes to the "track_2" field.
func (m *OrderPaymentPreferenceMutation) ResetTrack2() {
	m.track_2 = nil
	delete(m.clearedFields, orderpaymentpreference.FieldTrack2)
}

// SetPresentFlag sets the "present_flag" field.
func (m *OrderPaymentPreferenceMutation) SetPresentFlag(of orderpaymentpreference.PresentFlag) {
	m.present_flag = &of
}

// PresentFlag returns the value of the "present_flag" field in the mutation.
func (m *OrderPaymentPreferenceMutation) PresentFlag() (r orderpaymentpreference.PresentFlag, exists bool) {
	v := m.present_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldPresentFlag returns the old "present_flag" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldPresentFlag(ctx context.Context) (v orderpaymentpreference.PresentFlag, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPresentFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPresentFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPresentFlag: %w", err)
	}
	return oldValue.PresentFlag, nil
}

// ClearPresentFlag clears the value of the "present_flag" field.
func (m *OrderPaymentPreferenceMutation) ClearPresentFlag() {
	m.present_flag = nil
	m.clearedFields[orderpaymentpreference.FieldPresentFlag] = struct{}{}
}

// PresentFlagCleared returns if the "present_flag" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) PresentFlagCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldPresentFlag]
	return ok
}

// ResetPresentFlag resets all changes to the "present_flag" field.
func (m *OrderPaymentPreferenceMutation) ResetPresentFlag() {
	m.present_flag = nil
	delete(m.clearedFields, orderpaymentpreference.FieldPresentFlag)
}

// SetSwipedFlag sets the "swiped_flag" field.
func (m *OrderPaymentPreferenceMutation) SetSwipedFlag(of orderpaymentpreference.SwipedFlag) {
	m.swiped_flag = &of
}

// SwipedFlag returns the value of the "swiped_flag" field in the mutation.
func (m *OrderPaymentPreferenceMutation) SwipedFlag() (r orderpaymentpreference.SwipedFlag, exists bool) {
	v := m.swiped_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldSwipedFlag returns the old "swiped_flag" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldSwipedFlag(ctx context.Context) (v orderpaymentpreference.SwipedFlag, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSwipedFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSwipedFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSwipedFlag: %w", err)
	}
	return oldValue.SwipedFlag, nil
}

// ClearSwipedFlag clears the value of the "swiped_flag" field.
func (m *OrderPaymentPreferenceMutation) ClearSwipedFlag() {
	m.swiped_flag = nil
	m.clearedFields[orderpaymentpreference.FieldSwipedFlag] = struct{}{}
}

// SwipedFlagCleared returns if the "swiped_flag" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) SwipedFlagCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldSwipedFlag]
	return ok
}

// ResetSwipedFlag resets all changes to the "swiped_flag" field.
func (m *OrderPaymentPreferenceMutation) ResetSwipedFlag() {
	m.swiped_flag = nil
	delete(m.clearedFields, orderpaymentpreference.FieldSwipedFlag)
}

// SetOverflowFlag sets the "overflow_flag" field.
func (m *OrderPaymentPreferenceMutation) SetOverflowFlag(of orderpaymentpreference.OverflowFlag) {
	m.overflow_flag = &of
}

// OverflowFlag returns the value of the "overflow_flag" field in the mutation.
func (m *OrderPaymentPreferenceMutation) OverflowFlag() (r orderpaymentpreference.OverflowFlag, exists bool) {
	v := m.overflow_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldOverflowFlag returns the old "overflow_flag" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldOverflowFlag(ctx context.Context) (v orderpaymentpreference.OverflowFlag, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOverflowFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOverflowFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverflowFlag: %w", err)
	}
	return oldValue.OverflowFlag, nil
}

// ClearOverflowFlag clears the value of the "overflow_flag" field.
func (m *OrderPaymentPreferenceMutation) ClearOverflowFlag() {
	m.overflow_flag = nil
	m.clearedFields[orderpaymentpreference.FieldOverflowFlag] = struct{}{}
}

// OverflowFlagCleared returns if the "overflow_flag" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) OverflowFlagCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldOverflowFlag]
	return ok
}

// ResetOverflowFlag resets all changes to the "overflow_flag" field.
func (m *OrderPaymentPreferenceMutation) ResetOverflowFlag() {
	m.overflow_flag = nil
	delete(m.clearedFields, orderpaymentpreference.FieldOverflowFlag)
}

// SetMaxAmount sets the "max_amount" field.
func (m *OrderPaymentPreferenceMutation) SetMaxAmount(f float64) {
	m.max_amount = &f
	m.addmax_amount = nil
}

// MaxAmount returns the value of the "max_amount" field in the mutation.
func (m *OrderPaymentPreferenceMutation) MaxAmount() (r float64, exists bool) {
	v := m.max_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAmount returns the old "max_amount" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldMaxAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAmount: %w", err)
	}
	return oldValue.MaxAmount, nil
}

// AddMaxAmount adds f to the "max_amount" field.
func (m *OrderPaymentPreferenceMutation) AddMaxAmount(f float64) {
	if m.addmax_amount != nil {
		*m.addmax_amount += f
	} else {
		m.addmax_amount = &f
	}
}

// AddedMaxAmount returns the value that was added to the "max_amount" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedMaxAmount() (r float64, exists bool) {
	v := m.addmax_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxAmount clears the value of the "max_amount" field.
func (m *OrderPaymentPreferenceMutation) ClearMaxAmount() {
	m.max_amount = nil
	m.addmax_amount = nil
	m.clearedFields[orderpaymentpreference.FieldMaxAmount] = struct{}{}
}

// MaxAmountCleared returns if the "max_amount" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) MaxAmountCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldMaxAmount]
	return ok
}

// ResetMaxAmount resets all changes to the "max_amount" field.
func (m *OrderPaymentPreferenceMutation) ResetMaxAmount() {
	m.max_amount = nil
	m.addmax_amount = nil
	delete(m.clearedFields, orderpaymentpreference.FieldMaxAmount)
}

// SetProcessAttempt sets the "process_attempt" field.
func (m *OrderPaymentPreferenceMutation) SetProcessAttempt(i int) {
	m.process_attempt = &i
	m.addprocess_attempt = nil
}

// ProcessAttempt returns the value of the "process_attempt" field in the mutation.
func (m *OrderPaymentPreferenceMutation) ProcessAttempt() (r int, exists bool) {
	v := m.process_attempt
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessAttempt returns the old "process_attempt" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldProcessAttempt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProcessAttempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProcessAttempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessAttempt: %w", err)
	}
	return oldValue.ProcessAttempt, nil
}

// AddProcessAttempt adds i to the "process_attempt" field.
func (m *OrderPaymentPreferenceMutation) AddProcessAttempt(i int) {
	if m.addprocess_attempt != nil {
		*m.addprocess_attempt += i
	} else {
		m.addprocess_attempt = &i
	}
}

// AddedProcessAttempt returns the value that was added to the "process_attempt" field in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedProcessAttempt() (r int, exists bool) {
	v := m.addprocess_attempt
	if v == nil {
		return
	}
	return *v, true
}

// ClearProcessAttempt clears the value of the "process_attempt" field.
func (m *OrderPaymentPreferenceMutation) ClearProcessAttempt() {
	m.process_attempt = nil
	m.addprocess_attempt = nil
	m.clearedFields[orderpaymentpreference.FieldProcessAttempt] = struct{}{}
}

// ProcessAttemptCleared returns if the "process_attempt" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) ProcessAttemptCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldProcessAttempt]
	return ok
}

// ResetProcessAttempt resets all changes to the "process_attempt" field.
func (m *OrderPaymentPreferenceMutation) ResetProcessAttempt() {
	m.process_attempt = nil
	m.addprocess_attempt = nil
	delete(m.clearedFields, orderpaymentpreference.FieldProcessAttempt)
}

// SetBillingPostalCode sets the "billing_postal_code" field.
func (m *OrderPaymentPreferenceMutation) SetBillingPostalCode(s string) {
	m.billing_postal_code = &s
}

// BillingPostalCode returns the value of the "billing_postal_code" field in the mutation.
func (m *OrderPaymentPreferenceMutation) BillingPostalCode() (r string, exists bool) {
	v := m.billing_postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingPostalCode returns the old "billing_postal_code" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldBillingPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillingPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillingPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingPostalCode: %w", err)
	}
	return oldValue.BillingPostalCode, nil
}

// ClearBillingPostalCode clears the value of the "billing_postal_code" field.
func (m *OrderPaymentPreferenceMutation) ClearBillingPostalCode() {
	m.billing_postal_code = nil
	m.clearedFields[orderpaymentpreference.FieldBillingPostalCode] = struct{}{}
}

// BillingPostalCodeCleared returns if the "billing_postal_code" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) BillingPostalCodeCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldBillingPostalCode]
	return ok
}

// ResetBillingPostalCode resets all changes to the "billing_postal_code" field.
func (m *OrderPaymentPreferenceMutation) ResetBillingPostalCode() {
	m.billing_postal_code = nil
	delete(m.clearedFields, orderpaymentpreference.FieldBillingPostalCode)
}

// SetManualAuthCode sets the "manual_auth_code" field.
func (m *OrderPaymentPreferenceMutation) SetManualAuthCode(s string) {
	m.manual_auth_code = &s
}

// ManualAuthCode returns the value of the "manual_auth_code" field in the mutation.
func (m *OrderPaymentPreferenceMutation) ManualAuthCode() (r string, exists bool) {
	v := m.manual_auth_code
	if v == nil {
		return
	}
	return *v, true
}

// OldManualAuthCode returns the old "manual_auth_code" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldManualAuthCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldManualAuthCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldManualAuthCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManualAuthCode: %w", err)
	}
	return oldValue.ManualAuthCode, nil
}

// ClearManualAuthCode clears the value of the "manual_auth_code" field.
func (m *OrderPaymentPreferenceMutation) ClearManualAuthCode() {
	m.manual_auth_code = nil
	m.clearedFields[orderpaymentpreference.FieldManualAuthCode] = struct{}{}
}

// ManualAuthCodeCleared returns if the "manual_auth_code" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) ManualAuthCodeCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldManualAuthCode]
	return ok
}

// ResetManualAuthCode resets all changes to the "manual_auth_code" field.
func (m *OrderPaymentPreferenceMutation) ResetManualAuthCode() {
	m.manual_auth_code = nil
	delete(m.clearedFields, orderpaymentpreference.FieldManualAuthCode)
}

// SetManualRefNum sets the "manual_ref_num" field.
func (m *OrderPaymentPreferenceMutation) SetManualRefNum(s string) {
	m.manual_ref_num = &s
}

// ManualRefNum returns the value of the "manual_ref_num" field in the mutation.
func (m *OrderPaymentPreferenceMutation) ManualRefNum() (r string, exists bool) {
	v := m.manual_ref_num
	if v == nil {
		return
	}
	return *v, true
}

// OldManualRefNum returns the old "manual_ref_num" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldManualRefNum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldManualRefNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldManualRefNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManualRefNum: %w", err)
	}
	return oldValue.ManualRefNum, nil
}

// ClearManualRefNum clears the value of the "manual_ref_num" field.
func (m *OrderPaymentPreferenceMutation) ClearManualRefNum() {
	m.manual_ref_num = nil
	m.clearedFields[orderpaymentpreference.FieldManualRefNum] = struct{}{}
}

// ManualRefNumCleared returns if the "manual_ref_num" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) ManualRefNumCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldManualRefNum]
	return ok
}

// ResetManualRefNum resets all changes to the "manual_ref_num" field.
func (m *OrderPaymentPreferenceMutation) ResetManualRefNum() {
	m.manual_ref_num = nil
	delete(m.clearedFields, orderpaymentpreference.FieldManualRefNum)
}

// SetNeedsNsfRetry sets the "needs_nsf_retry" field.
func (m *OrderPaymentPreferenceMutation) SetNeedsNsfRetry(onr orderpaymentpreference.NeedsNsfRetry) {
	m.needs_nsf_retry = &onr
}

// NeedsNsfRetry returns the value of the "needs_nsf_retry" field in the mutation.
func (m *OrderPaymentPreferenceMutation) NeedsNsfRetry() (r orderpaymentpreference.NeedsNsfRetry, exists bool) {
	v := m.needs_nsf_retry
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedsNsfRetry returns the old "needs_nsf_retry" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldNeedsNsfRetry(ctx context.Context) (v orderpaymentpreference.NeedsNsfRetry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNeedsNsfRetry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNeedsNsfRetry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedsNsfRetry: %w", err)
	}
	return oldValue.NeedsNsfRetry, nil
}

// ClearNeedsNsfRetry clears the value of the "needs_nsf_retry" field.
func (m *OrderPaymentPreferenceMutation) ClearNeedsNsfRetry() {
	m.needs_nsf_retry = nil
	m.clearedFields[orderpaymentpreference.FieldNeedsNsfRetry] = struct{}{}
}

// NeedsNsfRetryCleared returns if the "needs_nsf_retry" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) NeedsNsfRetryCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldNeedsNsfRetry]
	return ok
}

// ResetNeedsNsfRetry resets all changes to the "needs_nsf_retry" field.
func (m *OrderPaymentPreferenceMutation) ResetNeedsNsfRetry() {
	m.needs_nsf_retry = nil
	delete(m.clearedFields, orderpaymentpreference.FieldNeedsNsfRetry)
}

// SetCreatedDate sets the "created_date" field.
func (m *OrderPaymentPreferenceMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *OrderPaymentPreferenceMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *OrderPaymentPreferenceMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[orderpaymentpreference.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *OrderPaymentPreferenceMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, orderpaymentpreference.FieldCreatedDate)
}

// SetCreatedByUserLogin sets the "created_by_user_login" field.
func (m *OrderPaymentPreferenceMutation) SetCreatedByUserLogin(s string) {
	m.created_by_user_login = &s
}

// CreatedByUserLogin returns the value of the "created_by_user_login" field in the mutation.
func (m *OrderPaymentPreferenceMutation) CreatedByUserLogin() (r string, exists bool) {
	v := m.created_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByUserLogin returns the old "created_by_user_login" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldCreatedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByUserLogin: %w", err)
	}
	return oldValue.CreatedByUserLogin, nil
}

// ClearCreatedByUserLogin clears the value of the "created_by_user_login" field.
func (m *OrderPaymentPreferenceMutation) ClearCreatedByUserLogin() {
	m.created_by_user_login = nil
	m.clearedFields[orderpaymentpreference.FieldCreatedByUserLogin] = struct{}{}
}

// CreatedByUserLoginCleared returns if the "created_by_user_login" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) CreatedByUserLoginCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldCreatedByUserLogin]
	return ok
}

// ResetCreatedByUserLogin resets all changes to the "created_by_user_login" field.
func (m *OrderPaymentPreferenceMutation) ResetCreatedByUserLogin() {
	m.created_by_user_login = nil
	delete(m.clearedFields, orderpaymentpreference.FieldCreatedByUserLogin)
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *OrderPaymentPreferenceMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *OrderPaymentPreferenceMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ClearLastModifiedDate clears the value of the "last_modified_date" field.
func (m *OrderPaymentPreferenceMutation) ClearLastModifiedDate() {
	m.last_modified_date = nil
	m.clearedFields[orderpaymentpreference.FieldLastModifiedDate] = struct{}{}
}

// LastModifiedDateCleared returns if the "last_modified_date" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) LastModifiedDateCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldLastModifiedDate]
	return ok
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *OrderPaymentPreferenceMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
	delete(m.clearedFields, orderpaymentpreference.FieldLastModifiedDate)
}

// SetLastModifiedByUserLogin sets the "last_modified_by_user_login" field.
func (m *OrderPaymentPreferenceMutation) SetLastModifiedByUserLogin(s string) {
	m.last_modified_by_user_login = &s
}

// LastModifiedByUserLogin returns the value of the "last_modified_by_user_login" field in the mutation.
func (m *OrderPaymentPreferenceMutation) LastModifiedByUserLogin() (r string, exists bool) {
	v := m.last_modified_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedByUserLogin returns the old "last_modified_by_user_login" field's value of the OrderPaymentPreference entity.
// If the OrderPaymentPreference object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderPaymentPreferenceMutation) OldLastModifiedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedByUserLogin: %w", err)
	}
	return oldValue.LastModifiedByUserLogin, nil
}

// ClearLastModifiedByUserLogin clears the value of the "last_modified_by_user_login" field.
func (m *OrderPaymentPreferenceMutation) ClearLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	m.clearedFields[orderpaymentpreference.FieldLastModifiedByUserLogin] = struct{}{}
}

// LastModifiedByUserLoginCleared returns if the "last_modified_by_user_login" field was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) LastModifiedByUserLoginCleared() bool {
	_, ok := m.clearedFields[orderpaymentpreference.FieldLastModifiedByUserLogin]
	return ok
}

// ResetLastModifiedByUserLogin resets all changes to the "last_modified_by_user_login" field.
func (m *OrderPaymentPreferenceMutation) ResetLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	delete(m.clearedFields, orderpaymentpreference.FieldLastModifiedByUserLogin)
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderPaymentPreferenceMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderPaymentPreferenceMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderPaymentPreferenceMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderPaymentPreferenceMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderPaymentPreferenceMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderPaymentPreferenceMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetOrderItemID sets the "order_item" edge to the OrderItem entity by id.
func (m *OrderPaymentPreferenceMutation) SetOrderItemID(id int) {
	m.order_item = &id
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *OrderPaymentPreferenceMutation) ClearOrderItem() {
	m.clearedorder_item = true
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *OrderPaymentPreferenceMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemID returns the "order_item" edge ID in the mutation.
func (m *OrderPaymentPreferenceMutation) OrderItemID() (id int, exists bool) {
	if m.order_item != nil {
		return *m.order_item, true
	}
	return
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *OrderPaymentPreferenceMutation) OrderItemIDs() (ids []int) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *OrderPaymentPreferenceMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// SetOrderItemShipGroupID sets the "order_item_ship_group" edge to the OrderItemShipGroup entity by id.
func (m *OrderPaymentPreferenceMutation) SetOrderItemShipGroupID(id int) {
	m.order_item_ship_group = &id
}

// ClearOrderItemShipGroup clears the "order_item_ship_group" edge to the OrderItemShipGroup entity.
func (m *OrderPaymentPreferenceMutation) ClearOrderItemShipGroup() {
	m.clearedorder_item_ship_group = true
}

// OrderItemShipGroupCleared reports if the "order_item_ship_group" edge to the OrderItemShipGroup entity was cleared.
func (m *OrderPaymentPreferenceMutation) OrderItemShipGroupCleared() bool {
	return m.clearedorder_item_ship_group
}

// OrderItemShipGroupID returns the "order_item_ship_group" edge ID in the mutation.
func (m *OrderPaymentPreferenceMutation) OrderItemShipGroupID() (id int, exists bool) {
	if m.order_item_ship_group != nil {
		return *m.order_item_ship_group, true
	}
	return
}

// OrderItemShipGroupIDs returns the "order_item_ship_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemShipGroupID instead. It exists only for internal usage by the builders.
func (m *OrderPaymentPreferenceMutation) OrderItemShipGroupIDs() (ids []int) {
	if id := m.order_item_ship_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItemShipGroup resets all changes to the "order_item_ship_group" edge.
func (m *OrderPaymentPreferenceMutation) ResetOrderItemShipGroup() {
	m.order_item_ship_group = nil
	m.clearedorder_item_ship_group = false
}

// SetProductPricePurposeID sets the "product_price_purpose" edge to the ProductPricePurpose entity by id.
func (m *OrderPaymentPreferenceMutation) SetProductPricePurposeID(id int) {
	m.product_price_purpose = &id
}

// ClearProductPricePurpose clears the "product_price_purpose" edge to the ProductPricePurpose entity.
func (m *OrderPaymentPreferenceMutation) ClearProductPricePurpose() {
	m.clearedproduct_price_purpose = true
}

// ProductPricePurposeCleared reports if the "product_price_purpose" edge to the ProductPricePurpose entity was cleared.
func (m *OrderPaymentPreferenceMutation) ProductPricePurposeCleared() bool {
	return m.clearedproduct_price_purpose
}

// ProductPricePurposeID returns the "product_price_purpose" edge ID in the mutation.
func (m *OrderPaymentPreferenceMutation) ProductPricePurposeID() (id int, exists bool) {
	if m.product_price_purpose != nil {
		return *m.product_price_purpose, true
	}
	return
}

// ProductPricePurposeIDs returns the "product_price_purpose" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductPricePurposeID instead. It exists only for internal usage by the builders.
func (m *OrderPaymentPreferenceMutation) ProductPricePurposeIDs() (ids []int) {
	if id := m.product_price_purpose; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductPricePurpose resets all changes to the "product_price_purpose" edge.
func (m *OrderPaymentPreferenceMutation) ResetProductPricePurpose() {
	m.product_price_purpose = nil
	m.clearedproduct_price_purpose = false
}

// SetStatusItemID sets the "status_item" edge to the StatusItem entity by id.
func (m *OrderPaymentPreferenceMutation) SetStatusItemID(id int) {
	m.status_item = &id
}

// ClearStatusItem clears the "status_item" edge to the StatusItem entity.
func (m *OrderPaymentPreferenceMutation) ClearStatusItem() {
	m.clearedstatus_item = true
}

// StatusItemCleared reports if the "status_item" edge to the StatusItem entity was cleared.
func (m *OrderPaymentPreferenceMutation) StatusItemCleared() bool {
	return m.clearedstatus_item
}

// StatusItemID returns the "status_item" edge ID in the mutation.
func (m *OrderPaymentPreferenceMutation) StatusItemID() (id int, exists bool) {
	if m.status_item != nil {
		return *m.status_item, true
	}
	return
}

// StatusItemIDs returns the "status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusItemID instead. It exists only for internal usage by the builders.
func (m *OrderPaymentPreferenceMutation) StatusItemIDs() (ids []int) {
	if id := m.status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusItem resets all changes to the "status_item" edge.
func (m *OrderPaymentPreferenceMutation) ResetStatusItem() {
	m.status_item = nil
	m.clearedstatus_item = false
}

// AddOrderStatusIDs adds the "order_statuses" edge to the OrderStatus entity by ids.
func (m *OrderPaymentPreferenceMutation) AddOrderStatusIDs(ids ...int) {
	if m.order_statuses == nil {
		m.order_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.order_statuses[ids[i]] = struct{}{}
	}
}

// ClearOrderStatuses clears the "order_statuses" edge to the OrderStatus entity.
func (m *OrderPaymentPreferenceMutation) ClearOrderStatuses() {
	m.clearedorder_statuses = true
}

// OrderStatusesCleared reports if the "order_statuses" edge to the OrderStatus entity was cleared.
func (m *OrderPaymentPreferenceMutation) OrderStatusesCleared() bool {
	return m.clearedorder_statuses
}

// RemoveOrderStatusIDs removes the "order_statuses" edge to the OrderStatus entity by IDs.
func (m *OrderPaymentPreferenceMutation) RemoveOrderStatusIDs(ids ...int) {
	if m.removedorder_statuses == nil {
		m.removedorder_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_statuses[ids[i]] = struct{}{}
	}
}

// RemovedOrderStatuses returns the removed IDs of the "order_statuses" edge to the OrderStatus entity.
func (m *OrderPaymentPreferenceMutation) RemovedOrderStatusesIDs() (ids []int) {
	for id := range m.removedorder_statuses {
		ids = append(ids, id)
	}
	return
}

// OrderStatusesIDs returns the "order_statuses" edge IDs in the mutation.
func (m *OrderPaymentPreferenceMutation) OrderStatusesIDs() (ids []int) {
	for id := range m.order_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetOrderStatuses resets all changes to the "order_statuses" edge.
func (m *OrderPaymentPreferenceMutation) ResetOrderStatuses() {
	m.order_statuses = nil
	m.clearedorder_statuses = false
	m.removedorder_statuses = nil
}

// Op returns the operation name.
func (m *OrderPaymentPreferenceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderPaymentPreference).
func (m *OrderPaymentPreferenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderPaymentPreferenceMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.create_time != nil {
		fields = append(fields, orderpaymentpreference.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderpaymentpreference.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderpaymentpreference.FieldStringRef)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, orderpaymentpreference.FieldOrderItemSeqID)
	}
	if m.ship_group_seq_id != nil {
		fields = append(fields, orderpaymentpreference.FieldShipGroupSeqID)
	}
	if m.payment_method_type_id != nil {
		fields = append(fields, orderpaymentpreference.FieldPaymentMethodTypeID)
	}
	if m.payment_method_id != nil {
		fields = append(fields, orderpaymentpreference.FieldPaymentMethodID)
	}
	if m.fin_account_id != nil {
		fields = append(fields, orderpaymentpreference.FieldFinAccountID)
	}
	if m.security_code != nil {
		fields = append(fields, orderpaymentpreference.FieldSecurityCode)
	}
	if m.track_2 != nil {
		fields = append(fields, orderpaymentpreference.FieldTrack2)
	}
	if m.present_flag != nil {
		fields = append(fields, orderpaymentpreference.FieldPresentFlag)
	}
	if m.swiped_flag != nil {
		fields = append(fields, orderpaymentpreference.FieldSwipedFlag)
	}
	if m.overflow_flag != nil {
		fields = append(fields, orderpaymentpreference.FieldOverflowFlag)
	}
	if m.max_amount != nil {
		fields = append(fields, orderpaymentpreference.FieldMaxAmount)
	}
	if m.process_attempt != nil {
		fields = append(fields, orderpaymentpreference.FieldProcessAttempt)
	}
	if m.billing_postal_code != nil {
		fields = append(fields, orderpaymentpreference.FieldBillingPostalCode)
	}
	if m.manual_auth_code != nil {
		fields = append(fields, orderpaymentpreference.FieldManualAuthCode)
	}
	if m.manual_ref_num != nil {
		fields = append(fields, orderpaymentpreference.FieldManualRefNum)
	}
	if m.needs_nsf_retry != nil {
		fields = append(fields, orderpaymentpreference.FieldNeedsNsfRetry)
	}
	if m.created_date != nil {
		fields = append(fields, orderpaymentpreference.FieldCreatedDate)
	}
	if m.created_by_user_login != nil {
		fields = append(fields, orderpaymentpreference.FieldCreatedByUserLogin)
	}
	if m.last_modified_date != nil {
		fields = append(fields, orderpaymentpreference.FieldLastModifiedDate)
	}
	if m.last_modified_by_user_login != nil {
		fields = append(fields, orderpaymentpreference.FieldLastModifiedByUserLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderPaymentPreferenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderpaymentpreference.FieldCreateTime:
		return m.CreateTime()
	case orderpaymentpreference.FieldUpdateTime:
		return m.UpdateTime()
	case orderpaymentpreference.FieldStringRef:
		return m.StringRef()
	case orderpaymentpreference.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case orderpaymentpreference.FieldShipGroupSeqID:
		return m.ShipGroupSeqID()
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		return m.PaymentMethodTypeID()
	case orderpaymentpreference.FieldPaymentMethodID:
		return m.PaymentMethodID()
	case orderpaymentpreference.FieldFinAccountID:
		return m.FinAccountID()
	case orderpaymentpreference.FieldSecurityCode:
		return m.SecurityCode()
	case orderpaymentpreference.FieldTrack2:
		return m.Track2()
	case orderpaymentpreference.FieldPresentFlag:
		return m.PresentFlag()
	case orderpaymentpreference.FieldSwipedFlag:
		return m.SwipedFlag()
	case orderpaymentpreference.FieldOverflowFlag:
		return m.OverflowFlag()
	case orderpaymentpreference.FieldMaxAmount:
		return m.MaxAmount()
	case orderpaymentpreference.FieldProcessAttempt:
		return m.ProcessAttempt()
	case orderpaymentpreference.FieldBillingPostalCode:
		return m.BillingPostalCode()
	case orderpaymentpreference.FieldManualAuthCode:
		return m.ManualAuthCode()
	case orderpaymentpreference.FieldManualRefNum:
		return m.ManualRefNum()
	case orderpaymentpreference.FieldNeedsNsfRetry:
		return m.NeedsNsfRetry()
	case orderpaymentpreference.FieldCreatedDate:
		return m.CreatedDate()
	case orderpaymentpreference.FieldCreatedByUserLogin:
		return m.CreatedByUserLogin()
	case orderpaymentpreference.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case orderpaymentpreference.FieldLastModifiedByUserLogin:
		return m.LastModifiedByUserLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderPaymentPreferenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderpaymentpreference.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderpaymentpreference.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderpaymentpreference.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderpaymentpreference.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case orderpaymentpreference.FieldShipGroupSeqID:
		return m.OldShipGroupSeqID(ctx)
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		return m.OldPaymentMethodTypeID(ctx)
	case orderpaymentpreference.FieldPaymentMethodID:
		return m.OldPaymentMethodID(ctx)
	case orderpaymentpreference.FieldFinAccountID:
		return m.OldFinAccountID(ctx)
	case orderpaymentpreference.FieldSecurityCode:
		return m.OldSecurityCode(ctx)
	case orderpaymentpreference.FieldTrack2:
		return m.OldTrack2(ctx)
	case orderpaymentpreference.FieldPresentFlag:
		return m.OldPresentFlag(ctx)
	case orderpaymentpreference.FieldSwipedFlag:
		return m.OldSwipedFlag(ctx)
	case orderpaymentpreference.FieldOverflowFlag:
		return m.OldOverflowFlag(ctx)
	case orderpaymentpreference.FieldMaxAmount:
		return m.OldMaxAmount(ctx)
	case orderpaymentpreference.FieldProcessAttempt:
		return m.OldProcessAttempt(ctx)
	case orderpaymentpreference.FieldBillingPostalCode:
		return m.OldBillingPostalCode(ctx)
	case orderpaymentpreference.FieldManualAuthCode:
		return m.OldManualAuthCode(ctx)
	case orderpaymentpreference.FieldManualRefNum:
		return m.OldManualRefNum(ctx)
	case orderpaymentpreference.FieldNeedsNsfRetry:
		return m.OldNeedsNsfRetry(ctx)
	case orderpaymentpreference.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case orderpaymentpreference.FieldCreatedByUserLogin:
		return m.OldCreatedByUserLogin(ctx)
	case orderpaymentpreference.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case orderpaymentpreference.FieldLastModifiedByUserLogin:
		return m.OldLastModifiedByUserLogin(ctx)
	}
	return nil, fmt.Errorf("unknown OrderPaymentPreference field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPaymentPreferenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderpaymentpreference.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderpaymentpreference.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderpaymentpreference.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderpaymentpreference.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case orderpaymentpreference.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipGroupSeqID(v)
		return nil
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethodTypeID(v)
		return nil
	case orderpaymentpreference.FieldPaymentMethodID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethodID(v)
		return nil
	case orderpaymentpreference.FieldFinAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinAccountID(v)
		return nil
	case orderpaymentpreference.FieldSecurityCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityCode(v)
		return nil
	case orderpaymentpreference.FieldTrack2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrack2(v)
		return nil
	case orderpaymentpreference.FieldPresentFlag:
		v, ok := value.(orderpaymentpreference.PresentFlag)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPresentFlag(v)
		return nil
	case orderpaymentpreference.FieldSwipedFlag:
		v, ok := value.(orderpaymentpreference.SwipedFlag)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSwipedFlag(v)
		return nil
	case orderpaymentpreference.FieldOverflowFlag:
		v, ok := value.(orderpaymentpreference.OverflowFlag)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverflowFlag(v)
		return nil
	case orderpaymentpreference.FieldMaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAmount(v)
		return nil
	case orderpaymentpreference.FieldProcessAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessAttempt(v)
		return nil
	case orderpaymentpreference.FieldBillingPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingPostalCode(v)
		return nil
	case orderpaymentpreference.FieldManualAuthCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManualAuthCode(v)
		return nil
	case orderpaymentpreference.FieldManualRefNum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManualRefNum(v)
		return nil
	case orderpaymentpreference.FieldNeedsNsfRetry:
		v, ok := value.(orderpaymentpreference.NeedsNsfRetry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedsNsfRetry(v)
		return nil
	case orderpaymentpreference.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case orderpaymentpreference.FieldCreatedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByUserLogin(v)
		return nil
	case orderpaymentpreference.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case orderpaymentpreference.FieldLastModifiedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedByUserLogin(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentPreference field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderPaymentPreferenceMutation) AddedFields() []string {
	var fields []string
	if m.addorder_item_seq_id != nil {
		fields = append(fields, orderpaymentpreference.FieldOrderItemSeqID)
	}
	if m.addship_group_seq_id != nil {
		fields = append(fields, orderpaymentpreference.FieldShipGroupSeqID)
	}
	if m.addpayment_method_type_id != nil {
		fields = append(fields, orderpaymentpreference.FieldPaymentMethodTypeID)
	}
	if m.addpayment_method_id != nil {
		fields = append(fields, orderpaymentpreference.FieldPaymentMethodID)
	}
	if m.addfin_account_id != nil {
		fields = append(fields, orderpaymentpreference.FieldFinAccountID)
	}
	if m.addmax_amount != nil {
		fields = append(fields, orderpaymentpreference.FieldMaxAmount)
	}
	if m.addprocess_attempt != nil {
		fields = append(fields, orderpaymentpreference.FieldProcessAttempt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderPaymentPreferenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderpaymentpreference.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	case orderpaymentpreference.FieldShipGroupSeqID:
		return m.AddedShipGroupSeqID()
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		return m.AddedPaymentMethodTypeID()
	case orderpaymentpreference.FieldPaymentMethodID:
		return m.AddedPaymentMethodID()
	case orderpaymentpreference.FieldFinAccountID:
		return m.AddedFinAccountID()
	case orderpaymentpreference.FieldMaxAmount:
		return m.AddedMaxAmount()
	case orderpaymentpreference.FieldProcessAttempt:
		return m.AddedProcessAttempt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderPaymentPreferenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderpaymentpreference.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	case orderpaymentpreference.FieldShipGroupSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipGroupSeqID(v)
		return nil
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentMethodTypeID(v)
		return nil
	case orderpaymentpreference.FieldPaymentMethodID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentMethodID(v)
		return nil
	case orderpaymentpreference.FieldFinAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinAccountID(v)
		return nil
	case orderpaymentpreference.FieldMaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAmount(v)
		return nil
	case orderpaymentpreference.FieldProcessAttempt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessAttempt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentPreference numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderPaymentPreferenceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderpaymentpreference.FieldStringRef) {
		fields = append(fields, orderpaymentpreference.FieldStringRef)
	}
	if m.FieldCleared(orderpaymentpreference.FieldOrderItemSeqID) {
		fields = append(fields, orderpaymentpreference.FieldOrderItemSeqID)
	}
	if m.FieldCleared(orderpaymentpreference.FieldShipGroupSeqID) {
		fields = append(fields, orderpaymentpreference.FieldShipGroupSeqID)
	}
	if m.FieldCleared(orderpaymentpreference.FieldPaymentMethodTypeID) {
		fields = append(fields, orderpaymentpreference.FieldPaymentMethodTypeID)
	}
	if m.FieldCleared(orderpaymentpreference.FieldPaymentMethodID) {
		fields = append(fields, orderpaymentpreference.FieldPaymentMethodID)
	}
	if m.FieldCleared(orderpaymentpreference.FieldFinAccountID) {
		fields = append(fields, orderpaymentpreference.FieldFinAccountID)
	}
	if m.FieldCleared(orderpaymentpreference.FieldSecurityCode) {
		fields = append(fields, orderpaymentpreference.FieldSecurityCode)
	}
	if m.FieldCleared(orderpaymentpreference.FieldTrack2) {
		fields = append(fields, orderpaymentpreference.FieldTrack2)
	}
	if m.FieldCleared(orderpaymentpreference.FieldPresentFlag) {
		fields = append(fields, orderpaymentpreference.FieldPresentFlag)
	}
	if m.FieldCleared(orderpaymentpreference.FieldSwipedFlag) {
		fields = append(fields, orderpaymentpreference.FieldSwipedFlag)
	}
	if m.FieldCleared(orderpaymentpreference.FieldOverflowFlag) {
		fields = append(fields, orderpaymentpreference.FieldOverflowFlag)
	}
	if m.FieldCleared(orderpaymentpreference.FieldMaxAmount) {
		fields = append(fields, orderpaymentpreference.FieldMaxAmount)
	}
	if m.FieldCleared(orderpaymentpreference.FieldProcessAttempt) {
		fields = append(fields, orderpaymentpreference.FieldProcessAttempt)
	}
	if m.FieldCleared(orderpaymentpreference.FieldBillingPostalCode) {
		fields = append(fields, orderpaymentpreference.FieldBillingPostalCode)
	}
	if m.FieldCleared(orderpaymentpreference.FieldManualAuthCode) {
		fields = append(fields, orderpaymentpreference.FieldManualAuthCode)
	}
	if m.FieldCleared(orderpaymentpreference.FieldManualRefNum) {
		fields = append(fields, orderpaymentpreference.FieldManualRefNum)
	}
	if m.FieldCleared(orderpaymentpreference.FieldNeedsNsfRetry) {
		fields = append(fields, orderpaymentpreference.FieldNeedsNsfRetry)
	}
	if m.FieldCleared(orderpaymentpreference.FieldCreatedDate) {
		fields = append(fields, orderpaymentpreference.FieldCreatedDate)
	}
	if m.FieldCleared(orderpaymentpreference.FieldCreatedByUserLogin) {
		fields = append(fields, orderpaymentpreference.FieldCreatedByUserLogin)
	}
	if m.FieldCleared(orderpaymentpreference.FieldLastModifiedDate) {
		fields = append(fields, orderpaymentpreference.FieldLastModifiedDate)
	}
	if m.FieldCleared(orderpaymentpreference.FieldLastModifiedByUserLogin) {
		fields = append(fields, orderpaymentpreference.FieldLastModifiedByUserLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderPaymentPreferenceMutation) ClearField(name string) error {
	switch name {
	case orderpaymentpreference.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderpaymentpreference.FieldOrderItemSeqID:
		m.ClearOrderItemSeqID()
		return nil
	case orderpaymentpreference.FieldShipGroupSeqID:
		m.ClearShipGroupSeqID()
		return nil
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		m.ClearPaymentMethodTypeID()
		return nil
	case orderpaymentpreference.FieldPaymentMethodID:
		m.ClearPaymentMethodID()
		return nil
	case orderpaymentpreference.FieldFinAccountID:
		m.ClearFinAccountID()
		return nil
	case orderpaymentpreference.FieldSecurityCode:
		m.ClearSecurityCode()
		return nil
	case orderpaymentpreference.FieldTrack2:
		m.ClearTrack2()
		return nil
	case orderpaymentpreference.FieldPresentFlag:
		m.ClearPresentFlag()
		return nil
	case orderpaymentpreference.FieldSwipedFlag:
		m.ClearSwipedFlag()
		return nil
	case orderpaymentpreference.FieldOverflowFlag:
		m.ClearOverflowFlag()
		return nil
	case orderpaymentpreference.FieldMaxAmount:
		m.ClearMaxAmount()
		return nil
	case orderpaymentpreference.FieldProcessAttempt:
		m.ClearProcessAttempt()
		return nil
	case orderpaymentpreference.FieldBillingPostalCode:
		m.ClearBillingPostalCode()
		return nil
	case orderpaymentpreference.FieldManualAuthCode:
		m.ClearManualAuthCode()
		return nil
	case orderpaymentpreference.FieldManualRefNum:
		m.ClearManualRefNum()
		return nil
	case orderpaymentpreference.FieldNeedsNsfRetry:
		m.ClearNeedsNsfRetry()
		return nil
	case orderpaymentpreference.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case orderpaymentpreference.FieldCreatedByUserLogin:
		m.ClearCreatedByUserLogin()
		return nil
	case orderpaymentpreference.FieldLastModifiedDate:
		m.ClearLastModifiedDate()
		return nil
	case orderpaymentpreference.FieldLastModifiedByUserLogin:
		m.ClearLastModifiedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentPreference nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderPaymentPreferenceMutation) ResetField(name string) error {
	switch name {
	case orderpaymentpreference.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderpaymentpreference.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderpaymentpreference.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderpaymentpreference.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case orderpaymentpreference.FieldShipGroupSeqID:
		m.ResetShipGroupSeqID()
		return nil
	case orderpaymentpreference.FieldPaymentMethodTypeID:
		m.ResetPaymentMethodTypeID()
		return nil
	case orderpaymentpreference.FieldPaymentMethodID:
		m.ResetPaymentMethodID()
		return nil
	case orderpaymentpreference.FieldFinAccountID:
		m.ResetFinAccountID()
		return nil
	case orderpaymentpreference.FieldSecurityCode:
		m.ResetSecurityCode()
		return nil
	case orderpaymentpreference.FieldTrack2:
		m.ResetTrack2()
		return nil
	case orderpaymentpreference.FieldPresentFlag:
		m.ResetPresentFlag()
		return nil
	case orderpaymentpreference.FieldSwipedFlag:
		m.ResetSwipedFlag()
		return nil
	case orderpaymentpreference.FieldOverflowFlag:
		m.ResetOverflowFlag()
		return nil
	case orderpaymentpreference.FieldMaxAmount:
		m.ResetMaxAmount()
		return nil
	case orderpaymentpreference.FieldProcessAttempt:
		m.ResetProcessAttempt()
		return nil
	case orderpaymentpreference.FieldBillingPostalCode:
		m.ResetBillingPostalCode()
		return nil
	case orderpaymentpreference.FieldManualAuthCode:
		m.ResetManualAuthCode()
		return nil
	case orderpaymentpreference.FieldManualRefNum:
		m.ResetManualRefNum()
		return nil
	case orderpaymentpreference.FieldNeedsNsfRetry:
		m.ResetNeedsNsfRetry()
		return nil
	case orderpaymentpreference.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case orderpaymentpreference.FieldCreatedByUserLogin:
		m.ResetCreatedByUserLogin()
		return nil
	case orderpaymentpreference.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case orderpaymentpreference.FieldLastModifiedByUserLogin:
		m.ResetLastModifiedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentPreference field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.order_header != nil {
		edges = append(edges, orderpaymentpreference.EdgeOrderHeader)
	}
	if m.order_item != nil {
		edges = append(edges, orderpaymentpreference.EdgeOrderItem)
	}
	if m.order_item_ship_group != nil {
		edges = append(edges, orderpaymentpreference.EdgeOrderItemShipGroup)
	}
	if m.product_price_purpose != nil {
		edges = append(edges, orderpaymentpreference.EdgeProductPricePurpose)
	}
	if m.status_item != nil {
		edges = append(edges, orderpaymentpreference.EdgeStatusItem)
	}
	if m.order_statuses != nil {
		edges = append(edges, orderpaymentpreference.EdgeOrderStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderPaymentPreferenceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderpaymentpreference.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderpaymentpreference.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	case orderpaymentpreference.EdgeOrderItemShipGroup:
		if id := m.order_item_ship_group; id != nil {
			return []ent.Value{*id}
		}
	case orderpaymentpreference.EdgeProductPricePurpose:
		if id := m.product_price_purpose; id != nil {
			return []ent.Value{*id}
		}
	case orderpaymentpreference.EdgeStatusItem:
		if id := m.status_item; id != nil {
			return []ent.Value{*id}
		}
	case orderpaymentpreference.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.order_statuses))
		for id := range m.order_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderPaymentPreferenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedorder_statuses != nil {
		edges = append(edges, orderpaymentpreference.EdgeOrderStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderPaymentPreferenceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderpaymentpreference.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.removedorder_statuses))
		for id := range m.removedorder_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedorder_header {
		edges = append(edges, orderpaymentpreference.EdgeOrderHeader)
	}
	if m.clearedorder_item {
		edges = append(edges, orderpaymentpreference.EdgeOrderItem)
	}
	if m.clearedorder_item_ship_group {
		edges = append(edges, orderpaymentpreference.EdgeOrderItemShipGroup)
	}
	if m.clearedproduct_price_purpose {
		edges = append(edges, orderpaymentpreference.EdgeProductPricePurpose)
	}
	if m.clearedstatus_item {
		edges = append(edges, orderpaymentpreference.EdgeStatusItem)
	}
	if m.clearedorder_statuses {
		edges = append(edges, orderpaymentpreference.EdgeOrderStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderPaymentPreferenceMutation) EdgeCleared(name string) bool {
	switch name {
	case orderpaymentpreference.EdgeOrderHeader:
		return m.clearedorder_header
	case orderpaymentpreference.EdgeOrderItem:
		return m.clearedorder_item
	case orderpaymentpreference.EdgeOrderItemShipGroup:
		return m.clearedorder_item_ship_group
	case orderpaymentpreference.EdgeProductPricePurpose:
		return m.clearedproduct_price_purpose
	case orderpaymentpreference.EdgeStatusItem:
		return m.clearedstatus_item
	case orderpaymentpreference.EdgeOrderStatuses:
		return m.clearedorder_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderPaymentPreferenceMutation) ClearEdge(name string) error {
	switch name {
	case orderpaymentpreference.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderpaymentpreference.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	case orderpaymentpreference.EdgeOrderItemShipGroup:
		m.ClearOrderItemShipGroup()
		return nil
	case orderpaymentpreference.EdgeProductPricePurpose:
		m.ClearProductPricePurpose()
		return nil
	case orderpaymentpreference.EdgeStatusItem:
		m.ClearStatusItem()
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentPreference unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderPaymentPreferenceMutation) ResetEdge(name string) error {
	switch name {
	case orderpaymentpreference.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderpaymentpreference.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	case orderpaymentpreference.EdgeOrderItemShipGroup:
		m.ResetOrderItemShipGroup()
		return nil
	case orderpaymentpreference.EdgeProductPricePurpose:
		m.ResetProductPricePurpose()
		return nil
	case orderpaymentpreference.EdgeStatusItem:
		m.ResetStatusItem()
		return nil
	case orderpaymentpreference.EdgeOrderStatuses:
		m.ResetOrderStatuses()
		return nil
	}
	return fmt.Errorf("unknown OrderPaymentPreference edge %s", name)
}

// OrderRoleMutation represents an operation that mutates the OrderRole nodes in the graph.
type OrderRoleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	string_ref          *string
	party_id            *int
	addparty_id         *int
	clearedFields       map[string]struct{}
	order_header        *int
	clearedorder_header bool
	role_type           *int
	clearedrole_type    bool
	order_items         map[int]struct{}
	removedorder_items  map[int]struct{}
	clearedorder_items  bool
	done                bool
	oldValue            func(context.Context) (*OrderRole, error)
	predicates          []predicate.OrderRole
}

var _ ent.Mutation = (*OrderRoleMutation)(nil)

// orderroleOption allows management of the mutation configuration using functional options.
type orderroleOption func(*OrderRoleMutation)

// newOrderRoleMutation creates new mutation for the OrderRole entity.
func newOrderRoleMutation(c config, op Op, opts ...orderroleOption) *OrderRoleMutation {
	m := &OrderRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderRoleID sets the ID field of the mutation.
func withOrderRoleID(id int) orderroleOption {
	return func(m *OrderRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderRole
		)
		m.oldValue = func(ctx context.Context) (*OrderRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderRole sets the old OrderRole of the mutation.
func withOrderRole(node *OrderRole) orderroleOption {
	return func(m *OrderRoleMutation) {
		m.oldValue = func(context.Context) (*OrderRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderRoleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderRoleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderRole entity.
// If the OrderRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRoleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderRoleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderRoleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderRoleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderRole entity.
// If the OrderRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRoleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderRoleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderRoleMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderRoleMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderRole entity.
// If the OrderRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRoleMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderRoleMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderrole.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderRoleMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderrole.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderRoleMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderrole.FieldStringRef)
}

// SetPartyID sets the "party_id" field.
func (m *OrderRoleMutation) SetPartyID(i int) {
	m.party_id = &i
	m.addparty_id = nil
}

// PartyID returns the value of the "party_id" field in the mutation.
func (m *OrderRoleMutation) PartyID() (r int, exists bool) {
	v := m.party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPartyID returns the old "party_id" field's value of the OrderRole entity.
// If the OrderRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRoleMutation) OldPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartyID: %w", err)
	}
	return oldValue.PartyID, nil
}

// AddPartyID adds i to the "party_id" field.
func (m *OrderRoleMutation) AddPartyID(i int) {
	if m.addparty_id != nil {
		*m.addparty_id += i
	} else {
		m.addparty_id = &i
	}
}

// AddedPartyID returns the value that was added to the "party_id" field in this mutation.
func (m *OrderRoleMutation) AddedPartyID() (r int, exists bool) {
	v := m.addparty_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPartyID resets all changes to the "party_id" field.
func (m *OrderRoleMutation) ResetPartyID() {
	m.party_id = nil
	m.addparty_id = nil
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderRoleMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderRoleMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderRoleMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderRoleMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderRoleMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderRoleMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetRoleTypeID sets the "role_type" edge to the RoleType entity by id.
func (m *OrderRoleMutation) SetRoleTypeID(id int) {
	m.role_type = &id
}

// ClearRoleType clears the "role_type" edge to the RoleType entity.
func (m *OrderRoleMutation) ClearRoleType() {
	m.clearedrole_type = true
}

// RoleTypeCleared reports if the "role_type" edge to the RoleType entity was cleared.
func (m *OrderRoleMutation) RoleTypeCleared() bool {
	return m.clearedrole_type
}

// RoleTypeID returns the "role_type" edge ID in the mutation.
func (m *OrderRoleMutation) RoleTypeID() (id int, exists bool) {
	if m.role_type != nil {
		return *m.role_type, true
	}
	return
}

// RoleTypeIDs returns the "role_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleTypeID instead. It exists only for internal usage by the builders.
func (m *OrderRoleMutation) RoleTypeIDs() (ids []int) {
	if id := m.role_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoleType resets all changes to the "role_type" edge.
func (m *OrderRoleMutation) ResetRoleType() {
	m.role_type = nil
	m.clearedrole_type = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *OrderRoleMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *OrderRoleMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *OrderRoleMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *OrderRoleMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *OrderRoleMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *OrderRoleMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *OrderRoleMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// Op returns the operation name.
func (m *OrderRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderRole).
func (m *OrderRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderRoleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, orderrole.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderrole.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderrole.FieldStringRef)
	}
	if m.party_id != nil {
		fields = append(fields, orderrole.FieldPartyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderrole.FieldCreateTime:
		return m.CreateTime()
	case orderrole.FieldUpdateTime:
		return m.UpdateTime()
	case orderrole.FieldStringRef:
		return m.StringRef()
	case orderrole.FieldPartyID:
		return m.PartyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderrole.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderrole.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderrole.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderrole.FieldPartyID:
		return m.OldPartyID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderrole.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderrole.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderrole.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderrole.FieldPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartyID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderRoleMutation) AddedFields() []string {
	var fields []string
	if m.addparty_id != nil {
		fields = append(fields, orderrole.FieldPartyID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderrole.FieldPartyID:
		return m.AddedPartyID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderrole.FieldPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPartyID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderrole.FieldStringRef) {
		fields = append(fields, orderrole.FieldStringRef)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderRoleMutation) ClearField(name string) error {
	switch name {
	case orderrole.FieldStringRef:
		m.ClearStringRef()
		return nil
	}
	return fmt.Errorf("unknown OrderRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderRoleMutation) ResetField(name string) error {
	switch name {
	case orderrole.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderrole.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderrole.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderrole.FieldPartyID:
		m.ResetPartyID()
		return nil
	}
	return fmt.Errorf("unknown OrderRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.order_header != nil {
		edges = append(edges, orderrole.EdgeOrderHeader)
	}
	if m.role_type != nil {
		edges = append(edges, orderrole.EdgeRoleType)
	}
	if m.order_items != nil {
		edges = append(edges, orderrole.EdgeOrderItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderrole.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderrole.EdgeRoleType:
		if id := m.role_type; id != nil {
			return []ent.Value{*id}
		}
	case orderrole.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorder_items != nil {
		edges = append(edges, orderrole.EdgeOrderItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderrole.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorder_header {
		edges = append(edges, orderrole.EdgeOrderHeader)
	}
	if m.clearedrole_type {
		edges = append(edges, orderrole.EdgeRoleType)
	}
	if m.clearedorder_items {
		edges = append(edges, orderrole.EdgeOrderItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case orderrole.EdgeOrderHeader:
		return m.clearedorder_header
	case orderrole.EdgeRoleType:
		return m.clearedrole_type
	case orderrole.EdgeOrderItems:
		return m.clearedorder_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderRoleMutation) ClearEdge(name string) error {
	switch name {
	case orderrole.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderrole.EdgeRoleType:
		m.ClearRoleType()
		return nil
	}
	return fmt.Errorf("unknown OrderRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderRoleMutation) ResetEdge(name string) error {
	switch name {
	case orderrole.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderrole.EdgeRoleType:
		m.ResetRoleType()
		return nil
	case orderrole.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	}
	return fmt.Errorf("unknown OrderRole edge %s", name)
}

// OrderStatusMutation represents an operation that mutates the OrderStatus nodes in the graph.
type OrderStatusMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	create_time                     *time.Time
	update_time                     *time.Time
	string_ref                      *string
	order_item_seq_id               *int
	addorder_item_seq_id            *int
	status_datetime                 *time.Time
	status_user_login               *string
	change_reason                   *string
	clearedFields                   map[string]struct{}
	status_item                     *int
	clearedstatus_item              bool
	order_header                    *int
	clearedorder_header             bool
	order_item                      *int
	clearedorder_item               bool
	order_payment_preference        *int
	clearedorder_payment_preference bool
	done                            bool
	oldValue                        func(context.Context) (*OrderStatus, error)
	predicates                      []predicate.OrderStatus
}

var _ ent.Mutation = (*OrderStatusMutation)(nil)

// orderstatusOption allows management of the mutation configuration using functional options.
type orderstatusOption func(*OrderStatusMutation)

// newOrderStatusMutation creates new mutation for the OrderStatus entity.
func newOrderStatusMutation(c config, op Op, opts ...orderstatusOption) *OrderStatusMutation {
	m := &OrderStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderStatusID sets the ID field of the mutation.
func withOrderStatusID(id int) orderstatusOption {
	return func(m *OrderStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderStatus
		)
		m.oldValue = func(ctx context.Context) (*OrderStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderStatus sets the old OrderStatus of the mutation.
func withOrderStatus(node *OrderStatus) orderstatusOption {
	return func(m *OrderStatusMutation) {
		m.oldValue = func(context.Context) (*OrderStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderStatusMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderStatusMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderStatusMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderStatusMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderStatusMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderStatusMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *OrderStatusMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *OrderStatusMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *OrderStatusMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[orderstatus.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *OrderStatusMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[orderstatus.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *OrderStatusMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, orderstatus.FieldStringRef)
}

// SetOrderItemSeqID sets the "order_item_seq_id" field.
func (m *OrderStatusMutation) SetOrderItemSeqID(i int) {
	m.order_item_seq_id = &i
	m.addorder_item_seq_id = nil
}

// OrderItemSeqID returns the value of the "order_item_seq_id" field in the mutation.
func (m *OrderStatusMutation) OrderItemSeqID() (r int, exists bool) {
	v := m.order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderItemSeqID returns the old "order_item_seq_id" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderItemSeqID: %w", err)
	}
	return oldValue.OrderItemSeqID, nil
}

// AddOrderItemSeqID adds i to the "order_item_seq_id" field.
func (m *OrderStatusMutation) AddOrderItemSeqID(i int) {
	if m.addorder_item_seq_id != nil {
		*m.addorder_item_seq_id += i
	} else {
		m.addorder_item_seq_id = &i
	}
}

// AddedOrderItemSeqID returns the value that was added to the "order_item_seq_id" field in this mutation.
func (m *OrderStatusMutation) AddedOrderItemSeqID() (r int, exists bool) {
	v := m.addorder_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderItemSeqID clears the value of the "order_item_seq_id" field.
func (m *OrderStatusMutation) ClearOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	m.clearedFields[orderstatus.FieldOrderItemSeqID] = struct{}{}
}

// OrderItemSeqIDCleared returns if the "order_item_seq_id" field was cleared in this mutation.
func (m *OrderStatusMutation) OrderItemSeqIDCleared() bool {
	_, ok := m.clearedFields[orderstatus.FieldOrderItemSeqID]
	return ok
}

// ResetOrderItemSeqID resets all changes to the "order_item_seq_id" field.
func (m *OrderStatusMutation) ResetOrderItemSeqID() {
	m.order_item_seq_id = nil
	m.addorder_item_seq_id = nil
	delete(m.clearedFields, orderstatus.FieldOrderItemSeqID)
}

// SetStatusDatetime sets the "status_datetime" field.
func (m *OrderStatusMutation) SetStatusDatetime(t time.Time) {
	m.status_datetime = &t
}

// StatusDatetime returns the value of the "status_datetime" field in the mutation.
func (m *OrderStatusMutation) StatusDatetime() (r time.Time, exists bool) {
	v := m.status_datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDatetime returns the old "status_datetime" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldStatusDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusDatetime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDatetime: %w", err)
	}
	return oldValue.StatusDatetime, nil
}

// ClearStatusDatetime clears the value of the "status_datetime" field.
func (m *OrderStatusMutation) ClearStatusDatetime() {
	m.status_datetime = nil
	m.clearedFields[orderstatus.FieldStatusDatetime] = struct{}{}
}

// StatusDatetimeCleared returns if the "status_datetime" field was cleared in this mutation.
func (m *OrderStatusMutation) StatusDatetimeCleared() bool {
	_, ok := m.clearedFields[orderstatus.FieldStatusDatetime]
	return ok
}

// ResetStatusDatetime resets all changes to the "status_datetime" field.
func (m *OrderStatusMutation) ResetStatusDatetime() {
	m.status_datetime = nil
	delete(m.clearedFields, orderstatus.FieldStatusDatetime)
}

// SetStatusUserLogin sets the "status_user_login" field.
func (m *OrderStatusMutation) SetStatusUserLogin(s string) {
	m.status_user_login = &s
}

// StatusUserLogin returns the value of the "status_user_login" field in the mutation.
func (m *OrderStatusMutation) StatusUserLogin() (r string, exists bool) {
	v := m.status_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusUserLogin returns the old "status_user_login" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldStatusUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusUserLogin: %w", err)
	}
	return oldValue.StatusUserLogin, nil
}

// ClearStatusUserLogin clears the value of the "status_user_login" field.
func (m *OrderStatusMutation) ClearStatusUserLogin() {
	m.status_user_login = nil
	m.clearedFields[orderstatus.FieldStatusUserLogin] = struct{}{}
}

// StatusUserLoginCleared returns if the "status_user_login" field was cleared in this mutation.
func (m *OrderStatusMutation) StatusUserLoginCleared() bool {
	_, ok := m.clearedFields[orderstatus.FieldStatusUserLogin]
	return ok
}

// ResetStatusUserLogin resets all changes to the "status_user_login" field.
func (m *OrderStatusMutation) ResetStatusUserLogin() {
	m.status_user_login = nil
	delete(m.clearedFields, orderstatus.FieldStatusUserLogin)
}

// SetChangeReason sets the "change_reason" field.
func (m *OrderStatusMutation) SetChangeReason(s string) {
	m.change_reason = &s
}

// ChangeReason returns the value of the "change_reason" field in the mutation.
func (m *OrderStatusMutation) ChangeReason() (r string, exists bool) {
	v := m.change_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeReason returns the old "change_reason" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldChangeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChangeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChangeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeReason: %w", err)
	}
	return oldValue.ChangeReason, nil
}

// ClearChangeReason clears the value of the "change_reason" field.
func (m *OrderStatusMutation) ClearChangeReason() {
	m.change_reason = nil
	m.clearedFields[orderstatus.FieldChangeReason] = struct{}{}
}

// ChangeReasonCleared returns if the "change_reason" field was cleared in this mutation.
func (m *OrderStatusMutation) ChangeReasonCleared() bool {
	_, ok := m.clearedFields[orderstatus.FieldChangeReason]
	return ok
}

// ResetChangeReason resets all changes to the "change_reason" field.
func (m *OrderStatusMutation) ResetChangeReason() {
	m.change_reason = nil
	delete(m.clearedFields, orderstatus.FieldChangeReason)
}

// SetStatusItemID sets the "status_item" edge to the StatusItem entity by id.
func (m *OrderStatusMutation) SetStatusItemID(id int) {
	m.status_item = &id
}

// ClearStatusItem clears the "status_item" edge to the StatusItem entity.
func (m *OrderStatusMutation) ClearStatusItem() {
	m.clearedstatus_item = true
}

// StatusItemCleared reports if the "status_item" edge to the StatusItem entity was cleared.
func (m *OrderStatusMutation) StatusItemCleared() bool {
	return m.clearedstatus_item
}

// StatusItemID returns the "status_item" edge ID in the mutation.
func (m *OrderStatusMutation) StatusItemID() (id int, exists bool) {
	if m.status_item != nil {
		return *m.status_item, true
	}
	return
}

// StatusItemIDs returns the "status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusItemID instead. It exists only for internal usage by the builders.
func (m *OrderStatusMutation) StatusItemIDs() (ids []int) {
	if id := m.status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusItem resets all changes to the "status_item" edge.
func (m *OrderStatusMutation) ResetStatusItem() {
	m.status_item = nil
	m.clearedstatus_item = false
}

// SetOrderHeaderID sets the "order_header" edge to the OrderHeader entity by id.
func (m *OrderStatusMutation) SetOrderHeaderID(id int) {
	m.order_header = &id
}

// ClearOrderHeader clears the "order_header" edge to the OrderHeader entity.
func (m *OrderStatusMutation) ClearOrderHeader() {
	m.clearedorder_header = true
}

// OrderHeaderCleared reports if the "order_header" edge to the OrderHeader entity was cleared.
func (m *OrderStatusMutation) OrderHeaderCleared() bool {
	return m.clearedorder_header
}

// OrderHeaderID returns the "order_header" edge ID in the mutation.
func (m *OrderStatusMutation) OrderHeaderID() (id int, exists bool) {
	if m.order_header != nil {
		return *m.order_header, true
	}
	return
}

// OrderHeaderIDs returns the "order_header" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderHeaderID instead. It exists only for internal usage by the builders.
func (m *OrderStatusMutation) OrderHeaderIDs() (ids []int) {
	if id := m.order_header; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderHeader resets all changes to the "order_header" edge.
func (m *OrderStatusMutation) ResetOrderHeader() {
	m.order_header = nil
	m.clearedorder_header = false
}

// SetOrderItemID sets the "order_item" edge to the OrderItem entity by id.
func (m *OrderStatusMutation) SetOrderItemID(id int) {
	m.order_item = &id
}

// ClearOrderItem clears the "order_item" edge to the OrderItem entity.
func (m *OrderStatusMutation) ClearOrderItem() {
	m.clearedorder_item = true
}

// OrderItemCleared reports if the "order_item" edge to the OrderItem entity was cleared.
func (m *OrderStatusMutation) OrderItemCleared() bool {
	return m.clearedorder_item
}

// OrderItemID returns the "order_item" edge ID in the mutation.
func (m *OrderStatusMutation) OrderItemID() (id int, exists bool) {
	if m.order_item != nil {
		return *m.order_item, true
	}
	return
}

// OrderItemIDs returns the "order_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderItemID instead. It exists only for internal usage by the builders.
func (m *OrderStatusMutation) OrderItemIDs() (ids []int) {
	if id := m.order_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderItem resets all changes to the "order_item" edge.
func (m *OrderStatusMutation) ResetOrderItem() {
	m.order_item = nil
	m.clearedorder_item = false
}

// SetOrderPaymentPreferenceID sets the "order_payment_preference" edge to the OrderPaymentPreference entity by id.
func (m *OrderStatusMutation) SetOrderPaymentPreferenceID(id int) {
	m.order_payment_preference = &id
}

// ClearOrderPaymentPreference clears the "order_payment_preference" edge to the OrderPaymentPreference entity.
func (m *OrderStatusMutation) ClearOrderPaymentPreference() {
	m.clearedorder_payment_preference = true
}

// OrderPaymentPreferenceCleared reports if the "order_payment_preference" edge to the OrderPaymentPreference entity was cleared.
func (m *OrderStatusMutation) OrderPaymentPreferenceCleared() bool {
	return m.clearedorder_payment_preference
}

// OrderPaymentPreferenceID returns the "order_payment_preference" edge ID in the mutation.
func (m *OrderStatusMutation) OrderPaymentPreferenceID() (id int, exists bool) {
	if m.order_payment_preference != nil {
		return *m.order_payment_preference, true
	}
	return
}

// OrderPaymentPreferenceIDs returns the "order_payment_preference" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderPaymentPreferenceID instead. It exists only for internal usage by the builders.
func (m *OrderStatusMutation) OrderPaymentPreferenceIDs() (ids []int) {
	if id := m.order_payment_preference; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderPaymentPreference resets all changes to the "order_payment_preference" edge.
func (m *OrderStatusMutation) ResetOrderPaymentPreference() {
	m.order_payment_preference = nil
	m.clearedorder_payment_preference = false
}

// Op returns the operation name.
func (m *OrderStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderStatus).
func (m *OrderStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, orderstatus.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderstatus.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, orderstatus.FieldStringRef)
	}
	if m.order_item_seq_id != nil {
		fields = append(fields, orderstatus.FieldOrderItemSeqID)
	}
	if m.status_datetime != nil {
		fields = append(fields, orderstatus.FieldStatusDatetime)
	}
	if m.status_user_login != nil {
		fields = append(fields, orderstatus.FieldStatusUserLogin)
	}
	if m.change_reason != nil {
		fields = append(fields, orderstatus.FieldChangeReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderstatus.FieldCreateTime:
		return m.CreateTime()
	case orderstatus.FieldUpdateTime:
		return m.UpdateTime()
	case orderstatus.FieldStringRef:
		return m.StringRef()
	case orderstatus.FieldOrderItemSeqID:
		return m.OrderItemSeqID()
	case orderstatus.FieldStatusDatetime:
		return m.StatusDatetime()
	case orderstatus.FieldStatusUserLogin:
		return m.StatusUserLogin()
	case orderstatus.FieldChangeReason:
		return m.ChangeReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderstatus.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderstatus.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderstatus.FieldStringRef:
		return m.OldStringRef(ctx)
	case orderstatus.FieldOrderItemSeqID:
		return m.OldOrderItemSeqID(ctx)
	case orderstatus.FieldStatusDatetime:
		return m.OldStatusDatetime(ctx)
	case orderstatus.FieldStatusUserLogin:
		return m.OldStatusUserLogin(ctx)
	case orderstatus.FieldChangeReason:
		return m.OldChangeReason(ctx)
	}
	return nil, fmt.Errorf("unknown OrderStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderstatus.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderstatus.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderstatus.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case orderstatus.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderItemSeqID(v)
		return nil
	case orderstatus.FieldStatusDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDatetime(v)
		return nil
	case orderstatus.FieldStatusUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusUserLogin(v)
		return nil
	case orderstatus.FieldChangeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeReason(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderStatusMutation) AddedFields() []string {
	var fields []string
	if m.addorder_item_seq_id != nil {
		fields = append(fields, orderstatus.FieldOrderItemSeqID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderstatus.FieldOrderItemSeqID:
		return m.AddedOrderItemSeqID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderstatus.FieldOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderItemSeqID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderstatus.FieldStringRef) {
		fields = append(fields, orderstatus.FieldStringRef)
	}
	if m.FieldCleared(orderstatus.FieldOrderItemSeqID) {
		fields = append(fields, orderstatus.FieldOrderItemSeqID)
	}
	if m.FieldCleared(orderstatus.FieldStatusDatetime) {
		fields = append(fields, orderstatus.FieldStatusDatetime)
	}
	if m.FieldCleared(orderstatus.FieldStatusUserLogin) {
		fields = append(fields, orderstatus.FieldStatusUserLogin)
	}
	if m.FieldCleared(orderstatus.FieldChangeReason) {
		fields = append(fields, orderstatus.FieldChangeReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderStatusMutation) ClearField(name string) error {
	switch name {
	case orderstatus.FieldStringRef:
		m.ClearStringRef()
		return nil
	case orderstatus.FieldOrderItemSeqID:
		m.ClearOrderItemSeqID()
		return nil
	case orderstatus.FieldStatusDatetime:
		m.ClearStatusDatetime()
		return nil
	case orderstatus.FieldStatusUserLogin:
		m.ClearStatusUserLogin()
		return nil
	case orderstatus.FieldChangeReason:
		m.ClearChangeReason()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderStatusMutation) ResetField(name string) error {
	switch name {
	case orderstatus.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderstatus.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderstatus.FieldStringRef:
		m.ResetStringRef()
		return nil
	case orderstatus.FieldOrderItemSeqID:
		m.ResetOrderItemSeqID()
		return nil
	case orderstatus.FieldStatusDatetime:
		m.ResetStatusDatetime()
		return nil
	case orderstatus.FieldStatusUserLogin:
		m.ResetStatusUserLogin()
		return nil
	case orderstatus.FieldChangeReason:
		m.ResetChangeReason()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.status_item != nil {
		edges = append(edges, orderstatus.EdgeStatusItem)
	}
	if m.order_header != nil {
		edges = append(edges, orderstatus.EdgeOrderHeader)
	}
	if m.order_item != nil {
		edges = append(edges, orderstatus.EdgeOrderItem)
	}
	if m.order_payment_preference != nil {
		edges = append(edges, orderstatus.EdgeOrderPaymentPreference)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderstatus.EdgeStatusItem:
		if id := m.status_item; id != nil {
			return []ent.Value{*id}
		}
	case orderstatus.EdgeOrderHeader:
		if id := m.order_header; id != nil {
			return []ent.Value{*id}
		}
	case orderstatus.EdgeOrderItem:
		if id := m.order_item; id != nil {
			return []ent.Value{*id}
		}
	case orderstatus.EdgeOrderPaymentPreference:
		if id := m.order_payment_preference; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedstatus_item {
		edges = append(edges, orderstatus.EdgeStatusItem)
	}
	if m.clearedorder_header {
		edges = append(edges, orderstatus.EdgeOrderHeader)
	}
	if m.clearedorder_item {
		edges = append(edges, orderstatus.EdgeOrderItem)
	}
	if m.clearedorder_payment_preference {
		edges = append(edges, orderstatus.EdgeOrderPaymentPreference)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case orderstatus.EdgeStatusItem:
		return m.clearedstatus_item
	case orderstatus.EdgeOrderHeader:
		return m.clearedorder_header
	case orderstatus.EdgeOrderItem:
		return m.clearedorder_item
	case orderstatus.EdgeOrderPaymentPreference:
		return m.clearedorder_payment_preference
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderStatusMutation) ClearEdge(name string) error {
	switch name {
	case orderstatus.EdgeStatusItem:
		m.ClearStatusItem()
		return nil
	case orderstatus.EdgeOrderHeader:
		m.ClearOrderHeader()
		return nil
	case orderstatus.EdgeOrderItem:
		m.ClearOrderItem()
		return nil
	case orderstatus.EdgeOrderPaymentPreference:
		m.ClearOrderPaymentPreference()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderStatusMutation) ResetEdge(name string) error {
	switch name {
	case orderstatus.EdgeStatusItem:
		m.ResetStatusItem()
		return nil
	case orderstatus.EdgeOrderHeader:
		m.ResetOrderHeader()
		return nil
	case orderstatus.EdgeOrderItem:
		m.ResetOrderItem()
		return nil
	case orderstatus.EdgeOrderPaymentPreference:
		m.ResetOrderPaymentPreference()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus edge %s", name)
}

// ProdCatalogCategoryTypeMutation represents an operation that mutates the ProdCatalogCategoryType nodes in the graph.
type ProdCatalogCategoryTypeMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	create_time                              *time.Time
	update_time                              *time.Time
	string_ref                               *string
	description                              *string
	clearedFields                            map[string]struct{}
	parent                                   *int
	clearedparent                            bool
	children                                 map[int]struct{}
	removedchildren                          map[int]struct{}
	clearedchildren                          bool
	child_prod_catalog_category_types        map[int]struct{}
	removedchild_prod_catalog_category_types map[int]struct{}
	clearedchild_prod_catalog_category_types bool
	done                                     bool
	oldValue                                 func(context.Context) (*ProdCatalogCategoryType, error)
	predicates                               []predicate.ProdCatalogCategoryType
}

var _ ent.Mutation = (*ProdCatalogCategoryTypeMutation)(nil)

// prodcatalogcategorytypeOption allows management of the mutation configuration using functional options.
type prodcatalogcategorytypeOption func(*ProdCatalogCategoryTypeMutation)

// newProdCatalogCategoryTypeMutation creates new mutation for the ProdCatalogCategoryType entity.
func newProdCatalogCategoryTypeMutation(c config, op Op, opts ...prodcatalogcategorytypeOption) *ProdCatalogCategoryTypeMutation {
	m := &ProdCatalogCategoryTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProdCatalogCategoryType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProdCatalogCategoryTypeID sets the ID field of the mutation.
func withProdCatalogCategoryTypeID(id int) prodcatalogcategorytypeOption {
	return func(m *ProdCatalogCategoryTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProdCatalogCategoryType
		)
		m.oldValue = func(ctx context.Context) (*ProdCatalogCategoryType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProdCatalogCategoryType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProdCatalogCategoryType sets the old ProdCatalogCategoryType of the mutation.
func withProdCatalogCategoryType(node *ProdCatalogCategoryType) prodcatalogcategorytypeOption {
	return func(m *ProdCatalogCategoryTypeMutation) {
		m.oldValue = func(context.Context) (*ProdCatalogCategoryType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProdCatalogCategoryTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProdCatalogCategoryTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProdCatalogCategoryTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProdCatalogCategoryTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProdCatalogCategoryTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProdCatalogCategoryType entity.
// If the ProdCatalogCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdCatalogCategoryTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProdCatalogCategoryTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProdCatalogCategoryTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProdCatalogCategoryTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProdCatalogCategoryType entity.
// If the ProdCatalogCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdCatalogCategoryTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProdCatalogCategoryTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProdCatalogCategoryTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProdCatalogCategoryTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProdCatalogCategoryType entity.
// If the ProdCatalogCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdCatalogCategoryTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProdCatalogCategoryTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[prodcatalogcategorytype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProdCatalogCategoryTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[prodcatalogcategorytype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProdCatalogCategoryTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, prodcatalogcategorytype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProdCatalogCategoryTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProdCatalogCategoryTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProdCatalogCategoryType entity.
// If the ProdCatalogCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdCatalogCategoryTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProdCatalogCategoryTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[prodcatalogcategorytype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProdCatalogCategoryTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[prodcatalogcategorytype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProdCatalogCategoryTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, prodcatalogcategorytype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProdCatalogCategoryType entity by id.
func (m *ProdCatalogCategoryTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProdCatalogCategoryType entity.
func (m *ProdCatalogCategoryTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProdCatalogCategoryType entity was cleared.
func (m *ProdCatalogCategoryTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProdCatalogCategoryTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProdCatalogCategoryTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProdCatalogCategoryTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProdCatalogCategoryType entity by ids.
func (m *ProdCatalogCategoryTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProdCatalogCategoryType entity.
func (m *ProdCatalogCategoryTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProdCatalogCategoryType entity was cleared.
func (m *ProdCatalogCategoryTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProdCatalogCategoryType entity by IDs.
func (m *ProdCatalogCategoryTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProdCatalogCategoryType entity.
func (m *ProdCatalogCategoryTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProdCatalogCategoryTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProdCatalogCategoryTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProdCatalogCategoryTypeIDs adds the "child_prod_catalog_category_types" edge to the ProdCatalogCategoryType entity by ids.
func (m *ProdCatalogCategoryTypeMutation) AddChildProdCatalogCategoryTypeIDs(ids ...int) {
	if m.child_prod_catalog_category_types == nil {
		m.child_prod_catalog_category_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_prod_catalog_category_types[ids[i]] = struct{}{}
	}
}

// ClearChildProdCatalogCategoryTypes clears the "child_prod_catalog_category_types" edge to the ProdCatalogCategoryType entity.
func (m *ProdCatalogCategoryTypeMutation) ClearChildProdCatalogCategoryTypes() {
	m.clearedchild_prod_catalog_category_types = true
}

// ChildProdCatalogCategoryTypesCleared reports if the "child_prod_catalog_category_types" edge to the ProdCatalogCategoryType entity was cleared.
func (m *ProdCatalogCategoryTypeMutation) ChildProdCatalogCategoryTypesCleared() bool {
	return m.clearedchild_prod_catalog_category_types
}

// RemoveChildProdCatalogCategoryTypeIDs removes the "child_prod_catalog_category_types" edge to the ProdCatalogCategoryType entity by IDs.
func (m *ProdCatalogCategoryTypeMutation) RemoveChildProdCatalogCategoryTypeIDs(ids ...int) {
	if m.removedchild_prod_catalog_category_types == nil {
		m.removedchild_prod_catalog_category_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_prod_catalog_category_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProdCatalogCategoryTypes returns the removed IDs of the "child_prod_catalog_category_types" edge to the ProdCatalogCategoryType entity.
func (m *ProdCatalogCategoryTypeMutation) RemovedChildProdCatalogCategoryTypesIDs() (ids []int) {
	for id := range m.removedchild_prod_catalog_category_types {
		ids = append(ids, id)
	}
	return
}

// ChildProdCatalogCategoryTypesIDs returns the "child_prod_catalog_category_types" edge IDs in the mutation.
func (m *ProdCatalogCategoryTypeMutation) ChildProdCatalogCategoryTypesIDs() (ids []int) {
	for id := range m.child_prod_catalog_category_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProdCatalogCategoryTypes resets all changes to the "child_prod_catalog_category_types" edge.
func (m *ProdCatalogCategoryTypeMutation) ResetChildProdCatalogCategoryTypes() {
	m.child_prod_catalog_category_types = nil
	m.clearedchild_prod_catalog_category_types = false
	m.removedchild_prod_catalog_category_types = nil
}

// Op returns the operation name.
func (m *ProdCatalogCategoryTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProdCatalogCategoryType).
func (m *ProdCatalogCategoryTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProdCatalogCategoryTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, prodcatalogcategorytype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, prodcatalogcategorytype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, prodcatalogcategorytype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, prodcatalogcategorytype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProdCatalogCategoryTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prodcatalogcategorytype.FieldCreateTime:
		return m.CreateTime()
	case prodcatalogcategorytype.FieldUpdateTime:
		return m.UpdateTime()
	case prodcatalogcategorytype.FieldStringRef:
		return m.StringRef()
	case prodcatalogcategorytype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProdCatalogCategoryTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prodcatalogcategorytype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case prodcatalogcategorytype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case prodcatalogcategorytype.FieldStringRef:
		return m.OldStringRef(ctx)
	case prodcatalogcategorytype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProdCatalogCategoryType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProdCatalogCategoryTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prodcatalogcategorytype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case prodcatalogcategorytype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case prodcatalogcategorytype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case prodcatalogcategorytype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProdCatalogCategoryType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProdCatalogCategoryTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProdCatalogCategoryTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProdCatalogCategoryTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProdCatalogCategoryType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProdCatalogCategoryTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prodcatalogcategorytype.FieldStringRef) {
		fields = append(fields, prodcatalogcategorytype.FieldStringRef)
	}
	if m.FieldCleared(prodcatalogcategorytype.FieldDescription) {
		fields = append(fields, prodcatalogcategorytype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProdCatalogCategoryTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProdCatalogCategoryTypeMutation) ClearField(name string) error {
	switch name {
	case prodcatalogcategorytype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case prodcatalogcategorytype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProdCatalogCategoryType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProdCatalogCategoryTypeMutation) ResetField(name string) error {
	switch name {
	case prodcatalogcategorytype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case prodcatalogcategorytype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case prodcatalogcategorytype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case prodcatalogcategorytype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProdCatalogCategoryType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProdCatalogCategoryTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, prodcatalogcategorytype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, prodcatalogcategorytype.EdgeChildren)
	}
	if m.child_prod_catalog_category_types != nil {
		edges = append(edges, prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProdCatalogCategoryTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prodcatalogcategorytype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case prodcatalogcategorytype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes:
		ids := make([]ent.Value, 0, len(m.child_prod_catalog_category_types))
		for id := range m.child_prod_catalog_category_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProdCatalogCategoryTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, prodcatalogcategorytype.EdgeChildren)
	}
	if m.removedchild_prod_catalog_category_types != nil {
		edges = append(edges, prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProdCatalogCategoryTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prodcatalogcategorytype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_prod_catalog_category_types))
		for id := range m.removedchild_prod_catalog_category_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProdCatalogCategoryTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, prodcatalogcategorytype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, prodcatalogcategorytype.EdgeChildren)
	}
	if m.clearedchild_prod_catalog_category_types {
		edges = append(edges, prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProdCatalogCategoryTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case prodcatalogcategorytype.EdgeParent:
		return m.clearedparent
	case prodcatalogcategorytype.EdgeChildren:
		return m.clearedchildren
	case prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes:
		return m.clearedchild_prod_catalog_category_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProdCatalogCategoryTypeMutation) ClearEdge(name string) error {
	switch name {
	case prodcatalogcategorytype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProdCatalogCategoryType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProdCatalogCategoryTypeMutation) ResetEdge(name string) error {
	switch name {
	case prodcatalogcategorytype.EdgeParent:
		m.ResetParent()
		return nil
	case prodcatalogcategorytype.EdgeChildren:
		m.ResetChildren()
		return nil
	case prodcatalogcategorytype.EdgeChildProdCatalogCategoryTypes:
		m.ResetChildProdCatalogCategoryTypes()
		return nil
	}
	return fmt.Errorf("unknown ProdCatalogCategoryType edge %s", name)
}

// ProdConfItemContentTypeMutation represents an operation that mutates the ProdConfItemContentType nodes in the graph.
type ProdConfItemContentTypeMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *int
	create_time                               *time.Time
	update_time                               *time.Time
	string_ref                                *string
	has_table                                 *prodconfitemcontenttype.HasTable
	description                               *string
	clearedFields                             map[string]struct{}
	parent                                    *int
	clearedparent                             bool
	children                                  map[int]struct{}
	removedchildren                           map[int]struct{}
	clearedchildren                           bool
	child_prod_conf_item_content_types        map[int]struct{}
	removedchild_prod_conf_item_content_types map[int]struct{}
	clearedchild_prod_conf_item_content_types bool
	done                                      bool
	oldValue                                  func(context.Context) (*ProdConfItemContentType, error)
	predicates                                []predicate.ProdConfItemContentType
}

var _ ent.Mutation = (*ProdConfItemContentTypeMutation)(nil)

// prodconfitemcontenttypeOption allows management of the mutation configuration using functional options.
type prodconfitemcontenttypeOption func(*ProdConfItemContentTypeMutation)

// newProdConfItemContentTypeMutation creates new mutation for the ProdConfItemContentType entity.
func newProdConfItemContentTypeMutation(c config, op Op, opts ...prodconfitemcontenttypeOption) *ProdConfItemContentTypeMutation {
	m := &ProdConfItemContentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProdConfItemContentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProdConfItemContentTypeID sets the ID field of the mutation.
func withProdConfItemContentTypeID(id int) prodconfitemcontenttypeOption {
	return func(m *ProdConfItemContentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProdConfItemContentType
		)
		m.oldValue = func(ctx context.Context) (*ProdConfItemContentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProdConfItemContentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProdConfItemContentType sets the old ProdConfItemContentType of the mutation.
func withProdConfItemContentType(node *ProdConfItemContentType) prodconfitemcontenttypeOption {
	return func(m *ProdConfItemContentTypeMutation) {
		m.oldValue = func(context.Context) (*ProdConfItemContentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProdConfItemContentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProdConfItemContentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProdConfItemContentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProdConfItemContentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProdConfItemContentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProdConfItemContentType entity.
// If the ProdConfItemContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdConfItemContentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProdConfItemContentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProdConfItemContentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProdConfItemContentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProdConfItemContentType entity.
// If the ProdConfItemContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdConfItemContentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProdConfItemContentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProdConfItemContentTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProdConfItemContentTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProdConfItemContentType entity.
// If the ProdConfItemContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdConfItemContentTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProdConfItemContentTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[prodconfitemcontenttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProdConfItemContentTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[prodconfitemcontenttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProdConfItemContentTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, prodconfitemcontenttype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProdConfItemContentTypeMutation) SetHasTable(pt prodconfitemcontenttype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProdConfItemContentTypeMutation) HasTable() (r prodconfitemcontenttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProdConfItemContentType entity.
// If the ProdConfItemContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdConfItemContentTypeMutation) OldHasTable(ctx context.Context) (v prodconfitemcontenttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProdConfItemContentTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[prodconfitemcontenttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProdConfItemContentTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[prodconfitemcontenttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProdConfItemContentTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, prodconfitemcontenttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProdConfItemContentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProdConfItemContentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProdConfItemContentType entity.
// If the ProdConfItemContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProdConfItemContentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProdConfItemContentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[prodconfitemcontenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProdConfItemContentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[prodconfitemcontenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProdConfItemContentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, prodconfitemcontenttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProdConfItemContentType entity by id.
func (m *ProdConfItemContentTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProdConfItemContentType entity.
func (m *ProdConfItemContentTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProdConfItemContentType entity was cleared.
func (m *ProdConfItemContentTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProdConfItemContentTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProdConfItemContentTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProdConfItemContentTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProdConfItemContentType entity by ids.
func (m *ProdConfItemContentTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProdConfItemContentType entity.
func (m *ProdConfItemContentTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProdConfItemContentType entity was cleared.
func (m *ProdConfItemContentTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProdConfItemContentType entity by IDs.
func (m *ProdConfItemContentTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProdConfItemContentType entity.
func (m *ProdConfItemContentTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProdConfItemContentTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProdConfItemContentTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProdConfItemContentTypeIDs adds the "child_prod_conf_item_content_types" edge to the ProdConfItemContentType entity by ids.
func (m *ProdConfItemContentTypeMutation) AddChildProdConfItemContentTypeIDs(ids ...int) {
	if m.child_prod_conf_item_content_types == nil {
		m.child_prod_conf_item_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_prod_conf_item_content_types[ids[i]] = struct{}{}
	}
}

// ClearChildProdConfItemContentTypes clears the "child_prod_conf_item_content_types" edge to the ProdConfItemContentType entity.
func (m *ProdConfItemContentTypeMutation) ClearChildProdConfItemContentTypes() {
	m.clearedchild_prod_conf_item_content_types = true
}

// ChildProdConfItemContentTypesCleared reports if the "child_prod_conf_item_content_types" edge to the ProdConfItemContentType entity was cleared.
func (m *ProdConfItemContentTypeMutation) ChildProdConfItemContentTypesCleared() bool {
	return m.clearedchild_prod_conf_item_content_types
}

// RemoveChildProdConfItemContentTypeIDs removes the "child_prod_conf_item_content_types" edge to the ProdConfItemContentType entity by IDs.
func (m *ProdConfItemContentTypeMutation) RemoveChildProdConfItemContentTypeIDs(ids ...int) {
	if m.removedchild_prod_conf_item_content_types == nil {
		m.removedchild_prod_conf_item_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_prod_conf_item_content_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProdConfItemContentTypes returns the removed IDs of the "child_prod_conf_item_content_types" edge to the ProdConfItemContentType entity.
func (m *ProdConfItemContentTypeMutation) RemovedChildProdConfItemContentTypesIDs() (ids []int) {
	for id := range m.removedchild_prod_conf_item_content_types {
		ids = append(ids, id)
	}
	return
}

// ChildProdConfItemContentTypesIDs returns the "child_prod_conf_item_content_types" edge IDs in the mutation.
func (m *ProdConfItemContentTypeMutation) ChildProdConfItemContentTypesIDs() (ids []int) {
	for id := range m.child_prod_conf_item_content_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProdConfItemContentTypes resets all changes to the "child_prod_conf_item_content_types" edge.
func (m *ProdConfItemContentTypeMutation) ResetChildProdConfItemContentTypes() {
	m.child_prod_conf_item_content_types = nil
	m.clearedchild_prod_conf_item_content_types = false
	m.removedchild_prod_conf_item_content_types = nil
}

// Op returns the operation name.
func (m *ProdConfItemContentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProdConfItemContentType).
func (m *ProdConfItemContentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProdConfItemContentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, prodconfitemcontenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, prodconfitemcontenttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, prodconfitemcontenttype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, prodconfitemcontenttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, prodconfitemcontenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProdConfItemContentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prodconfitemcontenttype.FieldCreateTime:
		return m.CreateTime()
	case prodconfitemcontenttype.FieldUpdateTime:
		return m.UpdateTime()
	case prodconfitemcontenttype.FieldStringRef:
		return m.StringRef()
	case prodconfitemcontenttype.FieldHasTable:
		return m.HasTable()
	case prodconfitemcontenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProdConfItemContentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prodconfitemcontenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case prodconfitemcontenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case prodconfitemcontenttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case prodconfitemcontenttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case prodconfitemcontenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProdConfItemContentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProdConfItemContentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prodconfitemcontenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case prodconfitemcontenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case prodconfitemcontenttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case prodconfitemcontenttype.FieldHasTable:
		v, ok := value.(prodconfitemcontenttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case prodconfitemcontenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProdConfItemContentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProdConfItemContentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProdConfItemContentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProdConfItemContentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProdConfItemContentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProdConfItemContentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(prodconfitemcontenttype.FieldStringRef) {
		fields = append(fields, prodconfitemcontenttype.FieldStringRef)
	}
	if m.FieldCleared(prodconfitemcontenttype.FieldHasTable) {
		fields = append(fields, prodconfitemcontenttype.FieldHasTable)
	}
	if m.FieldCleared(prodconfitemcontenttype.FieldDescription) {
		fields = append(fields, prodconfitemcontenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProdConfItemContentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProdConfItemContentTypeMutation) ClearField(name string) error {
	switch name {
	case prodconfitemcontenttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case prodconfitemcontenttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case prodconfitemcontenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProdConfItemContentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProdConfItemContentTypeMutation) ResetField(name string) error {
	switch name {
	case prodconfitemcontenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case prodconfitemcontenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case prodconfitemcontenttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case prodconfitemcontenttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case prodconfitemcontenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProdConfItemContentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProdConfItemContentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, prodconfitemcontenttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, prodconfitemcontenttype.EdgeChildren)
	}
	if m.child_prod_conf_item_content_types != nil {
		edges = append(edges, prodconfitemcontenttype.EdgeChildProdConfItemContentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProdConfItemContentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prodconfitemcontenttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case prodconfitemcontenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case prodconfitemcontenttype.EdgeChildProdConfItemContentTypes:
		ids := make([]ent.Value, 0, len(m.child_prod_conf_item_content_types))
		for id := range m.child_prod_conf_item_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProdConfItemContentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, prodconfitemcontenttype.EdgeChildren)
	}
	if m.removedchild_prod_conf_item_content_types != nil {
		edges = append(edges, prodconfitemcontenttype.EdgeChildProdConfItemContentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProdConfItemContentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prodconfitemcontenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case prodconfitemcontenttype.EdgeChildProdConfItemContentTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_prod_conf_item_content_types))
		for id := range m.removedchild_prod_conf_item_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProdConfItemContentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, prodconfitemcontenttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, prodconfitemcontenttype.EdgeChildren)
	}
	if m.clearedchild_prod_conf_item_content_types {
		edges = append(edges, prodconfitemcontenttype.EdgeChildProdConfItemContentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProdConfItemContentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case prodconfitemcontenttype.EdgeParent:
		return m.clearedparent
	case prodconfitemcontenttype.EdgeChildren:
		return m.clearedchildren
	case prodconfitemcontenttype.EdgeChildProdConfItemContentTypes:
		return m.clearedchild_prod_conf_item_content_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProdConfItemContentTypeMutation) ClearEdge(name string) error {
	switch name {
	case prodconfitemcontenttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProdConfItemContentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProdConfItemContentTypeMutation) ResetEdge(name string) error {
	switch name {
	case prodconfitemcontenttype.EdgeParent:
		m.ResetParent()
		return nil
	case prodconfitemcontenttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case prodconfitemcontenttype.EdgeChildProdConfItemContentTypes:
		m.ResetChildProdConfItemContentTypes()
		return nil
	}
	return fmt.Errorf("unknown ProdConfItemContentType edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *int
	create_time                               *time.Time
	update_time                               *time.Time
	string_ref                                *string
	facility_id                               *int
	addfacility_id                            *int
	introduction_date                         *time.Time
	release_date                              *time.Time
	support_discontinuation_date              *time.Time
	sales_discontinuation_date                *time.Time
	sales_disc_when_not_avail                 *product.SalesDiscWhenNotAvail
	internal_name                             *string
	brand_name                                *string
	comments                                  *string
	product_name                              *string
	description                               *string
	long_description                          *string
	price_detail_text                         *string
	small_image_url                           *string
	medium_image_url                          *string
	large_image_url                           *string
	detail_image_url                          *string
	original_image_url                        *string
	detail_screen                             *string
	inventory_message                         *string
	require_inventory                         *product.RequireInventory
	quantity_uom_id                           *int
	addquantity_uom_id                        *int
	quantity_included                         *float64
	addquantity_included                      *float64
	pieces_included                           *int
	addpieces_included                        *int
	require_amount                            *product.RequireAmount
	fixed_amount                              *float64
	addfixed_amount                           *float64
	amount_uom_type_id                        *int
	addamount_uom_type_id                     *int
	weight_uom_id                             *int
	addweight_uom_id                          *int
	shipping_weight                           *float64
	addshipping_weight                        *float64
	product_weight                            *float64
	addproduct_weight                         *float64
	height_uom_id                             *int
	addheight_uom_id                          *int
	product_height                            *float64
	addproduct_height                         *float64
	shipping_height                           *float64
	addshipping_height                        *float64
	width_uom_id                              *int
	addwidth_uom_id                           *int
	product_width                             *float64
	addproduct_width                          *float64
	shipping_width                            *float64
	addshipping_width                         *float64
	depth_uom_id                              *int
	adddepth_uom_id                           *int
	product_depth                             *float64
	addproduct_depth                          *float64
	shipping_depth                            *float64
	addshipping_depth                         *float64
	diameter_uom_id                           *int
	adddiameter_uom_id                        *int
	product_diameter                          *float64
	addproduct_diameter                       *float64
	product_rating                            *float64
	addproduct_rating                         *float64
	returnable                                *product.Returnable
	taxable                                   *product.Taxable
	charge_shipping                           *product.ChargeShipping
	auto_create_keywords                      *product.AutoCreateKeywords
	include_in_promotions                     *product.IncludeInPromotions
	is_virtual                                *product.IsVirtual
	is_variant                                *product.IsVariant
	origin_geo_id                             *int
	addorigin_geo_id                          *int
	bill_of_material_level                    *int
	addbill_of_material_level                 *int
	reserv_max_persons                        *float64
	addreserv_max_persons                     *float64
	reserv_2_nd_pp_perc                       *float64
	addreserv_2_nd_pp_perc                    *float64
	reserv_nth_pp_perc                        *float64
	addreserv_nth_pp_perc                     *float64
	config_id                                 *int
	addconfig_id                              *int
	created_date                              *time.Time
	created_by_user_login                     *string
	last_modified_date                        *time.Time
	last_modified_by_user_login               *string
	in_shipping_box                           *product.InShippingBox
	default_shipment_box_type_id              *int
	adddefault_shipment_box_type_id           *int
	lot_id_filled_in                          *string
	order_decimal_quantity                    *product.OrderDecimalQuantity
	clearedFields                             map[string]struct{}
	product_type                              *int
	clearedproduct_type                       bool
	primary_product_category                  *int
	clearedprimary_product_category           bool
	virtual_variant_method_enumeration        *int
	clearedvirtual_variant_method_enumeration bool
	rating_enumeration                        *int
	clearedrating_enumeration                 bool
	requirement_method_enumeration            *int
	clearedrequirement_method_enumeration     bool
	inventory_item_type                       *int
	clearedinventory_item_type                bool
	order_items                               map[int]struct{}
	removedorder_items                        map[int]struct{}
	clearedorder_items                        bool
	main_product_assocs                       map[int]struct{}
	removedmain_product_assocs                map[int]struct{}
	clearedmain_product_assocs                bool
	assoc_product_assocs                      map[int]struct{}
	removedassoc_product_assocs               map[int]struct{}
	clearedassoc_product_assocs               bool
	product_prices                            map[int]struct{}
	removedproduct_prices                     map[int]struct{}
	clearedproduct_prices                     bool
	product_reviews                           map[int]struct{}
	removedproduct_reviews                    map[int]struct{}
	clearedproduct_reviews                    bool
	done                                      bool
	oldValue                                  func(context.Context) (*Product, error)
	predicates                                []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[product.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[product.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, product.FieldStringRef)
}

// SetFacilityID sets the "facility_id" field.
func (m *ProductMutation) SetFacilityID(i int) {
	m.facility_id = &i
	m.addfacility_id = nil
}

// FacilityID returns the value of the "facility_id" field in the mutation.
func (m *ProductMutation) FacilityID() (r int, exists bool) {
	v := m.facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "facility_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// AddFacilityID adds i to the "facility_id" field.
func (m *ProductMutation) AddFacilityID(i int) {
	if m.addfacility_id != nil {
		*m.addfacility_id += i
	} else {
		m.addfacility_id = &i
	}
}

// AddedFacilityID returns the value that was added to the "facility_id" field in this mutation.
func (m *ProductMutation) AddedFacilityID() (r int, exists bool) {
	v := m.addfacility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFacilityID clears the value of the "facility_id" field.
func (m *ProductMutation) ClearFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	m.clearedFields[product.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "facility_id" field was cleared in this mutation.
func (m *ProductMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[product.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "facility_id" field.
func (m *ProductMutation) ResetFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	delete(m.clearedFields, product.FieldFacilityID)
}

// SetIntroductionDate sets the "introduction_date" field.
func (m *ProductMutation) SetIntroductionDate(t time.Time) {
	m.introduction_date = &t
}

// IntroductionDate returns the value of the "introduction_date" field in the mutation.
func (m *ProductMutation) IntroductionDate() (r time.Time, exists bool) {
	v := m.introduction_date
	if v == nil {
		return
	}
	return *v, true
}

// OldIntroductionDate returns the old "introduction_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIntroductionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntroductionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntroductionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntroductionDate: %w", err)
	}
	return oldValue.IntroductionDate, nil
}

// ClearIntroductionDate clears the value of the "introduction_date" field.
func (m *ProductMutation) ClearIntroductionDate() {
	m.introduction_date = nil
	m.clearedFields[product.FieldIntroductionDate] = struct{}{}
}

// IntroductionDateCleared returns if the "introduction_date" field was cleared in this mutation.
func (m *ProductMutation) IntroductionDateCleared() bool {
	_, ok := m.clearedFields[product.FieldIntroductionDate]
	return ok
}

// ResetIntroductionDate resets all changes to the "introduction_date" field.
func (m *ProductMutation) ResetIntroductionDate() {
	m.introduction_date = nil
	delete(m.clearedFields, product.FieldIntroductionDate)
}

// SetReleaseDate sets the "release_date" field.
func (m *ProductMutation) SetReleaseDate(t time.Time) {
	m.release_date = &t
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *ProductMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *ProductMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[product.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *ProductMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[product.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *ProductMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, product.FieldReleaseDate)
}

// SetSupportDiscontinuationDate sets the "support_discontinuation_date" field.
func (m *ProductMutation) SetSupportDiscontinuationDate(t time.Time) {
	m.support_discontinuation_date = &t
}

// SupportDiscontinuationDate returns the value of the "support_discontinuation_date" field in the mutation.
func (m *ProductMutation) SupportDiscontinuationDate() (r time.Time, exists bool) {
	v := m.support_discontinuation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportDiscontinuationDate returns the old "support_discontinuation_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSupportDiscontinuationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSupportDiscontinuationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSupportDiscontinuationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportDiscontinuationDate: %w", err)
	}
	return oldValue.SupportDiscontinuationDate, nil
}

// ClearSupportDiscontinuationDate clears the value of the "support_discontinuation_date" field.
func (m *ProductMutation) ClearSupportDiscontinuationDate() {
	m.support_discontinuation_date = nil
	m.clearedFields[product.FieldSupportDiscontinuationDate] = struct{}{}
}

// SupportDiscontinuationDateCleared returns if the "support_discontinuation_date" field was cleared in this mutation.
func (m *ProductMutation) SupportDiscontinuationDateCleared() bool {
	_, ok := m.clearedFields[product.FieldSupportDiscontinuationDate]
	return ok
}

// ResetSupportDiscontinuationDate resets all changes to the "support_discontinuation_date" field.
func (m *ProductMutation) ResetSupportDiscontinuationDate() {
	m.support_discontinuation_date = nil
	delete(m.clearedFields, product.FieldSupportDiscontinuationDate)
}

// SetSalesDiscontinuationDate sets the "sales_discontinuation_date" field.
func (m *ProductMutation) SetSalesDiscontinuationDate(t time.Time) {
	m.sales_discontinuation_date = &t
}

// SalesDiscontinuationDate returns the value of the "sales_discontinuation_date" field in the mutation.
func (m *ProductMutation) SalesDiscontinuationDate() (r time.Time, exists bool) {
	v := m.sales_discontinuation_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesDiscontinuationDate returns the old "sales_discontinuation_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSalesDiscontinuationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalesDiscontinuationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalesDiscontinuationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesDiscontinuationDate: %w", err)
	}
	return oldValue.SalesDiscontinuationDate, nil
}

// ClearSalesDiscontinuationDate clears the value of the "sales_discontinuation_date" field.
func (m *ProductMutation) ClearSalesDiscontinuationDate() {
	m.sales_discontinuation_date = nil
	m.clearedFields[product.FieldSalesDiscontinuationDate] = struct{}{}
}

// SalesDiscontinuationDateCleared returns if the "sales_discontinuation_date" field was cleared in this mutation.
func (m *ProductMutation) SalesDiscontinuationDateCleared() bool {
	_, ok := m.clearedFields[product.FieldSalesDiscontinuationDate]
	return ok
}

// ResetSalesDiscontinuationDate resets all changes to the "sales_discontinuation_date" field.
func (m *ProductMutation) ResetSalesDiscontinuationDate() {
	m.sales_discontinuation_date = nil
	delete(m.clearedFields, product.FieldSalesDiscontinuationDate)
}

// SetSalesDiscWhenNotAvail sets the "sales_disc_when_not_avail" field.
func (m *ProductMutation) SetSalesDiscWhenNotAvail(pdwna product.SalesDiscWhenNotAvail) {
	m.sales_disc_when_not_avail = &pdwna
}

// SalesDiscWhenNotAvail returns the value of the "sales_disc_when_not_avail" field in the mutation.
func (m *ProductMutation) SalesDiscWhenNotAvail() (r product.SalesDiscWhenNotAvail, exists bool) {
	v := m.sales_disc_when_not_avail
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesDiscWhenNotAvail returns the old "sales_disc_when_not_avail" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSalesDiscWhenNotAvail(ctx context.Context) (v product.SalesDiscWhenNotAvail, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalesDiscWhenNotAvail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalesDiscWhenNotAvail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesDiscWhenNotAvail: %w", err)
	}
	return oldValue.SalesDiscWhenNotAvail, nil
}

// ClearSalesDiscWhenNotAvail clears the value of the "sales_disc_when_not_avail" field.
func (m *ProductMutation) ClearSalesDiscWhenNotAvail() {
	m.sales_disc_when_not_avail = nil
	m.clearedFields[product.FieldSalesDiscWhenNotAvail] = struct{}{}
}

// SalesDiscWhenNotAvailCleared returns if the "sales_disc_when_not_avail" field was cleared in this mutation.
func (m *ProductMutation) SalesDiscWhenNotAvailCleared() bool {
	_, ok := m.clearedFields[product.FieldSalesDiscWhenNotAvail]
	return ok
}

// ResetSalesDiscWhenNotAvail resets all changes to the "sales_disc_when_not_avail" field.
func (m *ProductMutation) ResetSalesDiscWhenNotAvail() {
	m.sales_disc_when_not_avail = nil
	delete(m.clearedFields, product.FieldSalesDiscWhenNotAvail)
}

// SetInternalName sets the "internal_name" field.
func (m *ProductMutation) SetInternalName(s string) {
	m.internal_name = &s
}

// InternalName returns the value of the "internal_name" field in the mutation.
func (m *ProductMutation) InternalName() (r string, exists bool) {
	v := m.internal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalName returns the old "internal_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldInternalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalName: %w", err)
	}
	return oldValue.InternalName, nil
}

// ClearInternalName clears the value of the "internal_name" field.
func (m *ProductMutation) ClearInternalName() {
	m.internal_name = nil
	m.clearedFields[product.FieldInternalName] = struct{}{}
}

// InternalNameCleared returns if the "internal_name" field was cleared in this mutation.
func (m *ProductMutation) InternalNameCleared() bool {
	_, ok := m.clearedFields[product.FieldInternalName]
	return ok
}

// ResetInternalName resets all changes to the "internal_name" field.
func (m *ProductMutation) ResetInternalName() {
	m.internal_name = nil
	delete(m.clearedFields, product.FieldInternalName)
}

// SetBrandName sets the "brand_name" field.
func (m *ProductMutation) SetBrandName(s string) {
	m.brand_name = &s
}

// BrandName returns the value of the "brand_name" field in the mutation.
func (m *ProductMutation) BrandName() (r string, exists bool) {
	v := m.brand_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandName returns the old "brand_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBrandName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrandName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrandName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandName: %w", err)
	}
	return oldValue.BrandName, nil
}

// ClearBrandName clears the value of the "brand_name" field.
func (m *ProductMutation) ClearBrandName() {
	m.brand_name = nil
	m.clearedFields[product.FieldBrandName] = struct{}{}
}

// BrandNameCleared returns if the "brand_name" field was cleared in this mutation.
func (m *ProductMutation) BrandNameCleared() bool {
	_, ok := m.clearedFields[product.FieldBrandName]
	return ok
}

// ResetBrandName resets all changes to the "brand_name" field.
func (m *ProductMutation) ResetBrandName() {
	m.brand_name = nil
	delete(m.clearedFields, product.FieldBrandName)
}

// SetComments sets the "comments" field.
func (m *ProductMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *ProductMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *ProductMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[product.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *ProductMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[product.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *ProductMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, product.FieldComments)
}

// SetProductName sets the "product_name" field.
func (m *ProductMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ProductMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *ProductMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[product.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *ProductMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[product.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ProductMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, product.FieldProductName)
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[product.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, product.FieldDescription)
}

// SetLongDescription sets the "long_description" field.
func (m *ProductMutation) SetLongDescription(s string) {
	m.long_description = &s
}

// LongDescription returns the value of the "long_description" field in the mutation.
func (m *ProductMutation) LongDescription() (r string, exists bool) {
	v := m.long_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLongDescription returns the old "long_description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLongDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongDescription: %w", err)
	}
	return oldValue.LongDescription, nil
}

// ClearLongDescription clears the value of the "long_description" field.
func (m *ProductMutation) ClearLongDescription() {
	m.long_description = nil
	m.clearedFields[product.FieldLongDescription] = struct{}{}
}

// LongDescriptionCleared returns if the "long_description" field was cleared in this mutation.
func (m *ProductMutation) LongDescriptionCleared() bool {
	_, ok := m.clearedFields[product.FieldLongDescription]
	return ok
}

// ResetLongDescription resets all changes to the "long_description" field.
func (m *ProductMutation) ResetLongDescription() {
	m.long_description = nil
	delete(m.clearedFields, product.FieldLongDescription)
}

// SetPriceDetailText sets the "price_detail_text" field.
func (m *ProductMutation) SetPriceDetailText(s string) {
	m.price_detail_text = &s
}

// PriceDetailText returns the value of the "price_detail_text" field in the mutation.
func (m *ProductMutation) PriceDetailText() (r string, exists bool) {
	v := m.price_detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceDetailText returns the old "price_detail_text" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPriceDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceDetailText: %w", err)
	}
	return oldValue.PriceDetailText, nil
}

// ClearPriceDetailText clears the value of the "price_detail_text" field.
func (m *ProductMutation) ClearPriceDetailText() {
	m.price_detail_text = nil
	m.clearedFields[product.FieldPriceDetailText] = struct{}{}
}

// PriceDetailTextCleared returns if the "price_detail_text" field was cleared in this mutation.
func (m *ProductMutation) PriceDetailTextCleared() bool {
	_, ok := m.clearedFields[product.FieldPriceDetailText]
	return ok
}

// ResetPriceDetailText resets all changes to the "price_detail_text" field.
func (m *ProductMutation) ResetPriceDetailText() {
	m.price_detail_text = nil
	delete(m.clearedFields, product.FieldPriceDetailText)
}

// SetSmallImageURL sets the "small_image_url" field.
func (m *ProductMutation) SetSmallImageURL(s string) {
	m.small_image_url = &s
}

// SmallImageURL returns the value of the "small_image_url" field in the mutation.
func (m *ProductMutation) SmallImageURL() (r string, exists bool) {
	v := m.small_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSmallImageURL returns the old "small_image_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSmallImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSmallImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSmallImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSmallImageURL: %w", err)
	}
	return oldValue.SmallImageURL, nil
}

// ClearSmallImageURL clears the value of the "small_image_url" field.
func (m *ProductMutation) ClearSmallImageURL() {
	m.small_image_url = nil
	m.clearedFields[product.FieldSmallImageURL] = struct{}{}
}

// SmallImageURLCleared returns if the "small_image_url" field was cleared in this mutation.
func (m *ProductMutation) SmallImageURLCleared() bool {
	_, ok := m.clearedFields[product.FieldSmallImageURL]
	return ok
}

// ResetSmallImageURL resets all changes to the "small_image_url" field.
func (m *ProductMutation) ResetSmallImageURL() {
	m.small_image_url = nil
	delete(m.clearedFields, product.FieldSmallImageURL)
}

// SetMediumImageURL sets the "medium_image_url" field.
func (m *ProductMutation) SetMediumImageURL(s string) {
	m.medium_image_url = &s
}

// MediumImageURL returns the value of the "medium_image_url" field in the mutation.
func (m *ProductMutation) MediumImageURL() (r string, exists bool) {
	v := m.medium_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMediumImageURL returns the old "medium_image_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMediumImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMediumImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMediumImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediumImageURL: %w", err)
	}
	return oldValue.MediumImageURL, nil
}

// ClearMediumImageURL clears the value of the "medium_image_url" field.
func (m *ProductMutation) ClearMediumImageURL() {
	m.medium_image_url = nil
	m.clearedFields[product.FieldMediumImageURL] = struct{}{}
}

// MediumImageURLCleared returns if the "medium_image_url" field was cleared in this mutation.
func (m *ProductMutation) MediumImageURLCleared() bool {
	_, ok := m.clearedFields[product.FieldMediumImageURL]
	return ok
}

// ResetMediumImageURL resets all changes to the "medium_image_url" field.
func (m *ProductMutation) ResetMediumImageURL() {
	m.medium_image_url = nil
	delete(m.clearedFields, product.FieldMediumImageURL)
}

// SetLargeImageURL sets the "large_image_url" field.
func (m *ProductMutation) SetLargeImageURL(s string) {
	m.large_image_url = &s
}

// LargeImageURL returns the value of the "large_image_url" field in the mutation.
func (m *ProductMutation) LargeImageURL() (r string, exists bool) {
	v := m.large_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLargeImageURL returns the old "large_image_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLargeImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLargeImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLargeImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLargeImageURL: %w", err)
	}
	return oldValue.LargeImageURL, nil
}

// ClearLargeImageURL clears the value of the "large_image_url" field.
func (m *ProductMutation) ClearLargeImageURL() {
	m.large_image_url = nil
	m.clearedFields[product.FieldLargeImageURL] = struct{}{}
}

// LargeImageURLCleared returns if the "large_image_url" field was cleared in this mutation.
func (m *ProductMutation) LargeImageURLCleared() bool {
	_, ok := m.clearedFields[product.FieldLargeImageURL]
	return ok
}

// ResetLargeImageURL resets all changes to the "large_image_url" field.
func (m *ProductMutation) ResetLargeImageURL() {
	m.large_image_url = nil
	delete(m.clearedFields, product.FieldLargeImageURL)
}

// SetDetailImageURL sets the "detail_image_url" field.
func (m *ProductMutation) SetDetailImageURL(s string) {
	m.detail_image_url = &s
}

// DetailImageURL returns the value of the "detail_image_url" field in the mutation.
func (m *ProductMutation) DetailImageURL() (r string, exists bool) {
	v := m.detail_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailImageURL returns the old "detail_image_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDetailImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailImageURL: %w", err)
	}
	return oldValue.DetailImageURL, nil
}

// ClearDetailImageURL clears the value of the "detail_image_url" field.
func (m *ProductMutation) ClearDetailImageURL() {
	m.detail_image_url = nil
	m.clearedFields[product.FieldDetailImageURL] = struct{}{}
}

// DetailImageURLCleared returns if the "detail_image_url" field was cleared in this mutation.
func (m *ProductMutation) DetailImageURLCleared() bool {
	_, ok := m.clearedFields[product.FieldDetailImageURL]
	return ok
}

// ResetDetailImageURL resets all changes to the "detail_image_url" field.
func (m *ProductMutation) ResetDetailImageURL() {
	m.detail_image_url = nil
	delete(m.clearedFields, product.FieldDetailImageURL)
}

// SetOriginalImageURL sets the "original_image_url" field.
func (m *ProductMutation) SetOriginalImageURL(s string) {
	m.original_image_url = &s
}

// OriginalImageURL returns the value of the "original_image_url" field in the mutation.
func (m *ProductMutation) OriginalImageURL() (r string, exists bool) {
	v := m.original_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalImageURL returns the old "original_image_url" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldOriginalImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOriginalImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOriginalImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalImageURL: %w", err)
	}
	return oldValue.OriginalImageURL, nil
}

// ClearOriginalImageURL clears the value of the "original_image_url" field.
func (m *ProductMutation) ClearOriginalImageURL() {
	m.original_image_url = nil
	m.clearedFields[product.FieldOriginalImageURL] = struct{}{}
}

// OriginalImageURLCleared returns if the "original_image_url" field was cleared in this mutation.
func (m *ProductMutation) OriginalImageURLCleared() bool {
	_, ok := m.clearedFields[product.FieldOriginalImageURL]
	return ok
}

// ResetOriginalImageURL resets all changes to the "original_image_url" field.
func (m *ProductMutation) ResetOriginalImageURL() {
	m.original_image_url = nil
	delete(m.clearedFields, product.FieldOriginalImageURL)
}

// SetDetailScreen sets the "detail_screen" field.
func (m *ProductMutation) SetDetailScreen(s string) {
	m.detail_screen = &s
}

// DetailScreen returns the value of the "detail_screen" field in the mutation.
func (m *ProductMutation) DetailScreen() (r string, exists bool) {
	v := m.detail_screen
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailScreen returns the old "detail_screen" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDetailScreen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailScreen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailScreen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailScreen: %w", err)
	}
	return oldValue.DetailScreen, nil
}

// ClearDetailScreen clears the value of the "detail_screen" field.
func (m *ProductMutation) ClearDetailScreen() {
	m.detail_screen = nil
	m.clearedFields[product.FieldDetailScreen] = struct{}{}
}

// DetailScreenCleared returns if the "detail_screen" field was cleared in this mutation.
func (m *ProductMutation) DetailScreenCleared() bool {
	_, ok := m.clearedFields[product.FieldDetailScreen]
	return ok
}

// ResetDetailScreen resets all changes to the "detail_screen" field.
func (m *ProductMutation) ResetDetailScreen() {
	m.detail_screen = nil
	delete(m.clearedFields, product.FieldDetailScreen)
}

// SetInventoryMessage sets the "inventory_message" field.
func (m *ProductMutation) SetInventoryMessage(s string) {
	m.inventory_message = &s
}

// InventoryMessage returns the value of the "inventory_message" field in the mutation.
func (m *ProductMutation) InventoryMessage() (r string, exists bool) {
	v := m.inventory_message
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryMessage returns the old "inventory_message" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldInventoryMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventoryMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventoryMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryMessage: %w", err)
	}
	return oldValue.InventoryMessage, nil
}

// ClearInventoryMessage clears the value of the "inventory_message" field.
func (m *ProductMutation) ClearInventoryMessage() {
	m.inventory_message = nil
	m.clearedFields[product.FieldInventoryMessage] = struct{}{}
}

// InventoryMessageCleared returns if the "inventory_message" field was cleared in this mutation.
func (m *ProductMutation) InventoryMessageCleared() bool {
	_, ok := m.clearedFields[product.FieldInventoryMessage]
	return ok
}

// ResetInventoryMessage resets all changes to the "inventory_message" field.
func (m *ProductMutation) ResetInventoryMessage() {
	m.inventory_message = nil
	delete(m.clearedFields, product.FieldInventoryMessage)
}

// SetRequireInventory sets the "require_inventory" field.
func (m *ProductMutation) SetRequireInventory(pi product.RequireInventory) {
	m.require_inventory = &pi
}

// RequireInventory returns the value of the "require_inventory" field in the mutation.
func (m *ProductMutation) RequireInventory() (r product.RequireInventory, exists bool) {
	v := m.require_inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireInventory returns the old "require_inventory" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRequireInventory(ctx context.Context) (v product.RequireInventory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequireInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequireInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireInventory: %w", err)
	}
	return oldValue.RequireInventory, nil
}

// ClearRequireInventory clears the value of the "require_inventory" field.
func (m *ProductMutation) ClearRequireInventory() {
	m.require_inventory = nil
	m.clearedFields[product.FieldRequireInventory] = struct{}{}
}

// RequireInventoryCleared returns if the "require_inventory" field was cleared in this mutation.
func (m *ProductMutation) RequireInventoryCleared() bool {
	_, ok := m.clearedFields[product.FieldRequireInventory]
	return ok
}

// ResetRequireInventory resets all changes to the "require_inventory" field.
func (m *ProductMutation) ResetRequireInventory() {
	m.require_inventory = nil
	delete(m.clearedFields, product.FieldRequireInventory)
}

// SetQuantityUomID sets the "quantity_uom_id" field.
func (m *ProductMutation) SetQuantityUomID(i int) {
	m.quantity_uom_id = &i
	m.addquantity_uom_id = nil
}

// QuantityUomID returns the value of the "quantity_uom_id" field in the mutation.
func (m *ProductMutation) QuantityUomID() (r int, exists bool) {
	v := m.quantity_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityUomID returns the old "quantity_uom_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantityUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityUomID: %w", err)
	}
	return oldValue.QuantityUomID, nil
}

// AddQuantityUomID adds i to the "quantity_uom_id" field.
func (m *ProductMutation) AddQuantityUomID(i int) {
	if m.addquantity_uom_id != nil {
		*m.addquantity_uom_id += i
	} else {
		m.addquantity_uom_id = &i
	}
}

// AddedQuantityUomID returns the value that was added to the "quantity_uom_id" field in this mutation.
func (m *ProductMutation) AddedQuantityUomID() (r int, exists bool) {
	v := m.addquantity_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityUomID clears the value of the "quantity_uom_id" field.
func (m *ProductMutation) ClearQuantityUomID() {
	m.quantity_uom_id = nil
	m.addquantity_uom_id = nil
	m.clearedFields[product.FieldQuantityUomID] = struct{}{}
}

// QuantityUomIDCleared returns if the "quantity_uom_id" field was cleared in this mutation.
func (m *ProductMutation) QuantityUomIDCleared() bool {
	_, ok := m.clearedFields[product.FieldQuantityUomID]
	return ok
}

// ResetQuantityUomID resets all changes to the "quantity_uom_id" field.
func (m *ProductMutation) ResetQuantityUomID() {
	m.quantity_uom_id = nil
	m.addquantity_uom_id = nil
	delete(m.clearedFields, product.FieldQuantityUomID)
}

// SetQuantityIncluded sets the "quantity_included" field.
func (m *ProductMutation) SetQuantityIncluded(f float64) {
	m.quantity_included = &f
	m.addquantity_included = nil
}

// QuantityIncluded returns the value of the "quantity_included" field in the mutation.
func (m *ProductMutation) QuantityIncluded() (r float64, exists bool) {
	v := m.quantity_included
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityIncluded returns the old "quantity_included" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantityIncluded(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityIncluded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityIncluded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityIncluded: %w", err)
	}
	return oldValue.QuantityIncluded, nil
}

// AddQuantityIncluded adds f to the "quantity_included" field.
func (m *ProductMutation) AddQuantityIncluded(f float64) {
	if m.addquantity_included != nil {
		*m.addquantity_included += f
	} else {
		m.addquantity_included = &f
	}
}

// AddedQuantityIncluded returns the value that was added to the "quantity_included" field in this mutation.
func (m *ProductMutation) AddedQuantityIncluded() (r float64, exists bool) {
	v := m.addquantity_included
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityIncluded clears the value of the "quantity_included" field.
func (m *ProductMutation) ClearQuantityIncluded() {
	m.quantity_included = nil
	m.addquantity_included = nil
	m.clearedFields[product.FieldQuantityIncluded] = struct{}{}
}

// QuantityIncludedCleared returns if the "quantity_included" field was cleared in this mutation.
func (m *ProductMutation) QuantityIncludedCleared() bool {
	_, ok := m.clearedFields[product.FieldQuantityIncluded]
	return ok
}

// ResetQuantityIncluded resets all changes to the "quantity_included" field.
func (m *ProductMutation) ResetQuantityIncluded() {
	m.quantity_included = nil
	m.addquantity_included = nil
	delete(m.clearedFields, product.FieldQuantityIncluded)
}

// SetPiecesIncluded sets the "pieces_included" field.
func (m *ProductMutation) SetPiecesIncluded(i int) {
	m.pieces_included = &i
	m.addpieces_included = nil
}

// PiecesIncluded returns the value of the "pieces_included" field in the mutation.
func (m *ProductMutation) PiecesIncluded() (r int, exists bool) {
	v := m.pieces_included
	if v == nil {
		return
	}
	return *v, true
}

// OldPiecesIncluded returns the old "pieces_included" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPiecesIncluded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPiecesIncluded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPiecesIncluded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPiecesIncluded: %w", err)
	}
	return oldValue.PiecesIncluded, nil
}

// AddPiecesIncluded adds i to the "pieces_included" field.
func (m *ProductMutation) AddPiecesIncluded(i int) {
	if m.addpieces_included != nil {
		*m.addpieces_included += i
	} else {
		m.addpieces_included = &i
	}
}

// AddedPiecesIncluded returns the value that was added to the "pieces_included" field in this mutation.
func (m *ProductMutation) AddedPiecesIncluded() (r int, exists bool) {
	v := m.addpieces_included
	if v == nil {
		return
	}
	return *v, true
}

// ClearPiecesIncluded clears the value of the "pieces_included" field.
func (m *ProductMutation) ClearPiecesIncluded() {
	m.pieces_included = nil
	m.addpieces_included = nil
	m.clearedFields[product.FieldPiecesIncluded] = struct{}{}
}

// PiecesIncludedCleared returns if the "pieces_included" field was cleared in this mutation.
func (m *ProductMutation) PiecesIncludedCleared() bool {
	_, ok := m.clearedFields[product.FieldPiecesIncluded]
	return ok
}

// ResetPiecesIncluded resets all changes to the "pieces_included" field.
func (m *ProductMutation) ResetPiecesIncluded() {
	m.pieces_included = nil
	m.addpieces_included = nil
	delete(m.clearedFields, product.FieldPiecesIncluded)
}

// SetRequireAmount sets the "require_amount" field.
func (m *ProductMutation) SetRequireAmount(pa product.RequireAmount) {
	m.require_amount = &pa
}

// RequireAmount returns the value of the "require_amount" field in the mutation.
func (m *ProductMutation) RequireAmount() (r product.RequireAmount, exists bool) {
	v := m.require_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireAmount returns the old "require_amount" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldRequireAmount(ctx context.Context) (v product.RequireAmount, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequireAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequireAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireAmount: %w", err)
	}
	return oldValue.RequireAmount, nil
}

// ClearRequireAmount clears the value of the "require_amount" field.
func (m *ProductMutation) ClearRequireAmount() {
	m.require_amount = nil
	m.clearedFields[product.FieldRequireAmount] = struct{}{}
}

// RequireAmountCleared returns if the "require_amount" field was cleared in this mutation.
func (m *ProductMutation) RequireAmountCleared() bool {
	_, ok := m.clearedFields[product.FieldRequireAmount]
	return ok
}

// ResetRequireAmount resets all changes to the "require_amount" field.
func (m *ProductMutation) ResetRequireAmount() {
	m.require_amount = nil
	delete(m.clearedFields, product.FieldRequireAmount)
}

// SetFixedAmount sets the "fixed_amount" field.
func (m *ProductMutation) SetFixedAmount(f float64) {
	m.fixed_amount = &f
	m.addfixed_amount = nil
}

// FixedAmount returns the value of the "fixed_amount" field in the mutation.
func (m *ProductMutation) FixedAmount() (r float64, exists bool) {
	v := m.fixed_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedAmount returns the old "fixed_amount" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldFixedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedAmount: %w", err)
	}
	return oldValue.FixedAmount, nil
}

// AddFixedAmount adds f to the "fixed_amount" field.
func (m *ProductMutation) AddFixedAmount(f float64) {
	if m.addfixed_amount != nil {
		*m.addfixed_amount += f
	} else {
		m.addfixed_amount = &f
	}
}

// AddedFixedAmount returns the value that was added to the "fixed_amount" field in this mutation.
func (m *ProductMutation) AddedFixedAmount() (r float64, exists bool) {
	v := m.addfixed_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedAmount clears the value of the "fixed_amount" field.
func (m *ProductMutation) ClearFixedAmount() {
	m.fixed_amount = nil
	m.addfixed_amount = nil
	m.clearedFields[product.FieldFixedAmount] = struct{}{}
}

// FixedAmountCleared returns if the "fixed_amount" field was cleared in this mutation.
func (m *ProductMutation) FixedAmountCleared() bool {
	_, ok := m.clearedFields[product.FieldFixedAmount]
	return ok
}

// ResetFixedAmount resets all changes to the "fixed_amount" field.
func (m *ProductMutation) ResetFixedAmount() {
	m.fixed_amount = nil
	m.addfixed_amount = nil
	delete(m.clearedFields, product.FieldFixedAmount)
}

// SetAmountUomTypeID sets the "amount_uom_type_id" field.
func (m *ProductMutation) SetAmountUomTypeID(i int) {
	m.amount_uom_type_id = &i
	m.addamount_uom_type_id = nil
}

// AmountUomTypeID returns the value of the "amount_uom_type_id" field in the mutation.
func (m *ProductMutation) AmountUomTypeID() (r int, exists bool) {
	v := m.amount_uom_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountUomTypeID returns the old "amount_uom_type_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAmountUomTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmountUomTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmountUomTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountUomTypeID: %w", err)
	}
	return oldValue.AmountUomTypeID, nil
}

// AddAmountUomTypeID adds i to the "amount_uom_type_id" field.
func (m *ProductMutation) AddAmountUomTypeID(i int) {
	if m.addamount_uom_type_id != nil {
		*m.addamount_uom_type_id += i
	} else {
		m.addamount_uom_type_id = &i
	}
}

// AddedAmountUomTypeID returns the value that was added to the "amount_uom_type_id" field in this mutation.
func (m *ProductMutation) AddedAmountUomTypeID() (r int, exists bool) {
	v := m.addamount_uom_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmountUomTypeID clears the value of the "amount_uom_type_id" field.
func (m *ProductMutation) ClearAmountUomTypeID() {
	m.amount_uom_type_id = nil
	m.addamount_uom_type_id = nil
	m.clearedFields[product.FieldAmountUomTypeID] = struct{}{}
}

// AmountUomTypeIDCleared returns if the "amount_uom_type_id" field was cleared in this mutation.
func (m *ProductMutation) AmountUomTypeIDCleared() bool {
	_, ok := m.clearedFields[product.FieldAmountUomTypeID]
	return ok
}

// ResetAmountUomTypeID resets all changes to the "amount_uom_type_id" field.
func (m *ProductMutation) ResetAmountUomTypeID() {
	m.amount_uom_type_id = nil
	m.addamount_uom_type_id = nil
	delete(m.clearedFields, product.FieldAmountUomTypeID)
}

// SetWeightUomID sets the "weight_uom_id" field.
func (m *ProductMutation) SetWeightUomID(i int) {
	m.weight_uom_id = &i
	m.addweight_uom_id = nil
}

// WeightUomID returns the value of the "weight_uom_id" field in the mutation.
func (m *ProductMutation) WeightUomID() (r int, exists bool) {
	v := m.weight_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightUomID returns the old "weight_uom_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWeightUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightUomID: %w", err)
	}
	return oldValue.WeightUomID, nil
}

// AddWeightUomID adds i to the "weight_uom_id" field.
func (m *ProductMutation) AddWeightUomID(i int) {
	if m.addweight_uom_id != nil {
		*m.addweight_uom_id += i
	} else {
		m.addweight_uom_id = &i
	}
}

// AddedWeightUomID returns the value that was added to the "weight_uom_id" field in this mutation.
func (m *ProductMutation) AddedWeightUomID() (r int, exists bool) {
	v := m.addweight_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeightUomID clears the value of the "weight_uom_id" field.
func (m *ProductMutation) ClearWeightUomID() {
	m.weight_uom_id = nil
	m.addweight_uom_id = nil
	m.clearedFields[product.FieldWeightUomID] = struct{}{}
}

// WeightUomIDCleared returns if the "weight_uom_id" field was cleared in this mutation.
func (m *ProductMutation) WeightUomIDCleared() bool {
	_, ok := m.clearedFields[product.FieldWeightUomID]
	return ok
}

// ResetWeightUomID resets all changes to the "weight_uom_id" field.
func (m *ProductMutation) ResetWeightUomID() {
	m.weight_uom_id = nil
	m.addweight_uom_id = nil
	delete(m.clearedFields, product.FieldWeightUomID)
}

// SetShippingWeight sets the "shipping_weight" field.
func (m *ProductMutation) SetShippingWeight(f float64) {
	m.shipping_weight = &f
	m.addshipping_weight = nil
}

// ShippingWeight returns the value of the "shipping_weight" field in the mutation.
func (m *ProductMutation) ShippingWeight() (r float64, exists bool) {
	v := m.shipping_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingWeight returns the old "shipping_weight" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShippingWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingWeight: %w", err)
	}
	return oldValue.ShippingWeight, nil
}

// AddShippingWeight adds f to the "shipping_weight" field.
func (m *ProductMutation) AddShippingWeight(f float64) {
	if m.addshipping_weight != nil {
		*m.addshipping_weight += f
	} else {
		m.addshipping_weight = &f
	}
}

// AddedShippingWeight returns the value that was added to the "shipping_weight" field in this mutation.
func (m *ProductMutation) AddedShippingWeight() (r float64, exists bool) {
	v := m.addshipping_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearShippingWeight clears the value of the "shipping_weight" field.
func (m *ProductMutation) ClearShippingWeight() {
	m.shipping_weight = nil
	m.addshipping_weight = nil
	m.clearedFields[product.FieldShippingWeight] = struct{}{}
}

// ShippingWeightCleared returns if the "shipping_weight" field was cleared in this mutation.
func (m *ProductMutation) ShippingWeightCleared() bool {
	_, ok := m.clearedFields[product.FieldShippingWeight]
	return ok
}

// ResetShippingWeight resets all changes to the "shipping_weight" field.
func (m *ProductMutation) ResetShippingWeight() {
	m.shipping_weight = nil
	m.addshipping_weight = nil
	delete(m.clearedFields, product.FieldShippingWeight)
}

// SetProductWeight sets the "product_weight" field.
func (m *ProductMutation) SetProductWeight(f float64) {
	m.product_weight = &f
	m.addproduct_weight = nil
}

// ProductWeight returns the value of the "product_weight" field in the mutation.
func (m *ProductMutation) ProductWeight() (r float64, exists bool) {
	v := m.product_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldProductWeight returns the old "product_weight" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductWeight: %w", err)
	}
	return oldValue.ProductWeight, nil
}

// AddProductWeight adds f to the "product_weight" field.
func (m *ProductMutation) AddProductWeight(f float64) {
	if m.addproduct_weight != nil {
		*m.addproduct_weight += f
	} else {
		m.addproduct_weight = &f
	}
}

// AddedProductWeight returns the value that was added to the "product_weight" field in this mutation.
func (m *ProductMutation) AddedProductWeight() (r float64, exists bool) {
	v := m.addproduct_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductWeight clears the value of the "product_weight" field.
func (m *ProductMutation) ClearProductWeight() {
	m.product_weight = nil
	m.addproduct_weight = nil
	m.clearedFields[product.FieldProductWeight] = struct{}{}
}

// ProductWeightCleared returns if the "product_weight" field was cleared in this mutation.
func (m *ProductMutation) ProductWeightCleared() bool {
	_, ok := m.clearedFields[product.FieldProductWeight]
	return ok
}

// ResetProductWeight resets all changes to the "product_weight" field.
func (m *ProductMutation) ResetProductWeight() {
	m.product_weight = nil
	m.addproduct_weight = nil
	delete(m.clearedFields, product.FieldProductWeight)
}

// SetHeightUomID sets the "height_uom_id" field.
func (m *ProductMutation) SetHeightUomID(i int) {
	m.height_uom_id = &i
	m.addheight_uom_id = nil
}

// HeightUomID returns the value of the "height_uom_id" field in the mutation.
func (m *ProductMutation) HeightUomID() (r int, exists bool) {
	v := m.height_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHeightUomID returns the old "height_uom_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldHeightUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeightUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeightUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeightUomID: %w", err)
	}
	return oldValue.HeightUomID, nil
}

// AddHeightUomID adds i to the "height_uom_id" field.
func (m *ProductMutation) AddHeightUomID(i int) {
	if m.addheight_uom_id != nil {
		*m.addheight_uom_id += i
	} else {
		m.addheight_uom_id = &i
	}
}

// AddedHeightUomID returns the value that was added to the "height_uom_id" field in this mutation.
func (m *ProductMutation) AddedHeightUomID() (r int, exists bool) {
	v := m.addheight_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeightUomID clears the value of the "height_uom_id" field.
func (m *ProductMutation) ClearHeightUomID() {
	m.height_uom_id = nil
	m.addheight_uom_id = nil
	m.clearedFields[product.FieldHeightUomID] = struct{}{}
}

// HeightUomIDCleared returns if the "height_uom_id" field was cleared in this mutation.
func (m *ProductMutation) HeightUomIDCleared() bool {
	_, ok := m.clearedFields[product.FieldHeightUomID]
	return ok
}

// ResetHeightUomID resets all changes to the "height_uom_id" field.
func (m *ProductMutation) ResetHeightUomID() {
	m.height_uom_id = nil
	m.addheight_uom_id = nil
	delete(m.clearedFields, product.FieldHeightUomID)
}

// SetProductHeight sets the "product_height" field.
func (m *ProductMutation) SetProductHeight(f float64) {
	m.product_height = &f
	m.addproduct_height = nil
}

// ProductHeight returns the value of the "product_height" field in the mutation.
func (m *ProductMutation) ProductHeight() (r float64, exists bool) {
	v := m.product_height
	if v == nil {
		return
	}
	return *v, true
}

// OldProductHeight returns the old "product_height" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductHeight: %w", err)
	}
	return oldValue.ProductHeight, nil
}

// AddProductHeight adds f to the "product_height" field.
func (m *ProductMutation) AddProductHeight(f float64) {
	if m.addproduct_height != nil {
		*m.addproduct_height += f
	} else {
		m.addproduct_height = &f
	}
}

// AddedProductHeight returns the value that was added to the "product_height" field in this mutation.
func (m *ProductMutation) AddedProductHeight() (r float64, exists bool) {
	v := m.addproduct_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductHeight clears the value of the "product_height" field.
func (m *ProductMutation) ClearProductHeight() {
	m.product_height = nil
	m.addproduct_height = nil
	m.clearedFields[product.FieldProductHeight] = struct{}{}
}

// ProductHeightCleared returns if the "product_height" field was cleared in this mutation.
func (m *ProductMutation) ProductHeightCleared() bool {
	_, ok := m.clearedFields[product.FieldProductHeight]
	return ok
}

// ResetProductHeight resets all changes to the "product_height" field.
func (m *ProductMutation) ResetProductHeight() {
	m.product_height = nil
	m.addproduct_height = nil
	delete(m.clearedFields, product.FieldProductHeight)
}

// SetShippingHeight sets the "shipping_height" field.
func (m *ProductMutation) SetShippingHeight(f float64) {
	m.shipping_height = &f
	m.addshipping_height = nil
}

// ShippingHeight returns the value of the "shipping_height" field in the mutation.
func (m *ProductMutation) ShippingHeight() (r float64, exists bool) {
	v := m.shipping_height
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingHeight returns the old "shipping_height" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShippingHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingHeight: %w", err)
	}
	return oldValue.ShippingHeight, nil
}

// AddShippingHeight adds f to the "shipping_height" field.
func (m *ProductMutation) AddShippingHeight(f float64) {
	if m.addshipping_height != nil {
		*m.addshipping_height += f
	} else {
		m.addshipping_height = &f
	}
}

// AddedShippingHeight returns the value that was added to the "shipping_height" field in this mutation.
func (m *ProductMutation) AddedShippingHeight() (r float64, exists bool) {
	v := m.addshipping_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearShippingHeight clears the value of the "shipping_height" field.
func (m *ProductMutation) ClearShippingHeight() {
	m.shipping_height = nil
	m.addshipping_height = nil
	m.clearedFields[product.FieldShippingHeight] = struct{}{}
}

// ShippingHeightCleared returns if the "shipping_height" field was cleared in this mutation.
func (m *ProductMutation) ShippingHeightCleared() bool {
	_, ok := m.clearedFields[product.FieldShippingHeight]
	return ok
}

// ResetShippingHeight resets all changes to the "shipping_height" field.
func (m *ProductMutation) ResetShippingHeight() {
	m.shipping_height = nil
	m.addshipping_height = nil
	delete(m.clearedFields, product.FieldShippingHeight)
}

// SetWidthUomID sets the "width_uom_id" field.
func (m *ProductMutation) SetWidthUomID(i int) {
	m.width_uom_id = &i
	m.addwidth_uom_id = nil
}

// WidthUomID returns the value of the "width_uom_id" field in the mutation.
func (m *ProductMutation) WidthUomID() (r int, exists bool) {
	v := m.width_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWidthUomID returns the old "width_uom_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWidthUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWidthUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWidthUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidthUomID: %w", err)
	}
	return oldValue.WidthUomID, nil
}

// AddWidthUomID adds i to the "width_uom_id" field.
func (m *ProductMutation) AddWidthUomID(i int) {
	if m.addwidth_uom_id != nil {
		*m.addwidth_uom_id += i
	} else {
		m.addwidth_uom_id = &i
	}
}

// AddedWidthUomID returns the value that was added to the "width_uom_id" field in this mutation.
func (m *ProductMutation) AddedWidthUomID() (r int, exists bool) {
	v := m.addwidth_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidthUomID clears the value of the "width_uom_id" field.
func (m *ProductMutation) ClearWidthUomID() {
	m.width_uom_id = nil
	m.addwidth_uom_id = nil
	m.clearedFields[product.FieldWidthUomID] = struct{}{}
}

// WidthUomIDCleared returns if the "width_uom_id" field was cleared in this mutation.
func (m *ProductMutation) WidthUomIDCleared() bool {
	_, ok := m.clearedFields[product.FieldWidthUomID]
	return ok
}

// ResetWidthUomID resets all changes to the "width_uom_id" field.
func (m *ProductMutation) ResetWidthUomID() {
	m.width_uom_id = nil
	m.addwidth_uom_id = nil
	delete(m.clearedFields, product.FieldWidthUomID)
}

// SetProductWidth sets the "product_width" field.
func (m *ProductMutation) SetProductWidth(f float64) {
	m.product_width = &f
	m.addproduct_width = nil
}

// ProductWidth returns the value of the "product_width" field in the mutation.
func (m *ProductMutation) ProductWidth() (r float64, exists bool) {
	v := m.product_width
	if v == nil {
		return
	}
	return *v, true
}

// OldProductWidth returns the old "product_width" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductWidth: %w", err)
	}
	return oldValue.ProductWidth, nil
}

// AddProductWidth adds f to the "product_width" field.
func (m *ProductMutation) AddProductWidth(f float64) {
	if m.addproduct_width != nil {
		*m.addproduct_width += f
	} else {
		m.addproduct_width = &f
	}
}

// AddedProductWidth returns the value that was added to the "product_width" field in this mutation.
func (m *ProductMutation) AddedProductWidth() (r float64, exists bool) {
	v := m.addproduct_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductWidth clears the value of the "product_width" field.
func (m *ProductMutation) ClearProductWidth() {
	m.product_width = nil
	m.addproduct_width = nil
	m.clearedFields[product.FieldProductWidth] = struct{}{}
}

// ProductWidthCleared returns if the "product_width" field was cleared in this mutation.
func (m *ProductMutation) ProductWidthCleared() bool {
	_, ok := m.clearedFields[product.FieldProductWidth]
	return ok
}

// ResetProductWidth resets all changes to the "product_width" field.
func (m *ProductMutation) ResetProductWidth() {
	m.product_width = nil
	m.addproduct_width = nil
	delete(m.clearedFields, product.FieldProductWidth)
}

// SetShippingWidth sets the "shipping_width" field.
func (m *ProductMutation) SetShippingWidth(f float64) {
	m.shipping_width = &f
	m.addshipping_width = nil
}

// ShippingWidth returns the value of the "shipping_width" field in the mutation.
func (m *ProductMutation) ShippingWidth() (r float64, exists bool) {
	v := m.shipping_width
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingWidth returns the old "shipping_width" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShippingWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingWidth: %w", err)
	}
	return oldValue.ShippingWidth, nil
}

// AddShippingWidth adds f to the "shipping_width" field.
func (m *ProductMutation) AddShippingWidth(f float64) {
	if m.addshipping_width != nil {
		*m.addshipping_width += f
	} else {
		m.addshipping_width = &f
	}
}

// AddedShippingWidth returns the value that was added to the "shipping_width" field in this mutation.
func (m *ProductMutation) AddedShippingWidth() (r float64, exists bool) {
	v := m.addshipping_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearShippingWidth clears the value of the "shipping_width" field.
func (m *ProductMutation) ClearShippingWidth() {
	m.shipping_width = nil
	m.addshipping_width = nil
	m.clearedFields[product.FieldShippingWidth] = struct{}{}
}

// ShippingWidthCleared returns if the "shipping_width" field was cleared in this mutation.
func (m *ProductMutation) ShippingWidthCleared() bool {
	_, ok := m.clearedFields[product.FieldShippingWidth]
	return ok
}

// ResetShippingWidth resets all changes to the "shipping_width" field.
func (m *ProductMutation) ResetShippingWidth() {
	m.shipping_width = nil
	m.addshipping_width = nil
	delete(m.clearedFields, product.FieldShippingWidth)
}

// SetDepthUomID sets the "depth_uom_id" field.
func (m *ProductMutation) SetDepthUomID(i int) {
	m.depth_uom_id = &i
	m.adddepth_uom_id = nil
}

// DepthUomID returns the value of the "depth_uom_id" field in the mutation.
func (m *ProductMutation) DepthUomID() (r int, exists bool) {
	v := m.depth_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDepthUomID returns the old "depth_uom_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDepthUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepthUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepthUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepthUomID: %w", err)
	}
	return oldValue.DepthUomID, nil
}

// AddDepthUomID adds i to the "depth_uom_id" field.
func (m *ProductMutation) AddDepthUomID(i int) {
	if m.adddepth_uom_id != nil {
		*m.adddepth_uom_id += i
	} else {
		m.adddepth_uom_id = &i
	}
}

// AddedDepthUomID returns the value that was added to the "depth_uom_id" field in this mutation.
func (m *ProductMutation) AddedDepthUomID() (r int, exists bool) {
	v := m.adddepth_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepthUomID clears the value of the "depth_uom_id" field.
func (m *ProductMutation) ClearDepthUomID() {
	m.depth_uom_id = nil
	m.adddepth_uom_id = nil
	m.clearedFields[product.FieldDepthUomID] = struct{}{}
}

// DepthUomIDCleared returns if the "depth_uom_id" field was cleared in this mutation.
func (m *ProductMutation) DepthUomIDCleared() bool {
	_, ok := m.clearedFields[product.FieldDepthUomID]
	return ok
}

// ResetDepthUomID resets all changes to the "depth_uom_id" field.
func (m *ProductMutation) ResetDepthUomID() {
	m.depth_uom_id = nil
	m.adddepth_uom_id = nil
	delete(m.clearedFields, product.FieldDepthUomID)
}

// SetProductDepth sets the "product_depth" field.
func (m *ProductMutation) SetProductDepth(f float64) {
	m.product_depth = &f
	m.addproduct_depth = nil
}

// ProductDepth returns the value of the "product_depth" field in the mutation.
func (m *ProductMutation) ProductDepth() (r float64, exists bool) {
	v := m.product_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldProductDepth returns the old "product_depth" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductDepth: %w", err)
	}
	return oldValue.ProductDepth, nil
}

// AddProductDepth adds f to the "product_depth" field.
func (m *ProductMutation) AddProductDepth(f float64) {
	if m.addproduct_depth != nil {
		*m.addproduct_depth += f
	} else {
		m.addproduct_depth = &f
	}
}

// AddedProductDepth returns the value that was added to the "product_depth" field in this mutation.
func (m *ProductMutation) AddedProductDepth() (r float64, exists bool) {
	v := m.addproduct_depth
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductDepth clears the value of the "product_depth" field.
func (m *ProductMutation) ClearProductDepth() {
	m.product_depth = nil
	m.addproduct_depth = nil
	m.clearedFields[product.FieldProductDepth] = struct{}{}
}

// ProductDepthCleared returns if the "product_depth" field was cleared in this mutation.
func (m *ProductMutation) ProductDepthCleared() bool {
	_, ok := m.clearedFields[product.FieldProductDepth]
	return ok
}

// ResetProductDepth resets all changes to the "product_depth" field.
func (m *ProductMutation) ResetProductDepth() {
	m.product_depth = nil
	m.addproduct_depth = nil
	delete(m.clearedFields, product.FieldProductDepth)
}

// SetShippingDepth sets the "shipping_depth" field.
func (m *ProductMutation) SetShippingDepth(f float64) {
	m.shipping_depth = &f
	m.addshipping_depth = nil
}

// ShippingDepth returns the value of the "shipping_depth" field in the mutation.
func (m *ProductMutation) ShippingDepth() (r float64, exists bool) {
	v := m.shipping_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingDepth returns the old "shipping_depth" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShippingDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingDepth: %w", err)
	}
	return oldValue.ShippingDepth, nil
}

// AddShippingDepth adds f to the "shipping_depth" field.
func (m *ProductMutation) AddShippingDepth(f float64) {
	if m.addshipping_depth != nil {
		*m.addshipping_depth += f
	} else {
		m.addshipping_depth = &f
	}
}

// AddedShippingDepth returns the value that was added to the "shipping_depth" field in this mutation.
func (m *ProductMutation) AddedShippingDepth() (r float64, exists bool) {
	v := m.addshipping_depth
	if v == nil {
		return
	}
	return *v, true
}

// ClearShippingDepth clears the value of the "shipping_depth" field.
func (m *ProductMutation) ClearShippingDepth() {
	m.shipping_depth = nil
	m.addshipping_depth = nil
	m.clearedFields[product.FieldShippingDepth] = struct{}{}
}

// ShippingDepthCleared returns if the "shipping_depth" field was cleared in this mutation.
func (m *ProductMutation) ShippingDepthCleared() bool {
	_, ok := m.clearedFields[product.FieldShippingDepth]
	return ok
}

// ResetShippingDepth resets all changes to the "shipping_depth" field.
func (m *ProductMutation) ResetShippingDepth() {
	m.shipping_depth = nil
	m.addshipping_depth = nil
	delete(m.clearedFields, product.FieldShippingDepth)
}

// SetDiameterUomID sets the "diameter_uom_id" field.
func (m *ProductMutation) SetDiameterUomID(i int) {
	m.diameter_uom_id = &i
	m.adddiameter_uom_id = nil
}

// DiameterUomID returns the value of the "diameter_uom_id" field in the mutation.
func (m *ProductMutation) DiameterUomID() (r int, exists bool) {
	v := m.diameter_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiameterUomID returns the old "diameter_uom_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDiameterUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiameterUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiameterUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiameterUomID: %w", err)
	}
	return oldValue.DiameterUomID, nil
}

// AddDiameterUomID adds i to the "diameter_uom_id" field.
func (m *ProductMutation) AddDiameterUomID(i int) {
	if m.adddiameter_uom_id != nil {
		*m.adddiameter_uom_id += i
	} else {
		m.adddiameter_uom_id = &i
	}
}

// AddedDiameterUomID returns the value that was added to the "diameter_uom_id" field in this mutation.
func (m *ProductMutation) AddedDiameterUomID() (r int, exists bool) {
	v := m.adddiameter_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDiameterUomID clears the value of the "diameter_uom_id" field.
func (m *ProductMutation) ClearDiameterUomID() {
	m.diameter_uom_id = nil
	m.adddiameter_uom_id = nil
	m.clearedFields[product.FieldDiameterUomID] = struct{}{}
}

// DiameterUomIDCleared returns if the "diameter_uom_id" field was cleared in this mutation.
func (m *ProductMutation) DiameterUomIDCleared() bool {
	_, ok := m.clearedFields[product.FieldDiameterUomID]
	return ok
}

// ResetDiameterUomID resets all changes to the "diameter_uom_id" field.
func (m *ProductMutation) ResetDiameterUomID() {
	m.diameter_uom_id = nil
	m.adddiameter_uom_id = nil
	delete(m.clearedFields, product.FieldDiameterUomID)
}

// SetProductDiameter sets the "product_diameter" field.
func (m *ProductMutation) SetProductDiameter(f float64) {
	m.product_diameter = &f
	m.addproduct_diameter = nil
}

// ProductDiameter returns the value of the "product_diameter" field in the mutation.
func (m *ProductMutation) ProductDiameter() (r float64, exists bool) {
	v := m.product_diameter
	if v == nil {
		return
	}
	return *v, true
}

// OldProductDiameter returns the old "product_diameter" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductDiameter(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductDiameter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductDiameter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductDiameter: %w", err)
	}
	return oldValue.ProductDiameter, nil
}

// AddProductDiameter adds f to the "product_diameter" field.
func (m *ProductMutation) AddProductDiameter(f float64) {
	if m.addproduct_diameter != nil {
		*m.addproduct_diameter += f
	} else {
		m.addproduct_diameter = &f
	}
}

// AddedProductDiameter returns the value that was added to the "product_diameter" field in this mutation.
func (m *ProductMutation) AddedProductDiameter() (r float64, exists bool) {
	v := m.addproduct_diameter
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductDiameter clears the value of the "product_diameter" field.
func (m *ProductMutation) ClearProductDiameter() {
	m.product_diameter = nil
	m.addproduct_diameter = nil
	m.clearedFields[product.FieldProductDiameter] = struct{}{}
}

// ProductDiameterCleared returns if the "product_diameter" field was cleared in this mutation.
func (m *ProductMutation) ProductDiameterCleared() bool {
	_, ok := m.clearedFields[product.FieldProductDiameter]
	return ok
}

// ResetProductDiameter resets all changes to the "product_diameter" field.
func (m *ProductMutation) ResetProductDiameter() {
	m.product_diameter = nil
	m.addproduct_diameter = nil
	delete(m.clearedFields, product.FieldProductDiameter)
}

// SetProductRating sets the "product_rating" field.
func (m *ProductMutation) SetProductRating(f float64) {
	m.product_rating = &f
	m.addproduct_rating = nil
}

// ProductRating returns the value of the "product_rating" field in the mutation.
func (m *ProductMutation) ProductRating() (r float64, exists bool) {
	v := m.product_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldProductRating returns the old "product_rating" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductRating: %w", err)
	}
	return oldValue.ProductRating, nil
}

// AddProductRating adds f to the "product_rating" field.
func (m *ProductMutation) AddProductRating(f float64) {
	if m.addproduct_rating != nil {
		*m.addproduct_rating += f
	} else {
		m.addproduct_rating = &f
	}
}

// AddedProductRating returns the value that was added to the "product_rating" field in this mutation.
func (m *ProductMutation) AddedProductRating() (r float64, exists bool) {
	v := m.addproduct_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductRating clears the value of the "product_rating" field.
func (m *ProductMutation) ClearProductRating() {
	m.product_rating = nil
	m.addproduct_rating = nil
	m.clearedFields[product.FieldProductRating] = struct{}{}
}

// ProductRatingCleared returns if the "product_rating" field was cleared in this mutation.
func (m *ProductMutation) ProductRatingCleared() bool {
	_, ok := m.clearedFields[product.FieldProductRating]
	return ok
}

// ResetProductRating resets all changes to the "product_rating" field.
func (m *ProductMutation) ResetProductRating() {
	m.product_rating = nil
	m.addproduct_rating = nil
	delete(m.clearedFields, product.FieldProductRating)
}

// SetReturnable sets the "returnable" field.
func (m *ProductMutation) SetReturnable(pr product.Returnable) {
	m.returnable = &pr
}

// Returnable returns the value of the "returnable" field in the mutation.
func (m *ProductMutation) Returnable() (r product.Returnable, exists bool) {
	v := m.returnable
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnable returns the old "returnable" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReturnable(ctx context.Context) (v product.Returnable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReturnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReturnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnable: %w", err)
	}
	return oldValue.Returnable, nil
}

// ClearReturnable clears the value of the "returnable" field.
func (m *ProductMutation) ClearReturnable() {
	m.returnable = nil
	m.clearedFields[product.FieldReturnable] = struct{}{}
}

// ReturnableCleared returns if the "returnable" field was cleared in this mutation.
func (m *ProductMutation) ReturnableCleared() bool {
	_, ok := m.clearedFields[product.FieldReturnable]
	return ok
}

// ResetReturnable resets all changes to the "returnable" field.
func (m *ProductMutation) ResetReturnable() {
	m.returnable = nil
	delete(m.clearedFields, product.FieldReturnable)
}

// SetTaxable sets the "taxable" field.
func (m *ProductMutation) SetTaxable(pr product.Taxable) {
	m.taxable = &pr
}

// Taxable returns the value of the "taxable" field in the mutation.
func (m *ProductMutation) Taxable() (r product.Taxable, exists bool) {
	v := m.taxable
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxable returns the old "taxable" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTaxable(ctx context.Context) (v product.Taxable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxable: %w", err)
	}
	return oldValue.Taxable, nil
}

// ClearTaxable clears the value of the "taxable" field.
func (m *ProductMutation) ClearTaxable() {
	m.taxable = nil
	m.clearedFields[product.FieldTaxable] = struct{}{}
}

// TaxableCleared returns if the "taxable" field was cleared in this mutation.
func (m *ProductMutation) TaxableCleared() bool {
	_, ok := m.clearedFields[product.FieldTaxable]
	return ok
}

// ResetTaxable resets all changes to the "taxable" field.
func (m *ProductMutation) ResetTaxable() {
	m.taxable = nil
	delete(m.clearedFields, product.FieldTaxable)
}

// SetChargeShipping sets the "charge_shipping" field.
func (m *ProductMutation) SetChargeShipping(ps product.ChargeShipping) {
	m.charge_shipping = &ps
}

// ChargeShipping returns the value of the "charge_shipping" field in the mutation.
func (m *ProductMutation) ChargeShipping() (r product.ChargeShipping, exists bool) {
	v := m.charge_shipping
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeShipping returns the old "charge_shipping" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldChargeShipping(ctx context.Context) (v product.ChargeShipping, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChargeShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChargeShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeShipping: %w", err)
	}
	return oldValue.ChargeShipping, nil
}

// ClearChargeShipping clears the value of the "charge_shipping" field.
func (m *ProductMutation) ClearChargeShipping() {
	m.charge_shipping = nil
	m.clearedFields[product.FieldChargeShipping] = struct{}{}
}

// ChargeShippingCleared returns if the "charge_shipping" field was cleared in this mutation.
func (m *ProductMutation) ChargeShippingCleared() bool {
	_, ok := m.clearedFields[product.FieldChargeShipping]
	return ok
}

// ResetChargeShipping resets all changes to the "charge_shipping" field.
func (m *ProductMutation) ResetChargeShipping() {
	m.charge_shipping = nil
	delete(m.clearedFields, product.FieldChargeShipping)
}

// SetAutoCreateKeywords sets the "auto_create_keywords" field.
func (m *ProductMutation) SetAutoCreateKeywords(pck product.AutoCreateKeywords) {
	m.auto_create_keywords = &pck
}

// AutoCreateKeywords returns the value of the "auto_create_keywords" field in the mutation.
func (m *ProductMutation) AutoCreateKeywords() (r product.AutoCreateKeywords, exists bool) {
	v := m.auto_create_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoCreateKeywords returns the old "auto_create_keywords" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldAutoCreateKeywords(ctx context.Context) (v product.AutoCreateKeywords, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoCreateKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoCreateKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoCreateKeywords: %w", err)
	}
	return oldValue.AutoCreateKeywords, nil
}

// ClearAutoCreateKeywords clears the value of the "auto_create_keywords" field.
func (m *ProductMutation) ClearAutoCreateKeywords() {
	m.auto_create_keywords = nil
	m.clearedFields[product.FieldAutoCreateKeywords] = struct{}{}
}

// AutoCreateKeywordsCleared returns if the "auto_create_keywords" field was cleared in this mutation.
func (m *ProductMutation) AutoCreateKeywordsCleared() bool {
	_, ok := m.clearedFields[product.FieldAutoCreateKeywords]
	return ok
}

// ResetAutoCreateKeywords resets all changes to the "auto_create_keywords" field.
func (m *ProductMutation) ResetAutoCreateKeywords() {
	m.auto_create_keywords = nil
	delete(m.clearedFields, product.FieldAutoCreateKeywords)
}

// SetIncludeInPromotions sets the "include_in_promotions" field.
func (m *ProductMutation) SetIncludeInPromotions(pip product.IncludeInPromotions) {
	m.include_in_promotions = &pip
}

// IncludeInPromotions returns the value of the "include_in_promotions" field in the mutation.
func (m *ProductMutation) IncludeInPromotions() (r product.IncludeInPromotions, exists bool) {
	v := m.include_in_promotions
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeInPromotions returns the old "include_in_promotions" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIncludeInPromotions(ctx context.Context) (v product.IncludeInPromotions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIncludeInPromotions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIncludeInPromotions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeInPromotions: %w", err)
	}
	return oldValue.IncludeInPromotions, nil
}

// ClearIncludeInPromotions clears the value of the "include_in_promotions" field.
func (m *ProductMutation) ClearIncludeInPromotions() {
	m.include_in_promotions = nil
	m.clearedFields[product.FieldIncludeInPromotions] = struct{}{}
}

// IncludeInPromotionsCleared returns if the "include_in_promotions" field was cleared in this mutation.
func (m *ProductMutation) IncludeInPromotionsCleared() bool {
	_, ok := m.clearedFields[product.FieldIncludeInPromotions]
	return ok
}

// ResetIncludeInPromotions resets all changes to the "include_in_promotions" field.
func (m *ProductMutation) ResetIncludeInPromotions() {
	m.include_in_promotions = nil
	delete(m.clearedFields, product.FieldIncludeInPromotions)
}

// SetIsVirtual sets the "is_virtual" field.
func (m *ProductMutation) SetIsVirtual(pv product.IsVirtual) {
	m.is_virtual = &pv
}

// IsVirtual returns the value of the "is_virtual" field in the mutation.
func (m *ProductMutation) IsVirtual() (r product.IsVirtual, exists bool) {
	v := m.is_virtual
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVirtual returns the old "is_virtual" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsVirtual(ctx context.Context) (v product.IsVirtual, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsVirtual is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsVirtual requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVirtual: %w", err)
	}
	return oldValue.IsVirtual, nil
}

// ClearIsVirtual clears the value of the "is_virtual" field.
func (m *ProductMutation) ClearIsVirtual() {
	m.is_virtual = nil
	m.clearedFields[product.FieldIsVirtual] = struct{}{}
}

// IsVirtualCleared returns if the "is_virtual" field was cleared in this mutation.
func (m *ProductMutation) IsVirtualCleared() bool {
	_, ok := m.clearedFields[product.FieldIsVirtual]
	return ok
}

// ResetIsVirtual resets all changes to the "is_virtual" field.
func (m *ProductMutation) ResetIsVirtual() {
	m.is_virtual = nil
	delete(m.clearedFields, product.FieldIsVirtual)
}

// SetIsVariant sets the "is_variant" field.
func (m *ProductMutation) SetIsVariant(pv product.IsVariant) {
	m.is_variant = &pv
}

// IsVariant returns the value of the "is_variant" field in the mutation.
func (m *ProductMutation) IsVariant() (r product.IsVariant, exists bool) {
	v := m.is_variant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVariant returns the old "is_variant" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldIsVariant(ctx context.Context) (v product.IsVariant, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsVariant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsVariant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVariant: %w", err)
	}
	return oldValue.IsVariant, nil
}

// ClearIsVariant clears the value of the "is_variant" field.
func (m *ProductMutation) ClearIsVariant() {
	m.is_variant = nil
	m.clearedFields[product.FieldIsVariant] = struct{}{}
}

// IsVariantCleared returns if the "is_variant" field was cleared in this mutation.
func (m *ProductMutation) IsVariantCleared() bool {
	_, ok := m.clearedFields[product.FieldIsVariant]
	return ok
}

// ResetIsVariant resets all changes to the "is_variant" field.
func (m *ProductMutation) ResetIsVariant() {
	m.is_variant = nil
	delete(m.clearedFields, product.FieldIsVariant)
}

// SetOriginGeoID sets the "origin_geo_id" field.
func (m *ProductMutation) SetOriginGeoID(i int) {
	m.origin_geo_id = &i
	m.addorigin_geo_id = nil
}

// OriginGeoID returns the value of the "origin_geo_id" field in the mutation.
func (m *ProductMutation) OriginGeoID() (r int, exists bool) {
	v := m.origin_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginGeoID returns the old "origin_geo_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldOriginGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOriginGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOriginGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginGeoID: %w", err)
	}
	return oldValue.OriginGeoID, nil
}

// AddOriginGeoID adds i to the "origin_geo_id" field.
func (m *ProductMutation) AddOriginGeoID(i int) {
	if m.addorigin_geo_id != nil {
		*m.addorigin_geo_id += i
	} else {
		m.addorigin_geo_id = &i
	}
}

// AddedOriginGeoID returns the value that was added to the "origin_geo_id" field in this mutation.
func (m *ProductMutation) AddedOriginGeoID() (r int, exists bool) {
	v := m.addorigin_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginGeoID clears the value of the "origin_geo_id" field.
func (m *ProductMutation) ClearOriginGeoID() {
	m.origin_geo_id = nil
	m.addorigin_geo_id = nil
	m.clearedFields[product.FieldOriginGeoID] = struct{}{}
}

// OriginGeoIDCleared returns if the "origin_geo_id" field was cleared in this mutation.
func (m *ProductMutation) OriginGeoIDCleared() bool {
	_, ok := m.clearedFields[product.FieldOriginGeoID]
	return ok
}

// ResetOriginGeoID resets all changes to the "origin_geo_id" field.
func (m *ProductMutation) ResetOriginGeoID() {
	m.origin_geo_id = nil
	m.addorigin_geo_id = nil
	delete(m.clearedFields, product.FieldOriginGeoID)
}

// SetBillOfMaterialLevel sets the "bill_of_material_level" field.
func (m *ProductMutation) SetBillOfMaterialLevel(i int) {
	m.bill_of_material_level = &i
	m.addbill_of_material_level = nil
}

// BillOfMaterialLevel returns the value of the "bill_of_material_level" field in the mutation.
func (m *ProductMutation) BillOfMaterialLevel() (r int, exists bool) {
	v := m.bill_of_material_level
	if v == nil {
		return
	}
	return *v, true
}

// OldBillOfMaterialLevel returns the old "bill_of_material_level" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBillOfMaterialLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillOfMaterialLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillOfMaterialLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillOfMaterialLevel: %w", err)
	}
	return oldValue.BillOfMaterialLevel, nil
}

// AddBillOfMaterialLevel adds i to the "bill_of_material_level" field.
func (m *ProductMutation) AddBillOfMaterialLevel(i int) {
	if m.addbill_of_material_level != nil {
		*m.addbill_of_material_level += i
	} else {
		m.addbill_of_material_level = &i
	}
}

// AddedBillOfMaterialLevel returns the value that was added to the "bill_of_material_level" field in this mutation.
func (m *ProductMutation) AddedBillOfMaterialLevel() (r int, exists bool) {
	v := m.addbill_of_material_level
	if v == nil {
		return
	}
	return *v, true
}

// ClearBillOfMaterialLevel clears the value of the "bill_of_material_level" field.
func (m *ProductMutation) ClearBillOfMaterialLevel() {
	m.bill_of_material_level = nil
	m.addbill_of_material_level = nil
	m.clearedFields[product.FieldBillOfMaterialLevel] = struct{}{}
}

// BillOfMaterialLevelCleared returns if the "bill_of_material_level" field was cleared in this mutation.
func (m *ProductMutation) BillOfMaterialLevelCleared() bool {
	_, ok := m.clearedFields[product.FieldBillOfMaterialLevel]
	return ok
}

// ResetBillOfMaterialLevel resets all changes to the "bill_of_material_level" field.
func (m *ProductMutation) ResetBillOfMaterialLevel() {
	m.bill_of_material_level = nil
	m.addbill_of_material_level = nil
	delete(m.clearedFields, product.FieldBillOfMaterialLevel)
}

// SetReservMaxPersons sets the "reserv_max_persons" field.
func (m *ProductMutation) SetReservMaxPersons(f float64) {
	m.reserv_max_persons = &f
	m.addreserv_max_persons = nil
}

// ReservMaxPersons returns the value of the "reserv_max_persons" field in the mutation.
func (m *ProductMutation) ReservMaxPersons() (r float64, exists bool) {
	v := m.reserv_max_persons
	if v == nil {
		return
	}
	return *v, true
}

// OldReservMaxPersons returns the old "reserv_max_persons" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReservMaxPersons(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReservMaxPersons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReservMaxPersons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservMaxPersons: %w", err)
	}
	return oldValue.ReservMaxPersons, nil
}

// AddReservMaxPersons adds f to the "reserv_max_persons" field.
func (m *ProductMutation) AddReservMaxPersons(f float64) {
	if m.addreserv_max_persons != nil {
		*m.addreserv_max_persons += f
	} else {
		m.addreserv_max_persons = &f
	}
}

// AddedReservMaxPersons returns the value that was added to the "reserv_max_persons" field in this mutation.
func (m *ProductMutation) AddedReservMaxPersons() (r float64, exists bool) {
	v := m.addreserv_max_persons
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservMaxPersons clears the value of the "reserv_max_persons" field.
func (m *ProductMutation) ClearReservMaxPersons() {
	m.reserv_max_persons = nil
	m.addreserv_max_persons = nil
	m.clearedFields[product.FieldReservMaxPersons] = struct{}{}
}

// ReservMaxPersonsCleared returns if the "reserv_max_persons" field was cleared in this mutation.
func (m *ProductMutation) ReservMaxPersonsCleared() bool {
	_, ok := m.clearedFields[product.FieldReservMaxPersons]
	return ok
}

// ResetReservMaxPersons resets all changes to the "reserv_max_persons" field.
func (m *ProductMutation) ResetReservMaxPersons() {
	m.reserv_max_persons = nil
	m.addreserv_max_persons = nil
	delete(m.clearedFields, product.FieldReservMaxPersons)
}

// SetReserv2NdPpPerc sets the "reserv_2_nd_pp_perc" field.
func (m *ProductMutation) SetReserv2NdPpPerc(f float64) {
	m.reserv_2_nd_pp_perc = &f
	m.addreserv_2_nd_pp_perc = nil
}

// Reserv2NdPpPerc returns the value of the "reserv_2_nd_pp_perc" field in the mutation.
func (m *ProductMutation) Reserv2NdPpPerc() (r float64, exists bool) {
	v := m.reserv_2_nd_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// OldReserv2NdPpPerc returns the old "reserv_2_nd_pp_perc" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReserv2NdPpPerc(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReserv2NdPpPerc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReserv2NdPpPerc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserv2NdPpPerc: %w", err)
	}
	return oldValue.Reserv2NdPpPerc, nil
}

// AddReserv2NdPpPerc adds f to the "reserv_2_nd_pp_perc" field.
func (m *ProductMutation) AddReserv2NdPpPerc(f float64) {
	if m.addreserv_2_nd_pp_perc != nil {
		*m.addreserv_2_nd_pp_perc += f
	} else {
		m.addreserv_2_nd_pp_perc = &f
	}
}

// AddedReserv2NdPpPerc returns the value that was added to the "reserv_2_nd_pp_perc" field in this mutation.
func (m *ProductMutation) AddedReserv2NdPpPerc() (r float64, exists bool) {
	v := m.addreserv_2_nd_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// ClearReserv2NdPpPerc clears the value of the "reserv_2_nd_pp_perc" field.
func (m *ProductMutation) ClearReserv2NdPpPerc() {
	m.reserv_2_nd_pp_perc = nil
	m.addreserv_2_nd_pp_perc = nil
	m.clearedFields[product.FieldReserv2NdPpPerc] = struct{}{}
}

// Reserv2NdPpPercCleared returns if the "reserv_2_nd_pp_perc" field was cleared in this mutation.
func (m *ProductMutation) Reserv2NdPpPercCleared() bool {
	_, ok := m.clearedFields[product.FieldReserv2NdPpPerc]
	return ok
}

// ResetReserv2NdPpPerc resets all changes to the "reserv_2_nd_pp_perc" field.
func (m *ProductMutation) ResetReserv2NdPpPerc() {
	m.reserv_2_nd_pp_perc = nil
	m.addreserv_2_nd_pp_perc = nil
	delete(m.clearedFields, product.FieldReserv2NdPpPerc)
}

// SetReservNthPpPerc sets the "reserv_nth_pp_perc" field.
func (m *ProductMutation) SetReservNthPpPerc(f float64) {
	m.reserv_nth_pp_perc = &f
	m.addreserv_nth_pp_perc = nil
}

// ReservNthPpPerc returns the value of the "reserv_nth_pp_perc" field in the mutation.
func (m *ProductMutation) ReservNthPpPerc() (r float64, exists bool) {
	v := m.reserv_nth_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// OldReservNthPpPerc returns the old "reserv_nth_pp_perc" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldReservNthPpPerc(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReservNthPpPerc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReservNthPpPerc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservNthPpPerc: %w", err)
	}
	return oldValue.ReservNthPpPerc, nil
}

// AddReservNthPpPerc adds f to the "reserv_nth_pp_perc" field.
func (m *ProductMutation) AddReservNthPpPerc(f float64) {
	if m.addreserv_nth_pp_perc != nil {
		*m.addreserv_nth_pp_perc += f
	} else {
		m.addreserv_nth_pp_perc = &f
	}
}

// AddedReservNthPpPerc returns the value that was added to the "reserv_nth_pp_perc" field in this mutation.
func (m *ProductMutation) AddedReservNthPpPerc() (r float64, exists bool) {
	v := m.addreserv_nth_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservNthPpPerc clears the value of the "reserv_nth_pp_perc" field.
func (m *ProductMutation) ClearReservNthPpPerc() {
	m.reserv_nth_pp_perc = nil
	m.addreserv_nth_pp_perc = nil
	m.clearedFields[product.FieldReservNthPpPerc] = struct{}{}
}

// ReservNthPpPercCleared returns if the "reserv_nth_pp_perc" field was cleared in this mutation.
func (m *ProductMutation) ReservNthPpPercCleared() bool {
	_, ok := m.clearedFields[product.FieldReservNthPpPerc]
	return ok
}

// ResetReservNthPpPerc resets all changes to the "reserv_nth_pp_perc" field.
func (m *ProductMutation) ResetReservNthPpPerc() {
	m.reserv_nth_pp_perc = nil
	m.addreserv_nth_pp_perc = nil
	delete(m.clearedFields, product.FieldReservNthPpPerc)
}

// SetConfigID sets the "config_id" field.
func (m *ProductMutation) SetConfigID(i int) {
	m.config_id = &i
	m.addconfig_id = nil
}

// ConfigID returns the value of the "config_id" field in the mutation.
func (m *ProductMutation) ConfigID() (r int, exists bool) {
	v := m.config_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigID returns the old "config_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldConfigID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigID: %w", err)
	}
	return oldValue.ConfigID, nil
}

// AddConfigID adds i to the "config_id" field.
func (m *ProductMutation) AddConfigID(i int) {
	if m.addconfig_id != nil {
		*m.addconfig_id += i
	} else {
		m.addconfig_id = &i
	}
}

// AddedConfigID returns the value that was added to the "config_id" field in this mutation.
func (m *ProductMutation) AddedConfigID() (r int, exists bool) {
	v := m.addconfig_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfigID clears the value of the "config_id" field.
func (m *ProductMutation) ClearConfigID() {
	m.config_id = nil
	m.addconfig_id = nil
	m.clearedFields[product.FieldConfigID] = struct{}{}
}

// ConfigIDCleared returns if the "config_id" field was cleared in this mutation.
func (m *ProductMutation) ConfigIDCleared() bool {
	_, ok := m.clearedFields[product.FieldConfigID]
	return ok
}

// ResetConfigID resets all changes to the "config_id" field.
func (m *ProductMutation) ResetConfigID() {
	m.config_id = nil
	m.addconfig_id = nil
	delete(m.clearedFields, product.FieldConfigID)
}

// SetCreatedDate sets the "created_date" field.
func (m *ProductMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *ProductMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *ProductMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[product.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *ProductMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *ProductMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, product.FieldCreatedDate)
}

// SetCreatedByUserLogin sets the "created_by_user_login" field.
func (m *ProductMutation) SetCreatedByUserLogin(s string) {
	m.created_by_user_login = &s
}

// CreatedByUserLogin returns the value of the "created_by_user_login" field in the mutation.
func (m *ProductMutation) CreatedByUserLogin() (r string, exists bool) {
	v := m.created_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByUserLogin returns the old "created_by_user_login" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByUserLogin: %w", err)
	}
	return oldValue.CreatedByUserLogin, nil
}

// ClearCreatedByUserLogin clears the value of the "created_by_user_login" field.
func (m *ProductMutation) ClearCreatedByUserLogin() {
	m.created_by_user_login = nil
	m.clearedFields[product.FieldCreatedByUserLogin] = struct{}{}
}

// CreatedByUserLoginCleared returns if the "created_by_user_login" field was cleared in this mutation.
func (m *ProductMutation) CreatedByUserLoginCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedByUserLogin]
	return ok
}

// ResetCreatedByUserLogin resets all changes to the "created_by_user_login" field.
func (m *ProductMutation) ResetCreatedByUserLogin() {
	m.created_by_user_login = nil
	delete(m.clearedFields, product.FieldCreatedByUserLogin)
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *ProductMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *ProductMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ClearLastModifiedDate clears the value of the "last_modified_date" field.
func (m *ProductMutation) ClearLastModifiedDate() {
	m.last_modified_date = nil
	m.clearedFields[product.FieldLastModifiedDate] = struct{}{}
}

// LastModifiedDateCleared returns if the "last_modified_date" field was cleared in this mutation.
func (m *ProductMutation) LastModifiedDateCleared() bool {
	_, ok := m.clearedFields[product.FieldLastModifiedDate]
	return ok
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *ProductMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
	delete(m.clearedFields, product.FieldLastModifiedDate)
}

// SetLastModifiedByUserLogin sets the "last_modified_by_user_login" field.
func (m *ProductMutation) SetLastModifiedByUserLogin(s string) {
	m.last_modified_by_user_login = &s
}

// LastModifiedByUserLogin returns the value of the "last_modified_by_user_login" field in the mutation.
func (m *ProductMutation) LastModifiedByUserLogin() (r string, exists bool) {
	v := m.last_modified_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedByUserLogin returns the old "last_modified_by_user_login" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLastModifiedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedByUserLogin: %w", err)
	}
	return oldValue.LastModifiedByUserLogin, nil
}

// ClearLastModifiedByUserLogin clears the value of the "last_modified_by_user_login" field.
func (m *ProductMutation) ClearLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	m.clearedFields[product.FieldLastModifiedByUserLogin] = struct{}{}
}

// LastModifiedByUserLoginCleared returns if the "last_modified_by_user_login" field was cleared in this mutation.
func (m *ProductMutation) LastModifiedByUserLoginCleared() bool {
	_, ok := m.clearedFields[product.FieldLastModifiedByUserLogin]
	return ok
}

// ResetLastModifiedByUserLogin resets all changes to the "last_modified_by_user_login" field.
func (m *ProductMutation) ResetLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	delete(m.clearedFields, product.FieldLastModifiedByUserLogin)
}

// SetInShippingBox sets the "in_shipping_box" field.
func (m *ProductMutation) SetInShippingBox(psb product.InShippingBox) {
	m.in_shipping_box = &psb
}

// InShippingBox returns the value of the "in_shipping_box" field in the mutation.
func (m *ProductMutation) InShippingBox() (r product.InShippingBox, exists bool) {
	v := m.in_shipping_box
	if v == nil {
		return
	}
	return *v, true
}

// OldInShippingBox returns the old "in_shipping_box" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldInShippingBox(ctx context.Context) (v product.InShippingBox, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInShippingBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInShippingBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInShippingBox: %w", err)
	}
	return oldValue.InShippingBox, nil
}

// ClearInShippingBox clears the value of the "in_shipping_box" field.
func (m *ProductMutation) ClearInShippingBox() {
	m.in_shipping_box = nil
	m.clearedFields[product.FieldInShippingBox] = struct{}{}
}

// InShippingBoxCleared returns if the "in_shipping_box" field was cleared in this mutation.
func (m *ProductMutation) InShippingBoxCleared() bool {
	_, ok := m.clearedFields[product.FieldInShippingBox]
	return ok
}

// ResetInShippingBox resets all changes to the "in_shipping_box" field.
func (m *ProductMutation) ResetInShippingBox() {
	m.in_shipping_box = nil
	delete(m.clearedFields, product.FieldInShippingBox)
}

// SetDefaultShipmentBoxTypeID sets the "default_shipment_box_type_id" field.
func (m *ProductMutation) SetDefaultShipmentBoxTypeID(i int) {
	m.default_shipment_box_type_id = &i
	m.adddefault_shipment_box_type_id = nil
}

// DefaultShipmentBoxTypeID returns the value of the "default_shipment_box_type_id" field in the mutation.
func (m *ProductMutation) DefaultShipmentBoxTypeID() (r int, exists bool) {
	v := m.default_shipment_box_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultShipmentBoxTypeID returns the old "default_shipment_box_type_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDefaultShipmentBoxTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultShipmentBoxTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultShipmentBoxTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultShipmentBoxTypeID: %w", err)
	}
	return oldValue.DefaultShipmentBoxTypeID, nil
}

// AddDefaultShipmentBoxTypeID adds i to the "default_shipment_box_type_id" field.
func (m *ProductMutation) AddDefaultShipmentBoxTypeID(i int) {
	if m.adddefault_shipment_box_type_id != nil {
		*m.adddefault_shipment_box_type_id += i
	} else {
		m.adddefault_shipment_box_type_id = &i
	}
}

// AddedDefaultShipmentBoxTypeID returns the value that was added to the "default_shipment_box_type_id" field in this mutation.
func (m *ProductMutation) AddedDefaultShipmentBoxTypeID() (r int, exists bool) {
	v := m.adddefault_shipment_box_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultShipmentBoxTypeID clears the value of the "default_shipment_box_type_id" field.
func (m *ProductMutation) ClearDefaultShipmentBoxTypeID() {
	m.default_shipment_box_type_id = nil
	m.adddefault_shipment_box_type_id = nil
	m.clearedFields[product.FieldDefaultShipmentBoxTypeID] = struct{}{}
}

// DefaultShipmentBoxTypeIDCleared returns if the "default_shipment_box_type_id" field was cleared in this mutation.
func (m *ProductMutation) DefaultShipmentBoxTypeIDCleared() bool {
	_, ok := m.clearedFields[product.FieldDefaultShipmentBoxTypeID]
	return ok
}

// ResetDefaultShipmentBoxTypeID resets all changes to the "default_shipment_box_type_id" field.
func (m *ProductMutation) ResetDefaultShipmentBoxTypeID() {
	m.default_shipment_box_type_id = nil
	m.adddefault_shipment_box_type_id = nil
	delete(m.clearedFields, product.FieldDefaultShipmentBoxTypeID)
}

// SetLotIDFilledIn sets the "lot_id_filled_in" field.
func (m *ProductMutation) SetLotIDFilledIn(s string) {
	m.lot_id_filled_in = &s
}

// LotIDFilledIn returns the value of the "lot_id_filled_in" field in the mutation.
func (m *ProductMutation) LotIDFilledIn() (r string, exists bool) {
	v := m.lot_id_filled_in
	if v == nil {
		return
	}
	return *v, true
}

// OldLotIDFilledIn returns the old "lot_id_filled_in" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLotIDFilledIn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLotIDFilledIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLotIDFilledIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotIDFilledIn: %w", err)
	}
	return oldValue.LotIDFilledIn, nil
}

// ClearLotIDFilledIn clears the value of the "lot_id_filled_in" field.
func (m *ProductMutation) ClearLotIDFilledIn() {
	m.lot_id_filled_in = nil
	m.clearedFields[product.FieldLotIDFilledIn] = struct{}{}
}

// LotIDFilledInCleared returns if the "lot_id_filled_in" field was cleared in this mutation.
func (m *ProductMutation) LotIDFilledInCleared() bool {
	_, ok := m.clearedFields[product.FieldLotIDFilledIn]
	return ok
}

// ResetLotIDFilledIn resets all changes to the "lot_id_filled_in" field.
func (m *ProductMutation) ResetLotIDFilledIn() {
	m.lot_id_filled_in = nil
	delete(m.clearedFields, product.FieldLotIDFilledIn)
}

// SetOrderDecimalQuantity sets the "order_decimal_quantity" field.
func (m *ProductMutation) SetOrderDecimalQuantity(pdq product.OrderDecimalQuantity) {
	m.order_decimal_quantity = &pdq
}

// OrderDecimalQuantity returns the value of the "order_decimal_quantity" field in the mutation.
func (m *ProductMutation) OrderDecimalQuantity() (r product.OrderDecimalQuantity, exists bool) {
	v := m.order_decimal_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDecimalQuantity returns the old "order_decimal_quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldOrderDecimalQuantity(ctx context.Context) (v product.OrderDecimalQuantity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderDecimalQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderDecimalQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDecimalQuantity: %w", err)
	}
	return oldValue.OrderDecimalQuantity, nil
}

// ClearOrderDecimalQuantity clears the value of the "order_decimal_quantity" field.
func (m *ProductMutation) ClearOrderDecimalQuantity() {
	m.order_decimal_quantity = nil
	m.clearedFields[product.FieldOrderDecimalQuantity] = struct{}{}
}

// OrderDecimalQuantityCleared returns if the "order_decimal_quantity" field was cleared in this mutation.
func (m *ProductMutation) OrderDecimalQuantityCleared() bool {
	_, ok := m.clearedFields[product.FieldOrderDecimalQuantity]
	return ok
}

// ResetOrderDecimalQuantity resets all changes to the "order_decimal_quantity" field.
func (m *ProductMutation) ResetOrderDecimalQuantity() {
	m.order_decimal_quantity = nil
	delete(m.clearedFields, product.FieldOrderDecimalQuantity)
}

// SetProductTypeID sets the "product_type" edge to the ProductType entity by id.
func (m *ProductMutation) SetProductTypeID(id int) {
	m.product_type = &id
}

// ClearProductType clears the "product_type" edge to the ProductType entity.
func (m *ProductMutation) ClearProductType() {
	m.clearedproduct_type = true
}

// ProductTypeCleared reports if the "product_type" edge to the ProductType entity was cleared.
func (m *ProductMutation) ProductTypeCleared() bool {
	return m.clearedproduct_type
}

// ProductTypeID returns the "product_type" edge ID in the mutation.
func (m *ProductMutation) ProductTypeID() (id int, exists bool) {
	if m.product_type != nil {
		return *m.product_type, true
	}
	return
}

// ProductTypeIDs returns the "product_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductTypeID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) ProductTypeIDs() (ids []int) {
	if id := m.product_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductType resets all changes to the "product_type" edge.
func (m *ProductMutation) ResetProductType() {
	m.product_type = nil
	m.clearedproduct_type = false
}

// SetPrimaryProductCategoryID sets the "primary_product_category" edge to the ProductCategory entity by id.
func (m *ProductMutation) SetPrimaryProductCategoryID(id int) {
	m.primary_product_category = &id
}

// ClearPrimaryProductCategory clears the "primary_product_category" edge to the ProductCategory entity.
func (m *ProductMutation) ClearPrimaryProductCategory() {
	m.clearedprimary_product_category = true
}

// PrimaryProductCategoryCleared reports if the "primary_product_category" edge to the ProductCategory entity was cleared.
func (m *ProductMutation) PrimaryProductCategoryCleared() bool {
	return m.clearedprimary_product_category
}

// PrimaryProductCategoryID returns the "primary_product_category" edge ID in the mutation.
func (m *ProductMutation) PrimaryProductCategoryID() (id int, exists bool) {
	if m.primary_product_category != nil {
		return *m.primary_product_category, true
	}
	return
}

// PrimaryProductCategoryIDs returns the "primary_product_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryProductCategoryID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) PrimaryProductCategoryIDs() (ids []int) {
	if id := m.primary_product_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryProductCategory resets all changes to the "primary_product_category" edge.
func (m *ProductMutation) ResetPrimaryProductCategory() {
	m.primary_product_category = nil
	m.clearedprimary_product_category = false
}

// SetVirtualVariantMethodEnumerationID sets the "virtual_variant_method_enumeration" edge to the Enumeration entity by id.
func (m *ProductMutation) SetVirtualVariantMethodEnumerationID(id int) {
	m.virtual_variant_method_enumeration = &id
}

// ClearVirtualVariantMethodEnumeration clears the "virtual_variant_method_enumeration" edge to the Enumeration entity.
func (m *ProductMutation) ClearVirtualVariantMethodEnumeration() {
	m.clearedvirtual_variant_method_enumeration = true
}

// VirtualVariantMethodEnumerationCleared reports if the "virtual_variant_method_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductMutation) VirtualVariantMethodEnumerationCleared() bool {
	return m.clearedvirtual_variant_method_enumeration
}

// VirtualVariantMethodEnumerationID returns the "virtual_variant_method_enumeration" edge ID in the mutation.
func (m *ProductMutation) VirtualVariantMethodEnumerationID() (id int, exists bool) {
	if m.virtual_variant_method_enumeration != nil {
		return *m.virtual_variant_method_enumeration, true
	}
	return
}

// VirtualVariantMethodEnumerationIDs returns the "virtual_variant_method_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VirtualVariantMethodEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) VirtualVariantMethodEnumerationIDs() (ids []int) {
	if id := m.virtual_variant_method_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVirtualVariantMethodEnumeration resets all changes to the "virtual_variant_method_enumeration" edge.
func (m *ProductMutation) ResetVirtualVariantMethodEnumeration() {
	m.virtual_variant_method_enumeration = nil
	m.clearedvirtual_variant_method_enumeration = false
}

// SetRatingEnumerationID sets the "rating_enumeration" edge to the Enumeration entity by id.
func (m *ProductMutation) SetRatingEnumerationID(id int) {
	m.rating_enumeration = &id
}

// ClearRatingEnumeration clears the "rating_enumeration" edge to the Enumeration entity.
func (m *ProductMutation) ClearRatingEnumeration() {
	m.clearedrating_enumeration = true
}

// RatingEnumerationCleared reports if the "rating_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductMutation) RatingEnumerationCleared() bool {
	return m.clearedrating_enumeration
}

// RatingEnumerationID returns the "rating_enumeration" edge ID in the mutation.
func (m *ProductMutation) RatingEnumerationID() (id int, exists bool) {
	if m.rating_enumeration != nil {
		return *m.rating_enumeration, true
	}
	return
}

// RatingEnumerationIDs returns the "rating_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RatingEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) RatingEnumerationIDs() (ids []int) {
	if id := m.rating_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRatingEnumeration resets all changes to the "rating_enumeration" edge.
func (m *ProductMutation) ResetRatingEnumeration() {
	m.rating_enumeration = nil
	m.clearedrating_enumeration = false
}

// SetRequirementMethodEnumerationID sets the "requirement_method_enumeration" edge to the Enumeration entity by id.
func (m *ProductMutation) SetRequirementMethodEnumerationID(id int) {
	m.requirement_method_enumeration = &id
}

// ClearRequirementMethodEnumeration clears the "requirement_method_enumeration" edge to the Enumeration entity.
func (m *ProductMutation) ClearRequirementMethodEnumeration() {
	m.clearedrequirement_method_enumeration = true
}

// RequirementMethodEnumerationCleared reports if the "requirement_method_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductMutation) RequirementMethodEnumerationCleared() bool {
	return m.clearedrequirement_method_enumeration
}

// RequirementMethodEnumerationID returns the "requirement_method_enumeration" edge ID in the mutation.
func (m *ProductMutation) RequirementMethodEnumerationID() (id int, exists bool) {
	if m.requirement_method_enumeration != nil {
		return *m.requirement_method_enumeration, true
	}
	return
}

// RequirementMethodEnumerationIDs returns the "requirement_method_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequirementMethodEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) RequirementMethodEnumerationIDs() (ids []int) {
	if id := m.requirement_method_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequirementMethodEnumeration resets all changes to the "requirement_method_enumeration" edge.
func (m *ProductMutation) ResetRequirementMethodEnumeration() {
	m.requirement_method_enumeration = nil
	m.clearedrequirement_method_enumeration = false
}

// SetInventoryItemTypeID sets the "inventory_item_type" edge to the InventoryItemType entity by id.
func (m *ProductMutation) SetInventoryItemTypeID(id int) {
	m.inventory_item_type = &id
}

// ClearInventoryItemType clears the "inventory_item_type" edge to the InventoryItemType entity.
func (m *ProductMutation) ClearInventoryItemType() {
	m.clearedinventory_item_type = true
}

// InventoryItemTypeCleared reports if the "inventory_item_type" edge to the InventoryItemType entity was cleared.
func (m *ProductMutation) InventoryItemTypeCleared() bool {
	return m.clearedinventory_item_type
}

// InventoryItemTypeID returns the "inventory_item_type" edge ID in the mutation.
func (m *ProductMutation) InventoryItemTypeID() (id int, exists bool) {
	if m.inventory_item_type != nil {
		return *m.inventory_item_type, true
	}
	return
}

// InventoryItemTypeIDs returns the "inventory_item_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryItemTypeID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) InventoryItemTypeIDs() (ids []int) {
	if id := m.inventory_item_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventoryItemType resets all changes to the "inventory_item_type" edge.
func (m *ProductMutation) ResetInventoryItemType() {
	m.inventory_item_type = nil
	m.clearedinventory_item_type = false
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *ProductMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *ProductMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *ProductMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *ProductMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *ProductMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *ProductMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *ProductMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddMainProductAssocIDs adds the "main_product_assocs" edge to the ProductAssoc entity by ids.
func (m *ProductMutation) AddMainProductAssocIDs(ids ...int) {
	if m.main_product_assocs == nil {
		m.main_product_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.main_product_assocs[ids[i]] = struct{}{}
	}
}

// ClearMainProductAssocs clears the "main_product_assocs" edge to the ProductAssoc entity.
func (m *ProductMutation) ClearMainProductAssocs() {
	m.clearedmain_product_assocs = true
}

// MainProductAssocsCleared reports if the "main_product_assocs" edge to the ProductAssoc entity was cleared.
func (m *ProductMutation) MainProductAssocsCleared() bool {
	return m.clearedmain_product_assocs
}

// RemoveMainProductAssocIDs removes the "main_product_assocs" edge to the ProductAssoc entity by IDs.
func (m *ProductMutation) RemoveMainProductAssocIDs(ids ...int) {
	if m.removedmain_product_assocs == nil {
		m.removedmain_product_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmain_product_assocs[ids[i]] = struct{}{}
	}
}

// RemovedMainProductAssocs returns the removed IDs of the "main_product_assocs" edge to the ProductAssoc entity.
func (m *ProductMutation) RemovedMainProductAssocsIDs() (ids []int) {
	for id := range m.removedmain_product_assocs {
		ids = append(ids, id)
	}
	return
}

// MainProductAssocsIDs returns the "main_product_assocs" edge IDs in the mutation.
func (m *ProductMutation) MainProductAssocsIDs() (ids []int) {
	for id := range m.main_product_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetMainProductAssocs resets all changes to the "main_product_assocs" edge.
func (m *ProductMutation) ResetMainProductAssocs() {
	m.main_product_assocs = nil
	m.clearedmain_product_assocs = false
	m.removedmain_product_assocs = nil
}

// AddAssocProductAssocIDs adds the "assoc_product_assocs" edge to the ProductAssoc entity by ids.
func (m *ProductMutation) AddAssocProductAssocIDs(ids ...int) {
	if m.assoc_product_assocs == nil {
		m.assoc_product_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.assoc_product_assocs[ids[i]] = struct{}{}
	}
}

// ClearAssocProductAssocs clears the "assoc_product_assocs" edge to the ProductAssoc entity.
func (m *ProductMutation) ClearAssocProductAssocs() {
	m.clearedassoc_product_assocs = true
}

// AssocProductAssocsCleared reports if the "assoc_product_assocs" edge to the ProductAssoc entity was cleared.
func (m *ProductMutation) AssocProductAssocsCleared() bool {
	return m.clearedassoc_product_assocs
}

// RemoveAssocProductAssocIDs removes the "assoc_product_assocs" edge to the ProductAssoc entity by IDs.
func (m *ProductMutation) RemoveAssocProductAssocIDs(ids ...int) {
	if m.removedassoc_product_assocs == nil {
		m.removedassoc_product_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedassoc_product_assocs[ids[i]] = struct{}{}
	}
}

// RemovedAssocProductAssocs returns the removed IDs of the "assoc_product_assocs" edge to the ProductAssoc entity.
func (m *ProductMutation) RemovedAssocProductAssocsIDs() (ids []int) {
	for id := range m.removedassoc_product_assocs {
		ids = append(ids, id)
	}
	return
}

// AssocProductAssocsIDs returns the "assoc_product_assocs" edge IDs in the mutation.
func (m *ProductMutation) AssocProductAssocsIDs() (ids []int) {
	for id := range m.assoc_product_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetAssocProductAssocs resets all changes to the "assoc_product_assocs" edge.
func (m *ProductMutation) ResetAssocProductAssocs() {
	m.assoc_product_assocs = nil
	m.clearedassoc_product_assocs = false
	m.removedassoc_product_assocs = nil
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrice entity by ids.
func (m *ProductMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrice entity.
func (m *ProductMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrice entity was cleared.
func (m *ProductMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrice entity by IDs.
func (m *ProductMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrice entity.
func (m *ProductMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *ProductMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *ProductMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// AddProductReviewIDs adds the "product_reviews" edge to the ProductReview entity by ids.
func (m *ProductMutation) AddProductReviewIDs(ids ...int) {
	if m.product_reviews == nil {
		m.product_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.product_reviews[ids[i]] = struct{}{}
	}
}

// ClearProductReviews clears the "product_reviews" edge to the ProductReview entity.
func (m *ProductMutation) ClearProductReviews() {
	m.clearedproduct_reviews = true
}

// ProductReviewsCleared reports if the "product_reviews" edge to the ProductReview entity was cleared.
func (m *ProductMutation) ProductReviewsCleared() bool {
	return m.clearedproduct_reviews
}

// RemoveProductReviewIDs removes the "product_reviews" edge to the ProductReview entity by IDs.
func (m *ProductMutation) RemoveProductReviewIDs(ids ...int) {
	if m.removedproduct_reviews == nil {
		m.removedproduct_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_reviews[ids[i]] = struct{}{}
	}
}

// RemovedProductReviews returns the removed IDs of the "product_reviews" edge to the ProductReview entity.
func (m *ProductMutation) RemovedProductReviewsIDs() (ids []int) {
	for id := range m.removedproduct_reviews {
		ids = append(ids, id)
	}
	return
}

// ProductReviewsIDs returns the "product_reviews" edge IDs in the mutation.
func (m *ProductMutation) ProductReviewsIDs() (ids []int) {
	for id := range m.product_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetProductReviews resets all changes to the "product_reviews" edge.
func (m *ProductMutation) ResetProductReviews() {
	m.product_reviews = nil
	m.clearedproduct_reviews = false
	m.removedproduct_reviews = nil
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 66)
	if m.create_time != nil {
		fields = append(fields, product.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, product.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, product.FieldStringRef)
	}
	if m.facility_id != nil {
		fields = append(fields, product.FieldFacilityID)
	}
	if m.introduction_date != nil {
		fields = append(fields, product.FieldIntroductionDate)
	}
	if m.release_date != nil {
		fields = append(fields, product.FieldReleaseDate)
	}
	if m.support_discontinuation_date != nil {
		fields = append(fields, product.FieldSupportDiscontinuationDate)
	}
	if m.sales_discontinuation_date != nil {
		fields = append(fields, product.FieldSalesDiscontinuationDate)
	}
	if m.sales_disc_when_not_avail != nil {
		fields = append(fields, product.FieldSalesDiscWhenNotAvail)
	}
	if m.internal_name != nil {
		fields = append(fields, product.FieldInternalName)
	}
	if m.brand_name != nil {
		fields = append(fields, product.FieldBrandName)
	}
	if m.comments != nil {
		fields = append(fields, product.FieldComments)
	}
	if m.product_name != nil {
		fields = append(fields, product.FieldProductName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.long_description != nil {
		fields = append(fields, product.FieldLongDescription)
	}
	if m.price_detail_text != nil {
		fields = append(fields, product.FieldPriceDetailText)
	}
	if m.small_image_url != nil {
		fields = append(fields, product.FieldSmallImageURL)
	}
	if m.medium_image_url != nil {
		fields = append(fields, product.FieldMediumImageURL)
	}
	if m.large_image_url != nil {
		fields = append(fields, product.FieldLargeImageURL)
	}
	if m.detail_image_url != nil {
		fields = append(fields, product.FieldDetailImageURL)
	}
	if m.original_image_url != nil {
		fields = append(fields, product.FieldOriginalImageURL)
	}
	if m.detail_screen != nil {
		fields = append(fields, product.FieldDetailScreen)
	}
	if m.inventory_message != nil {
		fields = append(fields, product.FieldInventoryMessage)
	}
	if m.require_inventory != nil {
		fields = append(fields, product.FieldRequireInventory)
	}
	if m.quantity_uom_id != nil {
		fields = append(fields, product.FieldQuantityUomID)
	}
	if m.quantity_included != nil {
		fields = append(fields, product.FieldQuantityIncluded)
	}
	if m.pieces_included != nil {
		fields = append(fields, product.FieldPiecesIncluded)
	}
	if m.require_amount != nil {
		fields = append(fields, product.FieldRequireAmount)
	}
	if m.fixed_amount != nil {
		fields = append(fields, product.FieldFixedAmount)
	}
	if m.amount_uom_type_id != nil {
		fields = append(fields, product.FieldAmountUomTypeID)
	}
	if m.weight_uom_id != nil {
		fields = append(fields, product.FieldWeightUomID)
	}
	if m.shipping_weight != nil {
		fields = append(fields, product.FieldShippingWeight)
	}
	if m.product_weight != nil {
		fields = append(fields, product.FieldProductWeight)
	}
	if m.height_uom_id != nil {
		fields = append(fields, product.FieldHeightUomID)
	}
	if m.product_height != nil {
		fields = append(fields, product.FieldProductHeight)
	}
	if m.shipping_height != nil {
		fields = append(fields, product.FieldShippingHeight)
	}
	if m.width_uom_id != nil {
		fields = append(fields, product.FieldWidthUomID)
	}
	if m.product_width != nil {
		fields = append(fields, product.FieldProductWidth)
	}
	if m.shipping_width != nil {
		fields = append(fields, product.FieldShippingWidth)
	}
	if m.depth_uom_id != nil {
		fields = append(fields, product.FieldDepthUomID)
	}
	if m.product_depth != nil {
		fields = append(fields, product.FieldProductDepth)
	}
	if m.shipping_depth != nil {
		fields = append(fields, product.FieldShippingDepth)
	}
	if m.diameter_uom_id != nil {
		fields = append(fields, product.FieldDiameterUomID)
	}
	if m.product_diameter != nil {
		fields = append(fields, product.FieldProductDiameter)
	}
	if m.product_rating != nil {
		fields = append(fields, product.FieldProductRating)
	}
	if m.returnable != nil {
		fields = append(fields, product.FieldReturnable)
	}
	if m.taxable != nil {
		fields = append(fields, product.FieldTaxable)
	}
	if m.charge_shipping != nil {
		fields = append(fields, product.FieldChargeShipping)
	}
	if m.auto_create_keywords != nil {
		fields = append(fields, product.FieldAutoCreateKeywords)
	}
	if m.include_in_promotions != nil {
		fields = append(fields, product.FieldIncludeInPromotions)
	}
	if m.is_virtual != nil {
		fields = append(fields, product.FieldIsVirtual)
	}
	if m.is_variant != nil {
		fields = append(fields, product.FieldIsVariant)
	}
	if m.origin_geo_id != nil {
		fields = append(fields, product.FieldOriginGeoID)
	}
	if m.bill_of_material_level != nil {
		fields = append(fields, product.FieldBillOfMaterialLevel)
	}
	if m.reserv_max_persons != nil {
		fields = append(fields, product.FieldReservMaxPersons)
	}
	if m.reserv_2_nd_pp_perc != nil {
		fields = append(fields, product.FieldReserv2NdPpPerc)
	}
	if m.reserv_nth_pp_perc != nil {
		fields = append(fields, product.FieldReservNthPpPerc)
	}
	if m.config_id != nil {
		fields = append(fields, product.FieldConfigID)
	}
	if m.created_date != nil {
		fields = append(fields, product.FieldCreatedDate)
	}
	if m.created_by_user_login != nil {
		fields = append(fields, product.FieldCreatedByUserLogin)
	}
	if m.last_modified_date != nil {
		fields = append(fields, product.FieldLastModifiedDate)
	}
	if m.last_modified_by_user_login != nil {
		fields = append(fields, product.FieldLastModifiedByUserLogin)
	}
	if m.in_shipping_box != nil {
		fields = append(fields, product.FieldInShippingBox)
	}
	if m.default_shipment_box_type_id != nil {
		fields = append(fields, product.FieldDefaultShipmentBoxTypeID)
	}
	if m.lot_id_filled_in != nil {
		fields = append(fields, product.FieldLotIDFilledIn)
	}
	if m.order_decimal_quantity != nil {
		fields = append(fields, product.FieldOrderDecimalQuantity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreateTime:
		return m.CreateTime()
	case product.FieldUpdateTime:
		return m.UpdateTime()
	case product.FieldStringRef:
		return m.StringRef()
	case product.FieldFacilityID:
		return m.FacilityID()
	case product.FieldIntroductionDate:
		return m.IntroductionDate()
	case product.FieldReleaseDate:
		return m.ReleaseDate()
	case product.FieldSupportDiscontinuationDate:
		return m.SupportDiscontinuationDate()
	case product.FieldSalesDiscontinuationDate:
		return m.SalesDiscontinuationDate()
	case product.FieldSalesDiscWhenNotAvail:
		return m.SalesDiscWhenNotAvail()
	case product.FieldInternalName:
		return m.InternalName()
	case product.FieldBrandName:
		return m.BrandName()
	case product.FieldComments:
		return m.Comments()
	case product.FieldProductName:
		return m.ProductName()
	case product.FieldDescription:
		return m.Description()
	case product.FieldLongDescription:
		return m.LongDescription()
	case product.FieldPriceDetailText:
		return m.PriceDetailText()
	case product.FieldSmallImageURL:
		return m.SmallImageURL()
	case product.FieldMediumImageURL:
		return m.MediumImageURL()
	case product.FieldLargeImageURL:
		return m.LargeImageURL()
	case product.FieldDetailImageURL:
		return m.DetailImageURL()
	case product.FieldOriginalImageURL:
		return m.OriginalImageURL()
	case product.FieldDetailScreen:
		return m.DetailScreen()
	case product.FieldInventoryMessage:
		return m.InventoryMessage()
	case product.FieldRequireInventory:
		return m.RequireInventory()
	case product.FieldQuantityUomID:
		return m.QuantityUomID()
	case product.FieldQuantityIncluded:
		return m.QuantityIncluded()
	case product.FieldPiecesIncluded:
		return m.PiecesIncluded()
	case product.FieldRequireAmount:
		return m.RequireAmount()
	case product.FieldFixedAmount:
		return m.FixedAmount()
	case product.FieldAmountUomTypeID:
		return m.AmountUomTypeID()
	case product.FieldWeightUomID:
		return m.WeightUomID()
	case product.FieldShippingWeight:
		return m.ShippingWeight()
	case product.FieldProductWeight:
		return m.ProductWeight()
	case product.FieldHeightUomID:
		return m.HeightUomID()
	case product.FieldProductHeight:
		return m.ProductHeight()
	case product.FieldShippingHeight:
		return m.ShippingHeight()
	case product.FieldWidthUomID:
		return m.WidthUomID()
	case product.FieldProductWidth:
		return m.ProductWidth()
	case product.FieldShippingWidth:
		return m.ShippingWidth()
	case product.FieldDepthUomID:
		return m.DepthUomID()
	case product.FieldProductDepth:
		return m.ProductDepth()
	case product.FieldShippingDepth:
		return m.ShippingDepth()
	case product.FieldDiameterUomID:
		return m.DiameterUomID()
	case product.FieldProductDiameter:
		return m.ProductDiameter()
	case product.FieldProductRating:
		return m.ProductRating()
	case product.FieldReturnable:
		return m.Returnable()
	case product.FieldTaxable:
		return m.Taxable()
	case product.FieldChargeShipping:
		return m.ChargeShipping()
	case product.FieldAutoCreateKeywords:
		return m.AutoCreateKeywords()
	case product.FieldIncludeInPromotions:
		return m.IncludeInPromotions()
	case product.FieldIsVirtual:
		return m.IsVirtual()
	case product.FieldIsVariant:
		return m.IsVariant()
	case product.FieldOriginGeoID:
		return m.OriginGeoID()
	case product.FieldBillOfMaterialLevel:
		return m.BillOfMaterialLevel()
	case product.FieldReservMaxPersons:
		return m.ReservMaxPersons()
	case product.FieldReserv2NdPpPerc:
		return m.Reserv2NdPpPerc()
	case product.FieldReservNthPpPerc:
		return m.ReservNthPpPerc()
	case product.FieldConfigID:
		return m.ConfigID()
	case product.FieldCreatedDate:
		return m.CreatedDate()
	case product.FieldCreatedByUserLogin:
		return m.CreatedByUserLogin()
	case product.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case product.FieldLastModifiedByUserLogin:
		return m.LastModifiedByUserLogin()
	case product.FieldInShippingBox:
		return m.InShippingBox()
	case product.FieldDefaultShipmentBoxTypeID:
		return m.DefaultShipmentBoxTypeID()
	case product.FieldLotIDFilledIn:
		return m.LotIDFilledIn()
	case product.FieldOrderDecimalQuantity:
		return m.OrderDecimalQuantity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case product.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case product.FieldStringRef:
		return m.OldStringRef(ctx)
	case product.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case product.FieldIntroductionDate:
		return m.OldIntroductionDate(ctx)
	case product.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case product.FieldSupportDiscontinuationDate:
		return m.OldSupportDiscontinuationDate(ctx)
	case product.FieldSalesDiscontinuationDate:
		return m.OldSalesDiscontinuationDate(ctx)
	case product.FieldSalesDiscWhenNotAvail:
		return m.OldSalesDiscWhenNotAvail(ctx)
	case product.FieldInternalName:
		return m.OldInternalName(ctx)
	case product.FieldBrandName:
		return m.OldBrandName(ctx)
	case product.FieldComments:
		return m.OldComments(ctx)
	case product.FieldProductName:
		return m.OldProductName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldLongDescription:
		return m.OldLongDescription(ctx)
	case product.FieldPriceDetailText:
		return m.OldPriceDetailText(ctx)
	case product.FieldSmallImageURL:
		return m.OldSmallImageURL(ctx)
	case product.FieldMediumImageURL:
		return m.OldMediumImageURL(ctx)
	case product.FieldLargeImageURL:
		return m.OldLargeImageURL(ctx)
	case product.FieldDetailImageURL:
		return m.OldDetailImageURL(ctx)
	case product.FieldOriginalImageURL:
		return m.OldOriginalImageURL(ctx)
	case product.FieldDetailScreen:
		return m.OldDetailScreen(ctx)
	case product.FieldInventoryMessage:
		return m.OldInventoryMessage(ctx)
	case product.FieldRequireInventory:
		return m.OldRequireInventory(ctx)
	case product.FieldQuantityUomID:
		return m.OldQuantityUomID(ctx)
	case product.FieldQuantityIncluded:
		return m.OldQuantityIncluded(ctx)
	case product.FieldPiecesIncluded:
		return m.OldPiecesIncluded(ctx)
	case product.FieldRequireAmount:
		return m.OldRequireAmount(ctx)
	case product.FieldFixedAmount:
		return m.OldFixedAmount(ctx)
	case product.FieldAmountUomTypeID:
		return m.OldAmountUomTypeID(ctx)
	case product.FieldWeightUomID:
		return m.OldWeightUomID(ctx)
	case product.FieldShippingWeight:
		return m.OldShippingWeight(ctx)
	case product.FieldProductWeight:
		return m.OldProductWeight(ctx)
	case product.FieldHeightUomID:
		return m.OldHeightUomID(ctx)
	case product.FieldProductHeight:
		return m.OldProductHeight(ctx)
	case product.FieldShippingHeight:
		return m.OldShippingHeight(ctx)
	case product.FieldWidthUomID:
		return m.OldWidthUomID(ctx)
	case product.FieldProductWidth:
		return m.OldProductWidth(ctx)
	case product.FieldShippingWidth:
		return m.OldShippingWidth(ctx)
	case product.FieldDepthUomID:
		return m.OldDepthUomID(ctx)
	case product.FieldProductDepth:
		return m.OldProductDepth(ctx)
	case product.FieldShippingDepth:
		return m.OldShippingDepth(ctx)
	case product.FieldDiameterUomID:
		return m.OldDiameterUomID(ctx)
	case product.FieldProductDiameter:
		return m.OldProductDiameter(ctx)
	case product.FieldProductRating:
		return m.OldProductRating(ctx)
	case product.FieldReturnable:
		return m.OldReturnable(ctx)
	case product.FieldTaxable:
		return m.OldTaxable(ctx)
	case product.FieldChargeShipping:
		return m.OldChargeShipping(ctx)
	case product.FieldAutoCreateKeywords:
		return m.OldAutoCreateKeywords(ctx)
	case product.FieldIncludeInPromotions:
		return m.OldIncludeInPromotions(ctx)
	case product.FieldIsVirtual:
		return m.OldIsVirtual(ctx)
	case product.FieldIsVariant:
		return m.OldIsVariant(ctx)
	case product.FieldOriginGeoID:
		return m.OldOriginGeoID(ctx)
	case product.FieldBillOfMaterialLevel:
		return m.OldBillOfMaterialLevel(ctx)
	case product.FieldReservMaxPersons:
		return m.OldReservMaxPersons(ctx)
	case product.FieldReserv2NdPpPerc:
		return m.OldReserv2NdPpPerc(ctx)
	case product.FieldReservNthPpPerc:
		return m.OldReservNthPpPerc(ctx)
	case product.FieldConfigID:
		return m.OldConfigID(ctx)
	case product.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case product.FieldCreatedByUserLogin:
		return m.OldCreatedByUserLogin(ctx)
	case product.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case product.FieldLastModifiedByUserLogin:
		return m.OldLastModifiedByUserLogin(ctx)
	case product.FieldInShippingBox:
		return m.OldInShippingBox(ctx)
	case product.FieldDefaultShipmentBoxTypeID:
		return m.OldDefaultShipmentBoxTypeID(ctx)
	case product.FieldLotIDFilledIn:
		return m.OldLotIDFilledIn(ctx)
	case product.FieldOrderDecimalQuantity:
		return m.OldOrderDecimalQuantity(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case product.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case product.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case product.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case product.FieldIntroductionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntroductionDate(v)
		return nil
	case product.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case product.FieldSupportDiscontinuationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportDiscontinuationDate(v)
		return nil
	case product.FieldSalesDiscontinuationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesDiscontinuationDate(v)
		return nil
	case product.FieldSalesDiscWhenNotAvail:
		v, ok := value.(product.SalesDiscWhenNotAvail)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesDiscWhenNotAvail(v)
		return nil
	case product.FieldInternalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalName(v)
		return nil
	case product.FieldBrandName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandName(v)
		return nil
	case product.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case product.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldLongDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongDescription(v)
		return nil
	case product.FieldPriceDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceDetailText(v)
		return nil
	case product.FieldSmallImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSmallImageURL(v)
		return nil
	case product.FieldMediumImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediumImageURL(v)
		return nil
	case product.FieldLargeImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLargeImageURL(v)
		return nil
	case product.FieldDetailImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailImageURL(v)
		return nil
	case product.FieldOriginalImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalImageURL(v)
		return nil
	case product.FieldDetailScreen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailScreen(v)
		return nil
	case product.FieldInventoryMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryMessage(v)
		return nil
	case product.FieldRequireInventory:
		v, ok := value.(product.RequireInventory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireInventory(v)
		return nil
	case product.FieldQuantityUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityUomID(v)
		return nil
	case product.FieldQuantityIncluded:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityIncluded(v)
		return nil
	case product.FieldPiecesIncluded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPiecesIncluded(v)
		return nil
	case product.FieldRequireAmount:
		v, ok := value.(product.RequireAmount)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireAmount(v)
		return nil
	case product.FieldFixedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedAmount(v)
		return nil
	case product.FieldAmountUomTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountUomTypeID(v)
		return nil
	case product.FieldWeightUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightUomID(v)
		return nil
	case product.FieldShippingWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingWeight(v)
		return nil
	case product.FieldProductWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductWeight(v)
		return nil
	case product.FieldHeightUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeightUomID(v)
		return nil
	case product.FieldProductHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductHeight(v)
		return nil
	case product.FieldShippingHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingHeight(v)
		return nil
	case product.FieldWidthUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidthUomID(v)
		return nil
	case product.FieldProductWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductWidth(v)
		return nil
	case product.FieldShippingWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingWidth(v)
		return nil
	case product.FieldDepthUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepthUomID(v)
		return nil
	case product.FieldProductDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductDepth(v)
		return nil
	case product.FieldShippingDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingDepth(v)
		return nil
	case product.FieldDiameterUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiameterUomID(v)
		return nil
	case product.FieldProductDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductDiameter(v)
		return nil
	case product.FieldProductRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductRating(v)
		return nil
	case product.FieldReturnable:
		v, ok := value.(product.Returnable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnable(v)
		return nil
	case product.FieldTaxable:
		v, ok := value.(product.Taxable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxable(v)
		return nil
	case product.FieldChargeShipping:
		v, ok := value.(product.ChargeShipping)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeShipping(v)
		return nil
	case product.FieldAutoCreateKeywords:
		v, ok := value.(product.AutoCreateKeywords)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoCreateKeywords(v)
		return nil
	case product.FieldIncludeInPromotions:
		v, ok := value.(product.IncludeInPromotions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeInPromotions(v)
		return nil
	case product.FieldIsVirtual:
		v, ok := value.(product.IsVirtual)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVirtual(v)
		return nil
	case product.FieldIsVariant:
		v, ok := value.(product.IsVariant)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVariant(v)
		return nil
	case product.FieldOriginGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginGeoID(v)
		return nil
	case product.FieldBillOfMaterialLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillOfMaterialLevel(v)
		return nil
	case product.FieldReservMaxPersons:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservMaxPersons(v)
		return nil
	case product.FieldReserv2NdPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserv2NdPpPerc(v)
		return nil
	case product.FieldReservNthPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservNthPpPerc(v)
		return nil
	case product.FieldConfigID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigID(v)
		return nil
	case product.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case product.FieldCreatedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByUserLogin(v)
		return nil
	case product.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case product.FieldLastModifiedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedByUserLogin(v)
		return nil
	case product.FieldInShippingBox:
		v, ok := value.(product.InShippingBox)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInShippingBox(v)
		return nil
	case product.FieldDefaultShipmentBoxTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultShipmentBoxTypeID(v)
		return nil
	case product.FieldLotIDFilledIn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotIDFilledIn(v)
		return nil
	case product.FieldOrderDecimalQuantity:
		v, ok := value.(product.OrderDecimalQuantity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDecimalQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addfacility_id != nil {
		fields = append(fields, product.FieldFacilityID)
	}
	if m.addquantity_uom_id != nil {
		fields = append(fields, product.FieldQuantityUomID)
	}
	if m.addquantity_included != nil {
		fields = append(fields, product.FieldQuantityIncluded)
	}
	if m.addpieces_included != nil {
		fields = append(fields, product.FieldPiecesIncluded)
	}
	if m.addfixed_amount != nil {
		fields = append(fields, product.FieldFixedAmount)
	}
	if m.addamount_uom_type_id != nil {
		fields = append(fields, product.FieldAmountUomTypeID)
	}
	if m.addweight_uom_id != nil {
		fields = append(fields, product.FieldWeightUomID)
	}
	if m.addshipping_weight != nil {
		fields = append(fields, product.FieldShippingWeight)
	}
	if m.addproduct_weight != nil {
		fields = append(fields, product.FieldProductWeight)
	}
	if m.addheight_uom_id != nil {
		fields = append(fields, product.FieldHeightUomID)
	}
	if m.addproduct_height != nil {
		fields = append(fields, product.FieldProductHeight)
	}
	if m.addshipping_height != nil {
		fields = append(fields, product.FieldShippingHeight)
	}
	if m.addwidth_uom_id != nil {
		fields = append(fields, product.FieldWidthUomID)
	}
	if m.addproduct_width != nil {
		fields = append(fields, product.FieldProductWidth)
	}
	if m.addshipping_width != nil {
		fields = append(fields, product.FieldShippingWidth)
	}
	if m.adddepth_uom_id != nil {
		fields = append(fields, product.FieldDepthUomID)
	}
	if m.addproduct_depth != nil {
		fields = append(fields, product.FieldProductDepth)
	}
	if m.addshipping_depth != nil {
		fields = append(fields, product.FieldShippingDepth)
	}
	if m.adddiameter_uom_id != nil {
		fields = append(fields, product.FieldDiameterUomID)
	}
	if m.addproduct_diameter != nil {
		fields = append(fields, product.FieldProductDiameter)
	}
	if m.addproduct_rating != nil {
		fields = append(fields, product.FieldProductRating)
	}
	if m.addorigin_geo_id != nil {
		fields = append(fields, product.FieldOriginGeoID)
	}
	if m.addbill_of_material_level != nil {
		fields = append(fields, product.FieldBillOfMaterialLevel)
	}
	if m.addreserv_max_persons != nil {
		fields = append(fields, product.FieldReservMaxPersons)
	}
	if m.addreserv_2_nd_pp_perc != nil {
		fields = append(fields, product.FieldReserv2NdPpPerc)
	}
	if m.addreserv_nth_pp_perc != nil {
		fields = append(fields, product.FieldReservNthPpPerc)
	}
	if m.addconfig_id != nil {
		fields = append(fields, product.FieldConfigID)
	}
	if m.adddefault_shipment_box_type_id != nil {
		fields = append(fields, product.FieldDefaultShipmentBoxTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldFacilityID:
		return m.AddedFacilityID()
	case product.FieldQuantityUomID:
		return m.AddedQuantityUomID()
	case product.FieldQuantityIncluded:
		return m.AddedQuantityIncluded()
	case product.FieldPiecesIncluded:
		return m.AddedPiecesIncluded()
	case product.FieldFixedAmount:
		return m.AddedFixedAmount()
	case product.FieldAmountUomTypeID:
		return m.AddedAmountUomTypeID()
	case product.FieldWeightUomID:
		return m.AddedWeightUomID()
	case product.FieldShippingWeight:
		return m.AddedShippingWeight()
	case product.FieldProductWeight:
		return m.AddedProductWeight()
	case product.FieldHeightUomID:
		return m.AddedHeightUomID()
	case product.FieldProductHeight:
		return m.AddedProductHeight()
	case product.FieldShippingHeight:
		return m.AddedShippingHeight()
	case product.FieldWidthUomID:
		return m.AddedWidthUomID()
	case product.FieldProductWidth:
		return m.AddedProductWidth()
	case product.FieldShippingWidth:
		return m.AddedShippingWidth()
	case product.FieldDepthUomID:
		return m.AddedDepthUomID()
	case product.FieldProductDepth:
		return m.AddedProductDepth()
	case product.FieldShippingDepth:
		return m.AddedShippingDepth()
	case product.FieldDiameterUomID:
		return m.AddedDiameterUomID()
	case product.FieldProductDiameter:
		return m.AddedProductDiameter()
	case product.FieldProductRating:
		return m.AddedProductRating()
	case product.FieldOriginGeoID:
		return m.AddedOriginGeoID()
	case product.FieldBillOfMaterialLevel:
		return m.AddedBillOfMaterialLevel()
	case product.FieldReservMaxPersons:
		return m.AddedReservMaxPersons()
	case product.FieldReserv2NdPpPerc:
		return m.AddedReserv2NdPpPerc()
	case product.FieldReservNthPpPerc:
		return m.AddedReservNthPpPerc()
	case product.FieldConfigID:
		return m.AddedConfigID()
	case product.FieldDefaultShipmentBoxTypeID:
		return m.AddedDefaultShipmentBoxTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFacilityID(v)
		return nil
	case product.FieldQuantityUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityUomID(v)
		return nil
	case product.FieldQuantityIncluded:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityIncluded(v)
		return nil
	case product.FieldPiecesIncluded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPiecesIncluded(v)
		return nil
	case product.FieldFixedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedAmount(v)
		return nil
	case product.FieldAmountUomTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountUomTypeID(v)
		return nil
	case product.FieldWeightUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightUomID(v)
		return nil
	case product.FieldShippingWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingWeight(v)
		return nil
	case product.FieldProductWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductWeight(v)
		return nil
	case product.FieldHeightUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeightUomID(v)
		return nil
	case product.FieldProductHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductHeight(v)
		return nil
	case product.FieldShippingHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingHeight(v)
		return nil
	case product.FieldWidthUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidthUomID(v)
		return nil
	case product.FieldProductWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductWidth(v)
		return nil
	case product.FieldShippingWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingWidth(v)
		return nil
	case product.FieldDepthUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepthUomID(v)
		return nil
	case product.FieldProductDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductDepth(v)
		return nil
	case product.FieldShippingDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingDepth(v)
		return nil
	case product.FieldDiameterUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiameterUomID(v)
		return nil
	case product.FieldProductDiameter:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductDiameter(v)
		return nil
	case product.FieldProductRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductRating(v)
		return nil
	case product.FieldOriginGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginGeoID(v)
		return nil
	case product.FieldBillOfMaterialLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBillOfMaterialLevel(v)
		return nil
	case product.FieldReservMaxPersons:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservMaxPersons(v)
		return nil
	case product.FieldReserv2NdPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReserv2NdPpPerc(v)
		return nil
	case product.FieldReservNthPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservNthPpPerc(v)
		return nil
	case product.FieldConfigID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigID(v)
		return nil
	case product.FieldDefaultShipmentBoxTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultShipmentBoxTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldStringRef) {
		fields = append(fields, product.FieldStringRef)
	}
	if m.FieldCleared(product.FieldFacilityID) {
		fields = append(fields, product.FieldFacilityID)
	}
	if m.FieldCleared(product.FieldIntroductionDate) {
		fields = append(fields, product.FieldIntroductionDate)
	}
	if m.FieldCleared(product.FieldReleaseDate) {
		fields = append(fields, product.FieldReleaseDate)
	}
	if m.FieldCleared(product.FieldSupportDiscontinuationDate) {
		fields = append(fields, product.FieldSupportDiscontinuationDate)
	}
	if m.FieldCleared(product.FieldSalesDiscontinuationDate) {
		fields = append(fields, product.FieldSalesDiscontinuationDate)
	}
	if m.FieldCleared(product.FieldSalesDiscWhenNotAvail) {
		fields = append(fields, product.FieldSalesDiscWhenNotAvail)
	}
	if m.FieldCleared(product.FieldInternalName) {
		fields = append(fields, product.FieldInternalName)
	}
	if m.FieldCleared(product.FieldBrandName) {
		fields = append(fields, product.FieldBrandName)
	}
	if m.FieldCleared(product.FieldComments) {
		fields = append(fields, product.FieldComments)
	}
	if m.FieldCleared(product.FieldProductName) {
		fields = append(fields, product.FieldProductName)
	}
	if m.FieldCleared(product.FieldDescription) {
		fields = append(fields, product.FieldDescription)
	}
	if m.FieldCleared(product.FieldLongDescription) {
		fields = append(fields, product.FieldLongDescription)
	}
	if m.FieldCleared(product.FieldPriceDetailText) {
		fields = append(fields, product.FieldPriceDetailText)
	}
	if m.FieldCleared(product.FieldSmallImageURL) {
		fields = append(fields, product.FieldSmallImageURL)
	}
	if m.FieldCleared(product.FieldMediumImageURL) {
		fields = append(fields, product.FieldMediumImageURL)
	}
	if m.FieldCleared(product.FieldLargeImageURL) {
		fields = append(fields, product.FieldLargeImageURL)
	}
	if m.FieldCleared(product.FieldDetailImageURL) {
		fields = append(fields, product.FieldDetailImageURL)
	}
	if m.FieldCleared(product.FieldOriginalImageURL) {
		fields = append(fields, product.FieldOriginalImageURL)
	}
	if m.FieldCleared(product.FieldDetailScreen) {
		fields = append(fields, product.FieldDetailScreen)
	}
	if m.FieldCleared(product.FieldInventoryMessage) {
		fields = append(fields, product.FieldInventoryMessage)
	}
	if m.FieldCleared(product.FieldRequireInventory) {
		fields = append(fields, product.FieldRequireInventory)
	}
	if m.FieldCleared(product.FieldQuantityUomID) {
		fields = append(fields, product.FieldQuantityUomID)
	}
	if m.FieldCleared(product.FieldQuantityIncluded) {
		fields = append(fields, product.FieldQuantityIncluded)
	}
	if m.FieldCleared(product.FieldPiecesIncluded) {
		fields = append(fields, product.FieldPiecesIncluded)
	}
	if m.FieldCleared(product.FieldRequireAmount) {
		fields = append(fields, product.FieldRequireAmount)
	}
	if m.FieldCleared(product.FieldFixedAmount) {
		fields = append(fields, product.FieldFixedAmount)
	}
	if m.FieldCleared(product.FieldAmountUomTypeID) {
		fields = append(fields, product.FieldAmountUomTypeID)
	}
	if m.FieldCleared(product.FieldWeightUomID) {
		fields = append(fields, product.FieldWeightUomID)
	}
	if m.FieldCleared(product.FieldShippingWeight) {
		fields = append(fields, product.FieldShippingWeight)
	}
	if m.FieldCleared(product.FieldProductWeight) {
		fields = append(fields, product.FieldProductWeight)
	}
	if m.FieldCleared(product.FieldHeightUomID) {
		fields = append(fields, product.FieldHeightUomID)
	}
	if m.FieldCleared(product.FieldProductHeight) {
		fields = append(fields, product.FieldProductHeight)
	}
	if m.FieldCleared(product.FieldShippingHeight) {
		fields = append(fields, product.FieldShippingHeight)
	}
	if m.FieldCleared(product.FieldWidthUomID) {
		fields = append(fields, product.FieldWidthUomID)
	}
	if m.FieldCleared(product.FieldProductWidth) {
		fields = append(fields, product.FieldProductWidth)
	}
	if m.FieldCleared(product.FieldShippingWidth) {
		fields = append(fields, product.FieldShippingWidth)
	}
	if m.FieldCleared(product.FieldDepthUomID) {
		fields = append(fields, product.FieldDepthUomID)
	}
	if m.FieldCleared(product.FieldProductDepth) {
		fields = append(fields, product.FieldProductDepth)
	}
	if m.FieldCleared(product.FieldShippingDepth) {
		fields = append(fields, product.FieldShippingDepth)
	}
	if m.FieldCleared(product.FieldDiameterUomID) {
		fields = append(fields, product.FieldDiameterUomID)
	}
	if m.FieldCleared(product.FieldProductDiameter) {
		fields = append(fields, product.FieldProductDiameter)
	}
	if m.FieldCleared(product.FieldProductRating) {
		fields = append(fields, product.FieldProductRating)
	}
	if m.FieldCleared(product.FieldReturnable) {
		fields = append(fields, product.FieldReturnable)
	}
	if m.FieldCleared(product.FieldTaxable) {
		fields = append(fields, product.FieldTaxable)
	}
	if m.FieldCleared(product.FieldChargeShipping) {
		fields = append(fields, product.FieldChargeShipping)
	}
	if m.FieldCleared(product.FieldAutoCreateKeywords) {
		fields = append(fields, product.FieldAutoCreateKeywords)
	}
	if m.FieldCleared(product.FieldIncludeInPromotions) {
		fields = append(fields, product.FieldIncludeInPromotions)
	}
	if m.FieldCleared(product.FieldIsVirtual) {
		fields = append(fields, product.FieldIsVirtual)
	}
	if m.FieldCleared(product.FieldIsVariant) {
		fields = append(fields, product.FieldIsVariant)
	}
	if m.FieldCleared(product.FieldOriginGeoID) {
		fields = append(fields, product.FieldOriginGeoID)
	}
	if m.FieldCleared(product.FieldBillOfMaterialLevel) {
		fields = append(fields, product.FieldBillOfMaterialLevel)
	}
	if m.FieldCleared(product.FieldReservMaxPersons) {
		fields = append(fields, product.FieldReservMaxPersons)
	}
	if m.FieldCleared(product.FieldReserv2NdPpPerc) {
		fields = append(fields, product.FieldReserv2NdPpPerc)
	}
	if m.FieldCleared(product.FieldReservNthPpPerc) {
		fields = append(fields, product.FieldReservNthPpPerc)
	}
	if m.FieldCleared(product.FieldConfigID) {
		fields = append(fields, product.FieldConfigID)
	}
	if m.FieldCleared(product.FieldCreatedDate) {
		fields = append(fields, product.FieldCreatedDate)
	}
	if m.FieldCleared(product.FieldCreatedByUserLogin) {
		fields = append(fields, product.FieldCreatedByUserLogin)
	}
	if m.FieldCleared(product.FieldLastModifiedDate) {
		fields = append(fields, product.FieldLastModifiedDate)
	}
	if m.FieldCleared(product.FieldLastModifiedByUserLogin) {
		fields = append(fields, product.FieldLastModifiedByUserLogin)
	}
	if m.FieldCleared(product.FieldInShippingBox) {
		fields = append(fields, product.FieldInShippingBox)
	}
	if m.FieldCleared(product.FieldDefaultShipmentBoxTypeID) {
		fields = append(fields, product.FieldDefaultShipmentBoxTypeID)
	}
	if m.FieldCleared(product.FieldLotIDFilledIn) {
		fields = append(fields, product.FieldLotIDFilledIn)
	}
	if m.FieldCleared(product.FieldOrderDecimalQuantity) {
		fields = append(fields, product.FieldOrderDecimalQuantity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldStringRef:
		m.ClearStringRef()
		return nil
	case product.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case product.FieldIntroductionDate:
		m.ClearIntroductionDate()
		return nil
	case product.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case product.FieldSupportDiscontinuationDate:
		m.ClearSupportDiscontinuationDate()
		return nil
	case product.FieldSalesDiscontinuationDate:
		m.ClearSalesDiscontinuationDate()
		return nil
	case product.FieldSalesDiscWhenNotAvail:
		m.ClearSalesDiscWhenNotAvail()
		return nil
	case product.FieldInternalName:
		m.ClearInternalName()
		return nil
	case product.FieldBrandName:
		m.ClearBrandName()
		return nil
	case product.FieldComments:
		m.ClearComments()
		return nil
	case product.FieldProductName:
		m.ClearProductName()
		return nil
	case product.FieldDescription:
		m.ClearDescription()
		return nil
	case product.FieldLongDescription:
		m.ClearLongDescription()
		return nil
	case product.FieldPriceDetailText:
		m.ClearPriceDetailText()
		return nil
	case product.FieldSmallImageURL:
		m.ClearSmallImageURL()
		return nil
	case product.FieldMediumImageURL:
		m.ClearMediumImageURL()
		return nil
	case product.FieldLargeImageURL:
		m.ClearLargeImageURL()
		return nil
	case product.FieldDetailImageURL:
		m.ClearDetailImageURL()
		return nil
	case product.FieldOriginalImageURL:
		m.ClearOriginalImageURL()
		return nil
	case product.FieldDetailScreen:
		m.ClearDetailScreen()
		return nil
	case product.FieldInventoryMessage:
		m.ClearInventoryMessage()
		return nil
	case product.FieldRequireInventory:
		m.ClearRequireInventory()
		return nil
	case product.FieldQuantityUomID:
		m.ClearQuantityUomID()
		return nil
	case product.FieldQuantityIncluded:
		m.ClearQuantityIncluded()
		return nil
	case product.FieldPiecesIncluded:
		m.ClearPiecesIncluded()
		return nil
	case product.FieldRequireAmount:
		m.ClearRequireAmount()
		return nil
	case product.FieldFixedAmount:
		m.ClearFixedAmount()
		return nil
	case product.FieldAmountUomTypeID:
		m.ClearAmountUomTypeID()
		return nil
	case product.FieldWeightUomID:
		m.ClearWeightUomID()
		return nil
	case product.FieldShippingWeight:
		m.ClearShippingWeight()
		return nil
	case product.FieldProductWeight:
		m.ClearProductWeight()
		return nil
	case product.FieldHeightUomID:
		m.ClearHeightUomID()
		return nil
	case product.FieldProductHeight:
		m.ClearProductHeight()
		return nil
	case product.FieldShippingHeight:
		m.ClearShippingHeight()
		return nil
	case product.FieldWidthUomID:
		m.ClearWidthUomID()
		return nil
	case product.FieldProductWidth:
		m.ClearProductWidth()
		return nil
	case product.FieldShippingWidth:
		m.ClearShippingWidth()
		return nil
	case product.FieldDepthUomID:
		m.ClearDepthUomID()
		return nil
	case product.FieldProductDepth:
		m.ClearProductDepth()
		return nil
	case product.FieldShippingDepth:
		m.ClearShippingDepth()
		return nil
	case product.FieldDiameterUomID:
		m.ClearDiameterUomID()
		return nil
	case product.FieldProductDiameter:
		m.ClearProductDiameter()
		return nil
	case product.FieldProductRating:
		m.ClearProductRating()
		return nil
	case product.FieldReturnable:
		m.ClearReturnable()
		return nil
	case product.FieldTaxable:
		m.ClearTaxable()
		return nil
	case product.FieldChargeShipping:
		m.ClearChargeShipping()
		return nil
	case product.FieldAutoCreateKeywords:
		m.ClearAutoCreateKeywords()
		return nil
	case product.FieldIncludeInPromotions:
		m.ClearIncludeInPromotions()
		return nil
	case product.FieldIsVirtual:
		m.ClearIsVirtual()
		return nil
	case product.FieldIsVariant:
		m.ClearIsVariant()
		return nil
	case product.FieldOriginGeoID:
		m.ClearOriginGeoID()
		return nil
	case product.FieldBillOfMaterialLevel:
		m.ClearBillOfMaterialLevel()
		return nil
	case product.FieldReservMaxPersons:
		m.ClearReservMaxPersons()
		return nil
	case product.FieldReserv2NdPpPerc:
		m.ClearReserv2NdPpPerc()
		return nil
	case product.FieldReservNthPpPerc:
		m.ClearReservNthPpPerc()
		return nil
	case product.FieldConfigID:
		m.ClearConfigID()
		return nil
	case product.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case product.FieldCreatedByUserLogin:
		m.ClearCreatedByUserLogin()
		return nil
	case product.FieldLastModifiedDate:
		m.ClearLastModifiedDate()
		return nil
	case product.FieldLastModifiedByUserLogin:
		m.ClearLastModifiedByUserLogin()
		return nil
	case product.FieldInShippingBox:
		m.ClearInShippingBox()
		return nil
	case product.FieldDefaultShipmentBoxTypeID:
		m.ClearDefaultShipmentBoxTypeID()
		return nil
	case product.FieldLotIDFilledIn:
		m.ClearLotIDFilledIn()
		return nil
	case product.FieldOrderDecimalQuantity:
		m.ClearOrderDecimalQuantity()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case product.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case product.FieldStringRef:
		m.ResetStringRef()
		return nil
	case product.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case product.FieldIntroductionDate:
		m.ResetIntroductionDate()
		return nil
	case product.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case product.FieldSupportDiscontinuationDate:
		m.ResetSupportDiscontinuationDate()
		return nil
	case product.FieldSalesDiscontinuationDate:
		m.ResetSalesDiscontinuationDate()
		return nil
	case product.FieldSalesDiscWhenNotAvail:
		m.ResetSalesDiscWhenNotAvail()
		return nil
	case product.FieldInternalName:
		m.ResetInternalName()
		return nil
	case product.FieldBrandName:
		m.ResetBrandName()
		return nil
	case product.FieldComments:
		m.ResetComments()
		return nil
	case product.FieldProductName:
		m.ResetProductName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldLongDescription:
		m.ResetLongDescription()
		return nil
	case product.FieldPriceDetailText:
		m.ResetPriceDetailText()
		return nil
	case product.FieldSmallImageURL:
		m.ResetSmallImageURL()
		return nil
	case product.FieldMediumImageURL:
		m.ResetMediumImageURL()
		return nil
	case product.FieldLargeImageURL:
		m.ResetLargeImageURL()
		return nil
	case product.FieldDetailImageURL:
		m.ResetDetailImageURL()
		return nil
	case product.FieldOriginalImageURL:
		m.ResetOriginalImageURL()
		return nil
	case product.FieldDetailScreen:
		m.ResetDetailScreen()
		return nil
	case product.FieldInventoryMessage:
		m.ResetInventoryMessage()
		return nil
	case product.FieldRequireInventory:
		m.ResetRequireInventory()
		return nil
	case product.FieldQuantityUomID:
		m.ResetQuantityUomID()
		return nil
	case product.FieldQuantityIncluded:
		m.ResetQuantityIncluded()
		return nil
	case product.FieldPiecesIncluded:
		m.ResetPiecesIncluded()
		return nil
	case product.FieldRequireAmount:
		m.ResetRequireAmount()
		return nil
	case product.FieldFixedAmount:
		m.ResetFixedAmount()
		return nil
	case product.FieldAmountUomTypeID:
		m.ResetAmountUomTypeID()
		return nil
	case product.FieldWeightUomID:
		m.ResetWeightUomID()
		return nil
	case product.FieldShippingWeight:
		m.ResetShippingWeight()
		return nil
	case product.FieldProductWeight:
		m.ResetProductWeight()
		return nil
	case product.FieldHeightUomID:
		m.ResetHeightUomID()
		return nil
	case product.FieldProductHeight:
		m.ResetProductHeight()
		return nil
	case product.FieldShippingHeight:
		m.ResetShippingHeight()
		return nil
	case product.FieldWidthUomID:
		m.ResetWidthUomID()
		return nil
	case product.FieldProductWidth:
		m.ResetProductWidth()
		return nil
	case product.FieldShippingWidth:
		m.ResetShippingWidth()
		return nil
	case product.FieldDepthUomID:
		m.ResetDepthUomID()
		return nil
	case product.FieldProductDepth:
		m.ResetProductDepth()
		return nil
	case product.FieldShippingDepth:
		m.ResetShippingDepth()
		return nil
	case product.FieldDiameterUomID:
		m.ResetDiameterUomID()
		return nil
	case product.FieldProductDiameter:
		m.ResetProductDiameter()
		return nil
	case product.FieldProductRating:
		m.ResetProductRating()
		return nil
	case product.FieldReturnable:
		m.ResetReturnable()
		return nil
	case product.FieldTaxable:
		m.ResetTaxable()
		return nil
	case product.FieldChargeShipping:
		m.ResetChargeShipping()
		return nil
	case product.FieldAutoCreateKeywords:
		m.ResetAutoCreateKeywords()
		return nil
	case product.FieldIncludeInPromotions:
		m.ResetIncludeInPromotions()
		return nil
	case product.FieldIsVirtual:
		m.ResetIsVirtual()
		return nil
	case product.FieldIsVariant:
		m.ResetIsVariant()
		return nil
	case product.FieldOriginGeoID:
		m.ResetOriginGeoID()
		return nil
	case product.FieldBillOfMaterialLevel:
		m.ResetBillOfMaterialLevel()
		return nil
	case product.FieldReservMaxPersons:
		m.ResetReservMaxPersons()
		return nil
	case product.FieldReserv2NdPpPerc:
		m.ResetReserv2NdPpPerc()
		return nil
	case product.FieldReservNthPpPerc:
		m.ResetReservNthPpPerc()
		return nil
	case product.FieldConfigID:
		m.ResetConfigID()
		return nil
	case product.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case product.FieldCreatedByUserLogin:
		m.ResetCreatedByUserLogin()
		return nil
	case product.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case product.FieldLastModifiedByUserLogin:
		m.ResetLastModifiedByUserLogin()
		return nil
	case product.FieldInShippingBox:
		m.ResetInShippingBox()
		return nil
	case product.FieldDefaultShipmentBoxTypeID:
		m.ResetDefaultShipmentBoxTypeID()
		return nil
	case product.FieldLotIDFilledIn:
		m.ResetLotIDFilledIn()
		return nil
	case product.FieldOrderDecimalQuantity:
		m.ResetOrderDecimalQuantity()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.product_type != nil {
		edges = append(edges, product.EdgeProductType)
	}
	if m.primary_product_category != nil {
		edges = append(edges, product.EdgePrimaryProductCategory)
	}
	if m.virtual_variant_method_enumeration != nil {
		edges = append(edges, product.EdgeVirtualVariantMethodEnumeration)
	}
	if m.rating_enumeration != nil {
		edges = append(edges, product.EdgeRatingEnumeration)
	}
	if m.requirement_method_enumeration != nil {
		edges = append(edges, product.EdgeRequirementMethodEnumeration)
	}
	if m.inventory_item_type != nil {
		edges = append(edges, product.EdgeInventoryItemType)
	}
	if m.order_items != nil {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.main_product_assocs != nil {
		edges = append(edges, product.EdgeMainProductAssocs)
	}
	if m.assoc_product_assocs != nil {
		edges = append(edges, product.EdgeAssocProductAssocs)
	}
	if m.product_prices != nil {
		edges = append(edges, product.EdgeProductPrices)
	}
	if m.product_reviews != nil {
		edges = append(edges, product.EdgeProductReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeProductType:
		if id := m.product_type; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgePrimaryProductCategory:
		if id := m.primary_product_category; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeVirtualVariantMethodEnumeration:
		if id := m.virtual_variant_method_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeRatingEnumeration:
		if id := m.rating_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeRequirementMethodEnumeration:
		if id := m.requirement_method_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeInventoryItemType:
		if id := m.inventory_item_type; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMainProductAssocs:
		ids := make([]ent.Value, 0, len(m.main_product_assocs))
		for id := range m.main_product_assocs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAssocProductAssocs:
		ids := make([]ent.Value, 0, len(m.assoc_product_assocs))
		for id := range m.assoc_product_assocs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductReviews:
		ids := make([]ent.Value, 0, len(m.product_reviews))
		for id := range m.product_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedorder_items != nil {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.removedmain_product_assocs != nil {
		edges = append(edges, product.EdgeMainProductAssocs)
	}
	if m.removedassoc_product_assocs != nil {
		edges = append(edges, product.EdgeAssocProductAssocs)
	}
	if m.removedproduct_prices != nil {
		edges = append(edges, product.EdgeProductPrices)
	}
	if m.removedproduct_reviews != nil {
		edges = append(edges, product.EdgeProductReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeMainProductAssocs:
		ids := make([]ent.Value, 0, len(m.removedmain_product_assocs))
		for id := range m.removedmain_product_assocs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeAssocProductAssocs:
		ids := make([]ent.Value, 0, len(m.removedassoc_product_assocs))
		for id := range m.removedassoc_product_assocs {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductReviews:
		ids := make([]ent.Value, 0, len(m.removedproduct_reviews))
		for id := range m.removedproduct_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedproduct_type {
		edges = append(edges, product.EdgeProductType)
	}
	if m.clearedprimary_product_category {
		edges = append(edges, product.EdgePrimaryProductCategory)
	}
	if m.clearedvirtual_variant_method_enumeration {
		edges = append(edges, product.EdgeVirtualVariantMethodEnumeration)
	}
	if m.clearedrating_enumeration {
		edges = append(edges, product.EdgeRatingEnumeration)
	}
	if m.clearedrequirement_method_enumeration {
		edges = append(edges, product.EdgeRequirementMethodEnumeration)
	}
	if m.clearedinventory_item_type {
		edges = append(edges, product.EdgeInventoryItemType)
	}
	if m.clearedorder_items {
		edges = append(edges, product.EdgeOrderItems)
	}
	if m.clearedmain_product_assocs {
		edges = append(edges, product.EdgeMainProductAssocs)
	}
	if m.clearedassoc_product_assocs {
		edges = append(edges, product.EdgeAssocProductAssocs)
	}
	if m.clearedproduct_prices {
		edges = append(edges, product.EdgeProductPrices)
	}
	if m.clearedproduct_reviews {
		edges = append(edges, product.EdgeProductReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeProductType:
		return m.clearedproduct_type
	case product.EdgePrimaryProductCategory:
		return m.clearedprimary_product_category
	case product.EdgeVirtualVariantMethodEnumeration:
		return m.clearedvirtual_variant_method_enumeration
	case product.EdgeRatingEnumeration:
		return m.clearedrating_enumeration
	case product.EdgeRequirementMethodEnumeration:
		return m.clearedrequirement_method_enumeration
	case product.EdgeInventoryItemType:
		return m.clearedinventory_item_type
	case product.EdgeOrderItems:
		return m.clearedorder_items
	case product.EdgeMainProductAssocs:
		return m.clearedmain_product_assocs
	case product.EdgeAssocProductAssocs:
		return m.clearedassoc_product_assocs
	case product.EdgeProductPrices:
		return m.clearedproduct_prices
	case product.EdgeProductReviews:
		return m.clearedproduct_reviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeProductType:
		m.ClearProductType()
		return nil
	case product.EdgePrimaryProductCategory:
		m.ClearPrimaryProductCategory()
		return nil
	case product.EdgeVirtualVariantMethodEnumeration:
		m.ClearVirtualVariantMethodEnumeration()
		return nil
	case product.EdgeRatingEnumeration:
		m.ClearRatingEnumeration()
		return nil
	case product.EdgeRequirementMethodEnumeration:
		m.ClearRequirementMethodEnumeration()
		return nil
	case product.EdgeInventoryItemType:
		m.ClearInventoryItemType()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeProductType:
		m.ResetProductType()
		return nil
	case product.EdgePrimaryProductCategory:
		m.ResetPrimaryProductCategory()
		return nil
	case product.EdgeVirtualVariantMethodEnumeration:
		m.ResetVirtualVariantMethodEnumeration()
		return nil
	case product.EdgeRatingEnumeration:
		m.ResetRatingEnumeration()
		return nil
	case product.EdgeRequirementMethodEnumeration:
		m.ResetRequirementMethodEnumeration()
		return nil
	case product.EdgeInventoryItemType:
		m.ResetInventoryItemType()
		return nil
	case product.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case product.EdgeMainProductAssocs:
		m.ResetMainProductAssocs()
		return nil
	case product.EdgeAssocProductAssocs:
		m.ResetAssocProductAssocs()
		return nil
	case product.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	case product.EdgeProductReviews:
		m.ResetProductReviews()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductAssocMutation represents an operation that mutates the ProductAssoc nodes in the graph.
type ProductAssocMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	create_time               *time.Time
	update_time               *time.Time
	string_ref                *string
	from_date                 *time.Time
	thru_date                 *time.Time
	sequence_num              *int
	addsequence_num           *int
	reason                    *string
	quantity                  *float64
	addquantity               *float64
	scrap_factor              *float64
	addscrap_factor           *float64
	instruction               *string
	routing_work_effort_id    *int
	addrouting_work_effort_id *int
	recurrence_info_id        *int
	addrecurrence_info_id     *int
	clearedFields             map[string]struct{}
	product_assoc_type        *int
	clearedproduct_assoc_type bool
	main_product              *int
	clearedmain_product       bool
	assoc_product             *int
	clearedassoc_product      bool
	custom_method             *int
	clearedcustom_method      bool
	done                      bool
	oldValue                  func(context.Context) (*ProductAssoc, error)
	predicates                []predicate.ProductAssoc
}

var _ ent.Mutation = (*ProductAssocMutation)(nil)

// productassocOption allows management of the mutation configuration using functional options.
type productassocOption func(*ProductAssocMutation)

// newProductAssocMutation creates new mutation for the ProductAssoc entity.
func newProductAssocMutation(c config, op Op, opts ...productassocOption) *ProductAssocMutation {
	m := &ProductAssocMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAssoc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAssocID sets the ID field of the mutation.
func withProductAssocID(id int) productassocOption {
	return func(m *ProductAssocMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAssoc
		)
		m.oldValue = func(ctx context.Context) (*ProductAssoc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAssoc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAssoc sets the old ProductAssoc of the mutation.
func withProductAssoc(node *ProductAssoc) productassocOption {
	return func(m *ProductAssocMutation) {
		m.oldValue = func(context.Context) (*ProductAssoc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAssocMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAssocMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAssocMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductAssocMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductAssocMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductAssocMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductAssocMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductAssocMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductAssocMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductAssocMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductAssocMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductAssocMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productassoc.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductAssocMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductAssocMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productassoc.FieldStringRef)
}

// SetFromDate sets the "from_date" field.
func (m *ProductAssocMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *ProductAssocMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *ProductAssocMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *ProductAssocMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *ProductAssocMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *ProductAssocMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[productassoc.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *ProductAssocMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *ProductAssocMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, productassoc.FieldThruDate)
}

// SetSequenceNum sets the "sequence_num" field.
func (m *ProductAssocMutation) SetSequenceNum(i int) {
	m.sequence_num = &i
	m.addsequence_num = nil
}

// SequenceNum returns the value of the "sequence_num" field in the mutation.
func (m *ProductAssocMutation) SequenceNum() (r int, exists bool) {
	v := m.sequence_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNum returns the old "sequence_num" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldSequenceNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNum: %w", err)
	}
	return oldValue.SequenceNum, nil
}

// AddSequenceNum adds i to the "sequence_num" field.
func (m *ProductAssocMutation) AddSequenceNum(i int) {
	if m.addsequence_num != nil {
		*m.addsequence_num += i
	} else {
		m.addsequence_num = &i
	}
}

// AddedSequenceNum returns the value that was added to the "sequence_num" field in this mutation.
func (m *ProductAssocMutation) AddedSequenceNum() (r int, exists bool) {
	v := m.addsequence_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNum clears the value of the "sequence_num" field.
func (m *ProductAssocMutation) ClearSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	m.clearedFields[productassoc.FieldSequenceNum] = struct{}{}
}

// SequenceNumCleared returns if the "sequence_num" field was cleared in this mutation.
func (m *ProductAssocMutation) SequenceNumCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldSequenceNum]
	return ok
}

// ResetSequenceNum resets all changes to the "sequence_num" field.
func (m *ProductAssocMutation) ResetSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	delete(m.clearedFields, productassoc.FieldSequenceNum)
}

// SetReason sets the "reason" field.
func (m *ProductAssocMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ProductAssocMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *ProductAssocMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[productassoc.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *ProductAssocMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *ProductAssocMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, productassoc.FieldReason)
}

// SetQuantity sets the "quantity" field.
func (m *ProductAssocMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ProductAssocMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ProductAssocMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ProductAssocMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *ProductAssocMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[productassoc.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *ProductAssocMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ProductAssocMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, productassoc.FieldQuantity)
}

// SetScrapFactor sets the "scrap_factor" field.
func (m *ProductAssocMutation) SetScrapFactor(f float64) {
	m.scrap_factor = &f
	m.addscrap_factor = nil
}

// ScrapFactor returns the value of the "scrap_factor" field in the mutation.
func (m *ProductAssocMutation) ScrapFactor() (r float64, exists bool) {
	v := m.scrap_factor
	if v == nil {
		return
	}
	return *v, true
}

// OldScrapFactor returns the old "scrap_factor" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldScrapFactor(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScrapFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScrapFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScrapFactor: %w", err)
	}
	return oldValue.ScrapFactor, nil
}

// AddScrapFactor adds f to the "scrap_factor" field.
func (m *ProductAssocMutation) AddScrapFactor(f float64) {
	if m.addscrap_factor != nil {
		*m.addscrap_factor += f
	} else {
		m.addscrap_factor = &f
	}
}

// AddedScrapFactor returns the value that was added to the "scrap_factor" field in this mutation.
func (m *ProductAssocMutation) AddedScrapFactor() (r float64, exists bool) {
	v := m.addscrap_factor
	if v == nil {
		return
	}
	return *v, true
}

// ClearScrapFactor clears the value of the "scrap_factor" field.
func (m *ProductAssocMutation) ClearScrapFactor() {
	m.scrap_factor = nil
	m.addscrap_factor = nil
	m.clearedFields[productassoc.FieldScrapFactor] = struct{}{}
}

// ScrapFactorCleared returns if the "scrap_factor" field was cleared in this mutation.
func (m *ProductAssocMutation) ScrapFactorCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldScrapFactor]
	return ok
}

// ResetScrapFactor resets all changes to the "scrap_factor" field.
func (m *ProductAssocMutation) ResetScrapFactor() {
	m.scrap_factor = nil
	m.addscrap_factor = nil
	delete(m.clearedFields, productassoc.FieldScrapFactor)
}

// SetInstruction sets the "instruction" field.
func (m *ProductAssocMutation) SetInstruction(s string) {
	m.instruction = &s
}

// Instruction returns the value of the "instruction" field in the mutation.
func (m *ProductAssocMutation) Instruction() (r string, exists bool) {
	v := m.instruction
	if v == nil {
		return
	}
	return *v, true
}

// OldInstruction returns the old "instruction" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldInstruction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstruction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstruction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstruction: %w", err)
	}
	return oldValue.Instruction, nil
}

// ClearInstruction clears the value of the "instruction" field.
func (m *ProductAssocMutation) ClearInstruction() {
	m.instruction = nil
	m.clearedFields[productassoc.FieldInstruction] = struct{}{}
}

// InstructionCleared returns if the "instruction" field was cleared in this mutation.
func (m *ProductAssocMutation) InstructionCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldInstruction]
	return ok
}

// ResetInstruction resets all changes to the "instruction" field.
func (m *ProductAssocMutation) ResetInstruction() {
	m.instruction = nil
	delete(m.clearedFields, productassoc.FieldInstruction)
}

// SetRoutingWorkEffortID sets the "routing_work_effort_id" field.
func (m *ProductAssocMutation) SetRoutingWorkEffortID(i int) {
	m.routing_work_effort_id = &i
	m.addrouting_work_effort_id = nil
}

// RoutingWorkEffortID returns the value of the "routing_work_effort_id" field in the mutation.
func (m *ProductAssocMutation) RoutingWorkEffortID() (r int, exists bool) {
	v := m.routing_work_effort_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoutingWorkEffortID returns the old "routing_work_effort_id" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldRoutingWorkEffortID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoutingWorkEffortID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoutingWorkEffortID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoutingWorkEffortID: %w", err)
	}
	return oldValue.RoutingWorkEffortID, nil
}

// AddRoutingWorkEffortID adds i to the "routing_work_effort_id" field.
func (m *ProductAssocMutation) AddRoutingWorkEffortID(i int) {
	if m.addrouting_work_effort_id != nil {
		*m.addrouting_work_effort_id += i
	} else {
		m.addrouting_work_effort_id = &i
	}
}

// AddedRoutingWorkEffortID returns the value that was added to the "routing_work_effort_id" field in this mutation.
func (m *ProductAssocMutation) AddedRoutingWorkEffortID() (r int, exists bool) {
	v := m.addrouting_work_effort_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoutingWorkEffortID clears the value of the "routing_work_effort_id" field.
func (m *ProductAssocMutation) ClearRoutingWorkEffortID() {
	m.routing_work_effort_id = nil
	m.addrouting_work_effort_id = nil
	m.clearedFields[productassoc.FieldRoutingWorkEffortID] = struct{}{}
}

// RoutingWorkEffortIDCleared returns if the "routing_work_effort_id" field was cleared in this mutation.
func (m *ProductAssocMutation) RoutingWorkEffortIDCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldRoutingWorkEffortID]
	return ok
}

// ResetRoutingWorkEffortID resets all changes to the "routing_work_effort_id" field.
func (m *ProductAssocMutation) ResetRoutingWorkEffortID() {
	m.routing_work_effort_id = nil
	m.addrouting_work_effort_id = nil
	delete(m.clearedFields, productassoc.FieldRoutingWorkEffortID)
}

// SetRecurrenceInfoID sets the "recurrence_info_id" field.
func (m *ProductAssocMutation) SetRecurrenceInfoID(i int) {
	m.recurrence_info_id = &i
	m.addrecurrence_info_id = nil
}

// RecurrenceInfoID returns the value of the "recurrence_info_id" field in the mutation.
func (m *ProductAssocMutation) RecurrenceInfoID() (r int, exists bool) {
	v := m.recurrence_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceInfoID returns the old "recurrence_info_id" field's value of the ProductAssoc entity.
// If the ProductAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocMutation) OldRecurrenceInfoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecurrenceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecurrenceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceInfoID: %w", err)
	}
	return oldValue.RecurrenceInfoID, nil
}

// AddRecurrenceInfoID adds i to the "recurrence_info_id" field.
func (m *ProductAssocMutation) AddRecurrenceInfoID(i int) {
	if m.addrecurrence_info_id != nil {
		*m.addrecurrence_info_id += i
	} else {
		m.addrecurrence_info_id = &i
	}
}

// AddedRecurrenceInfoID returns the value that was added to the "recurrence_info_id" field in this mutation.
func (m *ProductAssocMutation) AddedRecurrenceInfoID() (r int, exists bool) {
	v := m.addrecurrence_info_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecurrenceInfoID clears the value of the "recurrence_info_id" field.
func (m *ProductAssocMutation) ClearRecurrenceInfoID() {
	m.recurrence_info_id = nil
	m.addrecurrence_info_id = nil
	m.clearedFields[productassoc.FieldRecurrenceInfoID] = struct{}{}
}

// RecurrenceInfoIDCleared returns if the "recurrence_info_id" field was cleared in this mutation.
func (m *ProductAssocMutation) RecurrenceInfoIDCleared() bool {
	_, ok := m.clearedFields[productassoc.FieldRecurrenceInfoID]
	return ok
}

// ResetRecurrenceInfoID resets all changes to the "recurrence_info_id" field.
func (m *ProductAssocMutation) ResetRecurrenceInfoID() {
	m.recurrence_info_id = nil
	m.addrecurrence_info_id = nil
	delete(m.clearedFields, productassoc.FieldRecurrenceInfoID)
}

// SetProductAssocTypeID sets the "product_assoc_type" edge to the ProductAssocType entity by id.
func (m *ProductAssocMutation) SetProductAssocTypeID(id int) {
	m.product_assoc_type = &id
}

// ClearProductAssocType clears the "product_assoc_type" edge to the ProductAssocType entity.
func (m *ProductAssocMutation) ClearProductAssocType() {
	m.clearedproduct_assoc_type = true
}

// ProductAssocTypeCleared reports if the "product_assoc_type" edge to the ProductAssocType entity was cleared.
func (m *ProductAssocMutation) ProductAssocTypeCleared() bool {
	return m.clearedproduct_assoc_type
}

// ProductAssocTypeID returns the "product_assoc_type" edge ID in the mutation.
func (m *ProductAssocMutation) ProductAssocTypeID() (id int, exists bool) {
	if m.product_assoc_type != nil {
		return *m.product_assoc_type, true
	}
	return
}

// ProductAssocTypeIDs returns the "product_assoc_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductAssocTypeID instead. It exists only for internal usage by the builders.
func (m *ProductAssocMutation) ProductAssocTypeIDs() (ids []int) {
	if id := m.product_assoc_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductAssocType resets all changes to the "product_assoc_type" edge.
func (m *ProductAssocMutation) ResetProductAssocType() {
	m.product_assoc_type = nil
	m.clearedproduct_assoc_type = false
}

// SetMainProductID sets the "main_product" edge to the Product entity by id.
func (m *ProductAssocMutation) SetMainProductID(id int) {
	m.main_product = &id
}

// ClearMainProduct clears the "main_product" edge to the Product entity.
func (m *ProductAssocMutation) ClearMainProduct() {
	m.clearedmain_product = true
}

// MainProductCleared reports if the "main_product" edge to the Product entity was cleared.
func (m *ProductAssocMutation) MainProductCleared() bool {
	return m.clearedmain_product
}

// MainProductID returns the "main_product" edge ID in the mutation.
func (m *ProductAssocMutation) MainProductID() (id int, exists bool) {
	if m.main_product != nil {
		return *m.main_product, true
	}
	return
}

// MainProductIDs returns the "main_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MainProductID instead. It exists only for internal usage by the builders.
func (m *ProductAssocMutation) MainProductIDs() (ids []int) {
	if id := m.main_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMainProduct resets all changes to the "main_product" edge.
func (m *ProductAssocMutation) ResetMainProduct() {
	m.main_product = nil
	m.clearedmain_product = false
}

// SetAssocProductID sets the "assoc_product" edge to the Product entity by id.
func (m *ProductAssocMutation) SetAssocProductID(id int) {
	m.assoc_product = &id
}

// ClearAssocProduct clears the "assoc_product" edge to the Product entity.
func (m *ProductAssocMutation) ClearAssocProduct() {
	m.clearedassoc_product = true
}

// AssocProductCleared reports if the "assoc_product" edge to the Product entity was cleared.
func (m *ProductAssocMutation) AssocProductCleared() bool {
	return m.clearedassoc_product
}

// AssocProductID returns the "assoc_product" edge ID in the mutation.
func (m *ProductAssocMutation) AssocProductID() (id int, exists bool) {
	if m.assoc_product != nil {
		return *m.assoc_product, true
	}
	return
}

// AssocProductIDs returns the "assoc_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssocProductID instead. It exists only for internal usage by the builders.
func (m *ProductAssocMutation) AssocProductIDs() (ids []int) {
	if id := m.assoc_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssocProduct resets all changes to the "assoc_product" edge.
func (m *ProductAssocMutation) ResetAssocProduct() {
	m.assoc_product = nil
	m.clearedassoc_product = false
}

// SetCustomMethodID sets the "custom_method" edge to the CustomMethod entity by id.
func (m *ProductAssocMutation) SetCustomMethodID(id int) {
	m.custom_method = &id
}

// ClearCustomMethod clears the "custom_method" edge to the CustomMethod entity.
func (m *ProductAssocMutation) ClearCustomMethod() {
	m.clearedcustom_method = true
}

// CustomMethodCleared reports if the "custom_method" edge to the CustomMethod entity was cleared.
func (m *ProductAssocMutation) CustomMethodCleared() bool {
	return m.clearedcustom_method
}

// CustomMethodID returns the "custom_method" edge ID in the mutation.
func (m *ProductAssocMutation) CustomMethodID() (id int, exists bool) {
	if m.custom_method != nil {
		return *m.custom_method, true
	}
	return
}

// CustomMethodIDs returns the "custom_method" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomMethodID instead. It exists only for internal usage by the builders.
func (m *ProductAssocMutation) CustomMethodIDs() (ids []int) {
	if id := m.custom_method; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomMethod resets all changes to the "custom_method" edge.
func (m *ProductAssocMutation) ResetCustomMethod() {
	m.custom_method = nil
	m.clearedcustom_method = false
}

// Op returns the operation name.
func (m *ProductAssocMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductAssoc).
func (m *ProductAssocMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAssocMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, productassoc.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productassoc.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productassoc.FieldStringRef)
	}
	if m.from_date != nil {
		fields = append(fields, productassoc.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, productassoc.FieldThruDate)
	}
	if m.sequence_num != nil {
		fields = append(fields, productassoc.FieldSequenceNum)
	}
	if m.reason != nil {
		fields = append(fields, productassoc.FieldReason)
	}
	if m.quantity != nil {
		fields = append(fields, productassoc.FieldQuantity)
	}
	if m.scrap_factor != nil {
		fields = append(fields, productassoc.FieldScrapFactor)
	}
	if m.instruction != nil {
		fields = append(fields, productassoc.FieldInstruction)
	}
	if m.routing_work_effort_id != nil {
		fields = append(fields, productassoc.FieldRoutingWorkEffortID)
	}
	if m.recurrence_info_id != nil {
		fields = append(fields, productassoc.FieldRecurrenceInfoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAssocMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productassoc.FieldCreateTime:
		return m.CreateTime()
	case productassoc.FieldUpdateTime:
		return m.UpdateTime()
	case productassoc.FieldStringRef:
		return m.StringRef()
	case productassoc.FieldFromDate:
		return m.FromDate()
	case productassoc.FieldThruDate:
		return m.ThruDate()
	case productassoc.FieldSequenceNum:
		return m.SequenceNum()
	case productassoc.FieldReason:
		return m.Reason()
	case productassoc.FieldQuantity:
		return m.Quantity()
	case productassoc.FieldScrapFactor:
		return m.ScrapFactor()
	case productassoc.FieldInstruction:
		return m.Instruction()
	case productassoc.FieldRoutingWorkEffortID:
		return m.RoutingWorkEffortID()
	case productassoc.FieldRecurrenceInfoID:
		return m.RecurrenceInfoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAssocMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productassoc.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productassoc.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productassoc.FieldStringRef:
		return m.OldStringRef(ctx)
	case productassoc.FieldFromDate:
		return m.OldFromDate(ctx)
	case productassoc.FieldThruDate:
		return m.OldThruDate(ctx)
	case productassoc.FieldSequenceNum:
		return m.OldSequenceNum(ctx)
	case productassoc.FieldReason:
		return m.OldReason(ctx)
	case productassoc.FieldQuantity:
		return m.OldQuantity(ctx)
	case productassoc.FieldScrapFactor:
		return m.OldScrapFactor(ctx)
	case productassoc.FieldInstruction:
		return m.OldInstruction(ctx)
	case productassoc.FieldRoutingWorkEffortID:
		return m.OldRoutingWorkEffortID(ctx)
	case productassoc.FieldRecurrenceInfoID:
		return m.OldRecurrenceInfoID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAssoc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAssocMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productassoc.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productassoc.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productassoc.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productassoc.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case productassoc.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	case productassoc.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNum(v)
		return nil
	case productassoc.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case productassoc.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case productassoc.FieldScrapFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScrapFactor(v)
		return nil
	case productassoc.FieldInstruction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstruction(v)
		return nil
	case productassoc.FieldRoutingWorkEffortID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoutingWorkEffortID(v)
		return nil
	case productassoc.FieldRecurrenceInfoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceInfoID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAssoc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAssocMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_num != nil {
		fields = append(fields, productassoc.FieldSequenceNum)
	}
	if m.addquantity != nil {
		fields = append(fields, productassoc.FieldQuantity)
	}
	if m.addscrap_factor != nil {
		fields = append(fields, productassoc.FieldScrapFactor)
	}
	if m.addrouting_work_effort_id != nil {
		fields = append(fields, productassoc.FieldRoutingWorkEffortID)
	}
	if m.addrecurrence_info_id != nil {
		fields = append(fields, productassoc.FieldRecurrenceInfoID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAssocMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productassoc.FieldSequenceNum:
		return m.AddedSequenceNum()
	case productassoc.FieldQuantity:
		return m.AddedQuantity()
	case productassoc.FieldScrapFactor:
		return m.AddedScrapFactor()
	case productassoc.FieldRoutingWorkEffortID:
		return m.AddedRoutingWorkEffortID()
	case productassoc.FieldRecurrenceInfoID:
		return m.AddedRecurrenceInfoID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAssocMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productassoc.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNum(v)
		return nil
	case productassoc.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case productassoc.FieldScrapFactor:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScrapFactor(v)
		return nil
	case productassoc.FieldRoutingWorkEffortID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoutingWorkEffortID(v)
		return nil
	case productassoc.FieldRecurrenceInfoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecurrenceInfoID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAssoc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAssocMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productassoc.FieldStringRef) {
		fields = append(fields, productassoc.FieldStringRef)
	}
	if m.FieldCleared(productassoc.FieldThruDate) {
		fields = append(fields, productassoc.FieldThruDate)
	}
	if m.FieldCleared(productassoc.FieldSequenceNum) {
		fields = append(fields, productassoc.FieldSequenceNum)
	}
	if m.FieldCleared(productassoc.FieldReason) {
		fields = append(fields, productassoc.FieldReason)
	}
	if m.FieldCleared(productassoc.FieldQuantity) {
		fields = append(fields, productassoc.FieldQuantity)
	}
	if m.FieldCleared(productassoc.FieldScrapFactor) {
		fields = append(fields, productassoc.FieldScrapFactor)
	}
	if m.FieldCleared(productassoc.FieldInstruction) {
		fields = append(fields, productassoc.FieldInstruction)
	}
	if m.FieldCleared(productassoc.FieldRoutingWorkEffortID) {
		fields = append(fields, productassoc.FieldRoutingWorkEffortID)
	}
	if m.FieldCleared(productassoc.FieldRecurrenceInfoID) {
		fields = append(fields, productassoc.FieldRecurrenceInfoID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAssocMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAssocMutation) ClearField(name string) error {
	switch name {
	case productassoc.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productassoc.FieldThruDate:
		m.ClearThruDate()
		return nil
	case productassoc.FieldSequenceNum:
		m.ClearSequenceNum()
		return nil
	case productassoc.FieldReason:
		m.ClearReason()
		return nil
	case productassoc.FieldQuantity:
		m.ClearQuantity()
		return nil
	case productassoc.FieldScrapFactor:
		m.ClearScrapFactor()
		return nil
	case productassoc.FieldInstruction:
		m.ClearInstruction()
		return nil
	case productassoc.FieldRoutingWorkEffortID:
		m.ClearRoutingWorkEffortID()
		return nil
	case productassoc.FieldRecurrenceInfoID:
		m.ClearRecurrenceInfoID()
		return nil
	}
	return fmt.Errorf("unknown ProductAssoc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAssocMutation) ResetField(name string) error {
	switch name {
	case productassoc.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productassoc.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productassoc.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productassoc.FieldFromDate:
		m.ResetFromDate()
		return nil
	case productassoc.FieldThruDate:
		m.ResetThruDate()
		return nil
	case productassoc.FieldSequenceNum:
		m.ResetSequenceNum()
		return nil
	case productassoc.FieldReason:
		m.ResetReason()
		return nil
	case productassoc.FieldQuantity:
		m.ResetQuantity()
		return nil
	case productassoc.FieldScrapFactor:
		m.ResetScrapFactor()
		return nil
	case productassoc.FieldInstruction:
		m.ResetInstruction()
		return nil
	case productassoc.FieldRoutingWorkEffortID:
		m.ResetRoutingWorkEffortID()
		return nil
	case productassoc.FieldRecurrenceInfoID:
		m.ResetRecurrenceInfoID()
		return nil
	}
	return fmt.Errorf("unknown ProductAssoc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAssocMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.product_assoc_type != nil {
		edges = append(edges, productassoc.EdgeProductAssocType)
	}
	if m.main_product != nil {
		edges = append(edges, productassoc.EdgeMainProduct)
	}
	if m.assoc_product != nil {
		edges = append(edges, productassoc.EdgeAssocProduct)
	}
	if m.custom_method != nil {
		edges = append(edges, productassoc.EdgeCustomMethod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAssocMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productassoc.EdgeProductAssocType:
		if id := m.product_assoc_type; id != nil {
			return []ent.Value{*id}
		}
	case productassoc.EdgeMainProduct:
		if id := m.main_product; id != nil {
			return []ent.Value{*id}
		}
	case productassoc.EdgeAssocProduct:
		if id := m.assoc_product; id != nil {
			return []ent.Value{*id}
		}
	case productassoc.EdgeCustomMethod:
		if id := m.custom_method; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAssocMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAssocMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAssocMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproduct_assoc_type {
		edges = append(edges, productassoc.EdgeProductAssocType)
	}
	if m.clearedmain_product {
		edges = append(edges, productassoc.EdgeMainProduct)
	}
	if m.clearedassoc_product {
		edges = append(edges, productassoc.EdgeAssocProduct)
	}
	if m.clearedcustom_method {
		edges = append(edges, productassoc.EdgeCustomMethod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAssocMutation) EdgeCleared(name string) bool {
	switch name {
	case productassoc.EdgeProductAssocType:
		return m.clearedproduct_assoc_type
	case productassoc.EdgeMainProduct:
		return m.clearedmain_product
	case productassoc.EdgeAssocProduct:
		return m.clearedassoc_product
	case productassoc.EdgeCustomMethod:
		return m.clearedcustom_method
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAssocMutation) ClearEdge(name string) error {
	switch name {
	case productassoc.EdgeProductAssocType:
		m.ClearProductAssocType()
		return nil
	case productassoc.EdgeMainProduct:
		m.ClearMainProduct()
		return nil
	case productassoc.EdgeAssocProduct:
		m.ClearAssocProduct()
		return nil
	case productassoc.EdgeCustomMethod:
		m.ClearCustomMethod()
		return nil
	}
	return fmt.Errorf("unknown ProductAssoc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAssocMutation) ResetEdge(name string) error {
	switch name {
	case productassoc.EdgeProductAssocType:
		m.ResetProductAssocType()
		return nil
	case productassoc.EdgeMainProduct:
		m.ResetMainProduct()
		return nil
	case productassoc.EdgeAssocProduct:
		m.ResetAssocProduct()
		return nil
	case productassoc.EdgeCustomMethod:
		m.ResetCustomMethod()
		return nil
	}
	return fmt.Errorf("unknown ProductAssoc edge %s", name)
}

// ProductAssocTypeMutation represents an operation that mutates the ProductAssocType nodes in the graph.
type ProductAssocTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	create_time                      *time.Time
	update_time                      *time.Time
	string_ref                       *string
	has_table                        *productassoctype.HasTable
	description                      *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	children                         map[int]struct{}
	removedchildren                  map[int]struct{}
	clearedchildren                  bool
	product_assocs                   map[int]struct{}
	removedproduct_assocs            map[int]struct{}
	clearedproduct_assocs            bool
	child_product_assoc_types        map[int]struct{}
	removedchild_product_assoc_types map[int]struct{}
	clearedchild_product_assoc_types bool
	done                             bool
	oldValue                         func(context.Context) (*ProductAssocType, error)
	predicates                       []predicate.ProductAssocType
}

var _ ent.Mutation = (*ProductAssocTypeMutation)(nil)

// productassoctypeOption allows management of the mutation configuration using functional options.
type productassoctypeOption func(*ProductAssocTypeMutation)

// newProductAssocTypeMutation creates new mutation for the ProductAssocType entity.
func newProductAssocTypeMutation(c config, op Op, opts ...productassoctypeOption) *ProductAssocTypeMutation {
	m := &ProductAssocTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductAssocType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductAssocTypeID sets the ID field of the mutation.
func withProductAssocTypeID(id int) productassoctypeOption {
	return func(m *ProductAssocTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductAssocType
		)
		m.oldValue = func(ctx context.Context) (*ProductAssocType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductAssocType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductAssocType sets the old ProductAssocType of the mutation.
func withProductAssocType(node *ProductAssocType) productassoctypeOption {
	return func(m *ProductAssocTypeMutation) {
		m.oldValue = func(context.Context) (*ProductAssocType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductAssocTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductAssocTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductAssocTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductAssocTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductAssocTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductAssocType entity.
// If the ProductAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductAssocTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductAssocTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductAssocTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductAssocType entity.
// If the ProductAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductAssocTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductAssocTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductAssocTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductAssocType entity.
// If the ProductAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductAssocTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productassoctype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductAssocTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productassoctype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductAssocTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productassoctype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductAssocTypeMutation) SetHasTable(pt productassoctype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductAssocTypeMutation) HasTable() (r productassoctype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductAssocType entity.
// If the ProductAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocTypeMutation) OldHasTable(ctx context.Context) (v productassoctype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductAssocTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productassoctype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductAssocTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productassoctype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductAssocTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productassoctype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductAssocTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductAssocTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductAssocType entity.
// If the ProductAssocType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductAssocTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductAssocTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productassoctype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductAssocTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productassoctype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductAssocTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productassoctype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductAssocType entity by id.
func (m *ProductAssocTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductAssocType entity.
func (m *ProductAssocTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductAssocType entity was cleared.
func (m *ProductAssocTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductAssocTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductAssocTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductAssocTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductAssocType entity by ids.
func (m *ProductAssocTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductAssocType entity.
func (m *ProductAssocTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductAssocType entity was cleared.
func (m *ProductAssocTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductAssocType entity by IDs.
func (m *ProductAssocTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductAssocType entity.
func (m *ProductAssocTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductAssocTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductAssocTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductAssocIDs adds the "product_assocs" edge to the ProductAssoc entity by ids.
func (m *ProductAssocTypeMutation) AddProductAssocIDs(ids ...int) {
	if m.product_assocs == nil {
		m.product_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.product_assocs[ids[i]] = struct{}{}
	}
}

// ClearProductAssocs clears the "product_assocs" edge to the ProductAssoc entity.
func (m *ProductAssocTypeMutation) ClearProductAssocs() {
	m.clearedproduct_assocs = true
}

// ProductAssocsCleared reports if the "product_assocs" edge to the ProductAssoc entity was cleared.
func (m *ProductAssocTypeMutation) ProductAssocsCleared() bool {
	return m.clearedproduct_assocs
}

// RemoveProductAssocIDs removes the "product_assocs" edge to the ProductAssoc entity by IDs.
func (m *ProductAssocTypeMutation) RemoveProductAssocIDs(ids ...int) {
	if m.removedproduct_assocs == nil {
		m.removedproduct_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_assocs[ids[i]] = struct{}{}
	}
}

// RemovedProductAssocs returns the removed IDs of the "product_assocs" edge to the ProductAssoc entity.
func (m *ProductAssocTypeMutation) RemovedProductAssocsIDs() (ids []int) {
	for id := range m.removedproduct_assocs {
		ids = append(ids, id)
	}
	return
}

// ProductAssocsIDs returns the "product_assocs" edge IDs in the mutation.
func (m *ProductAssocTypeMutation) ProductAssocsIDs() (ids []int) {
	for id := range m.product_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetProductAssocs resets all changes to the "product_assocs" edge.
func (m *ProductAssocTypeMutation) ResetProductAssocs() {
	m.product_assocs = nil
	m.clearedproduct_assocs = false
	m.removedproduct_assocs = nil
}

// AddChildProductAssocTypeIDs adds the "child_product_assoc_types" edge to the ProductAssocType entity by ids.
func (m *ProductAssocTypeMutation) AddChildProductAssocTypeIDs(ids ...int) {
	if m.child_product_assoc_types == nil {
		m.child_product_assoc_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_assoc_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductAssocTypes clears the "child_product_assoc_types" edge to the ProductAssocType entity.
func (m *ProductAssocTypeMutation) ClearChildProductAssocTypes() {
	m.clearedchild_product_assoc_types = true
}

// ChildProductAssocTypesCleared reports if the "child_product_assoc_types" edge to the ProductAssocType entity was cleared.
func (m *ProductAssocTypeMutation) ChildProductAssocTypesCleared() bool {
	return m.clearedchild_product_assoc_types
}

// RemoveChildProductAssocTypeIDs removes the "child_product_assoc_types" edge to the ProductAssocType entity by IDs.
func (m *ProductAssocTypeMutation) RemoveChildProductAssocTypeIDs(ids ...int) {
	if m.removedchild_product_assoc_types == nil {
		m.removedchild_product_assoc_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_assoc_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductAssocTypes returns the removed IDs of the "child_product_assoc_types" edge to the ProductAssocType entity.
func (m *ProductAssocTypeMutation) RemovedChildProductAssocTypesIDs() (ids []int) {
	for id := range m.removedchild_product_assoc_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductAssocTypesIDs returns the "child_product_assoc_types" edge IDs in the mutation.
func (m *ProductAssocTypeMutation) ChildProductAssocTypesIDs() (ids []int) {
	for id := range m.child_product_assoc_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductAssocTypes resets all changes to the "child_product_assoc_types" edge.
func (m *ProductAssocTypeMutation) ResetChildProductAssocTypes() {
	m.child_product_assoc_types = nil
	m.clearedchild_product_assoc_types = false
	m.removedchild_product_assoc_types = nil
}

// Op returns the operation name.
func (m *ProductAssocTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductAssocType).
func (m *ProductAssocTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductAssocTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productassoctype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productassoctype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productassoctype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productassoctype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productassoctype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductAssocTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productassoctype.FieldCreateTime:
		return m.CreateTime()
	case productassoctype.FieldUpdateTime:
		return m.UpdateTime()
	case productassoctype.FieldStringRef:
		return m.StringRef()
	case productassoctype.FieldHasTable:
		return m.HasTable()
	case productassoctype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductAssocTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productassoctype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productassoctype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productassoctype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productassoctype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productassoctype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductAssocType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAssocTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productassoctype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productassoctype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productassoctype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productassoctype.FieldHasTable:
		v, ok := value.(productassoctype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productassoctype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductAssocType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductAssocTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductAssocTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductAssocTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductAssocType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductAssocTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productassoctype.FieldStringRef) {
		fields = append(fields, productassoctype.FieldStringRef)
	}
	if m.FieldCleared(productassoctype.FieldHasTable) {
		fields = append(fields, productassoctype.FieldHasTable)
	}
	if m.FieldCleared(productassoctype.FieldDescription) {
		fields = append(fields, productassoctype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductAssocTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductAssocTypeMutation) ClearField(name string) error {
	switch name {
	case productassoctype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productassoctype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productassoctype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductAssocType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductAssocTypeMutation) ResetField(name string) error {
	switch name {
	case productassoctype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productassoctype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productassoctype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productassoctype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productassoctype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductAssocType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductAssocTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, productassoctype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productassoctype.EdgeChildren)
	}
	if m.product_assocs != nil {
		edges = append(edges, productassoctype.EdgeProductAssocs)
	}
	if m.child_product_assoc_types != nil {
		edges = append(edges, productassoctype.EdgeChildProductAssocTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductAssocTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productassoctype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productassoctype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productassoctype.EdgeProductAssocs:
		ids := make([]ent.Value, 0, len(m.product_assocs))
		for id := range m.product_assocs {
			ids = append(ids, id)
		}
		return ids
	case productassoctype.EdgeChildProductAssocTypes:
		ids := make([]ent.Value, 0, len(m.child_product_assoc_types))
		for id := range m.child_product_assoc_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductAssocTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, productassoctype.EdgeChildren)
	}
	if m.removedproduct_assocs != nil {
		edges = append(edges, productassoctype.EdgeProductAssocs)
	}
	if m.removedchild_product_assoc_types != nil {
		edges = append(edges, productassoctype.EdgeChildProductAssocTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductAssocTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productassoctype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productassoctype.EdgeProductAssocs:
		ids := make([]ent.Value, 0, len(m.removedproduct_assocs))
		for id := range m.removedproduct_assocs {
			ids = append(ids, id)
		}
		return ids
	case productassoctype.EdgeChildProductAssocTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_assoc_types))
		for id := range m.removedchild_product_assoc_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductAssocTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, productassoctype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productassoctype.EdgeChildren)
	}
	if m.clearedproduct_assocs {
		edges = append(edges, productassoctype.EdgeProductAssocs)
	}
	if m.clearedchild_product_assoc_types {
		edges = append(edges, productassoctype.EdgeChildProductAssocTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductAssocTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productassoctype.EdgeParent:
		return m.clearedparent
	case productassoctype.EdgeChildren:
		return m.clearedchildren
	case productassoctype.EdgeProductAssocs:
		return m.clearedproduct_assocs
	case productassoctype.EdgeChildProductAssocTypes:
		return m.clearedchild_product_assoc_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductAssocTypeMutation) ClearEdge(name string) error {
	switch name {
	case productassoctype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductAssocType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductAssocTypeMutation) ResetEdge(name string) error {
	switch name {
	case productassoctype.EdgeParent:
		m.ResetParent()
		return nil
	case productassoctype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productassoctype.EdgeProductAssocs:
		m.ResetProductAssocs()
		return nil
	case productassoctype.EdgeChildProductAssocTypes:
		m.ResetChildProductAssocTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductAssocType edge %s", name)
}

// ProductCategoryMutation represents an operation that mutates the ProductCategory nodes in the graph.
type ProductCategoryMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	create_time                             *time.Time
	update_time                             *time.Time
	string_ref                              *string
	category_name                           *string
	description                             *string
	long_description                        *string
	category_image_url                      *string
	link_one_image_url                      *string
	link_two_image_url                      *string
	detail_screen                           *string
	show_in_select                          *productcategory.ShowInSelect
	clearedFields                           map[string]struct{}
	product_category_type                   *int
	clearedproduct_category_type            bool
	parent                                  *int
	clearedparent                           bool
	children                                map[int]struct{}
	removedchildren                         map[int]struct{}
	clearedchildren                         bool
	primary_child_product_categories        map[int]struct{}
	removedprimary_child_product_categories map[int]struct{}
	clearedprimary_child_product_categories bool
	primary_products                        map[int]struct{}
	removedprimary_products                 map[int]struct{}
	clearedprimary_products                 bool
	done                                    bool
	oldValue                                func(context.Context) (*ProductCategory, error)
	predicates                              []predicate.ProductCategory
}

var _ ent.Mutation = (*ProductCategoryMutation)(nil)

// productcategoryOption allows management of the mutation configuration using functional options.
type productcategoryOption func(*ProductCategoryMutation)

// newProductCategoryMutation creates new mutation for the ProductCategory entity.
func newProductCategoryMutation(c config, op Op, opts ...productcategoryOption) *ProductCategoryMutation {
	m := &ProductCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryID sets the ID field of the mutation.
func withProductCategoryID(id int) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategory
		)
		m.oldValue = func(ctx context.Context) (*ProductCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategory sets the old ProductCategory of the mutation.
func withProductCategory(node *ProductCategory) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		m.oldValue = func(context.Context) (*ProductCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductCategoryMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductCategoryMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductCategoryMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productcategory.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductCategoryMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductCategoryMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productcategory.FieldStringRef)
}

// SetCategoryName sets the "category_name" field.
func (m *ProductCategoryMutation) SetCategoryName(s string) {
	m.category_name = &s
}

// CategoryName returns the value of the "category_name" field in the mutation.
func (m *ProductCategoryMutation) CategoryName() (r string, exists bool) {
	v := m.category_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryName returns the old "category_name" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryName: %w", err)
	}
	return oldValue.CategoryName, nil
}

// ClearCategoryName clears the value of the "category_name" field.
func (m *ProductCategoryMutation) ClearCategoryName() {
	m.category_name = nil
	m.clearedFields[productcategory.FieldCategoryName] = struct{}{}
}

// CategoryNameCleared returns if the "category_name" field was cleared in this mutation.
func (m *ProductCategoryMutation) CategoryNameCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldCategoryName]
	return ok
}

// ResetCategoryName resets all changes to the "category_name" field.
func (m *ProductCategoryMutation) ResetCategoryName() {
	m.category_name = nil
	delete(m.clearedFields, productcategory.FieldCategoryName)
}

// SetDescription sets the "description" field.
func (m *ProductCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productcategory.FieldDescription)
}

// SetLongDescription sets the "long_description" field.
func (m *ProductCategoryMutation) SetLongDescription(s string) {
	m.long_description = &s
}

// LongDescription returns the value of the "long_description" field in the mutation.
func (m *ProductCategoryMutation) LongDescription() (r string, exists bool) {
	v := m.long_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLongDescription returns the old "long_description" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldLongDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongDescription: %w", err)
	}
	return oldValue.LongDescription, nil
}

// ClearLongDescription clears the value of the "long_description" field.
func (m *ProductCategoryMutation) ClearLongDescription() {
	m.long_description = nil
	m.clearedFields[productcategory.FieldLongDescription] = struct{}{}
}

// LongDescriptionCleared returns if the "long_description" field was cleared in this mutation.
func (m *ProductCategoryMutation) LongDescriptionCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldLongDescription]
	return ok
}

// ResetLongDescription resets all changes to the "long_description" field.
func (m *ProductCategoryMutation) ResetLongDescription() {
	m.long_description = nil
	delete(m.clearedFields, productcategory.FieldLongDescription)
}

// SetCategoryImageURL sets the "category_image_url" field.
func (m *ProductCategoryMutation) SetCategoryImageURL(s string) {
	m.category_image_url = &s
}

// CategoryImageURL returns the value of the "category_image_url" field in the mutation.
func (m *ProductCategoryMutation) CategoryImageURL() (r string, exists bool) {
	v := m.category_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryImageURL returns the old "category_image_url" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldCategoryImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryImageURL: %w", err)
	}
	return oldValue.CategoryImageURL, nil
}

// ClearCategoryImageURL clears the value of the "category_image_url" field.
func (m *ProductCategoryMutation) ClearCategoryImageURL() {
	m.category_image_url = nil
	m.clearedFields[productcategory.FieldCategoryImageURL] = struct{}{}
}

// CategoryImageURLCleared returns if the "category_image_url" field was cleared in this mutation.
func (m *ProductCategoryMutation) CategoryImageURLCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldCategoryImageURL]
	return ok
}

// ResetCategoryImageURL resets all changes to the "category_image_url" field.
func (m *ProductCategoryMutation) ResetCategoryImageURL() {
	m.category_image_url = nil
	delete(m.clearedFields, productcategory.FieldCategoryImageURL)
}

// SetLinkOneImageURL sets the "link_one_image_url" field.
func (m *ProductCategoryMutation) SetLinkOneImageURL(s string) {
	m.link_one_image_url = &s
}

// LinkOneImageURL returns the value of the "link_one_image_url" field in the mutation.
func (m *ProductCategoryMutation) LinkOneImageURL() (r string, exists bool) {
	v := m.link_one_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkOneImageURL returns the old "link_one_image_url" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldLinkOneImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkOneImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkOneImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkOneImageURL: %w", err)
	}
	return oldValue.LinkOneImageURL, nil
}

// ClearLinkOneImageURL clears the value of the "link_one_image_url" field.
func (m *ProductCategoryMutation) ClearLinkOneImageURL() {
	m.link_one_image_url = nil
	m.clearedFields[productcategory.FieldLinkOneImageURL] = struct{}{}
}

// LinkOneImageURLCleared returns if the "link_one_image_url" field was cleared in this mutation.
func (m *ProductCategoryMutation) LinkOneImageURLCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldLinkOneImageURL]
	return ok
}

// ResetLinkOneImageURL resets all changes to the "link_one_image_url" field.
func (m *ProductCategoryMutation) ResetLinkOneImageURL() {
	m.link_one_image_url = nil
	delete(m.clearedFields, productcategory.FieldLinkOneImageURL)
}

// SetLinkTwoImageURL sets the "link_two_image_url" field.
func (m *ProductCategoryMutation) SetLinkTwoImageURL(s string) {
	m.link_two_image_url = &s
}

// LinkTwoImageURL returns the value of the "link_two_image_url" field in the mutation.
func (m *ProductCategoryMutation) LinkTwoImageURL() (r string, exists bool) {
	v := m.link_two_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkTwoImageURL returns the old "link_two_image_url" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldLinkTwoImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLinkTwoImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLinkTwoImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkTwoImageURL: %w", err)
	}
	return oldValue.LinkTwoImageURL, nil
}

// ClearLinkTwoImageURL clears the value of the "link_two_image_url" field.
func (m *ProductCategoryMutation) ClearLinkTwoImageURL() {
	m.link_two_image_url = nil
	m.clearedFields[productcategory.FieldLinkTwoImageURL] = struct{}{}
}

// LinkTwoImageURLCleared returns if the "link_two_image_url" field was cleared in this mutation.
func (m *ProductCategoryMutation) LinkTwoImageURLCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldLinkTwoImageURL]
	return ok
}

// ResetLinkTwoImageURL resets all changes to the "link_two_image_url" field.
func (m *ProductCategoryMutation) ResetLinkTwoImageURL() {
	m.link_two_image_url = nil
	delete(m.clearedFields, productcategory.FieldLinkTwoImageURL)
}

// SetDetailScreen sets the "detail_screen" field.
func (m *ProductCategoryMutation) SetDetailScreen(s string) {
	m.detail_screen = &s
}

// DetailScreen returns the value of the "detail_screen" field in the mutation.
func (m *ProductCategoryMutation) DetailScreen() (r string, exists bool) {
	v := m.detail_screen
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailScreen returns the old "detail_screen" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldDetailScreen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetailScreen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetailScreen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailScreen: %w", err)
	}
	return oldValue.DetailScreen, nil
}

// ClearDetailScreen clears the value of the "detail_screen" field.
func (m *ProductCategoryMutation) ClearDetailScreen() {
	m.detail_screen = nil
	m.clearedFields[productcategory.FieldDetailScreen] = struct{}{}
}

// DetailScreenCleared returns if the "detail_screen" field was cleared in this mutation.
func (m *ProductCategoryMutation) DetailScreenCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldDetailScreen]
	return ok
}

// ResetDetailScreen resets all changes to the "detail_screen" field.
func (m *ProductCategoryMutation) ResetDetailScreen() {
	m.detail_screen = nil
	delete(m.clearedFields, productcategory.FieldDetailScreen)
}

// SetShowInSelect sets the "show_in_select" field.
func (m *ProductCategoryMutation) SetShowInSelect(pis productcategory.ShowInSelect) {
	m.show_in_select = &pis
}

// ShowInSelect returns the value of the "show_in_select" field in the mutation.
func (m *ProductCategoryMutation) ShowInSelect() (r productcategory.ShowInSelect, exists bool) {
	v := m.show_in_select
	if v == nil {
		return
	}
	return *v, true
}

// OldShowInSelect returns the old "show_in_select" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldShowInSelect(ctx context.Context) (v productcategory.ShowInSelect, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowInSelect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowInSelect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowInSelect: %w", err)
	}
	return oldValue.ShowInSelect, nil
}

// ClearShowInSelect clears the value of the "show_in_select" field.
func (m *ProductCategoryMutation) ClearShowInSelect() {
	m.show_in_select = nil
	m.clearedFields[productcategory.FieldShowInSelect] = struct{}{}
}

// ShowInSelectCleared returns if the "show_in_select" field was cleared in this mutation.
func (m *ProductCategoryMutation) ShowInSelectCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldShowInSelect]
	return ok
}

// ResetShowInSelect resets all changes to the "show_in_select" field.
func (m *ProductCategoryMutation) ResetShowInSelect() {
	m.show_in_select = nil
	delete(m.clearedFields, productcategory.FieldShowInSelect)
}

// SetProductCategoryTypeID sets the "product_category_type" edge to the ProductCategoryType entity by id.
func (m *ProductCategoryMutation) SetProductCategoryTypeID(id int) {
	m.product_category_type = &id
}

// ClearProductCategoryType clears the "product_category_type" edge to the ProductCategoryType entity.
func (m *ProductCategoryMutation) ClearProductCategoryType() {
	m.clearedproduct_category_type = true
}

// ProductCategoryTypeCleared reports if the "product_category_type" edge to the ProductCategoryType entity was cleared.
func (m *ProductCategoryMutation) ProductCategoryTypeCleared() bool {
	return m.clearedproduct_category_type
}

// ProductCategoryTypeID returns the "product_category_type" edge ID in the mutation.
func (m *ProductCategoryMutation) ProductCategoryTypeID() (id int, exists bool) {
	if m.product_category_type != nil {
		return *m.product_category_type, true
	}
	return
}

// ProductCategoryTypeIDs returns the "product_category_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductCategoryTypeID instead. It exists only for internal usage by the builders.
func (m *ProductCategoryMutation) ProductCategoryTypeIDs() (ids []int) {
	if id := m.product_category_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductCategoryType resets all changes to the "product_category_type" edge.
func (m *ProductCategoryMutation) ResetProductCategoryType() {
	m.product_category_type = nil
	m.clearedproduct_category_type = false
}

// SetParentID sets the "parent" edge to the ProductCategory entity by id.
func (m *ProductCategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductCategory entity.
func (m *ProductCategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductCategory entity was cleared.
func (m *ProductCategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductCategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductCategory entity by ids.
func (m *ProductCategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductCategory entity.
func (m *ProductCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductCategory entity was cleared.
func (m *ProductCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductCategory entity by IDs.
func (m *ProductCategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductCategory entity.
func (m *ProductCategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductCategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddPrimaryChildProductCategoryIDs adds the "primary_child_product_categories" edge to the ProductCategory entity by ids.
func (m *ProductCategoryMutation) AddPrimaryChildProductCategoryIDs(ids ...int) {
	if m.primary_child_product_categories == nil {
		m.primary_child_product_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_child_product_categories[ids[i]] = struct{}{}
	}
}

// ClearPrimaryChildProductCategories clears the "primary_child_product_categories" edge to the ProductCategory entity.
func (m *ProductCategoryMutation) ClearPrimaryChildProductCategories() {
	m.clearedprimary_child_product_categories = true
}

// PrimaryChildProductCategoriesCleared reports if the "primary_child_product_categories" edge to the ProductCategory entity was cleared.
func (m *ProductCategoryMutation) PrimaryChildProductCategoriesCleared() bool {
	return m.clearedprimary_child_product_categories
}

// RemovePrimaryChildProductCategoryIDs removes the "primary_child_product_categories" edge to the ProductCategory entity by IDs.
func (m *ProductCategoryMutation) RemovePrimaryChildProductCategoryIDs(ids ...int) {
	if m.removedprimary_child_product_categories == nil {
		m.removedprimary_child_product_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprimary_child_product_categories[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryChildProductCategories returns the removed IDs of the "primary_child_product_categories" edge to the ProductCategory entity.
func (m *ProductCategoryMutation) RemovedPrimaryChildProductCategoriesIDs() (ids []int) {
	for id := range m.removedprimary_child_product_categories {
		ids = append(ids, id)
	}
	return
}

// PrimaryChildProductCategoriesIDs returns the "primary_child_product_categories" edge IDs in the mutation.
func (m *ProductCategoryMutation) PrimaryChildProductCategoriesIDs() (ids []int) {
	for id := range m.primary_child_product_categories {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryChildProductCategories resets all changes to the "primary_child_product_categories" edge.
func (m *ProductCategoryMutation) ResetPrimaryChildProductCategories() {
	m.primary_child_product_categories = nil
	m.clearedprimary_child_product_categories = false
	m.removedprimary_child_product_categories = nil
}

// AddPrimaryProductIDs adds the "primary_products" edge to the Product entity by ids.
func (m *ProductCategoryMutation) AddPrimaryProductIDs(ids ...int) {
	if m.primary_products == nil {
		m.primary_products = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_products[ids[i]] = struct{}{}
	}
}

// ClearPrimaryProducts clears the "primary_products" edge to the Product entity.
func (m *ProductCategoryMutation) ClearPrimaryProducts() {
	m.clearedprimary_products = true
}

// PrimaryProductsCleared reports if the "primary_products" edge to the Product entity was cleared.
func (m *ProductCategoryMutation) PrimaryProductsCleared() bool {
	return m.clearedprimary_products
}

// RemovePrimaryProductIDs removes the "primary_products" edge to the Product entity by IDs.
func (m *ProductCategoryMutation) RemovePrimaryProductIDs(ids ...int) {
	if m.removedprimary_products == nil {
		m.removedprimary_products = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprimary_products[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryProducts returns the removed IDs of the "primary_products" edge to the Product entity.
func (m *ProductCategoryMutation) RemovedPrimaryProductsIDs() (ids []int) {
	for id := range m.removedprimary_products {
		ids = append(ids, id)
	}
	return
}

// PrimaryProductsIDs returns the "primary_products" edge IDs in the mutation.
func (m *ProductCategoryMutation) PrimaryProductsIDs() (ids []int) {
	for id := range m.primary_products {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryProducts resets all changes to the "primary_products" edge.
func (m *ProductCategoryMutation) ResetPrimaryProducts() {
	m.primary_products = nil
	m.clearedprimary_products = false
	m.removedprimary_products = nil
}

// Op returns the operation name.
func (m *ProductCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategory).
func (m *ProductCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, productcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productcategory.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productcategory.FieldStringRef)
	}
	if m.category_name != nil {
		fields = append(fields, productcategory.FieldCategoryName)
	}
	if m.description != nil {
		fields = append(fields, productcategory.FieldDescription)
	}
	if m.long_description != nil {
		fields = append(fields, productcategory.FieldLongDescription)
	}
	if m.category_image_url != nil {
		fields = append(fields, productcategory.FieldCategoryImageURL)
	}
	if m.link_one_image_url != nil {
		fields = append(fields, productcategory.FieldLinkOneImageURL)
	}
	if m.link_two_image_url != nil {
		fields = append(fields, productcategory.FieldLinkTwoImageURL)
	}
	if m.detail_screen != nil {
		fields = append(fields, productcategory.FieldDetailScreen)
	}
	if m.show_in_select != nil {
		fields = append(fields, productcategory.FieldShowInSelect)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldCreateTime:
		return m.CreateTime()
	case productcategory.FieldUpdateTime:
		return m.UpdateTime()
	case productcategory.FieldStringRef:
		return m.StringRef()
	case productcategory.FieldCategoryName:
		return m.CategoryName()
	case productcategory.FieldDescription:
		return m.Description()
	case productcategory.FieldLongDescription:
		return m.LongDescription()
	case productcategory.FieldCategoryImageURL:
		return m.CategoryImageURL()
	case productcategory.FieldLinkOneImageURL:
		return m.LinkOneImageURL()
	case productcategory.FieldLinkTwoImageURL:
		return m.LinkTwoImageURL()
	case productcategory.FieldDetailScreen:
		return m.DetailScreen()
	case productcategory.FieldShowInSelect:
		return m.ShowInSelect()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productcategory.FieldStringRef:
		return m.OldStringRef(ctx)
	case productcategory.FieldCategoryName:
		return m.OldCategoryName(ctx)
	case productcategory.FieldDescription:
		return m.OldDescription(ctx)
	case productcategory.FieldLongDescription:
		return m.OldLongDescription(ctx)
	case productcategory.FieldCategoryImageURL:
		return m.OldCategoryImageURL(ctx)
	case productcategory.FieldLinkOneImageURL:
		return m.OldLinkOneImageURL(ctx)
	case productcategory.FieldLinkTwoImageURL:
		return m.OldLinkTwoImageURL(ctx)
	case productcategory.FieldDetailScreen:
		return m.OldDetailScreen(ctx)
	case productcategory.FieldShowInSelect:
		return m.OldShowInSelect(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productcategory.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productcategory.FieldCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryName(v)
		return nil
	case productcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productcategory.FieldLongDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongDescription(v)
		return nil
	case productcategory.FieldCategoryImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryImageURL(v)
		return nil
	case productcategory.FieldLinkOneImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkOneImageURL(v)
		return nil
	case productcategory.FieldLinkTwoImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkTwoImageURL(v)
		return nil
	case productcategory.FieldDetailScreen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailScreen(v)
		return nil
	case productcategory.FieldShowInSelect:
		v, ok := value.(productcategory.ShowInSelect)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowInSelect(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcategory.FieldStringRef) {
		fields = append(fields, productcategory.FieldStringRef)
	}
	if m.FieldCleared(productcategory.FieldCategoryName) {
		fields = append(fields, productcategory.FieldCategoryName)
	}
	if m.FieldCleared(productcategory.FieldDescription) {
		fields = append(fields, productcategory.FieldDescription)
	}
	if m.FieldCleared(productcategory.FieldLongDescription) {
		fields = append(fields, productcategory.FieldLongDescription)
	}
	if m.FieldCleared(productcategory.FieldCategoryImageURL) {
		fields = append(fields, productcategory.FieldCategoryImageURL)
	}
	if m.FieldCleared(productcategory.FieldLinkOneImageURL) {
		fields = append(fields, productcategory.FieldLinkOneImageURL)
	}
	if m.FieldCleared(productcategory.FieldLinkTwoImageURL) {
		fields = append(fields, productcategory.FieldLinkTwoImageURL)
	}
	if m.FieldCleared(productcategory.FieldDetailScreen) {
		fields = append(fields, productcategory.FieldDetailScreen)
	}
	if m.FieldCleared(productcategory.FieldShowInSelect) {
		fields = append(fields, productcategory.FieldShowInSelect)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ClearField(name string) error {
	switch name {
	case productcategory.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productcategory.FieldCategoryName:
		m.ClearCategoryName()
		return nil
	case productcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case productcategory.FieldLongDescription:
		m.ClearLongDescription()
		return nil
	case productcategory.FieldCategoryImageURL:
		m.ClearCategoryImageURL()
		return nil
	case productcategory.FieldLinkOneImageURL:
		m.ClearLinkOneImageURL()
		return nil
	case productcategory.FieldLinkTwoImageURL:
		m.ClearLinkTwoImageURL()
		return nil
	case productcategory.FieldDetailScreen:
		m.ClearDetailScreen()
		return nil
	case productcategory.FieldShowInSelect:
		m.ClearShowInSelect()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ResetField(name string) error {
	switch name {
	case productcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productcategory.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productcategory.FieldCategoryName:
		m.ResetCategoryName()
		return nil
	case productcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case productcategory.FieldLongDescription:
		m.ResetLongDescription()
		return nil
	case productcategory.FieldCategoryImageURL:
		m.ResetCategoryImageURL()
		return nil
	case productcategory.FieldLinkOneImageURL:
		m.ResetLinkOneImageURL()
		return nil
	case productcategory.FieldLinkTwoImageURL:
		m.ResetLinkTwoImageURL()
		return nil
	case productcategory.FieldDetailScreen:
		m.ResetDetailScreen()
		return nil
	case productcategory.FieldShowInSelect:
		m.ResetShowInSelect()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.product_category_type != nil {
		edges = append(edges, productcategory.EdgeProductCategoryType)
	}
	if m.parent != nil {
		edges = append(edges, productcategory.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productcategory.EdgeChildren)
	}
	if m.primary_child_product_categories != nil {
		edges = append(edges, productcategory.EdgePrimaryChildProductCategories)
	}
	if m.primary_products != nil {
		edges = append(edges, productcategory.EdgePrimaryProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategory.EdgeProductCategoryType:
		if id := m.product_category_type; id != nil {
			return []ent.Value{*id}
		}
	case productcategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productcategory.EdgePrimaryChildProductCategories:
		ids := make([]ent.Value, 0, len(m.primary_child_product_categories))
		for id := range m.primary_child_product_categories {
			ids = append(ids, id)
		}
		return ids
	case productcategory.EdgePrimaryProducts:
		ids := make([]ent.Value, 0, len(m.primary_products))
		for id := range m.primary_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, productcategory.EdgeChildren)
	}
	if m.removedprimary_child_product_categories != nil {
		edges = append(edges, productcategory.EdgePrimaryChildProductCategories)
	}
	if m.removedprimary_products != nil {
		edges = append(edges, productcategory.EdgePrimaryProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productcategory.EdgePrimaryChildProductCategories:
		ids := make([]ent.Value, 0, len(m.removedprimary_child_product_categories))
		for id := range m.removedprimary_child_product_categories {
			ids = append(ids, id)
		}
		return ids
	case productcategory.EdgePrimaryProducts:
		ids := make([]ent.Value, 0, len(m.removedprimary_products))
		for id := range m.removedprimary_products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproduct_category_type {
		edges = append(edges, productcategory.EdgeProductCategoryType)
	}
	if m.clearedparent {
		edges = append(edges, productcategory.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productcategory.EdgeChildren)
	}
	if m.clearedprimary_child_product_categories {
		edges = append(edges, productcategory.EdgePrimaryChildProductCategories)
	}
	if m.clearedprimary_products {
		edges = append(edges, productcategory.EdgePrimaryProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategory.EdgeProductCategoryType:
		return m.clearedproduct_category_type
	case productcategory.EdgeParent:
		return m.clearedparent
	case productcategory.EdgeChildren:
		return m.clearedchildren
	case productcategory.EdgePrimaryChildProductCategories:
		return m.clearedprimary_child_product_categories
	case productcategory.EdgePrimaryProducts:
		return m.clearedprimary_products
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMutation) ClearEdge(name string) error {
	switch name {
	case productcategory.EdgeProductCategoryType:
		m.ClearProductCategoryType()
		return nil
	case productcategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMutation) ResetEdge(name string) error {
	switch name {
	case productcategory.EdgeProductCategoryType:
		m.ResetProductCategoryType()
		return nil
	case productcategory.EdgeParent:
		m.ResetParent()
		return nil
	case productcategory.EdgeChildren:
		m.ResetChildren()
		return nil
	case productcategory.EdgePrimaryChildProductCategories:
		m.ResetPrimaryChildProductCategories()
		return nil
	case productcategory.EdgePrimaryProducts:
		m.ResetPrimaryProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory edge %s", name)
}

// ProductCategoryContentTypeMutation represents an operation that mutates the ProductCategoryContentType nodes in the graph.
type ProductCategoryContentTypeMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	create_time                                 *time.Time
	update_time                                 *time.Time
	string_ref                                  *string
	has_table                                   *productcategorycontenttype.HasTable
	description                                 *string
	clearedFields                               map[string]struct{}
	parent                                      *int
	clearedparent                               bool
	children                                    map[int]struct{}
	removedchildren                             map[int]struct{}
	clearedchildren                             bool
	child_product_category_content_types        map[int]struct{}
	removedchild_product_category_content_types map[int]struct{}
	clearedchild_product_category_content_types bool
	done                                        bool
	oldValue                                    func(context.Context) (*ProductCategoryContentType, error)
	predicates                                  []predicate.ProductCategoryContentType
}

var _ ent.Mutation = (*ProductCategoryContentTypeMutation)(nil)

// productcategorycontenttypeOption allows management of the mutation configuration using functional options.
type productcategorycontenttypeOption func(*ProductCategoryContentTypeMutation)

// newProductCategoryContentTypeMutation creates new mutation for the ProductCategoryContentType entity.
func newProductCategoryContentTypeMutation(c config, op Op, opts ...productcategorycontenttypeOption) *ProductCategoryContentTypeMutation {
	m := &ProductCategoryContentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategoryContentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryContentTypeID sets the ID field of the mutation.
func withProductCategoryContentTypeID(id int) productcategorycontenttypeOption {
	return func(m *ProductCategoryContentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategoryContentType
		)
		m.oldValue = func(ctx context.Context) (*ProductCategoryContentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategoryContentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategoryContentType sets the old ProductCategoryContentType of the mutation.
func withProductCategoryContentType(node *ProductCategoryContentType) productcategorycontenttypeOption {
	return func(m *ProductCategoryContentTypeMutation) {
		m.oldValue = func(context.Context) (*ProductCategoryContentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryContentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryContentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryContentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductCategoryContentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductCategoryContentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductCategoryContentType entity.
// If the ProductCategoryContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryContentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductCategoryContentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductCategoryContentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductCategoryContentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductCategoryContentType entity.
// If the ProductCategoryContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryContentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductCategoryContentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductCategoryContentTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductCategoryContentTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductCategoryContentType entity.
// If the ProductCategoryContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryContentTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductCategoryContentTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productcategorycontenttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductCategoryContentTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productcategorycontenttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductCategoryContentTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productcategorycontenttype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductCategoryContentTypeMutation) SetHasTable(pt productcategorycontenttype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductCategoryContentTypeMutation) HasTable() (r productcategorycontenttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductCategoryContentType entity.
// If the ProductCategoryContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryContentTypeMutation) OldHasTable(ctx context.Context) (v productcategorycontenttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductCategoryContentTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productcategorycontenttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductCategoryContentTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productcategorycontenttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductCategoryContentTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productcategorycontenttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductCategoryContentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductCategoryContentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductCategoryContentType entity.
// If the ProductCategoryContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryContentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductCategoryContentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productcategorycontenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductCategoryContentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productcategorycontenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductCategoryContentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productcategorycontenttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductCategoryContentType entity by id.
func (m *ProductCategoryContentTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductCategoryContentType entity.
func (m *ProductCategoryContentTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductCategoryContentType entity was cleared.
func (m *ProductCategoryContentTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductCategoryContentTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductCategoryContentTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductCategoryContentTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductCategoryContentType entity by ids.
func (m *ProductCategoryContentTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductCategoryContentType entity.
func (m *ProductCategoryContentTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductCategoryContentType entity was cleared.
func (m *ProductCategoryContentTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductCategoryContentType entity by IDs.
func (m *ProductCategoryContentTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductCategoryContentType entity.
func (m *ProductCategoryContentTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductCategoryContentTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductCategoryContentTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProductCategoryContentTypeIDs adds the "child_product_category_content_types" edge to the ProductCategoryContentType entity by ids.
func (m *ProductCategoryContentTypeMutation) AddChildProductCategoryContentTypeIDs(ids ...int) {
	if m.child_product_category_content_types == nil {
		m.child_product_category_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_category_content_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductCategoryContentTypes clears the "child_product_category_content_types" edge to the ProductCategoryContentType entity.
func (m *ProductCategoryContentTypeMutation) ClearChildProductCategoryContentTypes() {
	m.clearedchild_product_category_content_types = true
}

// ChildProductCategoryContentTypesCleared reports if the "child_product_category_content_types" edge to the ProductCategoryContentType entity was cleared.
func (m *ProductCategoryContentTypeMutation) ChildProductCategoryContentTypesCleared() bool {
	return m.clearedchild_product_category_content_types
}

// RemoveChildProductCategoryContentTypeIDs removes the "child_product_category_content_types" edge to the ProductCategoryContentType entity by IDs.
func (m *ProductCategoryContentTypeMutation) RemoveChildProductCategoryContentTypeIDs(ids ...int) {
	if m.removedchild_product_category_content_types == nil {
		m.removedchild_product_category_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_category_content_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductCategoryContentTypes returns the removed IDs of the "child_product_category_content_types" edge to the ProductCategoryContentType entity.
func (m *ProductCategoryContentTypeMutation) RemovedChildProductCategoryContentTypesIDs() (ids []int) {
	for id := range m.removedchild_product_category_content_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductCategoryContentTypesIDs returns the "child_product_category_content_types" edge IDs in the mutation.
func (m *ProductCategoryContentTypeMutation) ChildProductCategoryContentTypesIDs() (ids []int) {
	for id := range m.child_product_category_content_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductCategoryContentTypes resets all changes to the "child_product_category_content_types" edge.
func (m *ProductCategoryContentTypeMutation) ResetChildProductCategoryContentTypes() {
	m.child_product_category_content_types = nil
	m.clearedchild_product_category_content_types = false
	m.removedchild_product_category_content_types = nil
}

// Op returns the operation name.
func (m *ProductCategoryContentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategoryContentType).
func (m *ProductCategoryContentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryContentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productcategorycontenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productcategorycontenttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productcategorycontenttype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productcategorycontenttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productcategorycontenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryContentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategorycontenttype.FieldCreateTime:
		return m.CreateTime()
	case productcategorycontenttype.FieldUpdateTime:
		return m.UpdateTime()
	case productcategorycontenttype.FieldStringRef:
		return m.StringRef()
	case productcategorycontenttype.FieldHasTable:
		return m.HasTable()
	case productcategorycontenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryContentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategorycontenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productcategorycontenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productcategorycontenttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productcategorycontenttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productcategorycontenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategoryContentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryContentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategorycontenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productcategorycontenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productcategorycontenttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productcategorycontenttype.FieldHasTable:
		v, ok := value.(productcategorycontenttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productcategorycontenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryContentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryContentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryContentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryContentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryContentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryContentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcategorycontenttype.FieldStringRef) {
		fields = append(fields, productcategorycontenttype.FieldStringRef)
	}
	if m.FieldCleared(productcategorycontenttype.FieldHasTable) {
		fields = append(fields, productcategorycontenttype.FieldHasTable)
	}
	if m.FieldCleared(productcategorycontenttype.FieldDescription) {
		fields = append(fields, productcategorycontenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryContentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryContentTypeMutation) ClearField(name string) error {
	switch name {
	case productcategorycontenttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productcategorycontenttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productcategorycontenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryContentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryContentTypeMutation) ResetField(name string) error {
	switch name {
	case productcategorycontenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productcategorycontenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productcategorycontenttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productcategorycontenttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productcategorycontenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryContentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryContentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, productcategorycontenttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productcategorycontenttype.EdgeChildren)
	}
	if m.child_product_category_content_types != nil {
		edges = append(edges, productcategorycontenttype.EdgeChildProductCategoryContentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryContentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategorycontenttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productcategorycontenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productcategorycontenttype.EdgeChildProductCategoryContentTypes:
		ids := make([]ent.Value, 0, len(m.child_product_category_content_types))
		for id := range m.child_product_category_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryContentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, productcategorycontenttype.EdgeChildren)
	}
	if m.removedchild_product_category_content_types != nil {
		edges = append(edges, productcategorycontenttype.EdgeChildProductCategoryContentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryContentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategorycontenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productcategorycontenttype.EdgeChildProductCategoryContentTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_category_content_types))
		for id := range m.removedchild_product_category_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryContentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, productcategorycontenttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productcategorycontenttype.EdgeChildren)
	}
	if m.clearedchild_product_category_content_types {
		edges = append(edges, productcategorycontenttype.EdgeChildProductCategoryContentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryContentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategorycontenttype.EdgeParent:
		return m.clearedparent
	case productcategorycontenttype.EdgeChildren:
		return m.clearedchildren
	case productcategorycontenttype.EdgeChildProductCategoryContentTypes:
		return m.clearedchild_product_category_content_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryContentTypeMutation) ClearEdge(name string) error {
	switch name {
	case productcategorycontenttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryContentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryContentTypeMutation) ResetEdge(name string) error {
	switch name {
	case productcategorycontenttype.EdgeParent:
		m.ResetParent()
		return nil
	case productcategorycontenttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productcategorycontenttype.EdgeChildProductCategoryContentTypes:
		m.ResetChildProductCategoryContentTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryContentType edge %s", name)
}

// ProductCategoryTypeMutation represents an operation that mutates the ProductCategoryType nodes in the graph.
type ProductCategoryTypeMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	update_time                         *time.Time
	string_ref                          *string
	has_table                           *productcategorytype.HasTable
	description                         *string
	clearedFields                       map[string]struct{}
	parent                              *int
	clearedparent                       bool
	children                            map[int]struct{}
	removedchildren                     map[int]struct{}
	clearedchildren                     bool
	product_categories                  map[int]struct{}
	removedproduct_categories           map[int]struct{}
	clearedproduct_categories           bool
	child_product_category_types        map[int]struct{}
	removedchild_product_category_types map[int]struct{}
	clearedchild_product_category_types bool
	done                                bool
	oldValue                            func(context.Context) (*ProductCategoryType, error)
	predicates                          []predicate.ProductCategoryType
}

var _ ent.Mutation = (*ProductCategoryTypeMutation)(nil)

// productcategorytypeOption allows management of the mutation configuration using functional options.
type productcategorytypeOption func(*ProductCategoryTypeMutation)

// newProductCategoryTypeMutation creates new mutation for the ProductCategoryType entity.
func newProductCategoryTypeMutation(c config, op Op, opts ...productcategorytypeOption) *ProductCategoryTypeMutation {
	m := &ProductCategoryTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategoryType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryTypeID sets the ID field of the mutation.
func withProductCategoryTypeID(id int) productcategorytypeOption {
	return func(m *ProductCategoryTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategoryType
		)
		m.oldValue = func(ctx context.Context) (*ProductCategoryType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategoryType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategoryType sets the old ProductCategoryType of the mutation.
func withProductCategoryType(node *ProductCategoryType) productcategorytypeOption {
	return func(m *ProductCategoryTypeMutation) {
		m.oldValue = func(context.Context) (*ProductCategoryType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductCategoryTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductCategoryTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductCategoryType entity.
// If the ProductCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductCategoryTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductCategoryTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductCategoryTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductCategoryType entity.
// If the ProductCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductCategoryTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductCategoryTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductCategoryTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductCategoryType entity.
// If the ProductCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductCategoryTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productcategorytype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductCategoryTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productcategorytype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductCategoryTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productcategorytype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductCategoryTypeMutation) SetHasTable(pt productcategorytype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductCategoryTypeMutation) HasTable() (r productcategorytype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductCategoryType entity.
// If the ProductCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryTypeMutation) OldHasTable(ctx context.Context) (v productcategorytype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductCategoryTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productcategorytype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductCategoryTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productcategorytype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductCategoryTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productcategorytype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductCategoryTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductCategoryTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductCategoryType entity.
// If the ProductCategoryType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductCategoryTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productcategorytype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductCategoryTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productcategorytype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductCategoryTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productcategorytype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductCategoryType entity by id.
func (m *ProductCategoryTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductCategoryType entity.
func (m *ProductCategoryTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductCategoryType entity was cleared.
func (m *ProductCategoryTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductCategoryTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductCategoryTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductCategoryTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductCategoryType entity by ids.
func (m *ProductCategoryTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductCategoryType entity.
func (m *ProductCategoryTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductCategoryType entity was cleared.
func (m *ProductCategoryTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductCategoryType entity by IDs.
func (m *ProductCategoryTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductCategoryType entity.
func (m *ProductCategoryTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductCategoryTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductCategoryTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductCategoryIDs adds the "product_categories" edge to the ProductCategory entity by ids.
func (m *ProductCategoryTypeMutation) AddProductCategoryIDs(ids ...int) {
	if m.product_categories == nil {
		m.product_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.product_categories[ids[i]] = struct{}{}
	}
}

// ClearProductCategories clears the "product_categories" edge to the ProductCategory entity.
func (m *ProductCategoryTypeMutation) ClearProductCategories() {
	m.clearedproduct_categories = true
}

// ProductCategoriesCleared reports if the "product_categories" edge to the ProductCategory entity was cleared.
func (m *ProductCategoryTypeMutation) ProductCategoriesCleared() bool {
	return m.clearedproduct_categories
}

// RemoveProductCategoryIDs removes the "product_categories" edge to the ProductCategory entity by IDs.
func (m *ProductCategoryTypeMutation) RemoveProductCategoryIDs(ids ...int) {
	if m.removedproduct_categories == nil {
		m.removedproduct_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_categories[ids[i]] = struct{}{}
	}
}

// RemovedProductCategories returns the removed IDs of the "product_categories" edge to the ProductCategory entity.
func (m *ProductCategoryTypeMutation) RemovedProductCategoriesIDs() (ids []int) {
	for id := range m.removedproduct_categories {
		ids = append(ids, id)
	}
	return
}

// ProductCategoriesIDs returns the "product_categories" edge IDs in the mutation.
func (m *ProductCategoryTypeMutation) ProductCategoriesIDs() (ids []int) {
	for id := range m.product_categories {
		ids = append(ids, id)
	}
	return
}

// ResetProductCategories resets all changes to the "product_categories" edge.
func (m *ProductCategoryTypeMutation) ResetProductCategories() {
	m.product_categories = nil
	m.clearedproduct_categories = false
	m.removedproduct_categories = nil
}

// AddChildProductCategoryTypeIDs adds the "child_product_category_types" edge to the ProductCategoryType entity by ids.
func (m *ProductCategoryTypeMutation) AddChildProductCategoryTypeIDs(ids ...int) {
	if m.child_product_category_types == nil {
		m.child_product_category_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_category_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductCategoryTypes clears the "child_product_category_types" edge to the ProductCategoryType entity.
func (m *ProductCategoryTypeMutation) ClearChildProductCategoryTypes() {
	m.clearedchild_product_category_types = true
}

// ChildProductCategoryTypesCleared reports if the "child_product_category_types" edge to the ProductCategoryType entity was cleared.
func (m *ProductCategoryTypeMutation) ChildProductCategoryTypesCleared() bool {
	return m.clearedchild_product_category_types
}

// RemoveChildProductCategoryTypeIDs removes the "child_product_category_types" edge to the ProductCategoryType entity by IDs.
func (m *ProductCategoryTypeMutation) RemoveChildProductCategoryTypeIDs(ids ...int) {
	if m.removedchild_product_category_types == nil {
		m.removedchild_product_category_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_category_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductCategoryTypes returns the removed IDs of the "child_product_category_types" edge to the ProductCategoryType entity.
func (m *ProductCategoryTypeMutation) RemovedChildProductCategoryTypesIDs() (ids []int) {
	for id := range m.removedchild_product_category_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductCategoryTypesIDs returns the "child_product_category_types" edge IDs in the mutation.
func (m *ProductCategoryTypeMutation) ChildProductCategoryTypesIDs() (ids []int) {
	for id := range m.child_product_category_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductCategoryTypes resets all changes to the "child_product_category_types" edge.
func (m *ProductCategoryTypeMutation) ResetChildProductCategoryTypes() {
	m.child_product_category_types = nil
	m.clearedchild_product_category_types = false
	m.removedchild_product_category_types = nil
}

// Op returns the operation name.
func (m *ProductCategoryTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductCategoryType).
func (m *ProductCategoryTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productcategorytype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productcategorytype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productcategorytype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productcategorytype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productcategorytype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategorytype.FieldCreateTime:
		return m.CreateTime()
	case productcategorytype.FieldUpdateTime:
		return m.UpdateTime()
	case productcategorytype.FieldStringRef:
		return m.StringRef()
	case productcategorytype.FieldHasTable:
		return m.HasTable()
	case productcategorytype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategorytype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productcategorytype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productcategorytype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productcategorytype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productcategorytype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategoryType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategorytype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productcategorytype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productcategorytype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productcategorytype.FieldHasTable:
		v, ok := value.(productcategorytype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productcategorytype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategoryType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcategorytype.FieldStringRef) {
		fields = append(fields, productcategorytype.FieldStringRef)
	}
	if m.FieldCleared(productcategorytype.FieldHasTable) {
		fields = append(fields, productcategorytype.FieldHasTable)
	}
	if m.FieldCleared(productcategorytype.FieldDescription) {
		fields = append(fields, productcategorytype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryTypeMutation) ClearField(name string) error {
	switch name {
	case productcategorytype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productcategorytype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productcategorytype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryTypeMutation) ResetField(name string) error {
	switch name {
	case productcategorytype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productcategorytype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productcategorytype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productcategorytype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productcategorytype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, productcategorytype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productcategorytype.EdgeChildren)
	}
	if m.product_categories != nil {
		edges = append(edges, productcategorytype.EdgeProductCategories)
	}
	if m.child_product_category_types != nil {
		edges = append(edges, productcategorytype.EdgeChildProductCategoryTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategorytype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productcategorytype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productcategorytype.EdgeProductCategories:
		ids := make([]ent.Value, 0, len(m.product_categories))
		for id := range m.product_categories {
			ids = append(ids, id)
		}
		return ids
	case productcategorytype.EdgeChildProductCategoryTypes:
		ids := make([]ent.Value, 0, len(m.child_product_category_types))
		for id := range m.child_product_category_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, productcategorytype.EdgeChildren)
	}
	if m.removedproduct_categories != nil {
		edges = append(edges, productcategorytype.EdgeProductCategories)
	}
	if m.removedchild_product_category_types != nil {
		edges = append(edges, productcategorytype.EdgeChildProductCategoryTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategorytype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productcategorytype.EdgeProductCategories:
		ids := make([]ent.Value, 0, len(m.removedproduct_categories))
		for id := range m.removedproduct_categories {
			ids = append(ids, id)
		}
		return ids
	case productcategorytype.EdgeChildProductCategoryTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_category_types))
		for id := range m.removedchild_product_category_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, productcategorytype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productcategorytype.EdgeChildren)
	}
	if m.clearedproduct_categories {
		edges = append(edges, productcategorytype.EdgeProductCategories)
	}
	if m.clearedchild_product_category_types {
		edges = append(edges, productcategorytype.EdgeChildProductCategoryTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategorytype.EdgeParent:
		return m.clearedparent
	case productcategorytype.EdgeChildren:
		return m.clearedchildren
	case productcategorytype.EdgeProductCategories:
		return m.clearedproduct_categories
	case productcategorytype.EdgeChildProductCategoryTypes:
		return m.clearedchild_product_category_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryTypeMutation) ClearEdge(name string) error {
	switch name {
	case productcategorytype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryTypeMutation) ResetEdge(name string) error {
	switch name {
	case productcategorytype.EdgeParent:
		m.ResetParent()
		return nil
	case productcategorytype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productcategorytype.EdgeProductCategories:
		m.ResetProductCategories()
		return nil
	case productcategorytype.EdgeChildProductCategoryTypes:
		m.ResetChildProductCategoryTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductCategoryType edge %s", name)
}

// ProductConfigItemMutation represents an operation that mutates the ProductConfigItem nodes in the graph.
type ProductConfigItemMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	create_time            *time.Time
	update_time            *time.Time
	string_ref             *string
	config_item_type_id    *int
	addconfig_item_type_id *int
	config_item_name       *string
	description            *string
	long_description       *string
	image_url              *string
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ProductConfigItem, error)
	predicates             []predicate.ProductConfigItem
}

var _ ent.Mutation = (*ProductConfigItemMutation)(nil)

// productconfigitemOption allows management of the mutation configuration using functional options.
type productconfigitemOption func(*ProductConfigItemMutation)

// newProductConfigItemMutation creates new mutation for the ProductConfigItem entity.
func newProductConfigItemMutation(c config, op Op, opts ...productconfigitemOption) *ProductConfigItemMutation {
	m := &ProductConfigItemMutation{
		config:        c,
		op:            op,
		typ:           TypeProductConfigItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductConfigItemID sets the ID field of the mutation.
func withProductConfigItemID(id int) productconfigitemOption {
	return func(m *ProductConfigItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductConfigItem
		)
		m.oldValue = func(ctx context.Context) (*ProductConfigItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductConfigItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductConfigItem sets the old ProductConfigItem of the mutation.
func withProductConfigItem(node *ProductConfigItem) productconfigitemOption {
	return func(m *ProductConfigItemMutation) {
		m.oldValue = func(context.Context) (*ProductConfigItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductConfigItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductConfigItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductConfigItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductConfigItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductConfigItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductConfigItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductConfigItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductConfigItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductConfigItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductConfigItemMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductConfigItemMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductConfigItemMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productconfigitem.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductConfigItemMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productconfigitem.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductConfigItemMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productconfigitem.FieldStringRef)
}

// SetConfigItemTypeID sets the "config_item_type_id" field.
func (m *ProductConfigItemMutation) SetConfigItemTypeID(i int) {
	m.config_item_type_id = &i
	m.addconfig_item_type_id = nil
}

// ConfigItemTypeID returns the value of the "config_item_type_id" field in the mutation.
func (m *ProductConfigItemMutation) ConfigItemTypeID() (r int, exists bool) {
	v := m.config_item_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigItemTypeID returns the old "config_item_type_id" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldConfigItemTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfigItemTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfigItemTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigItemTypeID: %w", err)
	}
	return oldValue.ConfigItemTypeID, nil
}

// AddConfigItemTypeID adds i to the "config_item_type_id" field.
func (m *ProductConfigItemMutation) AddConfigItemTypeID(i int) {
	if m.addconfig_item_type_id != nil {
		*m.addconfig_item_type_id += i
	} else {
		m.addconfig_item_type_id = &i
	}
}

// AddedConfigItemTypeID returns the value that was added to the "config_item_type_id" field in this mutation.
func (m *ProductConfigItemMutation) AddedConfigItemTypeID() (r int, exists bool) {
	v := m.addconfig_item_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfigItemTypeID clears the value of the "config_item_type_id" field.
func (m *ProductConfigItemMutation) ClearConfigItemTypeID() {
	m.config_item_type_id = nil
	m.addconfig_item_type_id = nil
	m.clearedFields[productconfigitem.FieldConfigItemTypeID] = struct{}{}
}

// ConfigItemTypeIDCleared returns if the "config_item_type_id" field was cleared in this mutation.
func (m *ProductConfigItemMutation) ConfigItemTypeIDCleared() bool {
	_, ok := m.clearedFields[productconfigitem.FieldConfigItemTypeID]
	return ok
}

// ResetConfigItemTypeID resets all changes to the "config_item_type_id" field.
func (m *ProductConfigItemMutation) ResetConfigItemTypeID() {
	m.config_item_type_id = nil
	m.addconfig_item_type_id = nil
	delete(m.clearedFields, productconfigitem.FieldConfigItemTypeID)
}

// SetConfigItemName sets the "config_item_name" field.
func (m *ProductConfigItemMutation) SetConfigItemName(s string) {
	m.config_item_name = &s
}

// ConfigItemName returns the value of the "config_item_name" field in the mutation.
func (m *ProductConfigItemMutation) ConfigItemName() (r string, exists bool) {
	v := m.config_item_name
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigItemName returns the old "config_item_name" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldConfigItemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfigItemName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfigItemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigItemName: %w", err)
	}
	return oldValue.ConfigItemName, nil
}

// ClearConfigItemName clears the value of the "config_item_name" field.
func (m *ProductConfigItemMutation) ClearConfigItemName() {
	m.config_item_name = nil
	m.clearedFields[productconfigitem.FieldConfigItemName] = struct{}{}
}

// ConfigItemNameCleared returns if the "config_item_name" field was cleared in this mutation.
func (m *ProductConfigItemMutation) ConfigItemNameCleared() bool {
	_, ok := m.clearedFields[productconfigitem.FieldConfigItemName]
	return ok
}

// ResetConfigItemName resets all changes to the "config_item_name" field.
func (m *ProductConfigItemMutation) ResetConfigItemName() {
	m.config_item_name = nil
	delete(m.clearedFields, productconfigitem.FieldConfigItemName)
}

// SetDescription sets the "description" field.
func (m *ProductConfigItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductConfigItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductConfigItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productconfigitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductConfigItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productconfigitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductConfigItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productconfigitem.FieldDescription)
}

// SetLongDescription sets the "long_description" field.
func (m *ProductConfigItemMutation) SetLongDescription(s string) {
	m.long_description = &s
}

// LongDescription returns the value of the "long_description" field in the mutation.
func (m *ProductConfigItemMutation) LongDescription() (r string, exists bool) {
	v := m.long_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLongDescription returns the old "long_description" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldLongDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongDescription: %w", err)
	}
	return oldValue.LongDescription, nil
}

// ClearLongDescription clears the value of the "long_description" field.
func (m *ProductConfigItemMutation) ClearLongDescription() {
	m.long_description = nil
	m.clearedFields[productconfigitem.FieldLongDescription] = struct{}{}
}

// LongDescriptionCleared returns if the "long_description" field was cleared in this mutation.
func (m *ProductConfigItemMutation) LongDescriptionCleared() bool {
	_, ok := m.clearedFields[productconfigitem.FieldLongDescription]
	return ok
}

// ResetLongDescription resets all changes to the "long_description" field.
func (m *ProductConfigItemMutation) ResetLongDescription() {
	m.long_description = nil
	delete(m.clearedFields, productconfigitem.FieldLongDescription)
}

// SetImageURL sets the "image_url" field.
func (m *ProductConfigItemMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ProductConfigItemMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the ProductConfigItem entity.
// If the ProductConfigItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductConfigItemMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *ProductConfigItemMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[productconfigitem.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *ProductConfigItemMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[productconfigitem.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ProductConfigItemMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, productconfigitem.FieldImageURL)
}

// Op returns the operation name.
func (m *ProductConfigItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductConfigItem).
func (m *ProductConfigItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductConfigItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, productconfigitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productconfigitem.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productconfigitem.FieldStringRef)
	}
	if m.config_item_type_id != nil {
		fields = append(fields, productconfigitem.FieldConfigItemTypeID)
	}
	if m.config_item_name != nil {
		fields = append(fields, productconfigitem.FieldConfigItemName)
	}
	if m.description != nil {
		fields = append(fields, productconfigitem.FieldDescription)
	}
	if m.long_description != nil {
		fields = append(fields, productconfigitem.FieldLongDescription)
	}
	if m.image_url != nil {
		fields = append(fields, productconfigitem.FieldImageURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductConfigItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productconfigitem.FieldCreateTime:
		return m.CreateTime()
	case productconfigitem.FieldUpdateTime:
		return m.UpdateTime()
	case productconfigitem.FieldStringRef:
		return m.StringRef()
	case productconfigitem.FieldConfigItemTypeID:
		return m.ConfigItemTypeID()
	case productconfigitem.FieldConfigItemName:
		return m.ConfigItemName()
	case productconfigitem.FieldDescription:
		return m.Description()
	case productconfigitem.FieldLongDescription:
		return m.LongDescription()
	case productconfigitem.FieldImageURL:
		return m.ImageURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductConfigItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productconfigitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productconfigitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productconfigitem.FieldStringRef:
		return m.OldStringRef(ctx)
	case productconfigitem.FieldConfigItemTypeID:
		return m.OldConfigItemTypeID(ctx)
	case productconfigitem.FieldConfigItemName:
		return m.OldConfigItemName(ctx)
	case productconfigitem.FieldDescription:
		return m.OldDescription(ctx)
	case productconfigitem.FieldLongDescription:
		return m.OldLongDescription(ctx)
	case productconfigitem.FieldImageURL:
		return m.OldImageURL(ctx)
	}
	return nil, fmt.Errorf("unknown ProductConfigItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductConfigItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productconfigitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productconfigitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productconfigitem.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productconfigitem.FieldConfigItemTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigItemTypeID(v)
		return nil
	case productconfigitem.FieldConfigItemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigItemName(v)
		return nil
	case productconfigitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productconfigitem.FieldLongDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongDescription(v)
		return nil
	case productconfigitem.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	}
	return fmt.Errorf("unknown ProductConfigItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductConfigItemMutation) AddedFields() []string {
	var fields []string
	if m.addconfig_item_type_id != nil {
		fields = append(fields, productconfigitem.FieldConfigItemTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductConfigItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productconfigitem.FieldConfigItemTypeID:
		return m.AddedConfigItemTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductConfigItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productconfigitem.FieldConfigItemTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigItemTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductConfigItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductConfigItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productconfigitem.FieldStringRef) {
		fields = append(fields, productconfigitem.FieldStringRef)
	}
	if m.FieldCleared(productconfigitem.FieldConfigItemTypeID) {
		fields = append(fields, productconfigitem.FieldConfigItemTypeID)
	}
	if m.FieldCleared(productconfigitem.FieldConfigItemName) {
		fields = append(fields, productconfigitem.FieldConfigItemName)
	}
	if m.FieldCleared(productconfigitem.FieldDescription) {
		fields = append(fields, productconfigitem.FieldDescription)
	}
	if m.FieldCleared(productconfigitem.FieldLongDescription) {
		fields = append(fields, productconfigitem.FieldLongDescription)
	}
	if m.FieldCleared(productconfigitem.FieldImageURL) {
		fields = append(fields, productconfigitem.FieldImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductConfigItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductConfigItemMutation) ClearField(name string) error {
	switch name {
	case productconfigitem.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productconfigitem.FieldConfigItemTypeID:
		m.ClearConfigItemTypeID()
		return nil
	case productconfigitem.FieldConfigItemName:
		m.ClearConfigItemName()
		return nil
	case productconfigitem.FieldDescription:
		m.ClearDescription()
		return nil
	case productconfigitem.FieldLongDescription:
		m.ClearLongDescription()
		return nil
	case productconfigitem.FieldImageURL:
		m.ClearImageURL()
		return nil
	}
	return fmt.Errorf("unknown ProductConfigItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductConfigItemMutation) ResetField(name string) error {
	switch name {
	case productconfigitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productconfigitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productconfigitem.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productconfigitem.FieldConfigItemTypeID:
		m.ResetConfigItemTypeID()
		return nil
	case productconfigitem.FieldConfigItemName:
		m.ResetConfigItemName()
		return nil
	case productconfigitem.FieldDescription:
		m.ResetDescription()
		return nil
	case productconfigitem.FieldLongDescription:
		m.ResetLongDescription()
		return nil
	case productconfigitem.FieldImageURL:
		m.ResetImageURL()
		return nil
	}
	return fmt.Errorf("unknown ProductConfigItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductConfigItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductConfigItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductConfigItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductConfigItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductConfigItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductConfigItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductConfigItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductConfigItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductConfigItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductConfigItem edge %s", name)
}

// ProductContentTypeMutation represents an operation that mutates the ProductContentType nodes in the graph.
type ProductContentTypeMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	string_ref                         *string
	has_table                          *productcontenttype.HasTable
	description                        *string
	clearedFields                      map[string]struct{}
	parent                             *int
	clearedparent                      bool
	children                           map[int]struct{}
	removedchildren                    map[int]struct{}
	clearedchildren                    bool
	child_product_content_types        map[int]struct{}
	removedchild_product_content_types map[int]struct{}
	clearedchild_product_content_types bool
	done                               bool
	oldValue                           func(context.Context) (*ProductContentType, error)
	predicates                         []predicate.ProductContentType
}

var _ ent.Mutation = (*ProductContentTypeMutation)(nil)

// productcontenttypeOption allows management of the mutation configuration using functional options.
type productcontenttypeOption func(*ProductContentTypeMutation)

// newProductContentTypeMutation creates new mutation for the ProductContentType entity.
func newProductContentTypeMutation(c config, op Op, opts ...productcontenttypeOption) *ProductContentTypeMutation {
	m := &ProductContentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductContentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductContentTypeID sets the ID field of the mutation.
func withProductContentTypeID(id int) productcontenttypeOption {
	return func(m *ProductContentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductContentType
		)
		m.oldValue = func(ctx context.Context) (*ProductContentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductContentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductContentType sets the old ProductContentType of the mutation.
func withProductContentType(node *ProductContentType) productcontenttypeOption {
	return func(m *ProductContentTypeMutation) {
		m.oldValue = func(context.Context) (*ProductContentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductContentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductContentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductContentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductContentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductContentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductContentType entity.
// If the ProductContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductContentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductContentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductContentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductContentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductContentType entity.
// If the ProductContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductContentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductContentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductContentTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductContentTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductContentType entity.
// If the ProductContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductContentTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductContentTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productcontenttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductContentTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productcontenttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductContentTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productcontenttype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductContentTypeMutation) SetHasTable(pt productcontenttype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductContentTypeMutation) HasTable() (r productcontenttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductContentType entity.
// If the ProductContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductContentTypeMutation) OldHasTable(ctx context.Context) (v productcontenttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductContentTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productcontenttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductContentTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productcontenttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductContentTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productcontenttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductContentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductContentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductContentType entity.
// If the ProductContentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductContentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductContentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productcontenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductContentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productcontenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductContentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productcontenttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductContentType entity by id.
func (m *ProductContentTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductContentType entity.
func (m *ProductContentTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductContentType entity was cleared.
func (m *ProductContentTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductContentTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductContentTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductContentTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductContentType entity by ids.
func (m *ProductContentTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductContentType entity.
func (m *ProductContentTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductContentType entity was cleared.
func (m *ProductContentTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductContentType entity by IDs.
func (m *ProductContentTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductContentType entity.
func (m *ProductContentTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductContentTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductContentTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProductContentTypeIDs adds the "child_product_content_types" edge to the ProductContentType entity by ids.
func (m *ProductContentTypeMutation) AddChildProductContentTypeIDs(ids ...int) {
	if m.child_product_content_types == nil {
		m.child_product_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_content_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductContentTypes clears the "child_product_content_types" edge to the ProductContentType entity.
func (m *ProductContentTypeMutation) ClearChildProductContentTypes() {
	m.clearedchild_product_content_types = true
}

// ChildProductContentTypesCleared reports if the "child_product_content_types" edge to the ProductContentType entity was cleared.
func (m *ProductContentTypeMutation) ChildProductContentTypesCleared() bool {
	return m.clearedchild_product_content_types
}

// RemoveChildProductContentTypeIDs removes the "child_product_content_types" edge to the ProductContentType entity by IDs.
func (m *ProductContentTypeMutation) RemoveChildProductContentTypeIDs(ids ...int) {
	if m.removedchild_product_content_types == nil {
		m.removedchild_product_content_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_content_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductContentTypes returns the removed IDs of the "child_product_content_types" edge to the ProductContentType entity.
func (m *ProductContentTypeMutation) RemovedChildProductContentTypesIDs() (ids []int) {
	for id := range m.removedchild_product_content_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductContentTypesIDs returns the "child_product_content_types" edge IDs in the mutation.
func (m *ProductContentTypeMutation) ChildProductContentTypesIDs() (ids []int) {
	for id := range m.child_product_content_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductContentTypes resets all changes to the "child_product_content_types" edge.
func (m *ProductContentTypeMutation) ResetChildProductContentTypes() {
	m.child_product_content_types = nil
	m.clearedchild_product_content_types = false
	m.removedchild_product_content_types = nil
}

// Op returns the operation name.
func (m *ProductContentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductContentType).
func (m *ProductContentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductContentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productcontenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productcontenttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productcontenttype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productcontenttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productcontenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductContentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcontenttype.FieldCreateTime:
		return m.CreateTime()
	case productcontenttype.FieldUpdateTime:
		return m.UpdateTime()
	case productcontenttype.FieldStringRef:
		return m.StringRef()
	case productcontenttype.FieldHasTable:
		return m.HasTable()
	case productcontenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductContentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcontenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productcontenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productcontenttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productcontenttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productcontenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductContentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductContentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcontenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productcontenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productcontenttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productcontenttype.FieldHasTable:
		v, ok := value.(productcontenttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productcontenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductContentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductContentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductContentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductContentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductContentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductContentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcontenttype.FieldStringRef) {
		fields = append(fields, productcontenttype.FieldStringRef)
	}
	if m.FieldCleared(productcontenttype.FieldHasTable) {
		fields = append(fields, productcontenttype.FieldHasTable)
	}
	if m.FieldCleared(productcontenttype.FieldDescription) {
		fields = append(fields, productcontenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductContentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductContentTypeMutation) ClearField(name string) error {
	switch name {
	case productcontenttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productcontenttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productcontenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductContentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductContentTypeMutation) ResetField(name string) error {
	switch name {
	case productcontenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productcontenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productcontenttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productcontenttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productcontenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductContentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductContentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, productcontenttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productcontenttype.EdgeChildren)
	}
	if m.child_product_content_types != nil {
		edges = append(edges, productcontenttype.EdgeChildProductContentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductContentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcontenttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productcontenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productcontenttype.EdgeChildProductContentTypes:
		ids := make([]ent.Value, 0, len(m.child_product_content_types))
		for id := range m.child_product_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductContentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, productcontenttype.EdgeChildren)
	}
	if m.removedchild_product_content_types != nil {
		edges = append(edges, productcontenttype.EdgeChildProductContentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductContentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcontenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productcontenttype.EdgeChildProductContentTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_content_types))
		for id := range m.removedchild_product_content_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductContentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, productcontenttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productcontenttype.EdgeChildren)
	}
	if m.clearedchild_product_content_types {
		edges = append(edges, productcontenttype.EdgeChildProductContentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductContentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productcontenttype.EdgeParent:
		return m.clearedparent
	case productcontenttype.EdgeChildren:
		return m.clearedchildren
	case productcontenttype.EdgeChildProductContentTypes:
		return m.clearedchild_product_content_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductContentTypeMutation) ClearEdge(name string) error {
	switch name {
	case productcontenttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductContentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductContentTypeMutation) ResetEdge(name string) error {
	switch name {
	case productcontenttype.EdgeParent:
		m.ResetParent()
		return nil
	case productcontenttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productcontenttype.EdgeChildProductContentTypes:
		m.ResetChildProductContentTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductContentType edge %s", name)
}

// ProductFeatureMutation represents an operation that mutates the ProductFeature nodes in the graph.
type ProductFeatureMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	create_time                     *time.Time
	update_time                     *time.Time
	string_ref                      *string
	description                     *string
	uom_id                          *int
	adduom_id                       *int
	number_specified                *float64
	addnumber_specified             *float64
	default_amount                  *float64
	adddefault_amount               *float64
	default_sequence_num            *int
	adddefault_sequence_num         *int
	abbrev                          *int
	addabbrev                       *int
	id_code                         *string
	clearedFields                   map[string]struct{}
	product_feature_category        *int
	clearedproduct_feature_category bool
	product_feature_type            *int
	clearedproduct_feature_type     bool
	done                            bool
	oldValue                        func(context.Context) (*ProductFeature, error)
	predicates                      []predicate.ProductFeature
}

var _ ent.Mutation = (*ProductFeatureMutation)(nil)

// productfeatureOption allows management of the mutation configuration using functional options.
type productfeatureOption func(*ProductFeatureMutation)

// newProductFeatureMutation creates new mutation for the ProductFeature entity.
func newProductFeatureMutation(c config, op Op, opts ...productfeatureOption) *ProductFeatureMutation {
	m := &ProductFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeProductFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductFeatureID sets the ID field of the mutation.
func withProductFeatureID(id int) productfeatureOption {
	return func(m *ProductFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductFeature
		)
		m.oldValue = func(ctx context.Context) (*ProductFeature, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductFeature sets the old ProductFeature of the mutation.
func withProductFeature(node *ProductFeature) productfeatureOption {
	return func(m *ProductFeatureMutation) {
		m.oldValue = func(context.Context) (*ProductFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductFeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductFeatureMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductFeatureMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductFeatureMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductFeatureMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductFeatureMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductFeatureMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductFeatureMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductFeatureMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductFeatureMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productfeature.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductFeatureMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductFeatureMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productfeature.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductFeatureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductFeatureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductFeatureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productfeature.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductFeatureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductFeatureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productfeature.FieldDescription)
}

// SetUomID sets the "uom_id" field.
func (m *ProductFeatureMutation) SetUomID(i int) {
	m.uom_id = &i
	m.adduom_id = nil
}

// UomID returns the value of the "uom_id" field in the mutation.
func (m *ProductFeatureMutation) UomID() (r int, exists bool) {
	v := m.uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUomID returns the old "uom_id" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUomID: %w", err)
	}
	return oldValue.UomID, nil
}

// AddUomID adds i to the "uom_id" field.
func (m *ProductFeatureMutation) AddUomID(i int) {
	if m.adduom_id != nil {
		*m.adduom_id += i
	} else {
		m.adduom_id = &i
	}
}

// AddedUomID returns the value that was added to the "uom_id" field in this mutation.
func (m *ProductFeatureMutation) AddedUomID() (r int, exists bool) {
	v := m.adduom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUomID clears the value of the "uom_id" field.
func (m *ProductFeatureMutation) ClearUomID() {
	m.uom_id = nil
	m.adduom_id = nil
	m.clearedFields[productfeature.FieldUomID] = struct{}{}
}

// UomIDCleared returns if the "uom_id" field was cleared in this mutation.
func (m *ProductFeatureMutation) UomIDCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldUomID]
	return ok
}

// ResetUomID resets all changes to the "uom_id" field.
func (m *ProductFeatureMutation) ResetUomID() {
	m.uom_id = nil
	m.adduom_id = nil
	delete(m.clearedFields, productfeature.FieldUomID)
}

// SetNumberSpecified sets the "number_specified" field.
func (m *ProductFeatureMutation) SetNumberSpecified(f float64) {
	m.number_specified = &f
	m.addnumber_specified = nil
}

// NumberSpecified returns the value of the "number_specified" field in the mutation.
func (m *ProductFeatureMutation) NumberSpecified() (r float64, exists bool) {
	v := m.number_specified
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberSpecified returns the old "number_specified" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldNumberSpecified(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumberSpecified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumberSpecified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberSpecified: %w", err)
	}
	return oldValue.NumberSpecified, nil
}

// AddNumberSpecified adds f to the "number_specified" field.
func (m *ProductFeatureMutation) AddNumberSpecified(f float64) {
	if m.addnumber_specified != nil {
		*m.addnumber_specified += f
	} else {
		m.addnumber_specified = &f
	}
}

// AddedNumberSpecified returns the value that was added to the "number_specified" field in this mutation.
func (m *ProductFeatureMutation) AddedNumberSpecified() (r float64, exists bool) {
	v := m.addnumber_specified
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberSpecified clears the value of the "number_specified" field.
func (m *ProductFeatureMutation) ClearNumberSpecified() {
	m.number_specified = nil
	m.addnumber_specified = nil
	m.clearedFields[productfeature.FieldNumberSpecified] = struct{}{}
}

// NumberSpecifiedCleared returns if the "number_specified" field was cleared in this mutation.
func (m *ProductFeatureMutation) NumberSpecifiedCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldNumberSpecified]
	return ok
}

// ResetNumberSpecified resets all changes to the "number_specified" field.
func (m *ProductFeatureMutation) ResetNumberSpecified() {
	m.number_specified = nil
	m.addnumber_specified = nil
	delete(m.clearedFields, productfeature.FieldNumberSpecified)
}

// SetDefaultAmount sets the "default_amount" field.
func (m *ProductFeatureMutation) SetDefaultAmount(f float64) {
	m.default_amount = &f
	m.adddefault_amount = nil
}

// DefaultAmount returns the value of the "default_amount" field in the mutation.
func (m *ProductFeatureMutation) DefaultAmount() (r float64, exists bool) {
	v := m.default_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultAmount returns the old "default_amount" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldDefaultAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultAmount: %w", err)
	}
	return oldValue.DefaultAmount, nil
}

// AddDefaultAmount adds f to the "default_amount" field.
func (m *ProductFeatureMutation) AddDefaultAmount(f float64) {
	if m.adddefault_amount != nil {
		*m.adddefault_amount += f
	} else {
		m.adddefault_amount = &f
	}
}

// AddedDefaultAmount returns the value that was added to the "default_amount" field in this mutation.
func (m *ProductFeatureMutation) AddedDefaultAmount() (r float64, exists bool) {
	v := m.adddefault_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultAmount clears the value of the "default_amount" field.
func (m *ProductFeatureMutation) ClearDefaultAmount() {
	m.default_amount = nil
	m.adddefault_amount = nil
	m.clearedFields[productfeature.FieldDefaultAmount] = struct{}{}
}

// DefaultAmountCleared returns if the "default_amount" field was cleared in this mutation.
func (m *ProductFeatureMutation) DefaultAmountCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldDefaultAmount]
	return ok
}

// ResetDefaultAmount resets all changes to the "default_amount" field.
func (m *ProductFeatureMutation) ResetDefaultAmount() {
	m.default_amount = nil
	m.adddefault_amount = nil
	delete(m.clearedFields, productfeature.FieldDefaultAmount)
}

// SetDefaultSequenceNum sets the "default_sequence_num" field.
func (m *ProductFeatureMutation) SetDefaultSequenceNum(i int) {
	m.default_sequence_num = &i
	m.adddefault_sequence_num = nil
}

// DefaultSequenceNum returns the value of the "default_sequence_num" field in the mutation.
func (m *ProductFeatureMutation) DefaultSequenceNum() (r int, exists bool) {
	v := m.default_sequence_num
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultSequenceNum returns the old "default_sequence_num" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldDefaultSequenceNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultSequenceNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultSequenceNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultSequenceNum: %w", err)
	}
	return oldValue.DefaultSequenceNum, nil
}

// AddDefaultSequenceNum adds i to the "default_sequence_num" field.
func (m *ProductFeatureMutation) AddDefaultSequenceNum(i int) {
	if m.adddefault_sequence_num != nil {
		*m.adddefault_sequence_num += i
	} else {
		m.adddefault_sequence_num = &i
	}
}

// AddedDefaultSequenceNum returns the value that was added to the "default_sequence_num" field in this mutation.
func (m *ProductFeatureMutation) AddedDefaultSequenceNum() (r int, exists bool) {
	v := m.adddefault_sequence_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultSequenceNum clears the value of the "default_sequence_num" field.
func (m *ProductFeatureMutation) ClearDefaultSequenceNum() {
	m.default_sequence_num = nil
	m.adddefault_sequence_num = nil
	m.clearedFields[productfeature.FieldDefaultSequenceNum] = struct{}{}
}

// DefaultSequenceNumCleared returns if the "default_sequence_num" field was cleared in this mutation.
func (m *ProductFeatureMutation) DefaultSequenceNumCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldDefaultSequenceNum]
	return ok
}

// ResetDefaultSequenceNum resets all changes to the "default_sequence_num" field.
func (m *ProductFeatureMutation) ResetDefaultSequenceNum() {
	m.default_sequence_num = nil
	m.adddefault_sequence_num = nil
	delete(m.clearedFields, productfeature.FieldDefaultSequenceNum)
}

// SetAbbrev sets the "abbrev" field.
func (m *ProductFeatureMutation) SetAbbrev(i int) {
	m.abbrev = &i
	m.addabbrev = nil
}

// Abbrev returns the value of the "abbrev" field in the mutation.
func (m *ProductFeatureMutation) Abbrev() (r int, exists bool) {
	v := m.abbrev
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbrev returns the old "abbrev" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldAbbrev(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbbrev is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbbrev requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbrev: %w", err)
	}
	return oldValue.Abbrev, nil
}

// AddAbbrev adds i to the "abbrev" field.
func (m *ProductFeatureMutation) AddAbbrev(i int) {
	if m.addabbrev != nil {
		*m.addabbrev += i
	} else {
		m.addabbrev = &i
	}
}

// AddedAbbrev returns the value that was added to the "abbrev" field in this mutation.
func (m *ProductFeatureMutation) AddedAbbrev() (r int, exists bool) {
	v := m.addabbrev
	if v == nil {
		return
	}
	return *v, true
}

// ClearAbbrev clears the value of the "abbrev" field.
func (m *ProductFeatureMutation) ClearAbbrev() {
	m.abbrev = nil
	m.addabbrev = nil
	m.clearedFields[productfeature.FieldAbbrev] = struct{}{}
}

// AbbrevCleared returns if the "abbrev" field was cleared in this mutation.
func (m *ProductFeatureMutation) AbbrevCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldAbbrev]
	return ok
}

// ResetAbbrev resets all changes to the "abbrev" field.
func (m *ProductFeatureMutation) ResetAbbrev() {
	m.abbrev = nil
	m.addabbrev = nil
	delete(m.clearedFields, productfeature.FieldAbbrev)
}

// SetIDCode sets the "id_code" field.
func (m *ProductFeatureMutation) SetIDCode(s string) {
	m.id_code = &s
}

// IDCode returns the value of the "id_code" field in the mutation.
func (m *ProductFeatureMutation) IDCode() (r string, exists bool) {
	v := m.id_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCode returns the old "id_code" field's value of the ProductFeature entity.
// If the ProductFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureMutation) OldIDCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIDCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIDCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCode: %w", err)
	}
	return oldValue.IDCode, nil
}

// ClearIDCode clears the value of the "id_code" field.
func (m *ProductFeatureMutation) ClearIDCode() {
	m.id_code = nil
	m.clearedFields[productfeature.FieldIDCode] = struct{}{}
}

// IDCodeCleared returns if the "id_code" field was cleared in this mutation.
func (m *ProductFeatureMutation) IDCodeCleared() bool {
	_, ok := m.clearedFields[productfeature.FieldIDCode]
	return ok
}

// ResetIDCode resets all changes to the "id_code" field.
func (m *ProductFeatureMutation) ResetIDCode() {
	m.id_code = nil
	delete(m.clearedFields, productfeature.FieldIDCode)
}

// SetProductFeatureCategoryID sets the "product_feature_category" edge to the ProductFeatureCategory entity by id.
func (m *ProductFeatureMutation) SetProductFeatureCategoryID(id int) {
	m.product_feature_category = &id
}

// ClearProductFeatureCategory clears the "product_feature_category" edge to the ProductFeatureCategory entity.
func (m *ProductFeatureMutation) ClearProductFeatureCategory() {
	m.clearedproduct_feature_category = true
}

// ProductFeatureCategoryCleared reports if the "product_feature_category" edge to the ProductFeatureCategory entity was cleared.
func (m *ProductFeatureMutation) ProductFeatureCategoryCleared() bool {
	return m.clearedproduct_feature_category
}

// ProductFeatureCategoryID returns the "product_feature_category" edge ID in the mutation.
func (m *ProductFeatureMutation) ProductFeatureCategoryID() (id int, exists bool) {
	if m.product_feature_category != nil {
		return *m.product_feature_category, true
	}
	return
}

// ProductFeatureCategoryIDs returns the "product_feature_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductFeatureCategoryID instead. It exists only for internal usage by the builders.
func (m *ProductFeatureMutation) ProductFeatureCategoryIDs() (ids []int) {
	if id := m.product_feature_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductFeatureCategory resets all changes to the "product_feature_category" edge.
func (m *ProductFeatureMutation) ResetProductFeatureCategory() {
	m.product_feature_category = nil
	m.clearedproduct_feature_category = false
}

// SetProductFeatureTypeID sets the "product_feature_type" edge to the ProductFeatureType entity by id.
func (m *ProductFeatureMutation) SetProductFeatureTypeID(id int) {
	m.product_feature_type = &id
}

// ClearProductFeatureType clears the "product_feature_type" edge to the ProductFeatureType entity.
func (m *ProductFeatureMutation) ClearProductFeatureType() {
	m.clearedproduct_feature_type = true
}

// ProductFeatureTypeCleared reports if the "product_feature_type" edge to the ProductFeatureType entity was cleared.
func (m *ProductFeatureMutation) ProductFeatureTypeCleared() bool {
	return m.clearedproduct_feature_type
}

// ProductFeatureTypeID returns the "product_feature_type" edge ID in the mutation.
func (m *ProductFeatureMutation) ProductFeatureTypeID() (id int, exists bool) {
	if m.product_feature_type != nil {
		return *m.product_feature_type, true
	}
	return
}

// ProductFeatureTypeIDs returns the "product_feature_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductFeatureTypeID instead. It exists only for internal usage by the builders.
func (m *ProductFeatureMutation) ProductFeatureTypeIDs() (ids []int) {
	if id := m.product_feature_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductFeatureType resets all changes to the "product_feature_type" edge.
func (m *ProductFeatureMutation) ResetProductFeatureType() {
	m.product_feature_type = nil
	m.clearedproduct_feature_type = false
}

// Op returns the operation name.
func (m *ProductFeatureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductFeature).
func (m *ProductFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductFeatureMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, productfeature.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productfeature.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productfeature.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productfeature.FieldDescription)
	}
	if m.uom_id != nil {
		fields = append(fields, productfeature.FieldUomID)
	}
	if m.number_specified != nil {
		fields = append(fields, productfeature.FieldNumberSpecified)
	}
	if m.default_amount != nil {
		fields = append(fields, productfeature.FieldDefaultAmount)
	}
	if m.default_sequence_num != nil {
		fields = append(fields, productfeature.FieldDefaultSequenceNum)
	}
	if m.abbrev != nil {
		fields = append(fields, productfeature.FieldAbbrev)
	}
	if m.id_code != nil {
		fields = append(fields, productfeature.FieldIDCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductFeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productfeature.FieldCreateTime:
		return m.CreateTime()
	case productfeature.FieldUpdateTime:
		return m.UpdateTime()
	case productfeature.FieldStringRef:
		return m.StringRef()
	case productfeature.FieldDescription:
		return m.Description()
	case productfeature.FieldUomID:
		return m.UomID()
	case productfeature.FieldNumberSpecified:
		return m.NumberSpecified()
	case productfeature.FieldDefaultAmount:
		return m.DefaultAmount()
	case productfeature.FieldDefaultSequenceNum:
		return m.DefaultSequenceNum()
	case productfeature.FieldAbbrev:
		return m.Abbrev()
	case productfeature.FieldIDCode:
		return m.IDCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productfeature.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productfeature.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productfeature.FieldStringRef:
		return m.OldStringRef(ctx)
	case productfeature.FieldDescription:
		return m.OldDescription(ctx)
	case productfeature.FieldUomID:
		return m.OldUomID(ctx)
	case productfeature.FieldNumberSpecified:
		return m.OldNumberSpecified(ctx)
	case productfeature.FieldDefaultAmount:
		return m.OldDefaultAmount(ctx)
	case productfeature.FieldDefaultSequenceNum:
		return m.OldDefaultSequenceNum(ctx)
	case productfeature.FieldAbbrev:
		return m.OldAbbrev(ctx)
	case productfeature.FieldIDCode:
		return m.OldIDCode(ctx)
	}
	return nil, fmt.Errorf("unknown ProductFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productfeature.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productfeature.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productfeature.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productfeature.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productfeature.FieldUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUomID(v)
		return nil
	case productfeature.FieldNumberSpecified:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberSpecified(v)
		return nil
	case productfeature.FieldDefaultAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultAmount(v)
		return nil
	case productfeature.FieldDefaultSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultSequenceNum(v)
		return nil
	case productfeature.FieldAbbrev:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbrev(v)
		return nil
	case productfeature.FieldIDCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCode(v)
		return nil
	}
	return fmt.Errorf("unknown ProductFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductFeatureMutation) AddedFields() []string {
	var fields []string
	if m.adduom_id != nil {
		fields = append(fields, productfeature.FieldUomID)
	}
	if m.addnumber_specified != nil {
		fields = append(fields, productfeature.FieldNumberSpecified)
	}
	if m.adddefault_amount != nil {
		fields = append(fields, productfeature.FieldDefaultAmount)
	}
	if m.adddefault_sequence_num != nil {
		fields = append(fields, productfeature.FieldDefaultSequenceNum)
	}
	if m.addabbrev != nil {
		fields = append(fields, productfeature.FieldAbbrev)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductFeatureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productfeature.FieldUomID:
		return m.AddedUomID()
	case productfeature.FieldNumberSpecified:
		return m.AddedNumberSpecified()
	case productfeature.FieldDefaultAmount:
		return m.AddedDefaultAmount()
	case productfeature.FieldDefaultSequenceNum:
		return m.AddedDefaultSequenceNum()
	case productfeature.FieldAbbrev:
		return m.AddedAbbrev()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productfeature.FieldUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUomID(v)
		return nil
	case productfeature.FieldNumberSpecified:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberSpecified(v)
		return nil
	case productfeature.FieldDefaultAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultAmount(v)
		return nil
	case productfeature.FieldDefaultSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultSequenceNum(v)
		return nil
	case productfeature.FieldAbbrev:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbbrev(v)
		return nil
	}
	return fmt.Errorf("unknown ProductFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductFeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productfeature.FieldStringRef) {
		fields = append(fields, productfeature.FieldStringRef)
	}
	if m.FieldCleared(productfeature.FieldDescription) {
		fields = append(fields, productfeature.FieldDescription)
	}
	if m.FieldCleared(productfeature.FieldUomID) {
		fields = append(fields, productfeature.FieldUomID)
	}
	if m.FieldCleared(productfeature.FieldNumberSpecified) {
		fields = append(fields, productfeature.FieldNumberSpecified)
	}
	if m.FieldCleared(productfeature.FieldDefaultAmount) {
		fields = append(fields, productfeature.FieldDefaultAmount)
	}
	if m.FieldCleared(productfeature.FieldDefaultSequenceNum) {
		fields = append(fields, productfeature.FieldDefaultSequenceNum)
	}
	if m.FieldCleared(productfeature.FieldAbbrev) {
		fields = append(fields, productfeature.FieldAbbrev)
	}
	if m.FieldCleared(productfeature.FieldIDCode) {
		fields = append(fields, productfeature.FieldIDCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductFeatureMutation) ClearField(name string) error {
	switch name {
	case productfeature.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productfeature.FieldDescription:
		m.ClearDescription()
		return nil
	case productfeature.FieldUomID:
		m.ClearUomID()
		return nil
	case productfeature.FieldNumberSpecified:
		m.ClearNumberSpecified()
		return nil
	case productfeature.FieldDefaultAmount:
		m.ClearDefaultAmount()
		return nil
	case productfeature.FieldDefaultSequenceNum:
		m.ClearDefaultSequenceNum()
		return nil
	case productfeature.FieldAbbrev:
		m.ClearAbbrev()
		return nil
	case productfeature.FieldIDCode:
		m.ClearIDCode()
		return nil
	}
	return fmt.Errorf("unknown ProductFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductFeatureMutation) ResetField(name string) error {
	switch name {
	case productfeature.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productfeature.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productfeature.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productfeature.FieldDescription:
		m.ResetDescription()
		return nil
	case productfeature.FieldUomID:
		m.ResetUomID()
		return nil
	case productfeature.FieldNumberSpecified:
		m.ResetNumberSpecified()
		return nil
	case productfeature.FieldDefaultAmount:
		m.ResetDefaultAmount()
		return nil
	case productfeature.FieldDefaultSequenceNum:
		m.ResetDefaultSequenceNum()
		return nil
	case productfeature.FieldAbbrev:
		m.ResetAbbrev()
		return nil
	case productfeature.FieldIDCode:
		m.ResetIDCode()
		return nil
	}
	return fmt.Errorf("unknown ProductFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.product_feature_category != nil {
		edges = append(edges, productfeature.EdgeProductFeatureCategory)
	}
	if m.product_feature_type != nil {
		edges = append(edges, productfeature.EdgeProductFeatureType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productfeature.EdgeProductFeatureCategory:
		if id := m.product_feature_category; id != nil {
			return []ent.Value{*id}
		}
	case productfeature.EdgeProductFeatureType:
		if id := m.product_feature_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductFeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproduct_feature_category {
		edges = append(edges, productfeature.EdgeProductFeatureCategory)
	}
	if m.clearedproduct_feature_type {
		edges = append(edges, productfeature.EdgeProductFeatureType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case productfeature.EdgeProductFeatureCategory:
		return m.clearedproduct_feature_category
	case productfeature.EdgeProductFeatureType:
		return m.clearedproduct_feature_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductFeatureMutation) ClearEdge(name string) error {
	switch name {
	case productfeature.EdgeProductFeatureCategory:
		m.ClearProductFeatureCategory()
		return nil
	case productfeature.EdgeProductFeatureType:
		m.ClearProductFeatureType()
		return nil
	}
	return fmt.Errorf("unknown ProductFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductFeatureMutation) ResetEdge(name string) error {
	switch name {
	case productfeature.EdgeProductFeatureCategory:
		m.ResetProductFeatureCategory()
		return nil
	case productfeature.EdgeProductFeatureType:
		m.ResetProductFeatureType()
		return nil
	}
	return fmt.Errorf("unknown ProductFeature edge %s", name)
}

// ProductFeatureApplTypeMutation represents an operation that mutates the ProductFeatureApplType nodes in the graph.
type ProductFeatureApplTypeMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	create_time                             *time.Time
	update_time                             *time.Time
	string_ref                              *string
	has_table                               *productfeatureappltype.HasTable
	description                             *string
	clearedFields                           map[string]struct{}
	parent                                  *int
	clearedparent                           bool
	children                                map[int]struct{}
	removedchildren                         map[int]struct{}
	clearedchildren                         bool
	child_product_feature_appl_types        map[int]struct{}
	removedchild_product_feature_appl_types map[int]struct{}
	clearedchild_product_feature_appl_types bool
	done                                    bool
	oldValue                                func(context.Context) (*ProductFeatureApplType, error)
	predicates                              []predicate.ProductFeatureApplType
}

var _ ent.Mutation = (*ProductFeatureApplTypeMutation)(nil)

// productfeatureappltypeOption allows management of the mutation configuration using functional options.
type productfeatureappltypeOption func(*ProductFeatureApplTypeMutation)

// newProductFeatureApplTypeMutation creates new mutation for the ProductFeatureApplType entity.
func newProductFeatureApplTypeMutation(c config, op Op, opts ...productfeatureappltypeOption) *ProductFeatureApplTypeMutation {
	m := &ProductFeatureApplTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductFeatureApplType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductFeatureApplTypeID sets the ID field of the mutation.
func withProductFeatureApplTypeID(id int) productfeatureappltypeOption {
	return func(m *ProductFeatureApplTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductFeatureApplType
		)
		m.oldValue = func(ctx context.Context) (*ProductFeatureApplType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductFeatureApplType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductFeatureApplType sets the old ProductFeatureApplType of the mutation.
func withProductFeatureApplType(node *ProductFeatureApplType) productfeatureappltypeOption {
	return func(m *ProductFeatureApplTypeMutation) {
		m.oldValue = func(context.Context) (*ProductFeatureApplType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductFeatureApplTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductFeatureApplTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductFeatureApplTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductFeatureApplTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductFeatureApplTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductFeatureApplType entity.
// If the ProductFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureApplTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductFeatureApplTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductFeatureApplTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductFeatureApplTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductFeatureApplType entity.
// If the ProductFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureApplTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductFeatureApplTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductFeatureApplTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductFeatureApplTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductFeatureApplType entity.
// If the ProductFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureApplTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductFeatureApplTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productfeatureappltype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductFeatureApplTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productfeatureappltype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductFeatureApplTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productfeatureappltype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductFeatureApplTypeMutation) SetHasTable(pt productfeatureappltype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductFeatureApplTypeMutation) HasTable() (r productfeatureappltype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductFeatureApplType entity.
// If the ProductFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureApplTypeMutation) OldHasTable(ctx context.Context) (v productfeatureappltype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductFeatureApplTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productfeatureappltype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductFeatureApplTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productfeatureappltype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductFeatureApplTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productfeatureappltype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductFeatureApplTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductFeatureApplTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductFeatureApplType entity.
// If the ProductFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureApplTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductFeatureApplTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productfeatureappltype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductFeatureApplTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productfeatureappltype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductFeatureApplTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productfeatureappltype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductFeatureApplType entity by id.
func (m *ProductFeatureApplTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductFeatureApplType entity.
func (m *ProductFeatureApplTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductFeatureApplType entity was cleared.
func (m *ProductFeatureApplTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductFeatureApplTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductFeatureApplTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductFeatureApplTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductFeatureApplType entity by ids.
func (m *ProductFeatureApplTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductFeatureApplType entity.
func (m *ProductFeatureApplTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductFeatureApplType entity was cleared.
func (m *ProductFeatureApplTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductFeatureApplType entity by IDs.
func (m *ProductFeatureApplTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductFeatureApplType entity.
func (m *ProductFeatureApplTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductFeatureApplTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductFeatureApplTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProductFeatureApplTypeIDs adds the "child_product_feature_appl_types" edge to the ProductFeatureApplType entity by ids.
func (m *ProductFeatureApplTypeMutation) AddChildProductFeatureApplTypeIDs(ids ...int) {
	if m.child_product_feature_appl_types == nil {
		m.child_product_feature_appl_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_feature_appl_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductFeatureApplTypes clears the "child_product_feature_appl_types" edge to the ProductFeatureApplType entity.
func (m *ProductFeatureApplTypeMutation) ClearChildProductFeatureApplTypes() {
	m.clearedchild_product_feature_appl_types = true
}

// ChildProductFeatureApplTypesCleared reports if the "child_product_feature_appl_types" edge to the ProductFeatureApplType entity was cleared.
func (m *ProductFeatureApplTypeMutation) ChildProductFeatureApplTypesCleared() bool {
	return m.clearedchild_product_feature_appl_types
}

// RemoveChildProductFeatureApplTypeIDs removes the "child_product_feature_appl_types" edge to the ProductFeatureApplType entity by IDs.
func (m *ProductFeatureApplTypeMutation) RemoveChildProductFeatureApplTypeIDs(ids ...int) {
	if m.removedchild_product_feature_appl_types == nil {
		m.removedchild_product_feature_appl_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_feature_appl_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductFeatureApplTypes returns the removed IDs of the "child_product_feature_appl_types" edge to the ProductFeatureApplType entity.
func (m *ProductFeatureApplTypeMutation) RemovedChildProductFeatureApplTypesIDs() (ids []int) {
	for id := range m.removedchild_product_feature_appl_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductFeatureApplTypesIDs returns the "child_product_feature_appl_types" edge IDs in the mutation.
func (m *ProductFeatureApplTypeMutation) ChildProductFeatureApplTypesIDs() (ids []int) {
	for id := range m.child_product_feature_appl_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductFeatureApplTypes resets all changes to the "child_product_feature_appl_types" edge.
func (m *ProductFeatureApplTypeMutation) ResetChildProductFeatureApplTypes() {
	m.child_product_feature_appl_types = nil
	m.clearedchild_product_feature_appl_types = false
	m.removedchild_product_feature_appl_types = nil
}

// Op returns the operation name.
func (m *ProductFeatureApplTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductFeatureApplType).
func (m *ProductFeatureApplTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductFeatureApplTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productfeatureappltype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productfeatureappltype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productfeatureappltype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productfeatureappltype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productfeatureappltype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductFeatureApplTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productfeatureappltype.FieldCreateTime:
		return m.CreateTime()
	case productfeatureappltype.FieldUpdateTime:
		return m.UpdateTime()
	case productfeatureappltype.FieldStringRef:
		return m.StringRef()
	case productfeatureappltype.FieldHasTable:
		return m.HasTable()
	case productfeatureappltype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductFeatureApplTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productfeatureappltype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productfeatureappltype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productfeatureappltype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productfeatureappltype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productfeatureappltype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductFeatureApplType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureApplTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productfeatureappltype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productfeatureappltype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productfeatureappltype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productfeatureappltype.FieldHasTable:
		v, ok := value.(productfeatureappltype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productfeatureappltype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureApplType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductFeatureApplTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductFeatureApplTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureApplTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductFeatureApplType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductFeatureApplTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productfeatureappltype.FieldStringRef) {
		fields = append(fields, productfeatureappltype.FieldStringRef)
	}
	if m.FieldCleared(productfeatureappltype.FieldHasTable) {
		fields = append(fields, productfeatureappltype.FieldHasTable)
	}
	if m.FieldCleared(productfeatureappltype.FieldDescription) {
		fields = append(fields, productfeatureappltype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductFeatureApplTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductFeatureApplTypeMutation) ClearField(name string) error {
	switch name {
	case productfeatureappltype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productfeatureappltype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productfeatureappltype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureApplType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductFeatureApplTypeMutation) ResetField(name string) error {
	switch name {
	case productfeatureappltype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productfeatureappltype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productfeatureappltype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productfeatureappltype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productfeatureappltype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureApplType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductFeatureApplTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, productfeatureappltype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productfeatureappltype.EdgeChildren)
	}
	if m.child_product_feature_appl_types != nil {
		edges = append(edges, productfeatureappltype.EdgeChildProductFeatureApplTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductFeatureApplTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productfeatureappltype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productfeatureappltype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productfeatureappltype.EdgeChildProductFeatureApplTypes:
		ids := make([]ent.Value, 0, len(m.child_product_feature_appl_types))
		for id := range m.child_product_feature_appl_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductFeatureApplTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, productfeatureappltype.EdgeChildren)
	}
	if m.removedchild_product_feature_appl_types != nil {
		edges = append(edges, productfeatureappltype.EdgeChildProductFeatureApplTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductFeatureApplTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productfeatureappltype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productfeatureappltype.EdgeChildProductFeatureApplTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_feature_appl_types))
		for id := range m.removedchild_product_feature_appl_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductFeatureApplTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, productfeatureappltype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productfeatureappltype.EdgeChildren)
	}
	if m.clearedchild_product_feature_appl_types {
		edges = append(edges, productfeatureappltype.EdgeChildProductFeatureApplTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductFeatureApplTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productfeatureappltype.EdgeParent:
		return m.clearedparent
	case productfeatureappltype.EdgeChildren:
		return m.clearedchildren
	case productfeatureappltype.EdgeChildProductFeatureApplTypes:
		return m.clearedchild_product_feature_appl_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductFeatureApplTypeMutation) ClearEdge(name string) error {
	switch name {
	case productfeatureappltype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureApplType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductFeatureApplTypeMutation) ResetEdge(name string) error {
	switch name {
	case productfeatureappltype.EdgeParent:
		m.ResetParent()
		return nil
	case productfeatureappltype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productfeatureappltype.EdgeChildProductFeatureApplTypes:
		m.ResetChildProductFeatureApplTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureApplType edge %s", name)
}

// ProductFeatureCategoryMutation represents an operation that mutates the ProductFeatureCategory nodes in the graph.
type ProductFeatureCategoryMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	create_time                             *time.Time
	update_time                             *time.Time
	string_ref                              *string
	description                             *string
	clearedFields                           map[string]struct{}
	parent                                  *int
	clearedparent                           bool
	children                                map[int]struct{}
	removedchildren                         map[int]struct{}
	clearedchildren                         bool
	product_features                        map[int]struct{}
	removedproduct_features                 map[int]struct{}
	clearedproduct_features                 bool
	child_product_feature_categories        map[int]struct{}
	removedchild_product_feature_categories map[int]struct{}
	clearedchild_product_feature_categories bool
	done                                    bool
	oldValue                                func(context.Context) (*ProductFeatureCategory, error)
	predicates                              []predicate.ProductFeatureCategory
}

var _ ent.Mutation = (*ProductFeatureCategoryMutation)(nil)

// productfeaturecategoryOption allows management of the mutation configuration using functional options.
type productfeaturecategoryOption func(*ProductFeatureCategoryMutation)

// newProductFeatureCategoryMutation creates new mutation for the ProductFeatureCategory entity.
func newProductFeatureCategoryMutation(c config, op Op, opts ...productfeaturecategoryOption) *ProductFeatureCategoryMutation {
	m := &ProductFeatureCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProductFeatureCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductFeatureCategoryID sets the ID field of the mutation.
func withProductFeatureCategoryID(id int) productfeaturecategoryOption {
	return func(m *ProductFeatureCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductFeatureCategory
		)
		m.oldValue = func(ctx context.Context) (*ProductFeatureCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductFeatureCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductFeatureCategory sets the old ProductFeatureCategory of the mutation.
func withProductFeatureCategory(node *ProductFeatureCategory) productfeaturecategoryOption {
	return func(m *ProductFeatureCategoryMutation) {
		m.oldValue = func(context.Context) (*ProductFeatureCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductFeatureCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductFeatureCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductFeatureCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductFeatureCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductFeatureCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductFeatureCategory entity.
// If the ProductFeatureCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductFeatureCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductFeatureCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductFeatureCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductFeatureCategory entity.
// If the ProductFeatureCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductFeatureCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductFeatureCategoryMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductFeatureCategoryMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductFeatureCategory entity.
// If the ProductFeatureCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureCategoryMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductFeatureCategoryMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productfeaturecategory.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductFeatureCategoryMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productfeaturecategory.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductFeatureCategoryMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productfeaturecategory.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductFeatureCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductFeatureCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductFeatureCategory entity.
// If the ProductFeatureCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductFeatureCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productfeaturecategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductFeatureCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productfeaturecategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductFeatureCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productfeaturecategory.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductFeatureCategory entity by id.
func (m *ProductFeatureCategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductFeatureCategory entity.
func (m *ProductFeatureCategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductFeatureCategory entity was cleared.
func (m *ProductFeatureCategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductFeatureCategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductFeatureCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductFeatureCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductFeatureCategory entity by ids.
func (m *ProductFeatureCategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductFeatureCategory entity.
func (m *ProductFeatureCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductFeatureCategory entity was cleared.
func (m *ProductFeatureCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductFeatureCategory entity by IDs.
func (m *ProductFeatureCategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductFeatureCategory entity.
func (m *ProductFeatureCategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductFeatureCategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductFeatureCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductFeatureIDs adds the "product_features" edge to the ProductFeature entity by ids.
func (m *ProductFeatureCategoryMutation) AddProductFeatureIDs(ids ...int) {
	if m.product_features == nil {
		m.product_features = make(map[int]struct{})
	}
	for i := range ids {
		m.product_features[ids[i]] = struct{}{}
	}
}

// ClearProductFeatures clears the "product_features" edge to the ProductFeature entity.
func (m *ProductFeatureCategoryMutation) ClearProductFeatures() {
	m.clearedproduct_features = true
}

// ProductFeaturesCleared reports if the "product_features" edge to the ProductFeature entity was cleared.
func (m *ProductFeatureCategoryMutation) ProductFeaturesCleared() bool {
	return m.clearedproduct_features
}

// RemoveProductFeatureIDs removes the "product_features" edge to the ProductFeature entity by IDs.
func (m *ProductFeatureCategoryMutation) RemoveProductFeatureIDs(ids ...int) {
	if m.removedproduct_features == nil {
		m.removedproduct_features = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_features[ids[i]] = struct{}{}
	}
}

// RemovedProductFeatures returns the removed IDs of the "product_features" edge to the ProductFeature entity.
func (m *ProductFeatureCategoryMutation) RemovedProductFeaturesIDs() (ids []int) {
	for id := range m.removedproduct_features {
		ids = append(ids, id)
	}
	return
}

// ProductFeaturesIDs returns the "product_features" edge IDs in the mutation.
func (m *ProductFeatureCategoryMutation) ProductFeaturesIDs() (ids []int) {
	for id := range m.product_features {
		ids = append(ids, id)
	}
	return
}

// ResetProductFeatures resets all changes to the "product_features" edge.
func (m *ProductFeatureCategoryMutation) ResetProductFeatures() {
	m.product_features = nil
	m.clearedproduct_features = false
	m.removedproduct_features = nil
}

// AddChildProductFeatureCategoryIDs adds the "child_product_feature_categories" edge to the ProductFeatureCategory entity by ids.
func (m *ProductFeatureCategoryMutation) AddChildProductFeatureCategoryIDs(ids ...int) {
	if m.child_product_feature_categories == nil {
		m.child_product_feature_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_feature_categories[ids[i]] = struct{}{}
	}
}

// ClearChildProductFeatureCategories clears the "child_product_feature_categories" edge to the ProductFeatureCategory entity.
func (m *ProductFeatureCategoryMutation) ClearChildProductFeatureCategories() {
	m.clearedchild_product_feature_categories = true
}

// ChildProductFeatureCategoriesCleared reports if the "child_product_feature_categories" edge to the ProductFeatureCategory entity was cleared.
func (m *ProductFeatureCategoryMutation) ChildProductFeatureCategoriesCleared() bool {
	return m.clearedchild_product_feature_categories
}

// RemoveChildProductFeatureCategoryIDs removes the "child_product_feature_categories" edge to the ProductFeatureCategory entity by IDs.
func (m *ProductFeatureCategoryMutation) RemoveChildProductFeatureCategoryIDs(ids ...int) {
	if m.removedchild_product_feature_categories == nil {
		m.removedchild_product_feature_categories = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_feature_categories[ids[i]] = struct{}{}
	}
}

// RemovedChildProductFeatureCategories returns the removed IDs of the "child_product_feature_categories" edge to the ProductFeatureCategory entity.
func (m *ProductFeatureCategoryMutation) RemovedChildProductFeatureCategoriesIDs() (ids []int) {
	for id := range m.removedchild_product_feature_categories {
		ids = append(ids, id)
	}
	return
}

// ChildProductFeatureCategoriesIDs returns the "child_product_feature_categories" edge IDs in the mutation.
func (m *ProductFeatureCategoryMutation) ChildProductFeatureCategoriesIDs() (ids []int) {
	for id := range m.child_product_feature_categories {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductFeatureCategories resets all changes to the "child_product_feature_categories" edge.
func (m *ProductFeatureCategoryMutation) ResetChildProductFeatureCategories() {
	m.child_product_feature_categories = nil
	m.clearedchild_product_feature_categories = false
	m.removedchild_product_feature_categories = nil
}

// Op returns the operation name.
func (m *ProductFeatureCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductFeatureCategory).
func (m *ProductFeatureCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductFeatureCategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, productfeaturecategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productfeaturecategory.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productfeaturecategory.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productfeaturecategory.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductFeatureCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productfeaturecategory.FieldCreateTime:
		return m.CreateTime()
	case productfeaturecategory.FieldUpdateTime:
		return m.UpdateTime()
	case productfeaturecategory.FieldStringRef:
		return m.StringRef()
	case productfeaturecategory.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductFeatureCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productfeaturecategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productfeaturecategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productfeaturecategory.FieldStringRef:
		return m.OldStringRef(ctx)
	case productfeaturecategory.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductFeatureCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productfeaturecategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productfeaturecategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productfeaturecategory.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productfeaturecategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductFeatureCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductFeatureCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductFeatureCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductFeatureCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productfeaturecategory.FieldStringRef) {
		fields = append(fields, productfeaturecategory.FieldStringRef)
	}
	if m.FieldCleared(productfeaturecategory.FieldDescription) {
		fields = append(fields, productfeaturecategory.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductFeatureCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductFeatureCategoryMutation) ClearField(name string) error {
	switch name {
	case productfeaturecategory.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productfeaturecategory.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductFeatureCategoryMutation) ResetField(name string) error {
	switch name {
	case productfeaturecategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productfeaturecategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productfeaturecategory.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productfeaturecategory.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductFeatureCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, productfeaturecategory.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productfeaturecategory.EdgeChildren)
	}
	if m.product_features != nil {
		edges = append(edges, productfeaturecategory.EdgeProductFeatures)
	}
	if m.child_product_feature_categories != nil {
		edges = append(edges, productfeaturecategory.EdgeChildProductFeatureCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductFeatureCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productfeaturecategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productfeaturecategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productfeaturecategory.EdgeProductFeatures:
		ids := make([]ent.Value, 0, len(m.product_features))
		for id := range m.product_features {
			ids = append(ids, id)
		}
		return ids
	case productfeaturecategory.EdgeChildProductFeatureCategories:
		ids := make([]ent.Value, 0, len(m.child_product_feature_categories))
		for id := range m.child_product_feature_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductFeatureCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, productfeaturecategory.EdgeChildren)
	}
	if m.removedproduct_features != nil {
		edges = append(edges, productfeaturecategory.EdgeProductFeatures)
	}
	if m.removedchild_product_feature_categories != nil {
		edges = append(edges, productfeaturecategory.EdgeChildProductFeatureCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductFeatureCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productfeaturecategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productfeaturecategory.EdgeProductFeatures:
		ids := make([]ent.Value, 0, len(m.removedproduct_features))
		for id := range m.removedproduct_features {
			ids = append(ids, id)
		}
		return ids
	case productfeaturecategory.EdgeChildProductFeatureCategories:
		ids := make([]ent.Value, 0, len(m.removedchild_product_feature_categories))
		for id := range m.removedchild_product_feature_categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductFeatureCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, productfeaturecategory.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productfeaturecategory.EdgeChildren)
	}
	if m.clearedproduct_features {
		edges = append(edges, productfeaturecategory.EdgeProductFeatures)
	}
	if m.clearedchild_product_feature_categories {
		edges = append(edges, productfeaturecategory.EdgeChildProductFeatureCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductFeatureCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case productfeaturecategory.EdgeParent:
		return m.clearedparent
	case productfeaturecategory.EdgeChildren:
		return m.clearedchildren
	case productfeaturecategory.EdgeProductFeatures:
		return m.clearedproduct_features
	case productfeaturecategory.EdgeChildProductFeatureCategories:
		return m.clearedchild_product_feature_categories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductFeatureCategoryMutation) ClearEdge(name string) error {
	switch name {
	case productfeaturecategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductFeatureCategoryMutation) ResetEdge(name string) error {
	switch name {
	case productfeaturecategory.EdgeParent:
		m.ResetParent()
		return nil
	case productfeaturecategory.EdgeChildren:
		m.ResetChildren()
		return nil
	case productfeaturecategory.EdgeProductFeatures:
		m.ResetProductFeatures()
		return nil
	case productfeaturecategory.EdgeChildProductFeatureCategories:
		m.ResetChildProductFeatureCategories()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureCategory edge %s", name)
}

// ProductFeatureIactnTypeMutation represents an operation that mutates the ProductFeatureIactnType nodes in the graph.
type ProductFeatureIactnTypeMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	create_time                              *time.Time
	update_time                              *time.Time
	string_ref                               *string
	has_table                                *productfeatureiactntype.HasTable
	description                              *string
	clearedFields                            map[string]struct{}
	parent                                   *int
	clearedparent                            bool
	children                                 map[int]struct{}
	removedchildren                          map[int]struct{}
	clearedchildren                          bool
	child_product_feature_iactn_types        map[int]struct{}
	removedchild_product_feature_iactn_types map[int]struct{}
	clearedchild_product_feature_iactn_types bool
	done                                     bool
	oldValue                                 func(context.Context) (*ProductFeatureIactnType, error)
	predicates                               []predicate.ProductFeatureIactnType
}

var _ ent.Mutation = (*ProductFeatureIactnTypeMutation)(nil)

// productfeatureiactntypeOption allows management of the mutation configuration using functional options.
type productfeatureiactntypeOption func(*ProductFeatureIactnTypeMutation)

// newProductFeatureIactnTypeMutation creates new mutation for the ProductFeatureIactnType entity.
func newProductFeatureIactnTypeMutation(c config, op Op, opts ...productfeatureiactntypeOption) *ProductFeatureIactnTypeMutation {
	m := &ProductFeatureIactnTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductFeatureIactnType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductFeatureIactnTypeID sets the ID field of the mutation.
func withProductFeatureIactnTypeID(id int) productfeatureiactntypeOption {
	return func(m *ProductFeatureIactnTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductFeatureIactnType
		)
		m.oldValue = func(ctx context.Context) (*ProductFeatureIactnType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductFeatureIactnType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductFeatureIactnType sets the old ProductFeatureIactnType of the mutation.
func withProductFeatureIactnType(node *ProductFeatureIactnType) productfeatureiactntypeOption {
	return func(m *ProductFeatureIactnTypeMutation) {
		m.oldValue = func(context.Context) (*ProductFeatureIactnType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductFeatureIactnTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductFeatureIactnTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductFeatureIactnTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductFeatureIactnTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductFeatureIactnTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductFeatureIactnType entity.
// If the ProductFeatureIactnType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureIactnTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductFeatureIactnTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductFeatureIactnTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductFeatureIactnTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductFeatureIactnType entity.
// If the ProductFeatureIactnType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureIactnTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductFeatureIactnTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductFeatureIactnTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductFeatureIactnTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductFeatureIactnType entity.
// If the ProductFeatureIactnType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureIactnTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductFeatureIactnTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productfeatureiactntype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductFeatureIactnTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productfeatureiactntype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductFeatureIactnTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productfeatureiactntype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductFeatureIactnTypeMutation) SetHasTable(pt productfeatureiactntype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductFeatureIactnTypeMutation) HasTable() (r productfeatureiactntype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductFeatureIactnType entity.
// If the ProductFeatureIactnType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureIactnTypeMutation) OldHasTable(ctx context.Context) (v productfeatureiactntype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductFeatureIactnTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productfeatureiactntype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductFeatureIactnTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productfeatureiactntype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductFeatureIactnTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productfeatureiactntype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductFeatureIactnTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductFeatureIactnTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductFeatureIactnType entity.
// If the ProductFeatureIactnType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureIactnTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductFeatureIactnTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productfeatureiactntype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductFeatureIactnTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productfeatureiactntype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductFeatureIactnTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productfeatureiactntype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductFeatureIactnType entity by id.
func (m *ProductFeatureIactnTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductFeatureIactnType entity.
func (m *ProductFeatureIactnTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductFeatureIactnType entity was cleared.
func (m *ProductFeatureIactnTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductFeatureIactnTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductFeatureIactnTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductFeatureIactnTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductFeatureIactnType entity by ids.
func (m *ProductFeatureIactnTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductFeatureIactnType entity.
func (m *ProductFeatureIactnTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductFeatureIactnType entity was cleared.
func (m *ProductFeatureIactnTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductFeatureIactnType entity by IDs.
func (m *ProductFeatureIactnTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductFeatureIactnType entity.
func (m *ProductFeatureIactnTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductFeatureIactnTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductFeatureIactnTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProductFeatureIactnTypeIDs adds the "child_product_feature_iactn_types" edge to the ProductFeatureIactnType entity by ids.
func (m *ProductFeatureIactnTypeMutation) AddChildProductFeatureIactnTypeIDs(ids ...int) {
	if m.child_product_feature_iactn_types == nil {
		m.child_product_feature_iactn_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_feature_iactn_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductFeatureIactnTypes clears the "child_product_feature_iactn_types" edge to the ProductFeatureIactnType entity.
func (m *ProductFeatureIactnTypeMutation) ClearChildProductFeatureIactnTypes() {
	m.clearedchild_product_feature_iactn_types = true
}

// ChildProductFeatureIactnTypesCleared reports if the "child_product_feature_iactn_types" edge to the ProductFeatureIactnType entity was cleared.
func (m *ProductFeatureIactnTypeMutation) ChildProductFeatureIactnTypesCleared() bool {
	return m.clearedchild_product_feature_iactn_types
}

// RemoveChildProductFeatureIactnTypeIDs removes the "child_product_feature_iactn_types" edge to the ProductFeatureIactnType entity by IDs.
func (m *ProductFeatureIactnTypeMutation) RemoveChildProductFeatureIactnTypeIDs(ids ...int) {
	if m.removedchild_product_feature_iactn_types == nil {
		m.removedchild_product_feature_iactn_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_feature_iactn_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductFeatureIactnTypes returns the removed IDs of the "child_product_feature_iactn_types" edge to the ProductFeatureIactnType entity.
func (m *ProductFeatureIactnTypeMutation) RemovedChildProductFeatureIactnTypesIDs() (ids []int) {
	for id := range m.removedchild_product_feature_iactn_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductFeatureIactnTypesIDs returns the "child_product_feature_iactn_types" edge IDs in the mutation.
func (m *ProductFeatureIactnTypeMutation) ChildProductFeatureIactnTypesIDs() (ids []int) {
	for id := range m.child_product_feature_iactn_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductFeatureIactnTypes resets all changes to the "child_product_feature_iactn_types" edge.
func (m *ProductFeatureIactnTypeMutation) ResetChildProductFeatureIactnTypes() {
	m.child_product_feature_iactn_types = nil
	m.clearedchild_product_feature_iactn_types = false
	m.removedchild_product_feature_iactn_types = nil
}

// Op returns the operation name.
func (m *ProductFeatureIactnTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductFeatureIactnType).
func (m *ProductFeatureIactnTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductFeatureIactnTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productfeatureiactntype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productfeatureiactntype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productfeatureiactntype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productfeatureiactntype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productfeatureiactntype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductFeatureIactnTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productfeatureiactntype.FieldCreateTime:
		return m.CreateTime()
	case productfeatureiactntype.FieldUpdateTime:
		return m.UpdateTime()
	case productfeatureiactntype.FieldStringRef:
		return m.StringRef()
	case productfeatureiactntype.FieldHasTable:
		return m.HasTable()
	case productfeatureiactntype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductFeatureIactnTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productfeatureiactntype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productfeatureiactntype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productfeatureiactntype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productfeatureiactntype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productfeatureiactntype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductFeatureIactnType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureIactnTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productfeatureiactntype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productfeatureiactntype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productfeatureiactntype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productfeatureiactntype.FieldHasTable:
		v, ok := value.(productfeatureiactntype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productfeatureiactntype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureIactnType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductFeatureIactnTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductFeatureIactnTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureIactnTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductFeatureIactnType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductFeatureIactnTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productfeatureiactntype.FieldStringRef) {
		fields = append(fields, productfeatureiactntype.FieldStringRef)
	}
	if m.FieldCleared(productfeatureiactntype.FieldHasTable) {
		fields = append(fields, productfeatureiactntype.FieldHasTable)
	}
	if m.FieldCleared(productfeatureiactntype.FieldDescription) {
		fields = append(fields, productfeatureiactntype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductFeatureIactnTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductFeatureIactnTypeMutation) ClearField(name string) error {
	switch name {
	case productfeatureiactntype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productfeatureiactntype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productfeatureiactntype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureIactnType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductFeatureIactnTypeMutation) ResetField(name string) error {
	switch name {
	case productfeatureiactntype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productfeatureiactntype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productfeatureiactntype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productfeatureiactntype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productfeatureiactntype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureIactnType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductFeatureIactnTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, productfeatureiactntype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productfeatureiactntype.EdgeChildren)
	}
	if m.child_product_feature_iactn_types != nil {
		edges = append(edges, productfeatureiactntype.EdgeChildProductFeatureIactnTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductFeatureIactnTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productfeatureiactntype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productfeatureiactntype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productfeatureiactntype.EdgeChildProductFeatureIactnTypes:
		ids := make([]ent.Value, 0, len(m.child_product_feature_iactn_types))
		for id := range m.child_product_feature_iactn_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductFeatureIactnTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, productfeatureiactntype.EdgeChildren)
	}
	if m.removedchild_product_feature_iactn_types != nil {
		edges = append(edges, productfeatureiactntype.EdgeChildProductFeatureIactnTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductFeatureIactnTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productfeatureiactntype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productfeatureiactntype.EdgeChildProductFeatureIactnTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_feature_iactn_types))
		for id := range m.removedchild_product_feature_iactn_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductFeatureIactnTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, productfeatureiactntype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productfeatureiactntype.EdgeChildren)
	}
	if m.clearedchild_product_feature_iactn_types {
		edges = append(edges, productfeatureiactntype.EdgeChildProductFeatureIactnTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductFeatureIactnTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productfeatureiactntype.EdgeParent:
		return m.clearedparent
	case productfeatureiactntype.EdgeChildren:
		return m.clearedchildren
	case productfeatureiactntype.EdgeChildProductFeatureIactnTypes:
		return m.clearedchild_product_feature_iactn_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductFeatureIactnTypeMutation) ClearEdge(name string) error {
	switch name {
	case productfeatureiactntype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureIactnType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductFeatureIactnTypeMutation) ResetEdge(name string) error {
	switch name {
	case productfeatureiactntype.EdgeParent:
		m.ResetParent()
		return nil
	case productfeatureiactntype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productfeatureiactntype.EdgeChildProductFeatureIactnTypes:
		m.ResetChildProductFeatureIactnTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureIactnType edge %s", name)
}

// ProductFeatureTypeMutation represents an operation that mutates the ProductFeatureType nodes in the graph.
type ProductFeatureTypeMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	create_time                        *time.Time
	update_time                        *time.Time
	string_ref                         *string
	has_table                          *productfeaturetype.HasTable
	description                        *string
	clearedFields                      map[string]struct{}
	parent                             *int
	clearedparent                      bool
	children                           map[int]struct{}
	removedchildren                    map[int]struct{}
	clearedchildren                    bool
	product_features                   map[int]struct{}
	removedproduct_features            map[int]struct{}
	clearedproduct_features            bool
	child_product_feature_types        map[int]struct{}
	removedchild_product_feature_types map[int]struct{}
	clearedchild_product_feature_types bool
	done                               bool
	oldValue                           func(context.Context) (*ProductFeatureType, error)
	predicates                         []predicate.ProductFeatureType
}

var _ ent.Mutation = (*ProductFeatureTypeMutation)(nil)

// productfeaturetypeOption allows management of the mutation configuration using functional options.
type productfeaturetypeOption func(*ProductFeatureTypeMutation)

// newProductFeatureTypeMutation creates new mutation for the ProductFeatureType entity.
func newProductFeatureTypeMutation(c config, op Op, opts ...productfeaturetypeOption) *ProductFeatureTypeMutation {
	m := &ProductFeatureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductFeatureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductFeatureTypeID sets the ID field of the mutation.
func withProductFeatureTypeID(id int) productfeaturetypeOption {
	return func(m *ProductFeatureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductFeatureType
		)
		m.oldValue = func(ctx context.Context) (*ProductFeatureType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductFeatureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductFeatureType sets the old ProductFeatureType of the mutation.
func withProductFeatureType(node *ProductFeatureType) productfeaturetypeOption {
	return func(m *ProductFeatureTypeMutation) {
		m.oldValue = func(context.Context) (*ProductFeatureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductFeatureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductFeatureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductFeatureTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductFeatureTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductFeatureTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductFeatureType entity.
// If the ProductFeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductFeatureTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductFeatureTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductFeatureTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductFeatureType entity.
// If the ProductFeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductFeatureTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductFeatureTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductFeatureTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductFeatureType entity.
// If the ProductFeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductFeatureTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productfeaturetype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductFeatureTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productfeaturetype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductFeatureTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productfeaturetype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ProductFeatureTypeMutation) SetHasTable(pt productfeaturetype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductFeatureTypeMutation) HasTable() (r productfeaturetype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductFeatureType entity.
// If the ProductFeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureTypeMutation) OldHasTable(ctx context.Context) (v productfeaturetype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductFeatureTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[productfeaturetype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductFeatureTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[productfeaturetype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductFeatureTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, productfeaturetype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductFeatureTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductFeatureTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductFeatureType entity.
// If the ProductFeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductFeatureTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductFeatureTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productfeaturetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductFeatureTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productfeaturetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductFeatureTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productfeaturetype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductFeatureType entity by id.
func (m *ProductFeatureTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductFeatureType entity.
func (m *ProductFeatureTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductFeatureType entity was cleared.
func (m *ProductFeatureTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductFeatureTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductFeatureTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductFeatureTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductFeatureType entity by ids.
func (m *ProductFeatureTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductFeatureType entity.
func (m *ProductFeatureTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductFeatureType entity was cleared.
func (m *ProductFeatureTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductFeatureType entity by IDs.
func (m *ProductFeatureTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductFeatureType entity.
func (m *ProductFeatureTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductFeatureTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductFeatureTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductFeatureIDs adds the "product_features" edge to the ProductFeature entity by ids.
func (m *ProductFeatureTypeMutation) AddProductFeatureIDs(ids ...int) {
	if m.product_features == nil {
		m.product_features = make(map[int]struct{})
	}
	for i := range ids {
		m.product_features[ids[i]] = struct{}{}
	}
}

// ClearProductFeatures clears the "product_features" edge to the ProductFeature entity.
func (m *ProductFeatureTypeMutation) ClearProductFeatures() {
	m.clearedproduct_features = true
}

// ProductFeaturesCleared reports if the "product_features" edge to the ProductFeature entity was cleared.
func (m *ProductFeatureTypeMutation) ProductFeaturesCleared() bool {
	return m.clearedproduct_features
}

// RemoveProductFeatureIDs removes the "product_features" edge to the ProductFeature entity by IDs.
func (m *ProductFeatureTypeMutation) RemoveProductFeatureIDs(ids ...int) {
	if m.removedproduct_features == nil {
		m.removedproduct_features = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_features[ids[i]] = struct{}{}
	}
}

// RemovedProductFeatures returns the removed IDs of the "product_features" edge to the ProductFeature entity.
func (m *ProductFeatureTypeMutation) RemovedProductFeaturesIDs() (ids []int) {
	for id := range m.removedproduct_features {
		ids = append(ids, id)
	}
	return
}

// ProductFeaturesIDs returns the "product_features" edge IDs in the mutation.
func (m *ProductFeatureTypeMutation) ProductFeaturesIDs() (ids []int) {
	for id := range m.product_features {
		ids = append(ids, id)
	}
	return
}

// ResetProductFeatures resets all changes to the "product_features" edge.
func (m *ProductFeatureTypeMutation) ResetProductFeatures() {
	m.product_features = nil
	m.clearedproduct_features = false
	m.removedproduct_features = nil
}

// AddChildProductFeatureTypeIDs adds the "child_product_feature_types" edge to the ProductFeatureType entity by ids.
func (m *ProductFeatureTypeMutation) AddChildProductFeatureTypeIDs(ids ...int) {
	if m.child_product_feature_types == nil {
		m.child_product_feature_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_feature_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductFeatureTypes clears the "child_product_feature_types" edge to the ProductFeatureType entity.
func (m *ProductFeatureTypeMutation) ClearChildProductFeatureTypes() {
	m.clearedchild_product_feature_types = true
}

// ChildProductFeatureTypesCleared reports if the "child_product_feature_types" edge to the ProductFeatureType entity was cleared.
func (m *ProductFeatureTypeMutation) ChildProductFeatureTypesCleared() bool {
	return m.clearedchild_product_feature_types
}

// RemoveChildProductFeatureTypeIDs removes the "child_product_feature_types" edge to the ProductFeatureType entity by IDs.
func (m *ProductFeatureTypeMutation) RemoveChildProductFeatureTypeIDs(ids ...int) {
	if m.removedchild_product_feature_types == nil {
		m.removedchild_product_feature_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_feature_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductFeatureTypes returns the removed IDs of the "child_product_feature_types" edge to the ProductFeatureType entity.
func (m *ProductFeatureTypeMutation) RemovedChildProductFeatureTypesIDs() (ids []int) {
	for id := range m.removedchild_product_feature_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductFeatureTypesIDs returns the "child_product_feature_types" edge IDs in the mutation.
func (m *ProductFeatureTypeMutation) ChildProductFeatureTypesIDs() (ids []int) {
	for id := range m.child_product_feature_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductFeatureTypes resets all changes to the "child_product_feature_types" edge.
func (m *ProductFeatureTypeMutation) ResetChildProductFeatureTypes() {
	m.child_product_feature_types = nil
	m.clearedchild_product_feature_types = false
	m.removedchild_product_feature_types = nil
}

// Op returns the operation name.
func (m *ProductFeatureTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductFeatureType).
func (m *ProductFeatureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductFeatureTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productfeaturetype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productfeaturetype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productfeaturetype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, productfeaturetype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, productfeaturetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductFeatureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productfeaturetype.FieldCreateTime:
		return m.CreateTime()
	case productfeaturetype.FieldUpdateTime:
		return m.UpdateTime()
	case productfeaturetype.FieldStringRef:
		return m.StringRef()
	case productfeaturetype.FieldHasTable:
		return m.HasTable()
	case productfeaturetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductFeatureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productfeaturetype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productfeaturetype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productfeaturetype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productfeaturetype.FieldHasTable:
		return m.OldHasTable(ctx)
	case productfeaturetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductFeatureType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productfeaturetype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productfeaturetype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productfeaturetype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productfeaturetype.FieldHasTable:
		v, ok := value.(productfeaturetype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case productfeaturetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductFeatureTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductFeatureTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductFeatureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductFeatureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductFeatureTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productfeaturetype.FieldStringRef) {
		fields = append(fields, productfeaturetype.FieldStringRef)
	}
	if m.FieldCleared(productfeaturetype.FieldHasTable) {
		fields = append(fields, productfeaturetype.FieldHasTable)
	}
	if m.FieldCleared(productfeaturetype.FieldDescription) {
		fields = append(fields, productfeaturetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductFeatureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductFeatureTypeMutation) ClearField(name string) error {
	switch name {
	case productfeaturetype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productfeaturetype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case productfeaturetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductFeatureTypeMutation) ResetField(name string) error {
	switch name {
	case productfeaturetype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productfeaturetype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productfeaturetype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productfeaturetype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case productfeaturetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductFeatureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, productfeaturetype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productfeaturetype.EdgeChildren)
	}
	if m.product_features != nil {
		edges = append(edges, productfeaturetype.EdgeProductFeatures)
	}
	if m.child_product_feature_types != nil {
		edges = append(edges, productfeaturetype.EdgeChildProductFeatureTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductFeatureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productfeaturetype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productfeaturetype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productfeaturetype.EdgeProductFeatures:
		ids := make([]ent.Value, 0, len(m.product_features))
		for id := range m.product_features {
			ids = append(ids, id)
		}
		return ids
	case productfeaturetype.EdgeChildProductFeatureTypes:
		ids := make([]ent.Value, 0, len(m.child_product_feature_types))
		for id := range m.child_product_feature_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductFeatureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, productfeaturetype.EdgeChildren)
	}
	if m.removedproduct_features != nil {
		edges = append(edges, productfeaturetype.EdgeProductFeatures)
	}
	if m.removedchild_product_feature_types != nil {
		edges = append(edges, productfeaturetype.EdgeChildProductFeatureTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductFeatureTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productfeaturetype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productfeaturetype.EdgeProductFeatures:
		ids := make([]ent.Value, 0, len(m.removedproduct_features))
		for id := range m.removedproduct_features {
			ids = append(ids, id)
		}
		return ids
	case productfeaturetype.EdgeChildProductFeatureTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_feature_types))
		for id := range m.removedchild_product_feature_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductFeatureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, productfeaturetype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productfeaturetype.EdgeChildren)
	}
	if m.clearedproduct_features {
		edges = append(edges, productfeaturetype.EdgeProductFeatures)
	}
	if m.clearedchild_product_feature_types {
		edges = append(edges, productfeaturetype.EdgeChildProductFeatureTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductFeatureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productfeaturetype.EdgeParent:
		return m.clearedparent
	case productfeaturetype.EdgeChildren:
		return m.clearedchildren
	case productfeaturetype.EdgeProductFeatures:
		return m.clearedproduct_features
	case productfeaturetype.EdgeChildProductFeatureTypes:
		return m.clearedchild_product_feature_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductFeatureTypeMutation) ClearEdge(name string) error {
	switch name {
	case productfeaturetype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductFeatureTypeMutation) ResetEdge(name string) error {
	switch name {
	case productfeaturetype.EdgeParent:
		m.ResetParent()
		return nil
	case productfeaturetype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productfeaturetype.EdgeProductFeatures:
		m.ResetProductFeatures()
		return nil
	case productfeaturetype.EdgeChildProductFeatureTypes:
		m.ResetChildProductFeatureTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductFeatureType edge %s", name)
}

// ProductMaintTypeMutation represents an operation that mutates the ProductMaintType nodes in the graph.
type ProductMaintTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	create_time                      *time.Time
	update_time                      *time.Time
	string_ref                       *string
	description                      *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	children                         map[int]struct{}
	removedchildren                  map[int]struct{}
	clearedchildren                  bool
	child_product_maint_types        map[int]struct{}
	removedchild_product_maint_types map[int]struct{}
	clearedchild_product_maint_types bool
	done                             bool
	oldValue                         func(context.Context) (*ProductMaintType, error)
	predicates                       []predicate.ProductMaintType
}

var _ ent.Mutation = (*ProductMaintTypeMutation)(nil)

// productmainttypeOption allows management of the mutation configuration using functional options.
type productmainttypeOption func(*ProductMaintTypeMutation)

// newProductMaintTypeMutation creates new mutation for the ProductMaintType entity.
func newProductMaintTypeMutation(c config, op Op, opts ...productmainttypeOption) *ProductMaintTypeMutation {
	m := &ProductMaintTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductMaintType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductMaintTypeID sets the ID field of the mutation.
func withProductMaintTypeID(id int) productmainttypeOption {
	return func(m *ProductMaintTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductMaintType
		)
		m.oldValue = func(ctx context.Context) (*ProductMaintType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductMaintType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductMaintType sets the old ProductMaintType of the mutation.
func withProductMaintType(node *ProductMaintType) productmainttypeOption {
	return func(m *ProductMaintTypeMutation) {
		m.oldValue = func(context.Context) (*ProductMaintType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMaintTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMaintTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMaintTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductMaintTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductMaintTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductMaintType entity.
// If the ProductMaintType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMaintTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductMaintTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductMaintTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductMaintTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductMaintType entity.
// If the ProductMaintType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMaintTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductMaintTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductMaintTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductMaintTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductMaintType entity.
// If the ProductMaintType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMaintTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductMaintTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productmainttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductMaintTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productmainttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductMaintTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productmainttype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductMaintTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMaintTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductMaintType entity.
// If the ProductMaintType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMaintTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMaintTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productmainttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMaintTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productmainttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMaintTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productmainttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductMaintType entity by id.
func (m *ProductMaintTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductMaintType entity.
func (m *ProductMaintTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductMaintType entity was cleared.
func (m *ProductMaintTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductMaintTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductMaintTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductMaintTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductMaintType entity by ids.
func (m *ProductMaintTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductMaintType entity.
func (m *ProductMaintTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductMaintType entity was cleared.
func (m *ProductMaintTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductMaintType entity by IDs.
func (m *ProductMaintTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductMaintType entity.
func (m *ProductMaintTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductMaintTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductMaintTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildProductMaintTypeIDs adds the "child_product_maint_types" edge to the ProductMaintType entity by ids.
func (m *ProductMaintTypeMutation) AddChildProductMaintTypeIDs(ids ...int) {
	if m.child_product_maint_types == nil {
		m.child_product_maint_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_maint_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductMaintTypes clears the "child_product_maint_types" edge to the ProductMaintType entity.
func (m *ProductMaintTypeMutation) ClearChildProductMaintTypes() {
	m.clearedchild_product_maint_types = true
}

// ChildProductMaintTypesCleared reports if the "child_product_maint_types" edge to the ProductMaintType entity was cleared.
func (m *ProductMaintTypeMutation) ChildProductMaintTypesCleared() bool {
	return m.clearedchild_product_maint_types
}

// RemoveChildProductMaintTypeIDs removes the "child_product_maint_types" edge to the ProductMaintType entity by IDs.
func (m *ProductMaintTypeMutation) RemoveChildProductMaintTypeIDs(ids ...int) {
	if m.removedchild_product_maint_types == nil {
		m.removedchild_product_maint_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_maint_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductMaintTypes returns the removed IDs of the "child_product_maint_types" edge to the ProductMaintType entity.
func (m *ProductMaintTypeMutation) RemovedChildProductMaintTypesIDs() (ids []int) {
	for id := range m.removedchild_product_maint_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductMaintTypesIDs returns the "child_product_maint_types" edge IDs in the mutation.
func (m *ProductMaintTypeMutation) ChildProductMaintTypesIDs() (ids []int) {
	for id := range m.child_product_maint_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductMaintTypes resets all changes to the "child_product_maint_types" edge.
func (m *ProductMaintTypeMutation) ResetChildProductMaintTypes() {
	m.child_product_maint_types = nil
	m.clearedchild_product_maint_types = false
	m.removedchild_product_maint_types = nil
}

// Op returns the operation name.
func (m *ProductMaintTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductMaintType).
func (m *ProductMaintTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMaintTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, productmainttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productmainttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productmainttype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productmainttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMaintTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productmainttype.FieldCreateTime:
		return m.CreateTime()
	case productmainttype.FieldUpdateTime:
		return m.UpdateTime()
	case productmainttype.FieldStringRef:
		return m.StringRef()
	case productmainttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMaintTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productmainttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productmainttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productmainttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productmainttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductMaintType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMaintTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productmainttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productmainttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productmainttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productmainttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMaintType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMaintTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMaintTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMaintTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductMaintType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMaintTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productmainttype.FieldStringRef) {
		fields = append(fields, productmainttype.FieldStringRef)
	}
	if m.FieldCleared(productmainttype.FieldDescription) {
		fields = append(fields, productmainttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMaintTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMaintTypeMutation) ClearField(name string) error {
	switch name {
	case productmainttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productmainttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductMaintType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMaintTypeMutation) ResetField(name string) error {
	switch name {
	case productmainttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productmainttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productmainttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productmainttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductMaintType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMaintTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, productmainttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productmainttype.EdgeChildren)
	}
	if m.child_product_maint_types != nil {
		edges = append(edges, productmainttype.EdgeChildProductMaintTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMaintTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productmainttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productmainttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productmainttype.EdgeChildProductMaintTypes:
		ids := make([]ent.Value, 0, len(m.child_product_maint_types))
		for id := range m.child_product_maint_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMaintTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, productmainttype.EdgeChildren)
	}
	if m.removedchild_product_maint_types != nil {
		edges = append(edges, productmainttype.EdgeChildProductMaintTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMaintTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productmainttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productmainttype.EdgeChildProductMaintTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_maint_types))
		for id := range m.removedchild_product_maint_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMaintTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, productmainttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productmainttype.EdgeChildren)
	}
	if m.clearedchild_product_maint_types {
		edges = append(edges, productmainttype.EdgeChildProductMaintTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMaintTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productmainttype.EdgeParent:
		return m.clearedparent
	case productmainttype.EdgeChildren:
		return m.clearedchildren
	case productmainttype.EdgeChildProductMaintTypes:
		return m.clearedchild_product_maint_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMaintTypeMutation) ClearEdge(name string) error {
	switch name {
	case productmainttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductMaintType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMaintTypeMutation) ResetEdge(name string) error {
	switch name {
	case productmainttype.EdgeParent:
		m.ResetParent()
		return nil
	case productmainttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case productmainttype.EdgeChildProductMaintTypes:
		m.ResetChildProductMaintTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductMaintType edge %s", name)
}

// ProductMeterTypeMutation represents an operation that mutates the ProductMeterType nodes in the graph.
type ProductMeterTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	string_ref        *string
	description       *string
	default_uom_id    *int
	adddefault_uom_id *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ProductMeterType, error)
	predicates        []predicate.ProductMeterType
}

var _ ent.Mutation = (*ProductMeterTypeMutation)(nil)

// productmetertypeOption allows management of the mutation configuration using functional options.
type productmetertypeOption func(*ProductMeterTypeMutation)

// newProductMeterTypeMutation creates new mutation for the ProductMeterType entity.
func newProductMeterTypeMutation(c config, op Op, opts ...productmetertypeOption) *ProductMeterTypeMutation {
	m := &ProductMeterTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductMeterType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductMeterTypeID sets the ID field of the mutation.
func withProductMeterTypeID(id int) productmetertypeOption {
	return func(m *ProductMeterTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductMeterType
		)
		m.oldValue = func(ctx context.Context) (*ProductMeterType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductMeterType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductMeterType sets the old ProductMeterType of the mutation.
func withProductMeterType(node *ProductMeterType) productmetertypeOption {
	return func(m *ProductMeterTypeMutation) {
		m.oldValue = func(context.Context) (*ProductMeterType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMeterTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMeterTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMeterTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductMeterTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductMeterTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductMeterType entity.
// If the ProductMeterType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMeterTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductMeterTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductMeterTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductMeterTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductMeterType entity.
// If the ProductMeterType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMeterTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductMeterTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductMeterTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductMeterTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductMeterType entity.
// If the ProductMeterType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMeterTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductMeterTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productmetertype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductMeterTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productmetertype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductMeterTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productmetertype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductMeterTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMeterTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductMeterType entity.
// If the ProductMeterType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMeterTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductMeterTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productmetertype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductMeterTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productmetertype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMeterTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productmetertype.FieldDescription)
}

// SetDefaultUomID sets the "default_uom_id" field.
func (m *ProductMeterTypeMutation) SetDefaultUomID(i int) {
	m.default_uom_id = &i
	m.adddefault_uom_id = nil
}

// DefaultUomID returns the value of the "default_uom_id" field in the mutation.
func (m *ProductMeterTypeMutation) DefaultUomID() (r int, exists bool) {
	v := m.default_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultUomID returns the old "default_uom_id" field's value of the ProductMeterType entity.
// If the ProductMeterType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMeterTypeMutation) OldDefaultUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultUomID: %w", err)
	}
	return oldValue.DefaultUomID, nil
}

// AddDefaultUomID adds i to the "default_uom_id" field.
func (m *ProductMeterTypeMutation) AddDefaultUomID(i int) {
	if m.adddefault_uom_id != nil {
		*m.adddefault_uom_id += i
	} else {
		m.adddefault_uom_id = &i
	}
}

// AddedDefaultUomID returns the value that was added to the "default_uom_id" field in this mutation.
func (m *ProductMeterTypeMutation) AddedDefaultUomID() (r int, exists bool) {
	v := m.adddefault_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultUomID clears the value of the "default_uom_id" field.
func (m *ProductMeterTypeMutation) ClearDefaultUomID() {
	m.default_uom_id = nil
	m.adddefault_uom_id = nil
	m.clearedFields[productmetertype.FieldDefaultUomID] = struct{}{}
}

// DefaultUomIDCleared returns if the "default_uom_id" field was cleared in this mutation.
func (m *ProductMeterTypeMutation) DefaultUomIDCleared() bool {
	_, ok := m.clearedFields[productmetertype.FieldDefaultUomID]
	return ok
}

// ResetDefaultUomID resets all changes to the "default_uom_id" field.
func (m *ProductMeterTypeMutation) ResetDefaultUomID() {
	m.default_uom_id = nil
	m.adddefault_uom_id = nil
	delete(m.clearedFields, productmetertype.FieldDefaultUomID)
}

// Op returns the operation name.
func (m *ProductMeterTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductMeterType).
func (m *ProductMeterTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMeterTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, productmetertype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productmetertype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productmetertype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productmetertype.FieldDescription)
	}
	if m.default_uom_id != nil {
		fields = append(fields, productmetertype.FieldDefaultUomID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMeterTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productmetertype.FieldCreateTime:
		return m.CreateTime()
	case productmetertype.FieldUpdateTime:
		return m.UpdateTime()
	case productmetertype.FieldStringRef:
		return m.StringRef()
	case productmetertype.FieldDescription:
		return m.Description()
	case productmetertype.FieldDefaultUomID:
		return m.DefaultUomID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMeterTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productmetertype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productmetertype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productmetertype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productmetertype.FieldDescription:
		return m.OldDescription(ctx)
	case productmetertype.FieldDefaultUomID:
		return m.OldDefaultUomID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductMeterType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMeterTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productmetertype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productmetertype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productmetertype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productmetertype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productmetertype.FieldDefaultUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultUomID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMeterType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMeterTypeMutation) AddedFields() []string {
	var fields []string
	if m.adddefault_uom_id != nil {
		fields = append(fields, productmetertype.FieldDefaultUomID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMeterTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productmetertype.FieldDefaultUomID:
		return m.AddedDefaultUomID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMeterTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productmetertype.FieldDefaultUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultUomID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductMeterType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMeterTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productmetertype.FieldStringRef) {
		fields = append(fields, productmetertype.FieldStringRef)
	}
	if m.FieldCleared(productmetertype.FieldDescription) {
		fields = append(fields, productmetertype.FieldDescription)
	}
	if m.FieldCleared(productmetertype.FieldDefaultUomID) {
		fields = append(fields, productmetertype.FieldDefaultUomID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMeterTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMeterTypeMutation) ClearField(name string) error {
	switch name {
	case productmetertype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productmetertype.FieldDescription:
		m.ClearDescription()
		return nil
	case productmetertype.FieldDefaultUomID:
		m.ClearDefaultUomID()
		return nil
	}
	return fmt.Errorf("unknown ProductMeterType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMeterTypeMutation) ResetField(name string) error {
	switch name {
	case productmetertype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productmetertype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productmetertype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productmetertype.FieldDescription:
		m.ResetDescription()
		return nil
	case productmetertype.FieldDefaultUomID:
		m.ResetDefaultUomID()
		return nil
	}
	return fmt.Errorf("unknown ProductMeterType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMeterTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMeterTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMeterTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMeterTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMeterTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMeterTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMeterTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductMeterType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMeterTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductMeterType edge %s", name)
}

// ProductPriceMutation represents an operation that mutates the ProductPrice nodes in the graph.
type ProductPriceMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	create_time                  *time.Time
	update_time                  *time.Time
	string_ref                   *string
	currency_uom_id              *int
	addcurrency_uom_id           *int
	from_date                    *time.Time
	thru_date                    *time.Time
	price                        *float64
	addprice                     *float64
	term_uom_id                  *int
	addterm_uom_id               *int
	price_without_tax            *float64
	addprice_without_tax         *float64
	price_with_tax               *float64
	addprice_with_tax            *float64
	tax_amount                   *float64
	addtax_amount                *float64
	tax_percentage               *float64
	addtax_percentage            *float64
	tax_auth_party_id            *int
	addtax_auth_party_id         *int
	tax_auth_geo_id              *int
	addtax_auth_geo_id           *int
	tax_in_price                 *productprice.TaxInPrice
	created_date                 *time.Time
	created_by_user_login        *string
	last_modified_date           *time.Time
	last_modified_by_user_login  *string
	clearedFields                map[string]struct{}
	product                      *int
	clearedproduct               bool
	product_price_type           *int
	clearedproduct_price_type    bool
	product_price_purpose        *int
	clearedproduct_price_purpose bool
	product_store_group          *int
	clearedproduct_store_group   bool
	custom_method                *int
	clearedcustom_method         bool
	done                         bool
	oldValue                     func(context.Context) (*ProductPrice, error)
	predicates                   []predicate.ProductPrice
}

var _ ent.Mutation = (*ProductPriceMutation)(nil)

// productpriceOption allows management of the mutation configuration using functional options.
type productpriceOption func(*ProductPriceMutation)

// newProductPriceMutation creates new mutation for the ProductPrice entity.
func newProductPriceMutation(c config, op Op, opts ...productpriceOption) *ProductPriceMutation {
	m := &ProductPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPriceID sets the ID field of the mutation.
func withProductPriceID(id int) productpriceOption {
	return func(m *ProductPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPrice
		)
		m.oldValue = func(ctx context.Context) (*ProductPrice, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPrice sets the old ProductPrice of the mutation.
func withProductPrice(node *ProductPrice) productpriceOption {
	return func(m *ProductPriceMutation) {
		m.oldValue = func(context.Context) (*ProductPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPriceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductPriceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductPriceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductPriceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductPriceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductPriceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductPriceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductPriceMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductPriceMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductPriceMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productprice.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductPriceMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productprice.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductPriceMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productprice.FieldStringRef)
}

// SetCurrencyUomID sets the "currency_uom_id" field.
func (m *ProductPriceMutation) SetCurrencyUomID(i int) {
	m.currency_uom_id = &i
	m.addcurrency_uom_id = nil
}

// CurrencyUomID returns the value of the "currency_uom_id" field in the mutation.
func (m *ProductPriceMutation) CurrencyUomID() (r int, exists bool) {
	v := m.currency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyUomID returns the old "currency_uom_id" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldCurrencyUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrencyUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrencyUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyUomID: %w", err)
	}
	return oldValue.CurrencyUomID, nil
}

// AddCurrencyUomID adds i to the "currency_uom_id" field.
func (m *ProductPriceMutation) AddCurrencyUomID(i int) {
	if m.addcurrency_uom_id != nil {
		*m.addcurrency_uom_id += i
	} else {
		m.addcurrency_uom_id = &i
	}
}

// AddedCurrencyUomID returns the value that was added to the "currency_uom_id" field in this mutation.
func (m *ProductPriceMutation) AddedCurrencyUomID() (r int, exists bool) {
	v := m.addcurrency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrencyUomID resets all changes to the "currency_uom_id" field.
func (m *ProductPriceMutation) ResetCurrencyUomID() {
	m.currency_uom_id = nil
	m.addcurrency_uom_id = nil
}

// SetFromDate sets the "from_date" field.
func (m *ProductPriceMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *ProductPriceMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *ProductPriceMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *ProductPriceMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *ProductPriceMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *ProductPriceMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[productprice.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *ProductPriceMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[productprice.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *ProductPriceMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, productprice.FieldThruDate)
}

// SetPrice sets the "price" field.
func (m *ProductPriceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductPriceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductPriceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductPriceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *ProductPriceMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[productprice.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *ProductPriceMutation) PriceCleared() bool {
	_, ok := m.clearedFields[productprice.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductPriceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, productprice.FieldPrice)
}

// SetTermUomID sets the "term_uom_id" field.
func (m *ProductPriceMutation) SetTermUomID(i int) {
	m.term_uom_id = &i
	m.addterm_uom_id = nil
}

// TermUomID returns the value of the "term_uom_id" field in the mutation.
func (m *ProductPriceMutation) TermUomID() (r int, exists bool) {
	v := m.term_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTermUomID returns the old "term_uom_id" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldTermUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTermUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTermUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTermUomID: %w", err)
	}
	return oldValue.TermUomID, nil
}

// AddTermUomID adds i to the "term_uom_id" field.
func (m *ProductPriceMutation) AddTermUomID(i int) {
	if m.addterm_uom_id != nil {
		*m.addterm_uom_id += i
	} else {
		m.addterm_uom_id = &i
	}
}

// AddedTermUomID returns the value that was added to the "term_uom_id" field in this mutation.
func (m *ProductPriceMutation) AddedTermUomID() (r int, exists bool) {
	v := m.addterm_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTermUomID clears the value of the "term_uom_id" field.
func (m *ProductPriceMutation) ClearTermUomID() {
	m.term_uom_id = nil
	m.addterm_uom_id = nil
	m.clearedFields[productprice.FieldTermUomID] = struct{}{}
}

// TermUomIDCleared returns if the "term_uom_id" field was cleared in this mutation.
func (m *ProductPriceMutation) TermUomIDCleared() bool {
	_, ok := m.clearedFields[productprice.FieldTermUomID]
	return ok
}

// ResetTermUomID resets all changes to the "term_uom_id" field.
func (m *ProductPriceMutation) ResetTermUomID() {
	m.term_uom_id = nil
	m.addterm_uom_id = nil
	delete(m.clearedFields, productprice.FieldTermUomID)
}

// SetPriceWithoutTax sets the "price_without_tax" field.
func (m *ProductPriceMutation) SetPriceWithoutTax(f float64) {
	m.price_without_tax = &f
	m.addprice_without_tax = nil
}

// PriceWithoutTax returns the value of the "price_without_tax" field in the mutation.
func (m *ProductPriceMutation) PriceWithoutTax() (r float64, exists bool) {
	v := m.price_without_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceWithoutTax returns the old "price_without_tax" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldPriceWithoutTax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceWithoutTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceWithoutTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceWithoutTax: %w", err)
	}
	return oldValue.PriceWithoutTax, nil
}

// AddPriceWithoutTax adds f to the "price_without_tax" field.
func (m *ProductPriceMutation) AddPriceWithoutTax(f float64) {
	if m.addprice_without_tax != nil {
		*m.addprice_without_tax += f
	} else {
		m.addprice_without_tax = &f
	}
}

// AddedPriceWithoutTax returns the value that was added to the "price_without_tax" field in this mutation.
func (m *ProductPriceMutation) AddedPriceWithoutTax() (r float64, exists bool) {
	v := m.addprice_without_tax
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriceWithoutTax clears the value of the "price_without_tax" field.
func (m *ProductPriceMutation) ClearPriceWithoutTax() {
	m.price_without_tax = nil
	m.addprice_without_tax = nil
	m.clearedFields[productprice.FieldPriceWithoutTax] = struct{}{}
}

// PriceWithoutTaxCleared returns if the "price_without_tax" field was cleared in this mutation.
func (m *ProductPriceMutation) PriceWithoutTaxCleared() bool {
	_, ok := m.clearedFields[productprice.FieldPriceWithoutTax]
	return ok
}

// ResetPriceWithoutTax resets all changes to the "price_without_tax" field.
func (m *ProductPriceMutation) ResetPriceWithoutTax() {
	m.price_without_tax = nil
	m.addprice_without_tax = nil
	delete(m.clearedFields, productprice.FieldPriceWithoutTax)
}

// SetPriceWithTax sets the "price_with_tax" field.
func (m *ProductPriceMutation) SetPriceWithTax(f float64) {
	m.price_with_tax = &f
	m.addprice_with_tax = nil
}

// PriceWithTax returns the value of the "price_with_tax" field in the mutation.
func (m *ProductPriceMutation) PriceWithTax() (r float64, exists bool) {
	v := m.price_with_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceWithTax returns the old "price_with_tax" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldPriceWithTax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriceWithTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriceWithTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceWithTax: %w", err)
	}
	return oldValue.PriceWithTax, nil
}

// AddPriceWithTax adds f to the "price_with_tax" field.
func (m *ProductPriceMutation) AddPriceWithTax(f float64) {
	if m.addprice_with_tax != nil {
		*m.addprice_with_tax += f
	} else {
		m.addprice_with_tax = &f
	}
}

// AddedPriceWithTax returns the value that was added to the "price_with_tax" field in this mutation.
func (m *ProductPriceMutation) AddedPriceWithTax() (r float64, exists bool) {
	v := m.addprice_with_tax
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriceWithTax clears the value of the "price_with_tax" field.
func (m *ProductPriceMutation) ClearPriceWithTax() {
	m.price_with_tax = nil
	m.addprice_with_tax = nil
	m.clearedFields[productprice.FieldPriceWithTax] = struct{}{}
}

// PriceWithTaxCleared returns if the "price_with_tax" field was cleared in this mutation.
func (m *ProductPriceMutation) PriceWithTaxCleared() bool {
	_, ok := m.clearedFields[productprice.FieldPriceWithTax]
	return ok
}

// ResetPriceWithTax resets all changes to the "price_with_tax" field.
func (m *ProductPriceMutation) ResetPriceWithTax() {
	m.price_with_tax = nil
	m.addprice_with_tax = nil
	delete(m.clearedFields, productprice.FieldPriceWithTax)
}

// SetTaxAmount sets the "tax_amount" field.
func (m *ProductPriceMutation) SetTaxAmount(f float64) {
	m.tax_amount = &f
	m.addtax_amount = nil
}

// TaxAmount returns the value of the "tax_amount" field in the mutation.
func (m *ProductPriceMutation) TaxAmount() (r float64, exists bool) {
	v := m.tax_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAmount returns the old "tax_amount" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldTaxAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAmount: %w", err)
	}
	return oldValue.TaxAmount, nil
}

// AddTaxAmount adds f to the "tax_amount" field.
func (m *ProductPriceMutation) AddTaxAmount(f float64) {
	if m.addtax_amount != nil {
		*m.addtax_amount += f
	} else {
		m.addtax_amount = &f
	}
}

// AddedTaxAmount returns the value that was added to the "tax_amount" field in this mutation.
func (m *ProductPriceMutation) AddedTaxAmount() (r float64, exists bool) {
	v := m.addtax_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAmount clears the value of the "tax_amount" field.
func (m *ProductPriceMutation) ClearTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
	m.clearedFields[productprice.FieldTaxAmount] = struct{}{}
}

// TaxAmountCleared returns if the "tax_amount" field was cleared in this mutation.
func (m *ProductPriceMutation) TaxAmountCleared() bool {
	_, ok := m.clearedFields[productprice.FieldTaxAmount]
	return ok
}

// ResetTaxAmount resets all changes to the "tax_amount" field.
func (m *ProductPriceMutation) ResetTaxAmount() {
	m.tax_amount = nil
	m.addtax_amount = nil
	delete(m.clearedFields, productprice.FieldTaxAmount)
}

// SetTaxPercentage sets the "tax_percentage" field.
func (m *ProductPriceMutation) SetTaxPercentage(f float64) {
	m.tax_percentage = &f
	m.addtax_percentage = nil
}

// TaxPercentage returns the value of the "tax_percentage" field in the mutation.
func (m *ProductPriceMutation) TaxPercentage() (r float64, exists bool) {
	v := m.tax_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxPercentage returns the old "tax_percentage" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldTaxPercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxPercentage: %w", err)
	}
	return oldValue.TaxPercentage, nil
}

// AddTaxPercentage adds f to the "tax_percentage" field.
func (m *ProductPriceMutation) AddTaxPercentage(f float64) {
	if m.addtax_percentage != nil {
		*m.addtax_percentage += f
	} else {
		m.addtax_percentage = &f
	}
}

// AddedTaxPercentage returns the value that was added to the "tax_percentage" field in this mutation.
func (m *ProductPriceMutation) AddedTaxPercentage() (r float64, exists bool) {
	v := m.addtax_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxPercentage clears the value of the "tax_percentage" field.
func (m *ProductPriceMutation) ClearTaxPercentage() {
	m.tax_percentage = nil
	m.addtax_percentage = nil
	m.clearedFields[productprice.FieldTaxPercentage] = struct{}{}
}

// TaxPercentageCleared returns if the "tax_percentage" field was cleared in this mutation.
func (m *ProductPriceMutation) TaxPercentageCleared() bool {
	_, ok := m.clearedFields[productprice.FieldTaxPercentage]
	return ok
}

// ResetTaxPercentage resets all changes to the "tax_percentage" field.
func (m *ProductPriceMutation) ResetTaxPercentage() {
	m.tax_percentage = nil
	m.addtax_percentage = nil
	delete(m.clearedFields, productprice.FieldTaxPercentage)
}

// SetTaxAuthPartyID sets the "tax_auth_party_id" field.
func (m *ProductPriceMutation) SetTaxAuthPartyID(i int) {
	m.tax_auth_party_id = &i
	m.addtax_auth_party_id = nil
}

// TaxAuthPartyID returns the value of the "tax_auth_party_id" field in the mutation.
func (m *ProductPriceMutation) TaxAuthPartyID() (r int, exists bool) {
	v := m.tax_auth_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAuthPartyID returns the old "tax_auth_party_id" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldTaxAuthPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxAuthPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxAuthPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAuthPartyID: %w", err)
	}
	return oldValue.TaxAuthPartyID, nil
}

// AddTaxAuthPartyID adds i to the "tax_auth_party_id" field.
func (m *ProductPriceMutation) AddTaxAuthPartyID(i int) {
	if m.addtax_auth_party_id != nil {
		*m.addtax_auth_party_id += i
	} else {
		m.addtax_auth_party_id = &i
	}
}

// AddedTaxAuthPartyID returns the value that was added to the "tax_auth_party_id" field in this mutation.
func (m *ProductPriceMutation) AddedTaxAuthPartyID() (r int, exists bool) {
	v := m.addtax_auth_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAuthPartyID clears the value of the "tax_auth_party_id" field.
func (m *ProductPriceMutation) ClearTaxAuthPartyID() {
	m.tax_auth_party_id = nil
	m.addtax_auth_party_id = nil
	m.clearedFields[productprice.FieldTaxAuthPartyID] = struct{}{}
}

// TaxAuthPartyIDCleared returns if the "tax_auth_party_id" field was cleared in this mutation.
func (m *ProductPriceMutation) TaxAuthPartyIDCleared() bool {
	_, ok := m.clearedFields[productprice.FieldTaxAuthPartyID]
	return ok
}

// ResetTaxAuthPartyID resets all changes to the "tax_auth_party_id" field.
func (m *ProductPriceMutation) ResetTaxAuthPartyID() {
	m.tax_auth_party_id = nil
	m.addtax_auth_party_id = nil
	delete(m.clearedFields, productprice.FieldTaxAuthPartyID)
}

// SetTaxAuthGeoID sets the "tax_auth_geo_id" field.
func (m *ProductPriceMutation) SetTaxAuthGeoID(i int) {
	m.tax_auth_geo_id = &i
	m.addtax_auth_geo_id = nil
}

// TaxAuthGeoID returns the value of the "tax_auth_geo_id" field in the mutation.
func (m *ProductPriceMutation) TaxAuthGeoID() (r int, exists bool) {
	v := m.tax_auth_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAuthGeoID returns the old "tax_auth_geo_id" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldTaxAuthGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxAuthGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxAuthGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAuthGeoID: %w", err)
	}
	return oldValue.TaxAuthGeoID, nil
}

// AddTaxAuthGeoID adds i to the "tax_auth_geo_id" field.
func (m *ProductPriceMutation) AddTaxAuthGeoID(i int) {
	if m.addtax_auth_geo_id != nil {
		*m.addtax_auth_geo_id += i
	} else {
		m.addtax_auth_geo_id = &i
	}
}

// AddedTaxAuthGeoID returns the value that was added to the "tax_auth_geo_id" field in this mutation.
func (m *ProductPriceMutation) AddedTaxAuthGeoID() (r int, exists bool) {
	v := m.addtax_auth_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxAuthGeoID clears the value of the "tax_auth_geo_id" field.
func (m *ProductPriceMutation) ClearTaxAuthGeoID() {
	m.tax_auth_geo_id = nil
	m.addtax_auth_geo_id = nil
	m.clearedFields[productprice.FieldTaxAuthGeoID] = struct{}{}
}

// TaxAuthGeoIDCleared returns if the "tax_auth_geo_id" field was cleared in this mutation.
func (m *ProductPriceMutation) TaxAuthGeoIDCleared() bool {
	_, ok := m.clearedFields[productprice.FieldTaxAuthGeoID]
	return ok
}

// ResetTaxAuthGeoID resets all changes to the "tax_auth_geo_id" field.
func (m *ProductPriceMutation) ResetTaxAuthGeoID() {
	m.tax_auth_geo_id = nil
	m.addtax_auth_geo_id = nil
	delete(m.clearedFields, productprice.FieldTaxAuthGeoID)
}

// SetTaxInPrice sets the "tax_in_price" field.
func (m *ProductPriceMutation) SetTaxInPrice(pip productprice.TaxInPrice) {
	m.tax_in_price = &pip
}

// TaxInPrice returns the value of the "tax_in_price" field in the mutation.
func (m *ProductPriceMutation) TaxInPrice() (r productprice.TaxInPrice, exists bool) {
	v := m.tax_in_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxInPrice returns the old "tax_in_price" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldTaxInPrice(ctx context.Context) (v productprice.TaxInPrice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxInPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxInPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxInPrice: %w", err)
	}
	return oldValue.TaxInPrice, nil
}

// ClearTaxInPrice clears the value of the "tax_in_price" field.
func (m *ProductPriceMutation) ClearTaxInPrice() {
	m.tax_in_price = nil
	m.clearedFields[productprice.FieldTaxInPrice] = struct{}{}
}

// TaxInPriceCleared returns if the "tax_in_price" field was cleared in this mutation.
func (m *ProductPriceMutation) TaxInPriceCleared() bool {
	_, ok := m.clearedFields[productprice.FieldTaxInPrice]
	return ok
}

// ResetTaxInPrice resets all changes to the "tax_in_price" field.
func (m *ProductPriceMutation) ResetTaxInPrice() {
	m.tax_in_price = nil
	delete(m.clearedFields, productprice.FieldTaxInPrice)
}

// SetCreatedDate sets the "created_date" field.
func (m *ProductPriceMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *ProductPriceMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *ProductPriceMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[productprice.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *ProductPriceMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[productprice.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *ProductPriceMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, productprice.FieldCreatedDate)
}

// SetCreatedByUserLogin sets the "created_by_user_login" field.
func (m *ProductPriceMutation) SetCreatedByUserLogin(s string) {
	m.created_by_user_login = &s
}

// CreatedByUserLogin returns the value of the "created_by_user_login" field in the mutation.
func (m *ProductPriceMutation) CreatedByUserLogin() (r string, exists bool) {
	v := m.created_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByUserLogin returns the old "created_by_user_login" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldCreatedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByUserLogin: %w", err)
	}
	return oldValue.CreatedByUserLogin, nil
}

// ClearCreatedByUserLogin clears the value of the "created_by_user_login" field.
func (m *ProductPriceMutation) ClearCreatedByUserLogin() {
	m.created_by_user_login = nil
	m.clearedFields[productprice.FieldCreatedByUserLogin] = struct{}{}
}

// CreatedByUserLoginCleared returns if the "created_by_user_login" field was cleared in this mutation.
func (m *ProductPriceMutation) CreatedByUserLoginCleared() bool {
	_, ok := m.clearedFields[productprice.FieldCreatedByUserLogin]
	return ok
}

// ResetCreatedByUserLogin resets all changes to the "created_by_user_login" field.
func (m *ProductPriceMutation) ResetCreatedByUserLogin() {
	m.created_by_user_login = nil
	delete(m.clearedFields, productprice.FieldCreatedByUserLogin)
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *ProductPriceMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *ProductPriceMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ClearLastModifiedDate clears the value of the "last_modified_date" field.
func (m *ProductPriceMutation) ClearLastModifiedDate() {
	m.last_modified_date = nil
	m.clearedFields[productprice.FieldLastModifiedDate] = struct{}{}
}

// LastModifiedDateCleared returns if the "last_modified_date" field was cleared in this mutation.
func (m *ProductPriceMutation) LastModifiedDateCleared() bool {
	_, ok := m.clearedFields[productprice.FieldLastModifiedDate]
	return ok
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *ProductPriceMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
	delete(m.clearedFields, productprice.FieldLastModifiedDate)
}

// SetLastModifiedByUserLogin sets the "last_modified_by_user_login" field.
func (m *ProductPriceMutation) SetLastModifiedByUserLogin(s string) {
	m.last_modified_by_user_login = &s
}

// LastModifiedByUserLogin returns the value of the "last_modified_by_user_login" field in the mutation.
func (m *ProductPriceMutation) LastModifiedByUserLogin() (r string, exists bool) {
	v := m.last_modified_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedByUserLogin returns the old "last_modified_by_user_login" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldLastModifiedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedByUserLogin: %w", err)
	}
	return oldValue.LastModifiedByUserLogin, nil
}

// ClearLastModifiedByUserLogin clears the value of the "last_modified_by_user_login" field.
func (m *ProductPriceMutation) ClearLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	m.clearedFields[productprice.FieldLastModifiedByUserLogin] = struct{}{}
}

// LastModifiedByUserLoginCleared returns if the "last_modified_by_user_login" field was cleared in this mutation.
func (m *ProductPriceMutation) LastModifiedByUserLoginCleared() bool {
	_, ok := m.clearedFields[productprice.FieldLastModifiedByUserLogin]
	return ok
}

// ResetLastModifiedByUserLogin resets all changes to the "last_modified_by_user_login" field.
func (m *ProductPriceMutation) ResetLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	delete(m.clearedFields, productprice.FieldLastModifiedByUserLogin)
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ProductPriceMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductPriceMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductPriceMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ProductPriceMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductPriceMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductPriceMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetProductPriceTypeID sets the "product_price_type" edge to the ProductPriceType entity by id.
func (m *ProductPriceMutation) SetProductPriceTypeID(id int) {
	m.product_price_type = &id
}

// ClearProductPriceType clears the "product_price_type" edge to the ProductPriceType entity.
func (m *ProductPriceMutation) ClearProductPriceType() {
	m.clearedproduct_price_type = true
}

// ProductPriceTypeCleared reports if the "product_price_type" edge to the ProductPriceType entity was cleared.
func (m *ProductPriceMutation) ProductPriceTypeCleared() bool {
	return m.clearedproduct_price_type
}

// ProductPriceTypeID returns the "product_price_type" edge ID in the mutation.
func (m *ProductPriceMutation) ProductPriceTypeID() (id int, exists bool) {
	if m.product_price_type != nil {
		return *m.product_price_type, true
	}
	return
}

// ProductPriceTypeIDs returns the "product_price_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductPriceTypeID instead. It exists only for internal usage by the builders.
func (m *ProductPriceMutation) ProductPriceTypeIDs() (ids []int) {
	if id := m.product_price_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductPriceType resets all changes to the "product_price_type" edge.
func (m *ProductPriceMutation) ResetProductPriceType() {
	m.product_price_type = nil
	m.clearedproduct_price_type = false
}

// SetProductPricePurposeID sets the "product_price_purpose" edge to the ProductPricePurpose entity by id.
func (m *ProductPriceMutation) SetProductPricePurposeID(id int) {
	m.product_price_purpose = &id
}

// ClearProductPricePurpose clears the "product_price_purpose" edge to the ProductPricePurpose entity.
func (m *ProductPriceMutation) ClearProductPricePurpose() {
	m.clearedproduct_price_purpose = true
}

// ProductPricePurposeCleared reports if the "product_price_purpose" edge to the ProductPricePurpose entity was cleared.
func (m *ProductPriceMutation) ProductPricePurposeCleared() bool {
	return m.clearedproduct_price_purpose
}

// ProductPricePurposeID returns the "product_price_purpose" edge ID in the mutation.
func (m *ProductPriceMutation) ProductPricePurposeID() (id int, exists bool) {
	if m.product_price_purpose != nil {
		return *m.product_price_purpose, true
	}
	return
}

// ProductPricePurposeIDs returns the "product_price_purpose" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductPricePurposeID instead. It exists only for internal usage by the builders.
func (m *ProductPriceMutation) ProductPricePurposeIDs() (ids []int) {
	if id := m.product_price_purpose; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductPricePurpose resets all changes to the "product_price_purpose" edge.
func (m *ProductPriceMutation) ResetProductPricePurpose() {
	m.product_price_purpose = nil
	m.clearedproduct_price_purpose = false
}

// SetProductStoreGroupID sets the "product_store_group" edge to the ProductStoreGroup entity by id.
func (m *ProductPriceMutation) SetProductStoreGroupID(id int) {
	m.product_store_group = &id
}

// ClearProductStoreGroup clears the "product_store_group" edge to the ProductStoreGroup entity.
func (m *ProductPriceMutation) ClearProductStoreGroup() {
	m.clearedproduct_store_group = true
}

// ProductStoreGroupCleared reports if the "product_store_group" edge to the ProductStoreGroup entity was cleared.
func (m *ProductPriceMutation) ProductStoreGroupCleared() bool {
	return m.clearedproduct_store_group
}

// ProductStoreGroupID returns the "product_store_group" edge ID in the mutation.
func (m *ProductPriceMutation) ProductStoreGroupID() (id int, exists bool) {
	if m.product_store_group != nil {
		return *m.product_store_group, true
	}
	return
}

// ProductStoreGroupIDs returns the "product_store_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductStoreGroupID instead. It exists only for internal usage by the builders.
func (m *ProductPriceMutation) ProductStoreGroupIDs() (ids []int) {
	if id := m.product_store_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductStoreGroup resets all changes to the "product_store_group" edge.
func (m *ProductPriceMutation) ResetProductStoreGroup() {
	m.product_store_group = nil
	m.clearedproduct_store_group = false
}

// SetCustomMethodID sets the "custom_method" edge to the CustomMethod entity by id.
func (m *ProductPriceMutation) SetCustomMethodID(id int) {
	m.custom_method = &id
}

// ClearCustomMethod clears the "custom_method" edge to the CustomMethod entity.
func (m *ProductPriceMutation) ClearCustomMethod() {
	m.clearedcustom_method = true
}

// CustomMethodCleared reports if the "custom_method" edge to the CustomMethod entity was cleared.
func (m *ProductPriceMutation) CustomMethodCleared() bool {
	return m.clearedcustom_method
}

// CustomMethodID returns the "custom_method" edge ID in the mutation.
func (m *ProductPriceMutation) CustomMethodID() (id int, exists bool) {
	if m.custom_method != nil {
		return *m.custom_method, true
	}
	return
}

// CustomMethodIDs returns the "custom_method" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomMethodID instead. It exists only for internal usage by the builders.
func (m *ProductPriceMutation) CustomMethodIDs() (ids []int) {
	if id := m.custom_method; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomMethod resets all changes to the "custom_method" edge.
func (m *ProductPriceMutation) ResetCustomMethod() {
	m.custom_method = nil
	m.clearedcustom_method = false
}

// Op returns the operation name.
func (m *ProductPriceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductPrice).
func (m *ProductPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPriceMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.create_time != nil {
		fields = append(fields, productprice.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productprice.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productprice.FieldStringRef)
	}
	if m.currency_uom_id != nil {
		fields = append(fields, productprice.FieldCurrencyUomID)
	}
	if m.from_date != nil {
		fields = append(fields, productprice.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, productprice.FieldThruDate)
	}
	if m.price != nil {
		fields = append(fields, productprice.FieldPrice)
	}
	if m.term_uom_id != nil {
		fields = append(fields, productprice.FieldTermUomID)
	}
	if m.price_without_tax != nil {
		fields = append(fields, productprice.FieldPriceWithoutTax)
	}
	if m.price_with_tax != nil {
		fields = append(fields, productprice.FieldPriceWithTax)
	}
	if m.tax_amount != nil {
		fields = append(fields, productprice.FieldTaxAmount)
	}
	if m.tax_percentage != nil {
		fields = append(fields, productprice.FieldTaxPercentage)
	}
	if m.tax_auth_party_id != nil {
		fields = append(fields, productprice.FieldTaxAuthPartyID)
	}
	if m.tax_auth_geo_id != nil {
		fields = append(fields, productprice.FieldTaxAuthGeoID)
	}
	if m.tax_in_price != nil {
		fields = append(fields, productprice.FieldTaxInPrice)
	}
	if m.created_date != nil {
		fields = append(fields, productprice.FieldCreatedDate)
	}
	if m.created_by_user_login != nil {
		fields = append(fields, productprice.FieldCreatedByUserLogin)
	}
	if m.last_modified_date != nil {
		fields = append(fields, productprice.FieldLastModifiedDate)
	}
	if m.last_modified_by_user_login != nil {
		fields = append(fields, productprice.FieldLastModifiedByUserLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productprice.FieldCreateTime:
		return m.CreateTime()
	case productprice.FieldUpdateTime:
		return m.UpdateTime()
	case productprice.FieldStringRef:
		return m.StringRef()
	case productprice.FieldCurrencyUomID:
		return m.CurrencyUomID()
	case productprice.FieldFromDate:
		return m.FromDate()
	case productprice.FieldThruDate:
		return m.ThruDate()
	case productprice.FieldPrice:
		return m.Price()
	case productprice.FieldTermUomID:
		return m.TermUomID()
	case productprice.FieldPriceWithoutTax:
		return m.PriceWithoutTax()
	case productprice.FieldPriceWithTax:
		return m.PriceWithTax()
	case productprice.FieldTaxAmount:
		return m.TaxAmount()
	case productprice.FieldTaxPercentage:
		return m.TaxPercentage()
	case productprice.FieldTaxAuthPartyID:
		return m.TaxAuthPartyID()
	case productprice.FieldTaxAuthGeoID:
		return m.TaxAuthGeoID()
	case productprice.FieldTaxInPrice:
		return m.TaxInPrice()
	case productprice.FieldCreatedDate:
		return m.CreatedDate()
	case productprice.FieldCreatedByUserLogin:
		return m.CreatedByUserLogin()
	case productprice.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case productprice.FieldLastModifiedByUserLogin:
		return m.LastModifiedByUserLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productprice.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productprice.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productprice.FieldStringRef:
		return m.OldStringRef(ctx)
	case productprice.FieldCurrencyUomID:
		return m.OldCurrencyUomID(ctx)
	case productprice.FieldFromDate:
		return m.OldFromDate(ctx)
	case productprice.FieldThruDate:
		return m.OldThruDate(ctx)
	case productprice.FieldPrice:
		return m.OldPrice(ctx)
	case productprice.FieldTermUomID:
		return m.OldTermUomID(ctx)
	case productprice.FieldPriceWithoutTax:
		return m.OldPriceWithoutTax(ctx)
	case productprice.FieldPriceWithTax:
		return m.OldPriceWithTax(ctx)
	case productprice.FieldTaxAmount:
		return m.OldTaxAmount(ctx)
	case productprice.FieldTaxPercentage:
		return m.OldTaxPercentage(ctx)
	case productprice.FieldTaxAuthPartyID:
		return m.OldTaxAuthPartyID(ctx)
	case productprice.FieldTaxAuthGeoID:
		return m.OldTaxAuthGeoID(ctx)
	case productprice.FieldTaxInPrice:
		return m.OldTaxInPrice(ctx)
	case productprice.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case productprice.FieldCreatedByUserLogin:
		return m.OldCreatedByUserLogin(ctx)
	case productprice.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case productprice.FieldLastModifiedByUserLogin:
		return m.OldLastModifiedByUserLogin(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productprice.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productprice.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productprice.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productprice.FieldCurrencyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyUomID(v)
		return nil
	case productprice.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case productprice.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	case productprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productprice.FieldTermUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTermUomID(v)
		return nil
	case productprice.FieldPriceWithoutTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceWithoutTax(v)
		return nil
	case productprice.FieldPriceWithTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceWithTax(v)
		return nil
	case productprice.FieldTaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAmount(v)
		return nil
	case productprice.FieldTaxPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxPercentage(v)
		return nil
	case productprice.FieldTaxAuthPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAuthPartyID(v)
		return nil
	case productprice.FieldTaxAuthGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAuthGeoID(v)
		return nil
	case productprice.FieldTaxInPrice:
		v, ok := value.(productprice.TaxInPrice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxInPrice(v)
		return nil
	case productprice.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case productprice.FieldCreatedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByUserLogin(v)
		return nil
	case productprice.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case productprice.FieldLastModifiedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedByUserLogin(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPriceMutation) AddedFields() []string {
	var fields []string
	if m.addcurrency_uom_id != nil {
		fields = append(fields, productprice.FieldCurrencyUomID)
	}
	if m.addprice != nil {
		fields = append(fields, productprice.FieldPrice)
	}
	if m.addterm_uom_id != nil {
		fields = append(fields, productprice.FieldTermUomID)
	}
	if m.addprice_without_tax != nil {
		fields = append(fields, productprice.FieldPriceWithoutTax)
	}
	if m.addprice_with_tax != nil {
		fields = append(fields, productprice.FieldPriceWithTax)
	}
	if m.addtax_amount != nil {
		fields = append(fields, productprice.FieldTaxAmount)
	}
	if m.addtax_percentage != nil {
		fields = append(fields, productprice.FieldTaxPercentage)
	}
	if m.addtax_auth_party_id != nil {
		fields = append(fields, productprice.FieldTaxAuthPartyID)
	}
	if m.addtax_auth_geo_id != nil {
		fields = append(fields, productprice.FieldTaxAuthGeoID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productprice.FieldCurrencyUomID:
		return m.AddedCurrencyUomID()
	case productprice.FieldPrice:
		return m.AddedPrice()
	case productprice.FieldTermUomID:
		return m.AddedTermUomID()
	case productprice.FieldPriceWithoutTax:
		return m.AddedPriceWithoutTax()
	case productprice.FieldPriceWithTax:
		return m.AddedPriceWithTax()
	case productprice.FieldTaxAmount:
		return m.AddedTaxAmount()
	case productprice.FieldTaxPercentage:
		return m.AddedTaxPercentage()
	case productprice.FieldTaxAuthPartyID:
		return m.AddedTaxAuthPartyID()
	case productprice.FieldTaxAuthGeoID:
		return m.AddedTaxAuthGeoID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productprice.FieldCurrencyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrencyUomID(v)
		return nil
	case productprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case productprice.FieldTermUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTermUomID(v)
		return nil
	case productprice.FieldPriceWithoutTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceWithoutTax(v)
		return nil
	case productprice.FieldPriceWithTax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceWithTax(v)
		return nil
	case productprice.FieldTaxAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAmount(v)
		return nil
	case productprice.FieldTaxPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxPercentage(v)
		return nil
	case productprice.FieldTaxAuthPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAuthPartyID(v)
		return nil
	case productprice.FieldTaxAuthGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxAuthGeoID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productprice.FieldStringRef) {
		fields = append(fields, productprice.FieldStringRef)
	}
	if m.FieldCleared(productprice.FieldThruDate) {
		fields = append(fields, productprice.FieldThruDate)
	}
	if m.FieldCleared(productprice.FieldPrice) {
		fields = append(fields, productprice.FieldPrice)
	}
	if m.FieldCleared(productprice.FieldTermUomID) {
		fields = append(fields, productprice.FieldTermUomID)
	}
	if m.FieldCleared(productprice.FieldPriceWithoutTax) {
		fields = append(fields, productprice.FieldPriceWithoutTax)
	}
	if m.FieldCleared(productprice.FieldPriceWithTax) {
		fields = append(fields, productprice.FieldPriceWithTax)
	}
	if m.FieldCleared(productprice.FieldTaxAmount) {
		fields = append(fields, productprice.FieldTaxAmount)
	}
	if m.FieldCleared(productprice.FieldTaxPercentage) {
		fields = append(fields, productprice.FieldTaxPercentage)
	}
	if m.FieldCleared(productprice.FieldTaxAuthPartyID) {
		fields = append(fields, productprice.FieldTaxAuthPartyID)
	}
	if m.FieldCleared(productprice.FieldTaxAuthGeoID) {
		fields = append(fields, productprice.FieldTaxAuthGeoID)
	}
	if m.FieldCleared(productprice.FieldTaxInPrice) {
		fields = append(fields, productprice.FieldTaxInPrice)
	}
	if m.FieldCleared(productprice.FieldCreatedDate) {
		fields = append(fields, productprice.FieldCreatedDate)
	}
	if m.FieldCleared(productprice.FieldCreatedByUserLogin) {
		fields = append(fields, productprice.FieldCreatedByUserLogin)
	}
	if m.FieldCleared(productprice.FieldLastModifiedDate) {
		fields = append(fields, productprice.FieldLastModifiedDate)
	}
	if m.FieldCleared(productprice.FieldLastModifiedByUserLogin) {
		fields = append(fields, productprice.FieldLastModifiedByUserLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPriceMutation) ClearField(name string) error {
	switch name {
	case productprice.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productprice.FieldThruDate:
		m.ClearThruDate()
		return nil
	case productprice.FieldPrice:
		m.ClearPrice()
		return nil
	case productprice.FieldTermUomID:
		m.ClearTermUomID()
		return nil
	case productprice.FieldPriceWithoutTax:
		m.ClearPriceWithoutTax()
		return nil
	case productprice.FieldPriceWithTax:
		m.ClearPriceWithTax()
		return nil
	case productprice.FieldTaxAmount:
		m.ClearTaxAmount()
		return nil
	case productprice.FieldTaxPercentage:
		m.ClearTaxPercentage()
		return nil
	case productprice.FieldTaxAuthPartyID:
		m.ClearTaxAuthPartyID()
		return nil
	case productprice.FieldTaxAuthGeoID:
		m.ClearTaxAuthGeoID()
		return nil
	case productprice.FieldTaxInPrice:
		m.ClearTaxInPrice()
		return nil
	case productprice.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case productprice.FieldCreatedByUserLogin:
		m.ClearCreatedByUserLogin()
		return nil
	case productprice.FieldLastModifiedDate:
		m.ClearLastModifiedDate()
		return nil
	case productprice.FieldLastModifiedByUserLogin:
		m.ClearLastModifiedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPriceMutation) ResetField(name string) error {
	switch name {
	case productprice.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productprice.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productprice.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productprice.FieldCurrencyUomID:
		m.ResetCurrencyUomID()
		return nil
	case productprice.FieldFromDate:
		m.ResetFromDate()
		return nil
	case productprice.FieldThruDate:
		m.ResetThruDate()
		return nil
	case productprice.FieldPrice:
		m.ResetPrice()
		return nil
	case productprice.FieldTermUomID:
		m.ResetTermUomID()
		return nil
	case productprice.FieldPriceWithoutTax:
		m.ResetPriceWithoutTax()
		return nil
	case productprice.FieldPriceWithTax:
		m.ResetPriceWithTax()
		return nil
	case productprice.FieldTaxAmount:
		m.ResetTaxAmount()
		return nil
	case productprice.FieldTaxPercentage:
		m.ResetTaxPercentage()
		return nil
	case productprice.FieldTaxAuthPartyID:
		m.ResetTaxAuthPartyID()
		return nil
	case productprice.FieldTaxAuthGeoID:
		m.ResetTaxAuthGeoID()
		return nil
	case productprice.FieldTaxInPrice:
		m.ResetTaxInPrice()
		return nil
	case productprice.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case productprice.FieldCreatedByUserLogin:
		m.ResetCreatedByUserLogin()
		return nil
	case productprice.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case productprice.FieldLastModifiedByUserLogin:
		m.ResetLastModifiedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.product != nil {
		edges = append(edges, productprice.EdgeProduct)
	}
	if m.product_price_type != nil {
		edges = append(edges, productprice.EdgeProductPriceType)
	}
	if m.product_price_purpose != nil {
		edges = append(edges, productprice.EdgeProductPricePurpose)
	}
	if m.product_store_group != nil {
		edges = append(edges, productprice.EdgeProductStoreGroup)
	}
	if m.custom_method != nil {
		edges = append(edges, productprice.EdgeCustomMethod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productprice.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productprice.EdgeProductPriceType:
		if id := m.product_price_type; id != nil {
			return []ent.Value{*id}
		}
	case productprice.EdgeProductPricePurpose:
		if id := m.product_price_purpose; id != nil {
			return []ent.Value{*id}
		}
	case productprice.EdgeProductStoreGroup:
		if id := m.product_store_group; id != nil {
			return []ent.Value{*id}
		}
	case productprice.EdgeCustomMethod:
		if id := m.custom_method; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproduct {
		edges = append(edges, productprice.EdgeProduct)
	}
	if m.clearedproduct_price_type {
		edges = append(edges, productprice.EdgeProductPriceType)
	}
	if m.clearedproduct_price_purpose {
		edges = append(edges, productprice.EdgeProductPricePurpose)
	}
	if m.clearedproduct_store_group {
		edges = append(edges, productprice.EdgeProductStoreGroup)
	}
	if m.clearedcustom_method {
		edges = append(edges, productprice.EdgeCustomMethod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case productprice.EdgeProduct:
		return m.clearedproduct
	case productprice.EdgeProductPriceType:
		return m.clearedproduct_price_type
	case productprice.EdgeProductPricePurpose:
		return m.clearedproduct_price_purpose
	case productprice.EdgeProductStoreGroup:
		return m.clearedproduct_store_group
	case productprice.EdgeCustomMethod:
		return m.clearedcustom_method
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPriceMutation) ClearEdge(name string) error {
	switch name {
	case productprice.EdgeProduct:
		m.ClearProduct()
		return nil
	case productprice.EdgeProductPriceType:
		m.ClearProductPriceType()
		return nil
	case productprice.EdgeProductPricePurpose:
		m.ClearProductPricePurpose()
		return nil
	case productprice.EdgeProductStoreGroup:
		m.ClearProductStoreGroup()
		return nil
	case productprice.EdgeCustomMethod:
		m.ClearCustomMethod()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPriceMutation) ResetEdge(name string) error {
	switch name {
	case productprice.EdgeProduct:
		m.ResetProduct()
		return nil
	case productprice.EdgeProductPriceType:
		m.ResetProductPriceType()
		return nil
	case productprice.EdgeProductPricePurpose:
		m.ResetProductPricePurpose()
		return nil
	case productprice.EdgeProductStoreGroup:
		m.ResetProductStoreGroup()
		return nil
	case productprice.EdgeCustomMethod:
		m.ResetCustomMethod()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice edge %s", name)
}

// ProductPriceActionTypeMutation represents an operation that mutates the ProductPriceActionType nodes in the graph.
type ProductPriceActionTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProductPriceActionType, error)
	predicates    []predicate.ProductPriceActionType
}

var _ ent.Mutation = (*ProductPriceActionTypeMutation)(nil)

// productpriceactiontypeOption allows management of the mutation configuration using functional options.
type productpriceactiontypeOption func(*ProductPriceActionTypeMutation)

// newProductPriceActionTypeMutation creates new mutation for the ProductPriceActionType entity.
func newProductPriceActionTypeMutation(c config, op Op, opts ...productpriceactiontypeOption) *ProductPriceActionTypeMutation {
	m := &ProductPriceActionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPriceActionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPriceActionTypeID sets the ID field of the mutation.
func withProductPriceActionTypeID(id int) productpriceactiontypeOption {
	return func(m *ProductPriceActionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPriceActionType
		)
		m.oldValue = func(ctx context.Context) (*ProductPriceActionType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPriceActionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPriceActionType sets the old ProductPriceActionType of the mutation.
func withProductPriceActionType(node *ProductPriceActionType) productpriceactiontypeOption {
	return func(m *ProductPriceActionTypeMutation) {
		m.oldValue = func(context.Context) (*ProductPriceActionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPriceActionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPriceActionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPriceActionTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductPriceActionTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductPriceActionTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductPriceActionType entity.
// If the ProductPriceActionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceActionTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductPriceActionTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductPriceActionTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductPriceActionTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductPriceActionType entity.
// If the ProductPriceActionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceActionTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductPriceActionTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductPriceActionTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductPriceActionTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductPriceActionType entity.
// If the ProductPriceActionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceActionTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductPriceActionTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productpriceactiontype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductPriceActionTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productpriceactiontype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductPriceActionTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productpriceactiontype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductPriceActionTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductPriceActionTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductPriceActionType entity.
// If the ProductPriceActionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceActionTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductPriceActionTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productpriceactiontype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductPriceActionTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productpriceactiontype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductPriceActionTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productpriceactiontype.FieldDescription)
}

// Op returns the operation name.
func (m *ProductPriceActionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductPriceActionType).
func (m *ProductPriceActionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPriceActionTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, productpriceactiontype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productpriceactiontype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productpriceactiontype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productpriceactiontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPriceActionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productpriceactiontype.FieldCreateTime:
		return m.CreateTime()
	case productpriceactiontype.FieldUpdateTime:
		return m.UpdateTime()
	case productpriceactiontype.FieldStringRef:
		return m.StringRef()
	case productpriceactiontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPriceActionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productpriceactiontype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productpriceactiontype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productpriceactiontype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productpriceactiontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPriceActionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceActionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productpriceactiontype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productpriceactiontype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productpriceactiontype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productpriceactiontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPriceActionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPriceActionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPriceActionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceActionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductPriceActionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPriceActionTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productpriceactiontype.FieldStringRef) {
		fields = append(fields, productpriceactiontype.FieldStringRef)
	}
	if m.FieldCleared(productpriceactiontype.FieldDescription) {
		fields = append(fields, productpriceactiontype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPriceActionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPriceActionTypeMutation) ClearField(name string) error {
	switch name {
	case productpriceactiontype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productpriceactiontype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductPriceActionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPriceActionTypeMutation) ResetField(name string) error {
	switch name {
	case productpriceactiontype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productpriceactiontype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productpriceactiontype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productpriceactiontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductPriceActionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPriceActionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPriceActionTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPriceActionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPriceActionTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPriceActionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPriceActionTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPriceActionTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProductPriceActionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPriceActionTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProductPriceActionType edge %s", name)
}

// ProductPricePurposeMutation represents an operation that mutates the ProductPricePurpose nodes in the graph.
type ProductPricePurposeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	create_time                      *time.Time
	update_time                      *time.Time
	string_ref                       *string
	description                      *string
	clearedFields                    map[string]struct{}
	order_payment_preferences        map[int]struct{}
	removedorder_payment_preferences map[int]struct{}
	clearedorder_payment_preferences bool
	product_prices                   map[int]struct{}
	removedproduct_prices            map[int]struct{}
	clearedproduct_prices            bool
	done                             bool
	oldValue                         func(context.Context) (*ProductPricePurpose, error)
	predicates                       []predicate.ProductPricePurpose
}

var _ ent.Mutation = (*ProductPricePurposeMutation)(nil)

// productpricepurposeOption allows management of the mutation configuration using functional options.
type productpricepurposeOption func(*ProductPricePurposeMutation)

// newProductPricePurposeMutation creates new mutation for the ProductPricePurpose entity.
func newProductPricePurposeMutation(c config, op Op, opts ...productpricepurposeOption) *ProductPricePurposeMutation {
	m := &ProductPricePurposeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPricePurpose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPricePurposeID sets the ID field of the mutation.
func withProductPricePurposeID(id int) productpricepurposeOption {
	return func(m *ProductPricePurposeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPricePurpose
		)
		m.oldValue = func(ctx context.Context) (*ProductPricePurpose, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPricePurpose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPricePurpose sets the old ProductPricePurpose of the mutation.
func withProductPricePurpose(node *ProductPricePurpose) productpricepurposeOption {
	return func(m *ProductPricePurposeMutation) {
		m.oldValue = func(context.Context) (*ProductPricePurpose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPricePurposeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPricePurposeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPricePurposeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductPricePurposeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductPricePurposeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductPricePurpose entity.
// If the ProductPricePurpose object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricePurposeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductPricePurposeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductPricePurposeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductPricePurposeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductPricePurpose entity.
// If the ProductPricePurpose object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricePurposeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductPricePurposeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductPricePurposeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductPricePurposeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductPricePurpose entity.
// If the ProductPricePurpose object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricePurposeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductPricePurposeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productpricepurpose.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductPricePurposeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productpricepurpose.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductPricePurposeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productpricepurpose.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductPricePurposeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductPricePurposeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductPricePurpose entity.
// If the ProductPricePurpose object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPricePurposeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductPricePurposeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productpricepurpose.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductPricePurposeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productpricepurpose.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductPricePurposeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productpricepurpose.FieldDescription)
}

// AddOrderPaymentPreferenceIDs adds the "order_payment_preferences" edge to the OrderPaymentPreference entity by ids.
func (m *ProductPricePurposeMutation) AddOrderPaymentPreferenceIDs(ids ...int) {
	if m.order_payment_preferences == nil {
		m.order_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.order_payment_preferences[ids[i]] = struct{}{}
	}
}

// ClearOrderPaymentPreferences clears the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *ProductPricePurposeMutation) ClearOrderPaymentPreferences() {
	m.clearedorder_payment_preferences = true
}

// OrderPaymentPreferencesCleared reports if the "order_payment_preferences" edge to the OrderPaymentPreference entity was cleared.
func (m *ProductPricePurposeMutation) OrderPaymentPreferencesCleared() bool {
	return m.clearedorder_payment_preferences
}

// RemoveOrderPaymentPreferenceIDs removes the "order_payment_preferences" edge to the OrderPaymentPreference entity by IDs.
func (m *ProductPricePurposeMutation) RemoveOrderPaymentPreferenceIDs(ids ...int) {
	if m.removedorder_payment_preferences == nil {
		m.removedorder_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_payment_preferences[ids[i]] = struct{}{}
	}
}

// RemovedOrderPaymentPreferences returns the removed IDs of the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *ProductPricePurposeMutation) RemovedOrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.removedorder_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// OrderPaymentPreferencesIDs returns the "order_payment_preferences" edge IDs in the mutation.
func (m *ProductPricePurposeMutation) OrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.order_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// ResetOrderPaymentPreferences resets all changes to the "order_payment_preferences" edge.
func (m *ProductPricePurposeMutation) ResetOrderPaymentPreferences() {
	m.order_payment_preferences = nil
	m.clearedorder_payment_preferences = false
	m.removedorder_payment_preferences = nil
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrice entity by ids.
func (m *ProductPricePurposeMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrice entity.
func (m *ProductPricePurposeMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrice entity was cleared.
func (m *ProductPricePurposeMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrice entity by IDs.
func (m *ProductPricePurposeMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrice entity.
func (m *ProductPricePurposeMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *ProductPricePurposeMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *ProductPricePurposeMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// Op returns the operation name.
func (m *ProductPricePurposeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductPricePurpose).
func (m *ProductPricePurposeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPricePurposeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, productpricepurpose.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productpricepurpose.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productpricepurpose.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productpricepurpose.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPricePurposeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productpricepurpose.FieldCreateTime:
		return m.CreateTime()
	case productpricepurpose.FieldUpdateTime:
		return m.UpdateTime()
	case productpricepurpose.FieldStringRef:
		return m.StringRef()
	case productpricepurpose.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPricePurposeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productpricepurpose.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productpricepurpose.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productpricepurpose.FieldStringRef:
		return m.OldStringRef(ctx)
	case productpricepurpose.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPricePurpose field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPricePurposeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productpricepurpose.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productpricepurpose.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productpricepurpose.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productpricepurpose.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPricePurpose field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPricePurposeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPricePurposeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPricePurposeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductPricePurpose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPricePurposeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productpricepurpose.FieldStringRef) {
		fields = append(fields, productpricepurpose.FieldStringRef)
	}
	if m.FieldCleared(productpricepurpose.FieldDescription) {
		fields = append(fields, productpricepurpose.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPricePurposeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPricePurposeMutation) ClearField(name string) error {
	switch name {
	case productpricepurpose.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productpricepurpose.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductPricePurpose nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPricePurposeMutation) ResetField(name string) error {
	switch name {
	case productpricepurpose.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productpricepurpose.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productpricepurpose.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productpricepurpose.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductPricePurpose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPricePurposeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_payment_preferences != nil {
		edges = append(edges, productpricepurpose.EdgeOrderPaymentPreferences)
	}
	if m.product_prices != nil {
		edges = append(edges, productpricepurpose.EdgeProductPrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPricePurposeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productpricepurpose.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.order_payment_preferences))
		for id := range m.order_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case productpricepurpose.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPricePurposeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorder_payment_preferences != nil {
		edges = append(edges, productpricepurpose.EdgeOrderPaymentPreferences)
	}
	if m.removedproduct_prices != nil {
		edges = append(edges, productpricepurpose.EdgeProductPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPricePurposeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productpricepurpose.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.removedorder_payment_preferences))
		for id := range m.removedorder_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case productpricepurpose.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPricePurposeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_payment_preferences {
		edges = append(edges, productpricepurpose.EdgeOrderPaymentPreferences)
	}
	if m.clearedproduct_prices {
		edges = append(edges, productpricepurpose.EdgeProductPrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPricePurposeMutation) EdgeCleared(name string) bool {
	switch name {
	case productpricepurpose.EdgeOrderPaymentPreferences:
		return m.clearedorder_payment_preferences
	case productpricepurpose.EdgeProductPrices:
		return m.clearedproduct_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPricePurposeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductPricePurpose unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPricePurposeMutation) ResetEdge(name string) error {
	switch name {
	case productpricepurpose.EdgeOrderPaymentPreferences:
		m.ResetOrderPaymentPreferences()
		return nil
	case productpricepurpose.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	}
	return fmt.Errorf("unknown ProductPricePurpose edge %s", name)
}

// ProductPriceTypeMutation represents an operation that mutates the ProductPriceType nodes in the graph.
type ProductPriceTypeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	update_time           *time.Time
	string_ref            *string
	description           *string
	clearedFields         map[string]struct{}
	product_prices        map[int]struct{}
	removedproduct_prices map[int]struct{}
	clearedproduct_prices bool
	done                  bool
	oldValue              func(context.Context) (*ProductPriceType, error)
	predicates            []predicate.ProductPriceType
}

var _ ent.Mutation = (*ProductPriceTypeMutation)(nil)

// productpricetypeOption allows management of the mutation configuration using functional options.
type productpricetypeOption func(*ProductPriceTypeMutation)

// newProductPriceTypeMutation creates new mutation for the ProductPriceType entity.
func newProductPriceTypeMutation(c config, op Op, opts ...productpricetypeOption) *ProductPriceTypeMutation {
	m := &ProductPriceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPriceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPriceTypeID sets the ID field of the mutation.
func withProductPriceTypeID(id int) productpricetypeOption {
	return func(m *ProductPriceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPriceType
		)
		m.oldValue = func(ctx context.Context) (*ProductPriceType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPriceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPriceType sets the old ProductPriceType of the mutation.
func withProductPriceType(node *ProductPriceType) productpricetypeOption {
	return func(m *ProductPriceTypeMutation) {
		m.oldValue = func(context.Context) (*ProductPriceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPriceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPriceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPriceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductPriceTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductPriceTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductPriceType entity.
// If the ProductPriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductPriceTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductPriceTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductPriceTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductPriceType entity.
// If the ProductPriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductPriceTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductPriceTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductPriceTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductPriceType entity.
// If the ProductPriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductPriceTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productpricetype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductPriceTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productpricetype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductPriceTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productpricetype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ProductPriceTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductPriceTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductPriceType entity.
// If the ProductPriceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductPriceTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productpricetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductPriceTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productpricetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductPriceTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productpricetype.FieldDescription)
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrice entity by ids.
func (m *ProductPriceTypeMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrice entity.
func (m *ProductPriceTypeMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrice entity was cleared.
func (m *ProductPriceTypeMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrice entity by IDs.
func (m *ProductPriceTypeMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrice entity.
func (m *ProductPriceTypeMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *ProductPriceTypeMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *ProductPriceTypeMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// Op returns the operation name.
func (m *ProductPriceTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductPriceType).
func (m *ProductPriceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPriceTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, productpricetype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productpricetype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productpricetype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, productpricetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPriceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productpricetype.FieldCreateTime:
		return m.CreateTime()
	case productpricetype.FieldUpdateTime:
		return m.UpdateTime()
	case productpricetype.FieldStringRef:
		return m.StringRef()
	case productpricetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPriceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productpricetype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productpricetype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productpricetype.FieldStringRef:
		return m.OldStringRef(ctx)
	case productpricetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPriceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productpricetype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productpricetype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productpricetype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productpricetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPriceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPriceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPriceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductPriceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPriceTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productpricetype.FieldStringRef) {
		fields = append(fields, productpricetype.FieldStringRef)
	}
	if m.FieldCleared(productpricetype.FieldDescription) {
		fields = append(fields, productpricetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPriceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPriceTypeMutation) ClearField(name string) error {
	switch name {
	case productpricetype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productpricetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductPriceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPriceTypeMutation) ResetField(name string) error {
	switch name {
	case productpricetype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productpricetype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productpricetype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productpricetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductPriceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPriceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product_prices != nil {
		edges = append(edges, productpricetype.EdgeProductPrices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPriceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productpricetype.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPriceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproduct_prices != nil {
		edges = append(edges, productpricetype.EdgeProductPrices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPriceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productpricetype.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPriceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct_prices {
		edges = append(edges, productpricetype.EdgeProductPrices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPriceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case productpricetype.EdgeProductPrices:
		return m.clearedproduct_prices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPriceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductPriceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPriceTypeMutation) ResetEdge(name string) error {
	switch name {
	case productpricetype.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	}
	return fmt.Errorf("unknown ProductPriceType edge %s", name)
}

// ProductReviewMutation represents an operation that mutates the ProductReview nodes in the graph.
type ProductReviewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	string_ref           *string
	user_login_id        *string
	posted_anonymous     *productreview.PostedAnonymous
	posted_date_time     *time.Time
	product_rating       *float64
	addproduct_rating    *float64
	product_review       *string
	clearedFields        map[string]struct{}
	product_store        *int
	clearedproduct_store bool
	product              *int
	clearedproduct       bool
	status_item          *int
	clearedstatus_item   bool
	done                 bool
	oldValue             func(context.Context) (*ProductReview, error)
	predicates           []predicate.ProductReview
}

var _ ent.Mutation = (*ProductReviewMutation)(nil)

// productreviewOption allows management of the mutation configuration using functional options.
type productreviewOption func(*ProductReviewMutation)

// newProductReviewMutation creates new mutation for the ProductReview entity.
func newProductReviewMutation(c config, op Op, opts ...productreviewOption) *ProductReviewMutation {
	m := &ProductReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeProductReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductReviewID sets the ID field of the mutation.
func withProductReviewID(id int) productreviewOption {
	return func(m *ProductReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductReview
		)
		m.oldValue = func(ctx context.Context) (*ProductReview, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductReview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductReview sets the old ProductReview of the mutation.
func withProductReview(node *ProductReview) productreviewOption {
	return func(m *ProductReviewMutation) {
		m.oldValue = func(context.Context) (*ProductReview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductReviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductReviewMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductReviewMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductReviewMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductReviewMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductReviewMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductReviewMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductReviewMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductReviewMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductReviewMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productreview.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductReviewMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productreview.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductReviewMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productreview.FieldStringRef)
}

// SetUserLoginID sets the "user_login_id" field.
func (m *ProductReviewMutation) SetUserLoginID(s string) {
	m.user_login_id = &s
}

// UserLoginID returns the value of the "user_login_id" field in the mutation.
func (m *ProductReviewMutation) UserLoginID() (r string, exists bool) {
	v := m.user_login_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserLoginID returns the old "user_login_id" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldUserLoginID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserLoginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserLoginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserLoginID: %w", err)
	}
	return oldValue.UserLoginID, nil
}

// ClearUserLoginID clears the value of the "user_login_id" field.
func (m *ProductReviewMutation) ClearUserLoginID() {
	m.user_login_id = nil
	m.clearedFields[productreview.FieldUserLoginID] = struct{}{}
}

// UserLoginIDCleared returns if the "user_login_id" field was cleared in this mutation.
func (m *ProductReviewMutation) UserLoginIDCleared() bool {
	_, ok := m.clearedFields[productreview.FieldUserLoginID]
	return ok
}

// ResetUserLoginID resets all changes to the "user_login_id" field.
func (m *ProductReviewMutation) ResetUserLoginID() {
	m.user_login_id = nil
	delete(m.clearedFields, productreview.FieldUserLoginID)
}

// SetPostedAnonymous sets the "posted_anonymous" field.
func (m *ProductReviewMutation) SetPostedAnonymous(pa productreview.PostedAnonymous) {
	m.posted_anonymous = &pa
}

// PostedAnonymous returns the value of the "posted_anonymous" field in the mutation.
func (m *ProductReviewMutation) PostedAnonymous() (r productreview.PostedAnonymous, exists bool) {
	v := m.posted_anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldPostedAnonymous returns the old "posted_anonymous" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldPostedAnonymous(ctx context.Context) (v productreview.PostedAnonymous, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostedAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostedAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostedAnonymous: %w", err)
	}
	return oldValue.PostedAnonymous, nil
}

// ClearPostedAnonymous clears the value of the "posted_anonymous" field.
func (m *ProductReviewMutation) ClearPostedAnonymous() {
	m.posted_anonymous = nil
	m.clearedFields[productreview.FieldPostedAnonymous] = struct{}{}
}

// PostedAnonymousCleared returns if the "posted_anonymous" field was cleared in this mutation.
func (m *ProductReviewMutation) PostedAnonymousCleared() bool {
	_, ok := m.clearedFields[productreview.FieldPostedAnonymous]
	return ok
}

// ResetPostedAnonymous resets all changes to the "posted_anonymous" field.
func (m *ProductReviewMutation) ResetPostedAnonymous() {
	m.posted_anonymous = nil
	delete(m.clearedFields, productreview.FieldPostedAnonymous)
}

// SetPostedDateTime sets the "posted_date_time" field.
func (m *ProductReviewMutation) SetPostedDateTime(t time.Time) {
	m.posted_date_time = &t
}

// PostedDateTime returns the value of the "posted_date_time" field in the mutation.
func (m *ProductReviewMutation) PostedDateTime() (r time.Time, exists bool) {
	v := m.posted_date_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPostedDateTime returns the old "posted_date_time" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldPostedDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostedDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostedDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostedDateTime: %w", err)
	}
	return oldValue.PostedDateTime, nil
}

// ClearPostedDateTime clears the value of the "posted_date_time" field.
func (m *ProductReviewMutation) ClearPostedDateTime() {
	m.posted_date_time = nil
	m.clearedFields[productreview.FieldPostedDateTime] = struct{}{}
}

// PostedDateTimeCleared returns if the "posted_date_time" field was cleared in this mutation.
func (m *ProductReviewMutation) PostedDateTimeCleared() bool {
	_, ok := m.clearedFields[productreview.FieldPostedDateTime]
	return ok
}

// ResetPostedDateTime resets all changes to the "posted_date_time" field.
func (m *ProductReviewMutation) ResetPostedDateTime() {
	m.posted_date_time = nil
	delete(m.clearedFields, productreview.FieldPostedDateTime)
}

// SetProductRating sets the "product_rating" field.
func (m *ProductReviewMutation) SetProductRating(f float64) {
	m.product_rating = &f
	m.addproduct_rating = nil
}

// ProductRating returns the value of the "product_rating" field in the mutation.
func (m *ProductReviewMutation) ProductRating() (r float64, exists bool) {
	v := m.product_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldProductRating returns the old "product_rating" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldProductRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductRating: %w", err)
	}
	return oldValue.ProductRating, nil
}

// AddProductRating adds f to the "product_rating" field.
func (m *ProductReviewMutation) AddProductRating(f float64) {
	if m.addproduct_rating != nil {
		*m.addproduct_rating += f
	} else {
		m.addproduct_rating = &f
	}
}

// AddedProductRating returns the value that was added to the "product_rating" field in this mutation.
func (m *ProductReviewMutation) AddedProductRating() (r float64, exists bool) {
	v := m.addproduct_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductRating clears the value of the "product_rating" field.
func (m *ProductReviewMutation) ClearProductRating() {
	m.product_rating = nil
	m.addproduct_rating = nil
	m.clearedFields[productreview.FieldProductRating] = struct{}{}
}

// ProductRatingCleared returns if the "product_rating" field was cleared in this mutation.
func (m *ProductReviewMutation) ProductRatingCleared() bool {
	_, ok := m.clearedFields[productreview.FieldProductRating]
	return ok
}

// ResetProductRating resets all changes to the "product_rating" field.
func (m *ProductReviewMutation) ResetProductRating() {
	m.product_rating = nil
	m.addproduct_rating = nil
	delete(m.clearedFields, productreview.FieldProductRating)
}

// SetProductReview sets the "product_review" field.
func (m *ProductReviewMutation) SetProductReview(s string) {
	m.product_review = &s
}

// ProductReview returns the value of the "product_review" field in the mutation.
func (m *ProductReviewMutation) ProductReview() (r string, exists bool) {
	v := m.product_review
	if v == nil {
		return
	}
	return *v, true
}

// OldProductReview returns the old "product_review" field's value of the ProductReview entity.
// If the ProductReview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductReviewMutation) OldProductReview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductReview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductReview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductReview: %w", err)
	}
	return oldValue.ProductReview, nil
}

// ClearProductReview clears the value of the "product_review" field.
func (m *ProductReviewMutation) ClearProductReview() {
	m.product_review = nil
	m.clearedFields[productreview.FieldProductReview] = struct{}{}
}

// ProductReviewCleared returns if the "product_review" field was cleared in this mutation.
func (m *ProductReviewMutation) ProductReviewCleared() bool {
	_, ok := m.clearedFields[productreview.FieldProductReview]
	return ok
}

// ResetProductReview resets all changes to the "product_review" field.
func (m *ProductReviewMutation) ResetProductReview() {
	m.product_review = nil
	delete(m.clearedFields, productreview.FieldProductReview)
}

// SetProductStoreID sets the "product_store" edge to the ProductStore entity by id.
func (m *ProductReviewMutation) SetProductStoreID(id int) {
	m.product_store = &id
}

// ClearProductStore clears the "product_store" edge to the ProductStore entity.
func (m *ProductReviewMutation) ClearProductStore() {
	m.clearedproduct_store = true
}

// ProductStoreCleared reports if the "product_store" edge to the ProductStore entity was cleared.
func (m *ProductReviewMutation) ProductStoreCleared() bool {
	return m.clearedproduct_store
}

// ProductStoreID returns the "product_store" edge ID in the mutation.
func (m *ProductReviewMutation) ProductStoreID() (id int, exists bool) {
	if m.product_store != nil {
		return *m.product_store, true
	}
	return
}

// ProductStoreIDs returns the "product_store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductStoreID instead. It exists only for internal usage by the builders.
func (m *ProductReviewMutation) ProductStoreIDs() (ids []int) {
	if id := m.product_store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductStore resets all changes to the "product_store" edge.
func (m *ProductReviewMutation) ResetProductStore() {
	m.product_store = nil
	m.clearedproduct_store = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ProductReviewMutation) SetProductID(id int) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductReviewMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductReviewMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ProductReviewMutation) ProductID() (id int, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductReviewMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductReviewMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// SetStatusItemID sets the "status_item" edge to the StatusItem entity by id.
func (m *ProductReviewMutation) SetStatusItemID(id int) {
	m.status_item = &id
}

// ClearStatusItem clears the "status_item" edge to the StatusItem entity.
func (m *ProductReviewMutation) ClearStatusItem() {
	m.clearedstatus_item = true
}

// StatusItemCleared reports if the "status_item" edge to the StatusItem entity was cleared.
func (m *ProductReviewMutation) StatusItemCleared() bool {
	return m.clearedstatus_item
}

// StatusItemID returns the "status_item" edge ID in the mutation.
func (m *ProductReviewMutation) StatusItemID() (id int, exists bool) {
	if m.status_item != nil {
		return *m.status_item, true
	}
	return
}

// StatusItemIDs returns the "status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductReviewMutation) StatusItemIDs() (ids []int) {
	if id := m.status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusItem resets all changes to the "status_item" edge.
func (m *ProductReviewMutation) ResetStatusItem() {
	m.status_item = nil
	m.clearedstatus_item = false
}

// Op returns the operation name.
func (m *ProductReviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductReview).
func (m *ProductReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductReviewMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, productreview.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productreview.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productreview.FieldStringRef)
	}
	if m.user_login_id != nil {
		fields = append(fields, productreview.FieldUserLoginID)
	}
	if m.posted_anonymous != nil {
		fields = append(fields, productreview.FieldPostedAnonymous)
	}
	if m.posted_date_time != nil {
		fields = append(fields, productreview.FieldPostedDateTime)
	}
	if m.product_rating != nil {
		fields = append(fields, productreview.FieldProductRating)
	}
	if m.product_review != nil {
		fields = append(fields, productreview.FieldProductReview)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productreview.FieldCreateTime:
		return m.CreateTime()
	case productreview.FieldUpdateTime:
		return m.UpdateTime()
	case productreview.FieldStringRef:
		return m.StringRef()
	case productreview.FieldUserLoginID:
		return m.UserLoginID()
	case productreview.FieldPostedAnonymous:
		return m.PostedAnonymous()
	case productreview.FieldPostedDateTime:
		return m.PostedDateTime()
	case productreview.FieldProductRating:
		return m.ProductRating()
	case productreview.FieldProductReview:
		return m.ProductReview()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productreview.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productreview.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productreview.FieldStringRef:
		return m.OldStringRef(ctx)
	case productreview.FieldUserLoginID:
		return m.OldUserLoginID(ctx)
	case productreview.FieldPostedAnonymous:
		return m.OldPostedAnonymous(ctx)
	case productreview.FieldPostedDateTime:
		return m.OldPostedDateTime(ctx)
	case productreview.FieldProductRating:
		return m.OldProductRating(ctx)
	case productreview.FieldProductReview:
		return m.OldProductReview(ctx)
	}
	return nil, fmt.Errorf("unknown ProductReview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productreview.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productreview.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productreview.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productreview.FieldUserLoginID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserLoginID(v)
		return nil
	case productreview.FieldPostedAnonymous:
		v, ok := value.(productreview.PostedAnonymous)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostedAnonymous(v)
		return nil
	case productreview.FieldPostedDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostedDateTime(v)
		return nil
	case productreview.FieldProductRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductRating(v)
		return nil
	case productreview.FieldProductReview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductReview(v)
		return nil
	}
	return fmt.Errorf("unknown ProductReview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductReviewMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_rating != nil {
		fields = append(fields, productreview.FieldProductRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productreview.FieldProductRating:
		return m.AddedProductRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productreview.FieldProductRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductRating(v)
		return nil
	}
	return fmt.Errorf("unknown ProductReview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductReviewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productreview.FieldStringRef) {
		fields = append(fields, productreview.FieldStringRef)
	}
	if m.FieldCleared(productreview.FieldUserLoginID) {
		fields = append(fields, productreview.FieldUserLoginID)
	}
	if m.FieldCleared(productreview.FieldPostedAnonymous) {
		fields = append(fields, productreview.FieldPostedAnonymous)
	}
	if m.FieldCleared(productreview.FieldPostedDateTime) {
		fields = append(fields, productreview.FieldPostedDateTime)
	}
	if m.FieldCleared(productreview.FieldProductRating) {
		fields = append(fields, productreview.FieldProductRating)
	}
	if m.FieldCleared(productreview.FieldProductReview) {
		fields = append(fields, productreview.FieldProductReview)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductReviewMutation) ClearField(name string) error {
	switch name {
	case productreview.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productreview.FieldUserLoginID:
		m.ClearUserLoginID()
		return nil
	case productreview.FieldPostedAnonymous:
		m.ClearPostedAnonymous()
		return nil
	case productreview.FieldPostedDateTime:
		m.ClearPostedDateTime()
		return nil
	case productreview.FieldProductRating:
		m.ClearProductRating()
		return nil
	case productreview.FieldProductReview:
		m.ClearProductReview()
		return nil
	}
	return fmt.Errorf("unknown ProductReview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductReviewMutation) ResetField(name string) error {
	switch name {
	case productreview.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productreview.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productreview.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productreview.FieldUserLoginID:
		m.ResetUserLoginID()
		return nil
	case productreview.FieldPostedAnonymous:
		m.ResetPostedAnonymous()
		return nil
	case productreview.FieldPostedDateTime:
		m.ResetPostedDateTime()
		return nil
	case productreview.FieldProductRating:
		m.ResetProductRating()
		return nil
	case productreview.FieldProductReview:
		m.ResetProductReview()
		return nil
	}
	return fmt.Errorf("unknown ProductReview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.product_store != nil {
		edges = append(edges, productreview.EdgeProductStore)
	}
	if m.product != nil {
		edges = append(edges, productreview.EdgeProduct)
	}
	if m.status_item != nil {
		edges = append(edges, productreview.EdgeStatusItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productreview.EdgeProductStore:
		if id := m.product_store; id != nil {
			return []ent.Value{*id}
		}
	case productreview.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productreview.EdgeStatusItem:
		if id := m.status_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductReviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproduct_store {
		edges = append(edges, productreview.EdgeProductStore)
	}
	if m.clearedproduct {
		edges = append(edges, productreview.EdgeProduct)
	}
	if m.clearedstatus_item {
		edges = append(edges, productreview.EdgeStatusItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case productreview.EdgeProductStore:
		return m.clearedproduct_store
	case productreview.EdgeProduct:
		return m.clearedproduct
	case productreview.EdgeStatusItem:
		return m.clearedstatus_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductReviewMutation) ClearEdge(name string) error {
	switch name {
	case productreview.EdgeProductStore:
		m.ClearProductStore()
		return nil
	case productreview.EdgeProduct:
		m.ClearProduct()
		return nil
	case productreview.EdgeStatusItem:
		m.ClearStatusItem()
		return nil
	}
	return fmt.Errorf("unknown ProductReview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductReviewMutation) ResetEdge(name string) error {
	switch name {
	case productreview.EdgeProductStore:
		m.ResetProductStore()
		return nil
	case productreview.EdgeProduct:
		m.ResetProduct()
		return nil
	case productreview.EdgeStatusItem:
		m.ResetStatusItem()
		return nil
	}
	return fmt.Errorf("unknown ProductReview edge %s", name)
}

// ProductStoreMutation represents an operation that mutates the ProductStore nodes in the graph.
type ProductStoreMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	create_time                              *time.Time
	update_time                              *time.Time
	string_ref                               *string
	store_name                               *string
	company_name                             *string
	title                                    *string
	subtitle                                 *string
	pay_to_party_id                          *int
	addpay_to_party_id                       *int
	days_to_cancel_non_pay                   *int
	adddays_to_cancel_non_pay                *int
	manual_auth_is_capture                   *productstore.ManualAuthIsCapture
	prorate_shipping                         *productstore.ProrateShipping
	prorate_taxes                            *productstore.ProrateTaxes
	view_cart_on_add                         *productstore.ViewCartOnAdd
	auto_save_cart                           *productstore.AutoSaveCart
	auto_approve_reviews                     *productstore.AutoApproveReviews
	is_demo_store                            *productstore.IsDemoStore
	is_immediately_fulfilled                 *productstore.IsImmediatelyFulfilled
	inventory_facility_id                    *int
	addinventory_facility_id                 *int
	one_inventory_facility                   *productstore.OneInventoryFacility
	check_inventory                          *productstore.CheckInventory
	reserve_inventory                        *productstore.ReserveInventory
	require_inventory                        *productstore.RequireInventory
	balance_res_on_order_creation            *productstore.BalanceResOnOrderCreation
	order_number_prefix                      *string
	default_locale_string                    *string
	default_currency_uom_id                  *int
	adddefault_currency_uom_id               *int
	default_time_zone_string                 *string
	allow_password                           *productstore.AllowPassword
	default_password                         *string
	explode_order_items                      *productstore.ExplodeOrderItems
	check_gc_balance                         *productstore.CheckGcBalance
	retry_failed_auths                       *productstore.RetryFailedAuths
	auth_declined_message                    *string
	auth_fraud_message                       *string
	auth_error_message                       *string
	visual_theme_id                          *int
	addvisual_theme_id                       *int
	use_primary_email_username               *productstore.UsePrimaryEmailUsername
	require_customer_role                    *productstore.RequireCustomerRole
	auto_invoice_digital_items               *productstore.AutoInvoiceDigitalItems
	req_ship_addr_for_dig_items              *productstore.ReqShipAddrForDigItems
	show_checkout_gift_options               *productstore.ShowCheckoutGiftOptions
	select_payment_type_per_item             *productstore.SelectPaymentTypePerItem
	show_prices_with_vat_tax                 *productstore.ShowPricesWithVatTax
	show_tax_is_exempt                       *productstore.ShowTaxIsExempt
	vat_tax_auth_geo_id                      *int
	addvat_tax_auth_geo_id                   *int
	vat_tax_auth_party_id                    *int
	addvat_tax_auth_party_id                 *int
	enable_auto_suggestion_list              *productstore.EnableAutoSuggestionList
	enable_dig_prod_upload                   *productstore.EnableDigProdUpload
	prod_search_exclude_variants             *productstore.ProdSearchExcludeVariants
	dig_prod_upload_category_id              *int
	adddig_prod_upload_category_id           *int
	auto_order_cc_try_exp                    *productstore.AutoOrderCcTryExp
	auto_order_cc_try_other_cards            *productstore.AutoOrderCcTryOtherCards
	auto_order_cc_try_later_nsf              *productstore.AutoOrderCcTryLaterNsf
	auto_order_cc_try_later_max              *int
	addauto_order_cc_try_later_max           *int
	store_credit_valid_days                  *int
	addstore_credit_valid_days               *int
	auto_approve_invoice                     *productstore.AutoApproveInvoice
	auto_approve_order                       *productstore.AutoApproveOrder
	ship_if_capture_fails                    *productstore.ShipIfCaptureFails
	set_owner_upon_issuance                  *productstore.SetOwnerUponIssuance
	req_return_inventory_receive             *productstore.ReqReturnInventoryReceive
	add_to_cart_remove_incompat              *productstore.AddToCartRemoveIncompat
	add_to_cart_replace_upsell               *productstore.AddToCartReplaceUpsell
	split_pay_pref_per_shp_grp               *productstore.SplitPayPrefPerShpGrp
	managed_by_lot                           *productstore.ManagedByLot
	show_out_of_stock_products               *productstore.ShowOutOfStockProducts
	order_decimal_quantity                   *productstore.OrderDecimalQuantity
	allow_comment                            *productstore.AllowComment
	allocate_inventory                       *productstore.AllocateInventory
	clearedFields                            map[string]struct{}
	primary_product_store_group              *int
	clearedprimary_product_store_group       bool
	reserve_order_enumeration                *int
	clearedreserve_order_enumeration         bool
	requirement_method_enumeration           *int
	clearedrequirement_method_enumeration    bool
	default_sales_channel_enumeration        *int
	cleareddefault_sales_channel_enumeration bool
	header_approved_status_item              *int
	clearedheader_approved_status_item       bool
	item_approved_status_item                *int
	cleareditem_approved_status_item         bool
	digital_item_approved_status_item        *int
	cleareddigital_item_approved_status_item bool
	header_declined_status_item              *int
	clearedheader_declined_status_item       bool
	item_declined_status_item                *int
	cleareditem_declined_status_item         bool
	header_cancel_status_item                *int
	clearedheader_cancel_status_item         bool
	item_cancel_status_item                  *int
	cleareditem_cancel_status_item           bool
	store_credit_account_enumeration         *int
	clearedstore_credit_account_enumeration  bool
	order_headers                            map[int]struct{}
	removedorder_headers                     map[int]struct{}
	clearedorder_headers                     bool
	product_reviews                          map[int]struct{}
	removedproduct_reviews                   map[int]struct{}
	clearedproduct_reviews                   bool
	done                                     bool
	oldValue                                 func(context.Context) (*ProductStore, error)
	predicates                               []predicate.ProductStore
}

var _ ent.Mutation = (*ProductStoreMutation)(nil)

// productstoreOption allows management of the mutation configuration using functional options.
type productstoreOption func(*ProductStoreMutation)

// newProductStoreMutation creates new mutation for the ProductStore entity.
func newProductStoreMutation(c config, op Op, opts ...productstoreOption) *ProductStoreMutation {
	m := &ProductStoreMutation{
		config:        c,
		op:            op,
		typ:           TypeProductStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductStoreID sets the ID field of the mutation.
func withProductStoreID(id int) productstoreOption {
	return func(m *ProductStoreMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductStore
		)
		m.oldValue = func(ctx context.Context) (*ProductStore, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductStore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductStore sets the old ProductStore of the mutation.
func withProductStore(node *ProductStore) productstoreOption {
	return func(m *ProductStoreMutation) {
		m.oldValue = func(context.Context) (*ProductStore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductStoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductStoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductStoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductStoreMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductStoreMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductStoreMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductStoreMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductStoreMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductStoreMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductStoreMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductStoreMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductStoreMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productstore.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductStoreMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productstore.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductStoreMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productstore.FieldStringRef)
}

// SetStoreName sets the "store_name" field.
func (m *ProductStoreMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *ProductStoreMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ClearStoreName clears the value of the "store_name" field.
func (m *ProductStoreMutation) ClearStoreName() {
	m.store_name = nil
	m.clearedFields[productstore.FieldStoreName] = struct{}{}
}

// StoreNameCleared returns if the "store_name" field was cleared in this mutation.
func (m *ProductStoreMutation) StoreNameCleared() bool {
	_, ok := m.clearedFields[productstore.FieldStoreName]
	return ok
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *ProductStoreMutation) ResetStoreName() {
	m.store_name = nil
	delete(m.clearedFields, productstore.FieldStoreName)
}

// SetCompanyName sets the "company_name" field.
func (m *ProductStoreMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *ProductStoreMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *ProductStoreMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[productstore.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *ProductStoreMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[productstore.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *ProductStoreMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, productstore.FieldCompanyName)
}

// SetTitle sets the "title" field.
func (m *ProductStoreMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProductStoreMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ProductStoreMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[productstore.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ProductStoreMutation) TitleCleared() bool {
	_, ok := m.clearedFields[productstore.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ProductStoreMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, productstore.FieldTitle)
}

// SetSubtitle sets the "subtitle" field.
func (m *ProductStoreMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *ProductStoreMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ClearSubtitle clears the value of the "subtitle" field.
func (m *ProductStoreMutation) ClearSubtitle() {
	m.subtitle = nil
	m.clearedFields[productstore.FieldSubtitle] = struct{}{}
}

// SubtitleCleared returns if the "subtitle" field was cleared in this mutation.
func (m *ProductStoreMutation) SubtitleCleared() bool {
	_, ok := m.clearedFields[productstore.FieldSubtitle]
	return ok
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *ProductStoreMutation) ResetSubtitle() {
	m.subtitle = nil
	delete(m.clearedFields, productstore.FieldSubtitle)
}

// SetPayToPartyID sets the "pay_to_party_id" field.
func (m *ProductStoreMutation) SetPayToPartyID(i int) {
	m.pay_to_party_id = &i
	m.addpay_to_party_id = nil
}

// PayToPartyID returns the value of the "pay_to_party_id" field in the mutation.
func (m *ProductStoreMutation) PayToPartyID() (r int, exists bool) {
	v := m.pay_to_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPayToPartyID returns the old "pay_to_party_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldPayToPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayToPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayToPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayToPartyID: %w", err)
	}
	return oldValue.PayToPartyID, nil
}

// AddPayToPartyID adds i to the "pay_to_party_id" field.
func (m *ProductStoreMutation) AddPayToPartyID(i int) {
	if m.addpay_to_party_id != nil {
		*m.addpay_to_party_id += i
	} else {
		m.addpay_to_party_id = &i
	}
}

// AddedPayToPartyID returns the value that was added to the "pay_to_party_id" field in this mutation.
func (m *ProductStoreMutation) AddedPayToPartyID() (r int, exists bool) {
	v := m.addpay_to_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayToPartyID clears the value of the "pay_to_party_id" field.
func (m *ProductStoreMutation) ClearPayToPartyID() {
	m.pay_to_party_id = nil
	m.addpay_to_party_id = nil
	m.clearedFields[productstore.FieldPayToPartyID] = struct{}{}
}

// PayToPartyIDCleared returns if the "pay_to_party_id" field was cleared in this mutation.
func (m *ProductStoreMutation) PayToPartyIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldPayToPartyID]
	return ok
}

// ResetPayToPartyID resets all changes to the "pay_to_party_id" field.
func (m *ProductStoreMutation) ResetPayToPartyID() {
	m.pay_to_party_id = nil
	m.addpay_to_party_id = nil
	delete(m.clearedFields, productstore.FieldPayToPartyID)
}

// SetDaysToCancelNonPay sets the "days_to_cancel_non_pay" field.
func (m *ProductStoreMutation) SetDaysToCancelNonPay(i int) {
	m.days_to_cancel_non_pay = &i
	m.adddays_to_cancel_non_pay = nil
}

// DaysToCancelNonPay returns the value of the "days_to_cancel_non_pay" field in the mutation.
func (m *ProductStoreMutation) DaysToCancelNonPay() (r int, exists bool) {
	v := m.days_to_cancel_non_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldDaysToCancelNonPay returns the old "days_to_cancel_non_pay" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldDaysToCancelNonPay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDaysToCancelNonPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDaysToCancelNonPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDaysToCancelNonPay: %w", err)
	}
	return oldValue.DaysToCancelNonPay, nil
}

// AddDaysToCancelNonPay adds i to the "days_to_cancel_non_pay" field.
func (m *ProductStoreMutation) AddDaysToCancelNonPay(i int) {
	if m.adddays_to_cancel_non_pay != nil {
		*m.adddays_to_cancel_non_pay += i
	} else {
		m.adddays_to_cancel_non_pay = &i
	}
}

// AddedDaysToCancelNonPay returns the value that was added to the "days_to_cancel_non_pay" field in this mutation.
func (m *ProductStoreMutation) AddedDaysToCancelNonPay() (r int, exists bool) {
	v := m.adddays_to_cancel_non_pay
	if v == nil {
		return
	}
	return *v, true
}

// ClearDaysToCancelNonPay clears the value of the "days_to_cancel_non_pay" field.
func (m *ProductStoreMutation) ClearDaysToCancelNonPay() {
	m.days_to_cancel_non_pay = nil
	m.adddays_to_cancel_non_pay = nil
	m.clearedFields[productstore.FieldDaysToCancelNonPay] = struct{}{}
}

// DaysToCancelNonPayCleared returns if the "days_to_cancel_non_pay" field was cleared in this mutation.
func (m *ProductStoreMutation) DaysToCancelNonPayCleared() bool {
	_, ok := m.clearedFields[productstore.FieldDaysToCancelNonPay]
	return ok
}

// ResetDaysToCancelNonPay resets all changes to the "days_to_cancel_non_pay" field.
func (m *ProductStoreMutation) ResetDaysToCancelNonPay() {
	m.days_to_cancel_non_pay = nil
	m.adddays_to_cancel_non_pay = nil
	delete(m.clearedFields, productstore.FieldDaysToCancelNonPay)
}

// SetManualAuthIsCapture sets the "manual_auth_is_capture" field.
func (m *ProductStoreMutation) SetManualAuthIsCapture(paic productstore.ManualAuthIsCapture) {
	m.manual_auth_is_capture = &paic
}

// ManualAuthIsCapture returns the value of the "manual_auth_is_capture" field in the mutation.
func (m *ProductStoreMutation) ManualAuthIsCapture() (r productstore.ManualAuthIsCapture, exists bool) {
	v := m.manual_auth_is_capture
	if v == nil {
		return
	}
	return *v, true
}

// OldManualAuthIsCapture returns the old "manual_auth_is_capture" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldManualAuthIsCapture(ctx context.Context) (v productstore.ManualAuthIsCapture, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldManualAuthIsCapture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldManualAuthIsCapture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManualAuthIsCapture: %w", err)
	}
	return oldValue.ManualAuthIsCapture, nil
}

// ClearManualAuthIsCapture clears the value of the "manual_auth_is_capture" field.
func (m *ProductStoreMutation) ClearManualAuthIsCapture() {
	m.manual_auth_is_capture = nil
	m.clearedFields[productstore.FieldManualAuthIsCapture] = struct{}{}
}

// ManualAuthIsCaptureCleared returns if the "manual_auth_is_capture" field was cleared in this mutation.
func (m *ProductStoreMutation) ManualAuthIsCaptureCleared() bool {
	_, ok := m.clearedFields[productstore.FieldManualAuthIsCapture]
	return ok
}

// ResetManualAuthIsCapture resets all changes to the "manual_auth_is_capture" field.
func (m *ProductStoreMutation) ResetManualAuthIsCapture() {
	m.manual_auth_is_capture = nil
	delete(m.clearedFields, productstore.FieldManualAuthIsCapture)
}

// SetProrateShipping sets the "prorate_shipping" field.
func (m *ProductStoreMutation) SetProrateShipping(ps productstore.ProrateShipping) {
	m.prorate_shipping = &ps
}

// ProrateShipping returns the value of the "prorate_shipping" field in the mutation.
func (m *ProductStoreMutation) ProrateShipping() (r productstore.ProrateShipping, exists bool) {
	v := m.prorate_shipping
	if v == nil {
		return
	}
	return *v, true
}

// OldProrateShipping returns the old "prorate_shipping" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldProrateShipping(ctx context.Context) (v productstore.ProrateShipping, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProrateShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProrateShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProrateShipping: %w", err)
	}
	return oldValue.ProrateShipping, nil
}

// ClearProrateShipping clears the value of the "prorate_shipping" field.
func (m *ProductStoreMutation) ClearProrateShipping() {
	m.prorate_shipping = nil
	m.clearedFields[productstore.FieldProrateShipping] = struct{}{}
}

// ProrateShippingCleared returns if the "prorate_shipping" field was cleared in this mutation.
func (m *ProductStoreMutation) ProrateShippingCleared() bool {
	_, ok := m.clearedFields[productstore.FieldProrateShipping]
	return ok
}

// ResetProrateShipping resets all changes to the "prorate_shipping" field.
func (m *ProductStoreMutation) ResetProrateShipping() {
	m.prorate_shipping = nil
	delete(m.clearedFields, productstore.FieldProrateShipping)
}

// SetProrateTaxes sets the "prorate_taxes" field.
func (m *ProductStoreMutation) SetProrateTaxes(pt productstore.ProrateTaxes) {
	m.prorate_taxes = &pt
}

// ProrateTaxes returns the value of the "prorate_taxes" field in the mutation.
func (m *ProductStoreMutation) ProrateTaxes() (r productstore.ProrateTaxes, exists bool) {
	v := m.prorate_taxes
	if v == nil {
		return
	}
	return *v, true
}

// OldProrateTaxes returns the old "prorate_taxes" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldProrateTaxes(ctx context.Context) (v productstore.ProrateTaxes, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProrateTaxes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProrateTaxes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProrateTaxes: %w", err)
	}
	return oldValue.ProrateTaxes, nil
}

// ClearProrateTaxes clears the value of the "prorate_taxes" field.
func (m *ProductStoreMutation) ClearProrateTaxes() {
	m.prorate_taxes = nil
	m.clearedFields[productstore.FieldProrateTaxes] = struct{}{}
}

// ProrateTaxesCleared returns if the "prorate_taxes" field was cleared in this mutation.
func (m *ProductStoreMutation) ProrateTaxesCleared() bool {
	_, ok := m.clearedFields[productstore.FieldProrateTaxes]
	return ok
}

// ResetProrateTaxes resets all changes to the "prorate_taxes" field.
func (m *ProductStoreMutation) ResetProrateTaxes() {
	m.prorate_taxes = nil
	delete(m.clearedFields, productstore.FieldProrateTaxes)
}

// SetViewCartOnAdd sets the "view_cart_on_add" field.
func (m *ProductStoreMutation) SetViewCartOnAdd(pcoa productstore.ViewCartOnAdd) {
	m.view_cart_on_add = &pcoa
}

// ViewCartOnAdd returns the value of the "view_cart_on_add" field in the mutation.
func (m *ProductStoreMutation) ViewCartOnAdd() (r productstore.ViewCartOnAdd, exists bool) {
	v := m.view_cart_on_add
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCartOnAdd returns the old "view_cart_on_add" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldViewCartOnAdd(ctx context.Context) (v productstore.ViewCartOnAdd, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldViewCartOnAdd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldViewCartOnAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCartOnAdd: %w", err)
	}
	return oldValue.ViewCartOnAdd, nil
}

// ClearViewCartOnAdd clears the value of the "view_cart_on_add" field.
func (m *ProductStoreMutation) ClearViewCartOnAdd() {
	m.view_cart_on_add = nil
	m.clearedFields[productstore.FieldViewCartOnAdd] = struct{}{}
}

// ViewCartOnAddCleared returns if the "view_cart_on_add" field was cleared in this mutation.
func (m *ProductStoreMutation) ViewCartOnAddCleared() bool {
	_, ok := m.clearedFields[productstore.FieldViewCartOnAdd]
	return ok
}

// ResetViewCartOnAdd resets all changes to the "view_cart_on_add" field.
func (m *ProductStoreMutation) ResetViewCartOnAdd() {
	m.view_cart_on_add = nil
	delete(m.clearedFields, productstore.FieldViewCartOnAdd)
}

// SetAutoSaveCart sets the "auto_save_cart" field.
func (m *ProductStoreMutation) SetAutoSaveCart(psc productstore.AutoSaveCart) {
	m.auto_save_cart = &psc
}

// AutoSaveCart returns the value of the "auto_save_cart" field in the mutation.
func (m *ProductStoreMutation) AutoSaveCart() (r productstore.AutoSaveCart, exists bool) {
	v := m.auto_save_cart
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSaveCart returns the old "auto_save_cart" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoSaveCart(ctx context.Context) (v productstore.AutoSaveCart, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoSaveCart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoSaveCart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSaveCart: %w", err)
	}
	return oldValue.AutoSaveCart, nil
}

// ClearAutoSaveCart clears the value of the "auto_save_cart" field.
func (m *ProductStoreMutation) ClearAutoSaveCart() {
	m.auto_save_cart = nil
	m.clearedFields[productstore.FieldAutoSaveCart] = struct{}{}
}

// AutoSaveCartCleared returns if the "auto_save_cart" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoSaveCartCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoSaveCart]
	return ok
}

// ResetAutoSaveCart resets all changes to the "auto_save_cart" field.
func (m *ProductStoreMutation) ResetAutoSaveCart() {
	m.auto_save_cart = nil
	delete(m.clearedFields, productstore.FieldAutoSaveCart)
}

// SetAutoApproveReviews sets the "auto_approve_reviews" field.
func (m *ProductStoreMutation) SetAutoApproveReviews(par productstore.AutoApproveReviews) {
	m.auto_approve_reviews = &par
}

// AutoApproveReviews returns the value of the "auto_approve_reviews" field in the mutation.
func (m *ProductStoreMutation) AutoApproveReviews() (r productstore.AutoApproveReviews, exists bool) {
	v := m.auto_approve_reviews
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoApproveReviews returns the old "auto_approve_reviews" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoApproveReviews(ctx context.Context) (v productstore.AutoApproveReviews, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoApproveReviews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoApproveReviews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoApproveReviews: %w", err)
	}
	return oldValue.AutoApproveReviews, nil
}

// ClearAutoApproveReviews clears the value of the "auto_approve_reviews" field.
func (m *ProductStoreMutation) ClearAutoApproveReviews() {
	m.auto_approve_reviews = nil
	m.clearedFields[productstore.FieldAutoApproveReviews] = struct{}{}
}

// AutoApproveReviewsCleared returns if the "auto_approve_reviews" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoApproveReviewsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoApproveReviews]
	return ok
}

// ResetAutoApproveReviews resets all changes to the "auto_approve_reviews" field.
func (m *ProductStoreMutation) ResetAutoApproveReviews() {
	m.auto_approve_reviews = nil
	delete(m.clearedFields, productstore.FieldAutoApproveReviews)
}

// SetIsDemoStore sets the "is_demo_store" field.
func (m *ProductStoreMutation) SetIsDemoStore(pds productstore.IsDemoStore) {
	m.is_demo_store = &pds
}

// IsDemoStore returns the value of the "is_demo_store" field in the mutation.
func (m *ProductStoreMutation) IsDemoStore() (r productstore.IsDemoStore, exists bool) {
	v := m.is_demo_store
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDemoStore returns the old "is_demo_store" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldIsDemoStore(ctx context.Context) (v productstore.IsDemoStore, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDemoStore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDemoStore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDemoStore: %w", err)
	}
	return oldValue.IsDemoStore, nil
}

// ClearIsDemoStore clears the value of the "is_demo_store" field.
func (m *ProductStoreMutation) ClearIsDemoStore() {
	m.is_demo_store = nil
	m.clearedFields[productstore.FieldIsDemoStore] = struct{}{}
}

// IsDemoStoreCleared returns if the "is_demo_store" field was cleared in this mutation.
func (m *ProductStoreMutation) IsDemoStoreCleared() bool {
	_, ok := m.clearedFields[productstore.FieldIsDemoStore]
	return ok
}

// ResetIsDemoStore resets all changes to the "is_demo_store" field.
func (m *ProductStoreMutation) ResetIsDemoStore() {
	m.is_demo_store = nil
	delete(m.clearedFields, productstore.FieldIsDemoStore)
}

// SetIsImmediatelyFulfilled sets the "is_immediately_fulfilled" field.
func (m *ProductStoreMutation) SetIsImmediatelyFulfilled(pif productstore.IsImmediatelyFulfilled) {
	m.is_immediately_fulfilled = &pif
}

// IsImmediatelyFulfilled returns the value of the "is_immediately_fulfilled" field in the mutation.
func (m *ProductStoreMutation) IsImmediatelyFulfilled() (r productstore.IsImmediatelyFulfilled, exists bool) {
	v := m.is_immediately_fulfilled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsImmediatelyFulfilled returns the old "is_immediately_fulfilled" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldIsImmediatelyFulfilled(ctx context.Context) (v productstore.IsImmediatelyFulfilled, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsImmediatelyFulfilled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsImmediatelyFulfilled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsImmediatelyFulfilled: %w", err)
	}
	return oldValue.IsImmediatelyFulfilled, nil
}

// ClearIsImmediatelyFulfilled clears the value of the "is_immediately_fulfilled" field.
func (m *ProductStoreMutation) ClearIsImmediatelyFulfilled() {
	m.is_immediately_fulfilled = nil
	m.clearedFields[productstore.FieldIsImmediatelyFulfilled] = struct{}{}
}

// IsImmediatelyFulfilledCleared returns if the "is_immediately_fulfilled" field was cleared in this mutation.
func (m *ProductStoreMutation) IsImmediatelyFulfilledCleared() bool {
	_, ok := m.clearedFields[productstore.FieldIsImmediatelyFulfilled]
	return ok
}

// ResetIsImmediatelyFulfilled resets all changes to the "is_immediately_fulfilled" field.
func (m *ProductStoreMutation) ResetIsImmediatelyFulfilled() {
	m.is_immediately_fulfilled = nil
	delete(m.clearedFields, productstore.FieldIsImmediatelyFulfilled)
}

// SetInventoryFacilityID sets the "inventory_facility_id" field.
func (m *ProductStoreMutation) SetInventoryFacilityID(i int) {
	m.inventory_facility_id = &i
	m.addinventory_facility_id = nil
}

// InventoryFacilityID returns the value of the "inventory_facility_id" field in the mutation.
func (m *ProductStoreMutation) InventoryFacilityID() (r int, exists bool) {
	v := m.inventory_facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryFacilityID returns the old "inventory_facility_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldInventoryFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventoryFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventoryFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryFacilityID: %w", err)
	}
	return oldValue.InventoryFacilityID, nil
}

// AddInventoryFacilityID adds i to the "inventory_facility_id" field.
func (m *ProductStoreMutation) AddInventoryFacilityID(i int) {
	if m.addinventory_facility_id != nil {
		*m.addinventory_facility_id += i
	} else {
		m.addinventory_facility_id = &i
	}
}

// AddedInventoryFacilityID returns the value that was added to the "inventory_facility_id" field in this mutation.
func (m *ProductStoreMutation) AddedInventoryFacilityID() (r int, exists bool) {
	v := m.addinventory_facility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInventoryFacilityID clears the value of the "inventory_facility_id" field.
func (m *ProductStoreMutation) ClearInventoryFacilityID() {
	m.inventory_facility_id = nil
	m.addinventory_facility_id = nil
	m.clearedFields[productstore.FieldInventoryFacilityID] = struct{}{}
}

// InventoryFacilityIDCleared returns if the "inventory_facility_id" field was cleared in this mutation.
func (m *ProductStoreMutation) InventoryFacilityIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldInventoryFacilityID]
	return ok
}

// ResetInventoryFacilityID resets all changes to the "inventory_facility_id" field.
func (m *ProductStoreMutation) ResetInventoryFacilityID() {
	m.inventory_facility_id = nil
	m.addinventory_facility_id = nil
	delete(m.clearedFields, productstore.FieldInventoryFacilityID)
}

// SetOneInventoryFacility sets the "one_inventory_facility" field.
func (m *ProductStoreMutation) SetOneInventoryFacility(pif productstore.OneInventoryFacility) {
	m.one_inventory_facility = &pif
}

// OneInventoryFacility returns the value of the "one_inventory_facility" field in the mutation.
func (m *ProductStoreMutation) OneInventoryFacility() (r productstore.OneInventoryFacility, exists bool) {
	v := m.one_inventory_facility
	if v == nil {
		return
	}
	return *v, true
}

// OldOneInventoryFacility returns the old "one_inventory_facility" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldOneInventoryFacility(ctx context.Context) (v productstore.OneInventoryFacility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOneInventoryFacility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOneInventoryFacility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOneInventoryFacility: %w", err)
	}
	return oldValue.OneInventoryFacility, nil
}

// ClearOneInventoryFacility clears the value of the "one_inventory_facility" field.
func (m *ProductStoreMutation) ClearOneInventoryFacility() {
	m.one_inventory_facility = nil
	m.clearedFields[productstore.FieldOneInventoryFacility] = struct{}{}
}

// OneInventoryFacilityCleared returns if the "one_inventory_facility" field was cleared in this mutation.
func (m *ProductStoreMutation) OneInventoryFacilityCleared() bool {
	_, ok := m.clearedFields[productstore.FieldOneInventoryFacility]
	return ok
}

// ResetOneInventoryFacility resets all changes to the "one_inventory_facility" field.
func (m *ProductStoreMutation) ResetOneInventoryFacility() {
	m.one_inventory_facility = nil
	delete(m.clearedFields, productstore.FieldOneInventoryFacility)
}

// SetCheckInventory sets the "check_inventory" field.
func (m *ProductStoreMutation) SetCheckInventory(pi productstore.CheckInventory) {
	m.check_inventory = &pi
}

// CheckInventory returns the value of the "check_inventory" field in the mutation.
func (m *ProductStoreMutation) CheckInventory() (r productstore.CheckInventory, exists bool) {
	v := m.check_inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInventory returns the old "check_inventory" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldCheckInventory(ctx context.Context) (v productstore.CheckInventory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInventory: %w", err)
	}
	return oldValue.CheckInventory, nil
}

// ClearCheckInventory clears the value of the "check_inventory" field.
func (m *ProductStoreMutation) ClearCheckInventory() {
	m.check_inventory = nil
	m.clearedFields[productstore.FieldCheckInventory] = struct{}{}
}

// CheckInventoryCleared returns if the "check_inventory" field was cleared in this mutation.
func (m *ProductStoreMutation) CheckInventoryCleared() bool {
	_, ok := m.clearedFields[productstore.FieldCheckInventory]
	return ok
}

// ResetCheckInventory resets all changes to the "check_inventory" field.
func (m *ProductStoreMutation) ResetCheckInventory() {
	m.check_inventory = nil
	delete(m.clearedFields, productstore.FieldCheckInventory)
}

// SetReserveInventory sets the "reserve_inventory" field.
func (m *ProductStoreMutation) SetReserveInventory(pi productstore.ReserveInventory) {
	m.reserve_inventory = &pi
}

// ReserveInventory returns the value of the "reserve_inventory" field in the mutation.
func (m *ProductStoreMutation) ReserveInventory() (r productstore.ReserveInventory, exists bool) {
	v := m.reserve_inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldReserveInventory returns the old "reserve_inventory" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldReserveInventory(ctx context.Context) (v productstore.ReserveInventory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReserveInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReserveInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserveInventory: %w", err)
	}
	return oldValue.ReserveInventory, nil
}

// ClearReserveInventory clears the value of the "reserve_inventory" field.
func (m *ProductStoreMutation) ClearReserveInventory() {
	m.reserve_inventory = nil
	m.clearedFields[productstore.FieldReserveInventory] = struct{}{}
}

// ReserveInventoryCleared returns if the "reserve_inventory" field was cleared in this mutation.
func (m *ProductStoreMutation) ReserveInventoryCleared() bool {
	_, ok := m.clearedFields[productstore.FieldReserveInventory]
	return ok
}

// ResetReserveInventory resets all changes to the "reserve_inventory" field.
func (m *ProductStoreMutation) ResetReserveInventory() {
	m.reserve_inventory = nil
	delete(m.clearedFields, productstore.FieldReserveInventory)
}

// SetRequireInventory sets the "require_inventory" field.
func (m *ProductStoreMutation) SetRequireInventory(pi productstore.RequireInventory) {
	m.require_inventory = &pi
}

// RequireInventory returns the value of the "require_inventory" field in the mutation.
func (m *ProductStoreMutation) RequireInventory() (r productstore.RequireInventory, exists bool) {
	v := m.require_inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireInventory returns the old "require_inventory" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldRequireInventory(ctx context.Context) (v productstore.RequireInventory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequireInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequireInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireInventory: %w", err)
	}
	return oldValue.RequireInventory, nil
}

// ClearRequireInventory clears the value of the "require_inventory" field.
func (m *ProductStoreMutation) ClearRequireInventory() {
	m.require_inventory = nil
	m.clearedFields[productstore.FieldRequireInventory] = struct{}{}
}

// RequireInventoryCleared returns if the "require_inventory" field was cleared in this mutation.
func (m *ProductStoreMutation) RequireInventoryCleared() bool {
	_, ok := m.clearedFields[productstore.FieldRequireInventory]
	return ok
}

// ResetRequireInventory resets all changes to the "require_inventory" field.
func (m *ProductStoreMutation) ResetRequireInventory() {
	m.require_inventory = nil
	delete(m.clearedFields, productstore.FieldRequireInventory)
}

// SetBalanceResOnOrderCreation sets the "balance_res_on_order_creation" field.
func (m *ProductStoreMutation) SetBalanceResOnOrderCreation(prooc productstore.BalanceResOnOrderCreation) {
	m.balance_res_on_order_creation = &prooc
}

// BalanceResOnOrderCreation returns the value of the "balance_res_on_order_creation" field in the mutation.
func (m *ProductStoreMutation) BalanceResOnOrderCreation() (r productstore.BalanceResOnOrderCreation, exists bool) {
	v := m.balance_res_on_order_creation
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceResOnOrderCreation returns the old "balance_res_on_order_creation" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldBalanceResOnOrderCreation(ctx context.Context) (v productstore.BalanceResOnOrderCreation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalanceResOnOrderCreation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalanceResOnOrderCreation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceResOnOrderCreation: %w", err)
	}
	return oldValue.BalanceResOnOrderCreation, nil
}

// ClearBalanceResOnOrderCreation clears the value of the "balance_res_on_order_creation" field.
func (m *ProductStoreMutation) ClearBalanceResOnOrderCreation() {
	m.balance_res_on_order_creation = nil
	m.clearedFields[productstore.FieldBalanceResOnOrderCreation] = struct{}{}
}

// BalanceResOnOrderCreationCleared returns if the "balance_res_on_order_creation" field was cleared in this mutation.
func (m *ProductStoreMutation) BalanceResOnOrderCreationCleared() bool {
	_, ok := m.clearedFields[productstore.FieldBalanceResOnOrderCreation]
	return ok
}

// ResetBalanceResOnOrderCreation resets all changes to the "balance_res_on_order_creation" field.
func (m *ProductStoreMutation) ResetBalanceResOnOrderCreation() {
	m.balance_res_on_order_creation = nil
	delete(m.clearedFields, productstore.FieldBalanceResOnOrderCreation)
}

// SetOrderNumberPrefix sets the "order_number_prefix" field.
func (m *ProductStoreMutation) SetOrderNumberPrefix(s string) {
	m.order_number_prefix = &s
}

// OrderNumberPrefix returns the value of the "order_number_prefix" field in the mutation.
func (m *ProductStoreMutation) OrderNumberPrefix() (r string, exists bool) {
	v := m.order_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumberPrefix returns the old "order_number_prefix" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldOrderNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumberPrefix: %w", err)
	}
	return oldValue.OrderNumberPrefix, nil
}

// ClearOrderNumberPrefix clears the value of the "order_number_prefix" field.
func (m *ProductStoreMutation) ClearOrderNumberPrefix() {
	m.order_number_prefix = nil
	m.clearedFields[productstore.FieldOrderNumberPrefix] = struct{}{}
}

// OrderNumberPrefixCleared returns if the "order_number_prefix" field was cleared in this mutation.
func (m *ProductStoreMutation) OrderNumberPrefixCleared() bool {
	_, ok := m.clearedFields[productstore.FieldOrderNumberPrefix]
	return ok
}

// ResetOrderNumberPrefix resets all changes to the "order_number_prefix" field.
func (m *ProductStoreMutation) ResetOrderNumberPrefix() {
	m.order_number_prefix = nil
	delete(m.clearedFields, productstore.FieldOrderNumberPrefix)
}

// SetDefaultLocaleString sets the "default_locale_string" field.
func (m *ProductStoreMutation) SetDefaultLocaleString(s string) {
	m.default_locale_string = &s
}

// DefaultLocaleString returns the value of the "default_locale_string" field in the mutation.
func (m *ProductStoreMutation) DefaultLocaleString() (r string, exists bool) {
	v := m.default_locale_string
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultLocaleString returns the old "default_locale_string" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldDefaultLocaleString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultLocaleString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultLocaleString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultLocaleString: %w", err)
	}
	return oldValue.DefaultLocaleString, nil
}

// ClearDefaultLocaleString clears the value of the "default_locale_string" field.
func (m *ProductStoreMutation) ClearDefaultLocaleString() {
	m.default_locale_string = nil
	m.clearedFields[productstore.FieldDefaultLocaleString] = struct{}{}
}

// DefaultLocaleStringCleared returns if the "default_locale_string" field was cleared in this mutation.
func (m *ProductStoreMutation) DefaultLocaleStringCleared() bool {
	_, ok := m.clearedFields[productstore.FieldDefaultLocaleString]
	return ok
}

// ResetDefaultLocaleString resets all changes to the "default_locale_string" field.
func (m *ProductStoreMutation) ResetDefaultLocaleString() {
	m.default_locale_string = nil
	delete(m.clearedFields, productstore.FieldDefaultLocaleString)
}

// SetDefaultCurrencyUomID sets the "default_currency_uom_id" field.
func (m *ProductStoreMutation) SetDefaultCurrencyUomID(i int) {
	m.default_currency_uom_id = &i
	m.adddefault_currency_uom_id = nil
}

// DefaultCurrencyUomID returns the value of the "default_currency_uom_id" field in the mutation.
func (m *ProductStoreMutation) DefaultCurrencyUomID() (r int, exists bool) {
	v := m.default_currency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultCurrencyUomID returns the old "default_currency_uom_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldDefaultCurrencyUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultCurrencyUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultCurrencyUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultCurrencyUomID: %w", err)
	}
	return oldValue.DefaultCurrencyUomID, nil
}

// AddDefaultCurrencyUomID adds i to the "default_currency_uom_id" field.
func (m *ProductStoreMutation) AddDefaultCurrencyUomID(i int) {
	if m.adddefault_currency_uom_id != nil {
		*m.adddefault_currency_uom_id += i
	} else {
		m.adddefault_currency_uom_id = &i
	}
}

// AddedDefaultCurrencyUomID returns the value that was added to the "default_currency_uom_id" field in this mutation.
func (m *ProductStoreMutation) AddedDefaultCurrencyUomID() (r int, exists bool) {
	v := m.adddefault_currency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDefaultCurrencyUomID clears the value of the "default_currency_uom_id" field.
func (m *ProductStoreMutation) ClearDefaultCurrencyUomID() {
	m.default_currency_uom_id = nil
	m.adddefault_currency_uom_id = nil
	m.clearedFields[productstore.FieldDefaultCurrencyUomID] = struct{}{}
}

// DefaultCurrencyUomIDCleared returns if the "default_currency_uom_id" field was cleared in this mutation.
func (m *ProductStoreMutation) DefaultCurrencyUomIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldDefaultCurrencyUomID]
	return ok
}

// ResetDefaultCurrencyUomID resets all changes to the "default_currency_uom_id" field.
func (m *ProductStoreMutation) ResetDefaultCurrencyUomID() {
	m.default_currency_uom_id = nil
	m.adddefault_currency_uom_id = nil
	delete(m.clearedFields, productstore.FieldDefaultCurrencyUomID)
}

// SetDefaultTimeZoneString sets the "default_time_zone_string" field.
func (m *ProductStoreMutation) SetDefaultTimeZoneString(s string) {
	m.default_time_zone_string = &s
}

// DefaultTimeZoneString returns the value of the "default_time_zone_string" field in the mutation.
func (m *ProductStoreMutation) DefaultTimeZoneString() (r string, exists bool) {
	v := m.default_time_zone_string
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTimeZoneString returns the old "default_time_zone_string" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldDefaultTimeZoneString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultTimeZoneString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultTimeZoneString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTimeZoneString: %w", err)
	}
	return oldValue.DefaultTimeZoneString, nil
}

// ClearDefaultTimeZoneString clears the value of the "default_time_zone_string" field.
func (m *ProductStoreMutation) ClearDefaultTimeZoneString() {
	m.default_time_zone_string = nil
	m.clearedFields[productstore.FieldDefaultTimeZoneString] = struct{}{}
}

// DefaultTimeZoneStringCleared returns if the "default_time_zone_string" field was cleared in this mutation.
func (m *ProductStoreMutation) DefaultTimeZoneStringCleared() bool {
	_, ok := m.clearedFields[productstore.FieldDefaultTimeZoneString]
	return ok
}

// ResetDefaultTimeZoneString resets all changes to the "default_time_zone_string" field.
func (m *ProductStoreMutation) ResetDefaultTimeZoneString() {
	m.default_time_zone_string = nil
	delete(m.clearedFields, productstore.FieldDefaultTimeZoneString)
}

// SetAllowPassword sets the "allow_password" field.
func (m *ProductStoreMutation) SetAllowPassword(pp productstore.AllowPassword) {
	m.allow_password = &pp
}

// AllowPassword returns the value of the "allow_password" field in the mutation.
func (m *ProductStoreMutation) AllowPassword() (r productstore.AllowPassword, exists bool) {
	v := m.allow_password
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowPassword returns the old "allow_password" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAllowPassword(ctx context.Context) (v productstore.AllowPassword, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllowPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllowPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowPassword: %w", err)
	}
	return oldValue.AllowPassword, nil
}

// ClearAllowPassword clears the value of the "allow_password" field.
func (m *ProductStoreMutation) ClearAllowPassword() {
	m.allow_password = nil
	m.clearedFields[productstore.FieldAllowPassword] = struct{}{}
}

// AllowPasswordCleared returns if the "allow_password" field was cleared in this mutation.
func (m *ProductStoreMutation) AllowPasswordCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAllowPassword]
	return ok
}

// ResetAllowPassword resets all changes to the "allow_password" field.
func (m *ProductStoreMutation) ResetAllowPassword() {
	m.allow_password = nil
	delete(m.clearedFields, productstore.FieldAllowPassword)
}

// SetDefaultPassword sets the "default_password" field.
func (m *ProductStoreMutation) SetDefaultPassword(s string) {
	m.default_password = &s
}

// DefaultPassword returns the value of the "default_password" field in the mutation.
func (m *ProductStoreMutation) DefaultPassword() (r string, exists bool) {
	v := m.default_password
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultPassword returns the old "default_password" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldDefaultPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultPassword: %w", err)
	}
	return oldValue.DefaultPassword, nil
}

// ClearDefaultPassword clears the value of the "default_password" field.
func (m *ProductStoreMutation) ClearDefaultPassword() {
	m.default_password = nil
	m.clearedFields[productstore.FieldDefaultPassword] = struct{}{}
}

// DefaultPasswordCleared returns if the "default_password" field was cleared in this mutation.
func (m *ProductStoreMutation) DefaultPasswordCleared() bool {
	_, ok := m.clearedFields[productstore.FieldDefaultPassword]
	return ok
}

// ResetDefaultPassword resets all changes to the "default_password" field.
func (m *ProductStoreMutation) ResetDefaultPassword() {
	m.default_password = nil
	delete(m.clearedFields, productstore.FieldDefaultPassword)
}

// SetExplodeOrderItems sets the "explode_order_items" field.
func (m *ProductStoreMutation) SetExplodeOrderItems(poi productstore.ExplodeOrderItems) {
	m.explode_order_items = &poi
}

// ExplodeOrderItems returns the value of the "explode_order_items" field in the mutation.
func (m *ProductStoreMutation) ExplodeOrderItems() (r productstore.ExplodeOrderItems, exists bool) {
	v := m.explode_order_items
	if v == nil {
		return
	}
	return *v, true
}

// OldExplodeOrderItems returns the old "explode_order_items" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldExplodeOrderItems(ctx context.Context) (v productstore.ExplodeOrderItems, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExplodeOrderItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExplodeOrderItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExplodeOrderItems: %w", err)
	}
	return oldValue.ExplodeOrderItems, nil
}

// ClearExplodeOrderItems clears the value of the "explode_order_items" field.
func (m *ProductStoreMutation) ClearExplodeOrderItems() {
	m.explode_order_items = nil
	m.clearedFields[productstore.FieldExplodeOrderItems] = struct{}{}
}

// ExplodeOrderItemsCleared returns if the "explode_order_items" field was cleared in this mutation.
func (m *ProductStoreMutation) ExplodeOrderItemsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldExplodeOrderItems]
	return ok
}

// ResetExplodeOrderItems resets all changes to the "explode_order_items" field.
func (m *ProductStoreMutation) ResetExplodeOrderItems() {
	m.explode_order_items = nil
	delete(m.clearedFields, productstore.FieldExplodeOrderItems)
}

// SetCheckGcBalance sets the "check_gc_balance" field.
func (m *ProductStoreMutation) SetCheckGcBalance(pgb productstore.CheckGcBalance) {
	m.check_gc_balance = &pgb
}

// CheckGcBalance returns the value of the "check_gc_balance" field in the mutation.
func (m *ProductStoreMutation) CheckGcBalance() (r productstore.CheckGcBalance, exists bool) {
	v := m.check_gc_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckGcBalance returns the old "check_gc_balance" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldCheckGcBalance(ctx context.Context) (v productstore.CheckGcBalance, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckGcBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckGcBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckGcBalance: %w", err)
	}
	return oldValue.CheckGcBalance, nil
}

// ClearCheckGcBalance clears the value of the "check_gc_balance" field.
func (m *ProductStoreMutation) ClearCheckGcBalance() {
	m.check_gc_balance = nil
	m.clearedFields[productstore.FieldCheckGcBalance] = struct{}{}
}

// CheckGcBalanceCleared returns if the "check_gc_balance" field was cleared in this mutation.
func (m *ProductStoreMutation) CheckGcBalanceCleared() bool {
	_, ok := m.clearedFields[productstore.FieldCheckGcBalance]
	return ok
}

// ResetCheckGcBalance resets all changes to the "check_gc_balance" field.
func (m *ProductStoreMutation) ResetCheckGcBalance() {
	m.check_gc_balance = nil
	delete(m.clearedFields, productstore.FieldCheckGcBalance)
}

// SetRetryFailedAuths sets the "retry_failed_auths" field.
func (m *ProductStoreMutation) SetRetryFailedAuths(pfa productstore.RetryFailedAuths) {
	m.retry_failed_auths = &pfa
}

// RetryFailedAuths returns the value of the "retry_failed_auths" field in the mutation.
func (m *ProductStoreMutation) RetryFailedAuths() (r productstore.RetryFailedAuths, exists bool) {
	v := m.retry_failed_auths
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryFailedAuths returns the old "retry_failed_auths" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldRetryFailedAuths(ctx context.Context) (v productstore.RetryFailedAuths, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRetryFailedAuths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRetryFailedAuths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryFailedAuths: %w", err)
	}
	return oldValue.RetryFailedAuths, nil
}

// ClearRetryFailedAuths clears the value of the "retry_failed_auths" field.
func (m *ProductStoreMutation) ClearRetryFailedAuths() {
	m.retry_failed_auths = nil
	m.clearedFields[productstore.FieldRetryFailedAuths] = struct{}{}
}

// RetryFailedAuthsCleared returns if the "retry_failed_auths" field was cleared in this mutation.
func (m *ProductStoreMutation) RetryFailedAuthsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldRetryFailedAuths]
	return ok
}

// ResetRetryFailedAuths resets all changes to the "retry_failed_auths" field.
func (m *ProductStoreMutation) ResetRetryFailedAuths() {
	m.retry_failed_auths = nil
	delete(m.clearedFields, productstore.FieldRetryFailedAuths)
}

// SetAuthDeclinedMessage sets the "auth_declined_message" field.
func (m *ProductStoreMutation) SetAuthDeclinedMessage(s string) {
	m.auth_declined_message = &s
}

// AuthDeclinedMessage returns the value of the "auth_declined_message" field in the mutation.
func (m *ProductStoreMutation) AuthDeclinedMessage() (r string, exists bool) {
	v := m.auth_declined_message
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthDeclinedMessage returns the old "auth_declined_message" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAuthDeclinedMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthDeclinedMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthDeclinedMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthDeclinedMessage: %w", err)
	}
	return oldValue.AuthDeclinedMessage, nil
}

// ClearAuthDeclinedMessage clears the value of the "auth_declined_message" field.
func (m *ProductStoreMutation) ClearAuthDeclinedMessage() {
	m.auth_declined_message = nil
	m.clearedFields[productstore.FieldAuthDeclinedMessage] = struct{}{}
}

// AuthDeclinedMessageCleared returns if the "auth_declined_message" field was cleared in this mutation.
func (m *ProductStoreMutation) AuthDeclinedMessageCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAuthDeclinedMessage]
	return ok
}

// ResetAuthDeclinedMessage resets all changes to the "auth_declined_message" field.
func (m *ProductStoreMutation) ResetAuthDeclinedMessage() {
	m.auth_declined_message = nil
	delete(m.clearedFields, productstore.FieldAuthDeclinedMessage)
}

// SetAuthFraudMessage sets the "auth_fraud_message" field.
func (m *ProductStoreMutation) SetAuthFraudMessage(s string) {
	m.auth_fraud_message = &s
}

// AuthFraudMessage returns the value of the "auth_fraud_message" field in the mutation.
func (m *ProductStoreMutation) AuthFraudMessage() (r string, exists bool) {
	v := m.auth_fraud_message
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthFraudMessage returns the old "auth_fraud_message" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAuthFraudMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthFraudMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthFraudMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthFraudMessage: %w", err)
	}
	return oldValue.AuthFraudMessage, nil
}

// ClearAuthFraudMessage clears the value of the "auth_fraud_message" field.
func (m *ProductStoreMutation) ClearAuthFraudMessage() {
	m.auth_fraud_message = nil
	m.clearedFields[productstore.FieldAuthFraudMessage] = struct{}{}
}

// AuthFraudMessageCleared returns if the "auth_fraud_message" field was cleared in this mutation.
func (m *ProductStoreMutation) AuthFraudMessageCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAuthFraudMessage]
	return ok
}

// ResetAuthFraudMessage resets all changes to the "auth_fraud_message" field.
func (m *ProductStoreMutation) ResetAuthFraudMessage() {
	m.auth_fraud_message = nil
	delete(m.clearedFields, productstore.FieldAuthFraudMessage)
}

// SetAuthErrorMessage sets the "auth_error_message" field.
func (m *ProductStoreMutation) SetAuthErrorMessage(s string) {
	m.auth_error_message = &s
}

// AuthErrorMessage returns the value of the "auth_error_message" field in the mutation.
func (m *ProductStoreMutation) AuthErrorMessage() (r string, exists bool) {
	v := m.auth_error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthErrorMessage returns the old "auth_error_message" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAuthErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthErrorMessage: %w", err)
	}
	return oldValue.AuthErrorMessage, nil
}

// ClearAuthErrorMessage clears the value of the "auth_error_message" field.
func (m *ProductStoreMutation) ClearAuthErrorMessage() {
	m.auth_error_message = nil
	m.clearedFields[productstore.FieldAuthErrorMessage] = struct{}{}
}

// AuthErrorMessageCleared returns if the "auth_error_message" field was cleared in this mutation.
func (m *ProductStoreMutation) AuthErrorMessageCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAuthErrorMessage]
	return ok
}

// ResetAuthErrorMessage resets all changes to the "auth_error_message" field.
func (m *ProductStoreMutation) ResetAuthErrorMessage() {
	m.auth_error_message = nil
	delete(m.clearedFields, productstore.FieldAuthErrorMessage)
}

// SetVisualThemeID sets the "visual_theme_id" field.
func (m *ProductStoreMutation) SetVisualThemeID(i int) {
	m.visual_theme_id = &i
	m.addvisual_theme_id = nil
}

// VisualThemeID returns the value of the "visual_theme_id" field in the mutation.
func (m *ProductStoreMutation) VisualThemeID() (r int, exists bool) {
	v := m.visual_theme_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVisualThemeID returns the old "visual_theme_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldVisualThemeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVisualThemeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVisualThemeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisualThemeID: %w", err)
	}
	return oldValue.VisualThemeID, nil
}

// AddVisualThemeID adds i to the "visual_theme_id" field.
func (m *ProductStoreMutation) AddVisualThemeID(i int) {
	if m.addvisual_theme_id != nil {
		*m.addvisual_theme_id += i
	} else {
		m.addvisual_theme_id = &i
	}
}

// AddedVisualThemeID returns the value that was added to the "visual_theme_id" field in this mutation.
func (m *ProductStoreMutation) AddedVisualThemeID() (r int, exists bool) {
	v := m.addvisual_theme_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVisualThemeID clears the value of the "visual_theme_id" field.
func (m *ProductStoreMutation) ClearVisualThemeID() {
	m.visual_theme_id = nil
	m.addvisual_theme_id = nil
	m.clearedFields[productstore.FieldVisualThemeID] = struct{}{}
}

// VisualThemeIDCleared returns if the "visual_theme_id" field was cleared in this mutation.
func (m *ProductStoreMutation) VisualThemeIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldVisualThemeID]
	return ok
}

// ResetVisualThemeID resets all changes to the "visual_theme_id" field.
func (m *ProductStoreMutation) ResetVisualThemeID() {
	m.visual_theme_id = nil
	m.addvisual_theme_id = nil
	delete(m.clearedFields, productstore.FieldVisualThemeID)
}

// SetUsePrimaryEmailUsername sets the "use_primary_email_username" field.
func (m *ProductStoreMutation) SetUsePrimaryEmailUsername(ppeu productstore.UsePrimaryEmailUsername) {
	m.use_primary_email_username = &ppeu
}

// UsePrimaryEmailUsername returns the value of the "use_primary_email_username" field in the mutation.
func (m *ProductStoreMutation) UsePrimaryEmailUsername() (r productstore.UsePrimaryEmailUsername, exists bool) {
	v := m.use_primary_email_username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsePrimaryEmailUsername returns the old "use_primary_email_username" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldUsePrimaryEmailUsername(ctx context.Context) (v productstore.UsePrimaryEmailUsername, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsePrimaryEmailUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsePrimaryEmailUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsePrimaryEmailUsername: %w", err)
	}
	return oldValue.UsePrimaryEmailUsername, nil
}

// ClearUsePrimaryEmailUsername clears the value of the "use_primary_email_username" field.
func (m *ProductStoreMutation) ClearUsePrimaryEmailUsername() {
	m.use_primary_email_username = nil
	m.clearedFields[productstore.FieldUsePrimaryEmailUsername] = struct{}{}
}

// UsePrimaryEmailUsernameCleared returns if the "use_primary_email_username" field was cleared in this mutation.
func (m *ProductStoreMutation) UsePrimaryEmailUsernameCleared() bool {
	_, ok := m.clearedFields[productstore.FieldUsePrimaryEmailUsername]
	return ok
}

// ResetUsePrimaryEmailUsername resets all changes to the "use_primary_email_username" field.
func (m *ProductStoreMutation) ResetUsePrimaryEmailUsername() {
	m.use_primary_email_username = nil
	delete(m.clearedFields, productstore.FieldUsePrimaryEmailUsername)
}

// SetRequireCustomerRole sets the "require_customer_role" field.
func (m *ProductStoreMutation) SetRequireCustomerRole(pcr productstore.RequireCustomerRole) {
	m.require_customer_role = &pcr
}

// RequireCustomerRole returns the value of the "require_customer_role" field in the mutation.
func (m *ProductStoreMutation) RequireCustomerRole() (r productstore.RequireCustomerRole, exists bool) {
	v := m.require_customer_role
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireCustomerRole returns the old "require_customer_role" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldRequireCustomerRole(ctx context.Context) (v productstore.RequireCustomerRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequireCustomerRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequireCustomerRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireCustomerRole: %w", err)
	}
	return oldValue.RequireCustomerRole, nil
}

// ClearRequireCustomerRole clears the value of the "require_customer_role" field.
func (m *ProductStoreMutation) ClearRequireCustomerRole() {
	m.require_customer_role = nil
	m.clearedFields[productstore.FieldRequireCustomerRole] = struct{}{}
}

// RequireCustomerRoleCleared returns if the "require_customer_role" field was cleared in this mutation.
func (m *ProductStoreMutation) RequireCustomerRoleCleared() bool {
	_, ok := m.clearedFields[productstore.FieldRequireCustomerRole]
	return ok
}

// ResetRequireCustomerRole resets all changes to the "require_customer_role" field.
func (m *ProductStoreMutation) ResetRequireCustomerRole() {
	m.require_customer_role = nil
	delete(m.clearedFields, productstore.FieldRequireCustomerRole)
}

// SetAutoInvoiceDigitalItems sets the "auto_invoice_digital_items" field.
func (m *ProductStoreMutation) SetAutoInvoiceDigitalItems(pidi productstore.AutoInvoiceDigitalItems) {
	m.auto_invoice_digital_items = &pidi
}

// AutoInvoiceDigitalItems returns the value of the "auto_invoice_digital_items" field in the mutation.
func (m *ProductStoreMutation) AutoInvoiceDigitalItems() (r productstore.AutoInvoiceDigitalItems, exists bool) {
	v := m.auto_invoice_digital_items
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoInvoiceDigitalItems returns the old "auto_invoice_digital_items" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoInvoiceDigitalItems(ctx context.Context) (v productstore.AutoInvoiceDigitalItems, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoInvoiceDigitalItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoInvoiceDigitalItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoInvoiceDigitalItems: %w", err)
	}
	return oldValue.AutoInvoiceDigitalItems, nil
}

// ClearAutoInvoiceDigitalItems clears the value of the "auto_invoice_digital_items" field.
func (m *ProductStoreMutation) ClearAutoInvoiceDigitalItems() {
	m.auto_invoice_digital_items = nil
	m.clearedFields[productstore.FieldAutoInvoiceDigitalItems] = struct{}{}
}

// AutoInvoiceDigitalItemsCleared returns if the "auto_invoice_digital_items" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoInvoiceDigitalItemsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoInvoiceDigitalItems]
	return ok
}

// ResetAutoInvoiceDigitalItems resets all changes to the "auto_invoice_digital_items" field.
func (m *ProductStoreMutation) ResetAutoInvoiceDigitalItems() {
	m.auto_invoice_digital_items = nil
	delete(m.clearedFields, productstore.FieldAutoInvoiceDigitalItems)
}

// SetReqShipAddrForDigItems sets the "req_ship_addr_for_dig_items" field.
func (m *ProductStoreMutation) SetReqShipAddrForDigItems(psafdi productstore.ReqShipAddrForDigItems) {
	m.req_ship_addr_for_dig_items = &psafdi
}

// ReqShipAddrForDigItems returns the value of the "req_ship_addr_for_dig_items" field in the mutation.
func (m *ProductStoreMutation) ReqShipAddrForDigItems() (r productstore.ReqShipAddrForDigItems, exists bool) {
	v := m.req_ship_addr_for_dig_items
	if v == nil {
		return
	}
	return *v, true
}

// OldReqShipAddrForDigItems returns the old "req_ship_addr_for_dig_items" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldReqShipAddrForDigItems(ctx context.Context) (v productstore.ReqShipAddrForDigItems, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReqShipAddrForDigItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReqShipAddrForDigItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqShipAddrForDigItems: %w", err)
	}
	return oldValue.ReqShipAddrForDigItems, nil
}

// ClearReqShipAddrForDigItems clears the value of the "req_ship_addr_for_dig_items" field.
func (m *ProductStoreMutation) ClearReqShipAddrForDigItems() {
	m.req_ship_addr_for_dig_items = nil
	m.clearedFields[productstore.FieldReqShipAddrForDigItems] = struct{}{}
}

// ReqShipAddrForDigItemsCleared returns if the "req_ship_addr_for_dig_items" field was cleared in this mutation.
func (m *ProductStoreMutation) ReqShipAddrForDigItemsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldReqShipAddrForDigItems]
	return ok
}

// ResetReqShipAddrForDigItems resets all changes to the "req_ship_addr_for_dig_items" field.
func (m *ProductStoreMutation) ResetReqShipAddrForDigItems() {
	m.req_ship_addr_for_dig_items = nil
	delete(m.clearedFields, productstore.FieldReqShipAddrForDigItems)
}

// SetShowCheckoutGiftOptions sets the "show_checkout_gift_options" field.
func (m *ProductStoreMutation) SetShowCheckoutGiftOptions(pcgo productstore.ShowCheckoutGiftOptions) {
	m.show_checkout_gift_options = &pcgo
}

// ShowCheckoutGiftOptions returns the value of the "show_checkout_gift_options" field in the mutation.
func (m *ProductStoreMutation) ShowCheckoutGiftOptions() (r productstore.ShowCheckoutGiftOptions, exists bool) {
	v := m.show_checkout_gift_options
	if v == nil {
		return
	}
	return *v, true
}

// OldShowCheckoutGiftOptions returns the old "show_checkout_gift_options" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldShowCheckoutGiftOptions(ctx context.Context) (v productstore.ShowCheckoutGiftOptions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowCheckoutGiftOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowCheckoutGiftOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowCheckoutGiftOptions: %w", err)
	}
	return oldValue.ShowCheckoutGiftOptions, nil
}

// ClearShowCheckoutGiftOptions clears the value of the "show_checkout_gift_options" field.
func (m *ProductStoreMutation) ClearShowCheckoutGiftOptions() {
	m.show_checkout_gift_options = nil
	m.clearedFields[productstore.FieldShowCheckoutGiftOptions] = struct{}{}
}

// ShowCheckoutGiftOptionsCleared returns if the "show_checkout_gift_options" field was cleared in this mutation.
func (m *ProductStoreMutation) ShowCheckoutGiftOptionsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldShowCheckoutGiftOptions]
	return ok
}

// ResetShowCheckoutGiftOptions resets all changes to the "show_checkout_gift_options" field.
func (m *ProductStoreMutation) ResetShowCheckoutGiftOptions() {
	m.show_checkout_gift_options = nil
	delete(m.clearedFields, productstore.FieldShowCheckoutGiftOptions)
}

// SetSelectPaymentTypePerItem sets the "select_payment_type_per_item" field.
func (m *ProductStoreMutation) SetSelectPaymentTypePerItem(pptpi productstore.SelectPaymentTypePerItem) {
	m.select_payment_type_per_item = &pptpi
}

// SelectPaymentTypePerItem returns the value of the "select_payment_type_per_item" field in the mutation.
func (m *ProductStoreMutation) SelectPaymentTypePerItem() (r productstore.SelectPaymentTypePerItem, exists bool) {
	v := m.select_payment_type_per_item
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectPaymentTypePerItem returns the old "select_payment_type_per_item" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldSelectPaymentTypePerItem(ctx context.Context) (v productstore.SelectPaymentTypePerItem, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSelectPaymentTypePerItem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSelectPaymentTypePerItem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectPaymentTypePerItem: %w", err)
	}
	return oldValue.SelectPaymentTypePerItem, nil
}

// ClearSelectPaymentTypePerItem clears the value of the "select_payment_type_per_item" field.
func (m *ProductStoreMutation) ClearSelectPaymentTypePerItem() {
	m.select_payment_type_per_item = nil
	m.clearedFields[productstore.FieldSelectPaymentTypePerItem] = struct{}{}
}

// SelectPaymentTypePerItemCleared returns if the "select_payment_type_per_item" field was cleared in this mutation.
func (m *ProductStoreMutation) SelectPaymentTypePerItemCleared() bool {
	_, ok := m.clearedFields[productstore.FieldSelectPaymentTypePerItem]
	return ok
}

// ResetSelectPaymentTypePerItem resets all changes to the "select_payment_type_per_item" field.
func (m *ProductStoreMutation) ResetSelectPaymentTypePerItem() {
	m.select_payment_type_per_item = nil
	delete(m.clearedFields, productstore.FieldSelectPaymentTypePerItem)
}

// SetShowPricesWithVatTax sets the "show_prices_with_vat_tax" field.
func (m *ProductStoreMutation) SetShowPricesWithVatTax(ppwvt productstore.ShowPricesWithVatTax) {
	m.show_prices_with_vat_tax = &ppwvt
}

// ShowPricesWithVatTax returns the value of the "show_prices_with_vat_tax" field in the mutation.
func (m *ProductStoreMutation) ShowPricesWithVatTax() (r productstore.ShowPricesWithVatTax, exists bool) {
	v := m.show_prices_with_vat_tax
	if v == nil {
		return
	}
	return *v, true
}

// OldShowPricesWithVatTax returns the old "show_prices_with_vat_tax" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldShowPricesWithVatTax(ctx context.Context) (v productstore.ShowPricesWithVatTax, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowPricesWithVatTax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowPricesWithVatTax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowPricesWithVatTax: %w", err)
	}
	return oldValue.ShowPricesWithVatTax, nil
}

// ClearShowPricesWithVatTax clears the value of the "show_prices_with_vat_tax" field.
func (m *ProductStoreMutation) ClearShowPricesWithVatTax() {
	m.show_prices_with_vat_tax = nil
	m.clearedFields[productstore.FieldShowPricesWithVatTax] = struct{}{}
}

// ShowPricesWithVatTaxCleared returns if the "show_prices_with_vat_tax" field was cleared in this mutation.
func (m *ProductStoreMutation) ShowPricesWithVatTaxCleared() bool {
	_, ok := m.clearedFields[productstore.FieldShowPricesWithVatTax]
	return ok
}

// ResetShowPricesWithVatTax resets all changes to the "show_prices_with_vat_tax" field.
func (m *ProductStoreMutation) ResetShowPricesWithVatTax() {
	m.show_prices_with_vat_tax = nil
	delete(m.clearedFields, productstore.FieldShowPricesWithVatTax)
}

// SetShowTaxIsExempt sets the "show_tax_is_exempt" field.
func (m *ProductStoreMutation) SetShowTaxIsExempt(ptie productstore.ShowTaxIsExempt) {
	m.show_tax_is_exempt = &ptie
}

// ShowTaxIsExempt returns the value of the "show_tax_is_exempt" field in the mutation.
func (m *ProductStoreMutation) ShowTaxIsExempt() (r productstore.ShowTaxIsExempt, exists bool) {
	v := m.show_tax_is_exempt
	if v == nil {
		return
	}
	return *v, true
}

// OldShowTaxIsExempt returns the old "show_tax_is_exempt" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldShowTaxIsExempt(ctx context.Context) (v productstore.ShowTaxIsExempt, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowTaxIsExempt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowTaxIsExempt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowTaxIsExempt: %w", err)
	}
	return oldValue.ShowTaxIsExempt, nil
}

// ClearShowTaxIsExempt clears the value of the "show_tax_is_exempt" field.
func (m *ProductStoreMutation) ClearShowTaxIsExempt() {
	m.show_tax_is_exempt = nil
	m.clearedFields[productstore.FieldShowTaxIsExempt] = struct{}{}
}

// ShowTaxIsExemptCleared returns if the "show_tax_is_exempt" field was cleared in this mutation.
func (m *ProductStoreMutation) ShowTaxIsExemptCleared() bool {
	_, ok := m.clearedFields[productstore.FieldShowTaxIsExempt]
	return ok
}

// ResetShowTaxIsExempt resets all changes to the "show_tax_is_exempt" field.
func (m *ProductStoreMutation) ResetShowTaxIsExempt() {
	m.show_tax_is_exempt = nil
	delete(m.clearedFields, productstore.FieldShowTaxIsExempt)
}

// SetVatTaxAuthGeoID sets the "vat_tax_auth_geo_id" field.
func (m *ProductStoreMutation) SetVatTaxAuthGeoID(i int) {
	m.vat_tax_auth_geo_id = &i
	m.addvat_tax_auth_geo_id = nil
}

// VatTaxAuthGeoID returns the value of the "vat_tax_auth_geo_id" field in the mutation.
func (m *ProductStoreMutation) VatTaxAuthGeoID() (r int, exists bool) {
	v := m.vat_tax_auth_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVatTaxAuthGeoID returns the old "vat_tax_auth_geo_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldVatTaxAuthGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVatTaxAuthGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVatTaxAuthGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatTaxAuthGeoID: %w", err)
	}
	return oldValue.VatTaxAuthGeoID, nil
}

// AddVatTaxAuthGeoID adds i to the "vat_tax_auth_geo_id" field.
func (m *ProductStoreMutation) AddVatTaxAuthGeoID(i int) {
	if m.addvat_tax_auth_geo_id != nil {
		*m.addvat_tax_auth_geo_id += i
	} else {
		m.addvat_tax_auth_geo_id = &i
	}
}

// AddedVatTaxAuthGeoID returns the value that was added to the "vat_tax_auth_geo_id" field in this mutation.
func (m *ProductStoreMutation) AddedVatTaxAuthGeoID() (r int, exists bool) {
	v := m.addvat_tax_auth_geo_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVatTaxAuthGeoID clears the value of the "vat_tax_auth_geo_id" field.
func (m *ProductStoreMutation) ClearVatTaxAuthGeoID() {
	m.vat_tax_auth_geo_id = nil
	m.addvat_tax_auth_geo_id = nil
	m.clearedFields[productstore.FieldVatTaxAuthGeoID] = struct{}{}
}

// VatTaxAuthGeoIDCleared returns if the "vat_tax_auth_geo_id" field was cleared in this mutation.
func (m *ProductStoreMutation) VatTaxAuthGeoIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldVatTaxAuthGeoID]
	return ok
}

// ResetVatTaxAuthGeoID resets all changes to the "vat_tax_auth_geo_id" field.
func (m *ProductStoreMutation) ResetVatTaxAuthGeoID() {
	m.vat_tax_auth_geo_id = nil
	m.addvat_tax_auth_geo_id = nil
	delete(m.clearedFields, productstore.FieldVatTaxAuthGeoID)
}

// SetVatTaxAuthPartyID sets the "vat_tax_auth_party_id" field.
func (m *ProductStoreMutation) SetVatTaxAuthPartyID(i int) {
	m.vat_tax_auth_party_id = &i
	m.addvat_tax_auth_party_id = nil
}

// VatTaxAuthPartyID returns the value of the "vat_tax_auth_party_id" field in the mutation.
func (m *ProductStoreMutation) VatTaxAuthPartyID() (r int, exists bool) {
	v := m.vat_tax_auth_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVatTaxAuthPartyID returns the old "vat_tax_auth_party_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldVatTaxAuthPartyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVatTaxAuthPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVatTaxAuthPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatTaxAuthPartyID: %w", err)
	}
	return oldValue.VatTaxAuthPartyID, nil
}

// AddVatTaxAuthPartyID adds i to the "vat_tax_auth_party_id" field.
func (m *ProductStoreMutation) AddVatTaxAuthPartyID(i int) {
	if m.addvat_tax_auth_party_id != nil {
		*m.addvat_tax_auth_party_id += i
	} else {
		m.addvat_tax_auth_party_id = &i
	}
}

// AddedVatTaxAuthPartyID returns the value that was added to the "vat_tax_auth_party_id" field in this mutation.
func (m *ProductStoreMutation) AddedVatTaxAuthPartyID() (r int, exists bool) {
	v := m.addvat_tax_auth_party_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVatTaxAuthPartyID clears the value of the "vat_tax_auth_party_id" field.
func (m *ProductStoreMutation) ClearVatTaxAuthPartyID() {
	m.vat_tax_auth_party_id = nil
	m.addvat_tax_auth_party_id = nil
	m.clearedFields[productstore.FieldVatTaxAuthPartyID] = struct{}{}
}

// VatTaxAuthPartyIDCleared returns if the "vat_tax_auth_party_id" field was cleared in this mutation.
func (m *ProductStoreMutation) VatTaxAuthPartyIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldVatTaxAuthPartyID]
	return ok
}

// ResetVatTaxAuthPartyID resets all changes to the "vat_tax_auth_party_id" field.
func (m *ProductStoreMutation) ResetVatTaxAuthPartyID() {
	m.vat_tax_auth_party_id = nil
	m.addvat_tax_auth_party_id = nil
	delete(m.clearedFields, productstore.FieldVatTaxAuthPartyID)
}

// SetEnableAutoSuggestionList sets the "enable_auto_suggestion_list" field.
func (m *ProductStoreMutation) SetEnableAutoSuggestionList(pasl productstore.EnableAutoSuggestionList) {
	m.enable_auto_suggestion_list = &pasl
}

// EnableAutoSuggestionList returns the value of the "enable_auto_suggestion_list" field in the mutation.
func (m *ProductStoreMutation) EnableAutoSuggestionList() (r productstore.EnableAutoSuggestionList, exists bool) {
	v := m.enable_auto_suggestion_list
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoSuggestionList returns the old "enable_auto_suggestion_list" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldEnableAutoSuggestionList(ctx context.Context) (v productstore.EnableAutoSuggestionList, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnableAutoSuggestionList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnableAutoSuggestionList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoSuggestionList: %w", err)
	}
	return oldValue.EnableAutoSuggestionList, nil
}

// ClearEnableAutoSuggestionList clears the value of the "enable_auto_suggestion_list" field.
func (m *ProductStoreMutation) ClearEnableAutoSuggestionList() {
	m.enable_auto_suggestion_list = nil
	m.clearedFields[productstore.FieldEnableAutoSuggestionList] = struct{}{}
}

// EnableAutoSuggestionListCleared returns if the "enable_auto_suggestion_list" field was cleared in this mutation.
func (m *ProductStoreMutation) EnableAutoSuggestionListCleared() bool {
	_, ok := m.clearedFields[productstore.FieldEnableAutoSuggestionList]
	return ok
}

// ResetEnableAutoSuggestionList resets all changes to the "enable_auto_suggestion_list" field.
func (m *ProductStoreMutation) ResetEnableAutoSuggestionList() {
	m.enable_auto_suggestion_list = nil
	delete(m.clearedFields, productstore.FieldEnableAutoSuggestionList)
}

// SetEnableDigProdUpload sets the "enable_dig_prod_upload" field.
func (m *ProductStoreMutation) SetEnableDigProdUpload(pdpu productstore.EnableDigProdUpload) {
	m.enable_dig_prod_upload = &pdpu
}

// EnableDigProdUpload returns the value of the "enable_dig_prod_upload" field in the mutation.
func (m *ProductStoreMutation) EnableDigProdUpload() (r productstore.EnableDigProdUpload, exists bool) {
	v := m.enable_dig_prod_upload
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableDigProdUpload returns the old "enable_dig_prod_upload" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldEnableDigProdUpload(ctx context.Context) (v productstore.EnableDigProdUpload, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnableDigProdUpload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnableDigProdUpload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableDigProdUpload: %w", err)
	}
	return oldValue.EnableDigProdUpload, nil
}

// ClearEnableDigProdUpload clears the value of the "enable_dig_prod_upload" field.
func (m *ProductStoreMutation) ClearEnableDigProdUpload() {
	m.enable_dig_prod_upload = nil
	m.clearedFields[productstore.FieldEnableDigProdUpload] = struct{}{}
}

// EnableDigProdUploadCleared returns if the "enable_dig_prod_upload" field was cleared in this mutation.
func (m *ProductStoreMutation) EnableDigProdUploadCleared() bool {
	_, ok := m.clearedFields[productstore.FieldEnableDigProdUpload]
	return ok
}

// ResetEnableDigProdUpload resets all changes to the "enable_dig_prod_upload" field.
func (m *ProductStoreMutation) ResetEnableDigProdUpload() {
	m.enable_dig_prod_upload = nil
	delete(m.clearedFields, productstore.FieldEnableDigProdUpload)
}

// SetProdSearchExcludeVariants sets the "prod_search_exclude_variants" field.
func (m *ProductStoreMutation) SetProdSearchExcludeVariants(psev productstore.ProdSearchExcludeVariants) {
	m.prod_search_exclude_variants = &psev
}

// ProdSearchExcludeVariants returns the value of the "prod_search_exclude_variants" field in the mutation.
func (m *ProductStoreMutation) ProdSearchExcludeVariants() (r productstore.ProdSearchExcludeVariants, exists bool) {
	v := m.prod_search_exclude_variants
	if v == nil {
		return
	}
	return *v, true
}

// OldProdSearchExcludeVariants returns the old "prod_search_exclude_variants" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldProdSearchExcludeVariants(ctx context.Context) (v productstore.ProdSearchExcludeVariants, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProdSearchExcludeVariants is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProdSearchExcludeVariants requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProdSearchExcludeVariants: %w", err)
	}
	return oldValue.ProdSearchExcludeVariants, nil
}

// ClearProdSearchExcludeVariants clears the value of the "prod_search_exclude_variants" field.
func (m *ProductStoreMutation) ClearProdSearchExcludeVariants() {
	m.prod_search_exclude_variants = nil
	m.clearedFields[productstore.FieldProdSearchExcludeVariants] = struct{}{}
}

// ProdSearchExcludeVariantsCleared returns if the "prod_search_exclude_variants" field was cleared in this mutation.
func (m *ProductStoreMutation) ProdSearchExcludeVariantsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldProdSearchExcludeVariants]
	return ok
}

// ResetProdSearchExcludeVariants resets all changes to the "prod_search_exclude_variants" field.
func (m *ProductStoreMutation) ResetProdSearchExcludeVariants() {
	m.prod_search_exclude_variants = nil
	delete(m.clearedFields, productstore.FieldProdSearchExcludeVariants)
}

// SetDigProdUploadCategoryID sets the "dig_prod_upload_category_id" field.
func (m *ProductStoreMutation) SetDigProdUploadCategoryID(i int) {
	m.dig_prod_upload_category_id = &i
	m.adddig_prod_upload_category_id = nil
}

// DigProdUploadCategoryID returns the value of the "dig_prod_upload_category_id" field in the mutation.
func (m *ProductStoreMutation) DigProdUploadCategoryID() (r int, exists bool) {
	v := m.dig_prod_upload_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDigProdUploadCategoryID returns the old "dig_prod_upload_category_id" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldDigProdUploadCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDigProdUploadCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDigProdUploadCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigProdUploadCategoryID: %w", err)
	}
	return oldValue.DigProdUploadCategoryID, nil
}

// AddDigProdUploadCategoryID adds i to the "dig_prod_upload_category_id" field.
func (m *ProductStoreMutation) AddDigProdUploadCategoryID(i int) {
	if m.adddig_prod_upload_category_id != nil {
		*m.adddig_prod_upload_category_id += i
	} else {
		m.adddig_prod_upload_category_id = &i
	}
}

// AddedDigProdUploadCategoryID returns the value that was added to the "dig_prod_upload_category_id" field in this mutation.
func (m *ProductStoreMutation) AddedDigProdUploadCategoryID() (r int, exists bool) {
	v := m.adddig_prod_upload_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDigProdUploadCategoryID clears the value of the "dig_prod_upload_category_id" field.
func (m *ProductStoreMutation) ClearDigProdUploadCategoryID() {
	m.dig_prod_upload_category_id = nil
	m.adddig_prod_upload_category_id = nil
	m.clearedFields[productstore.FieldDigProdUploadCategoryID] = struct{}{}
}

// DigProdUploadCategoryIDCleared returns if the "dig_prod_upload_category_id" field was cleared in this mutation.
func (m *ProductStoreMutation) DigProdUploadCategoryIDCleared() bool {
	_, ok := m.clearedFields[productstore.FieldDigProdUploadCategoryID]
	return ok
}

// ResetDigProdUploadCategoryID resets all changes to the "dig_prod_upload_category_id" field.
func (m *ProductStoreMutation) ResetDigProdUploadCategoryID() {
	m.dig_prod_upload_category_id = nil
	m.adddig_prod_upload_category_id = nil
	delete(m.clearedFields, productstore.FieldDigProdUploadCategoryID)
}

// SetAutoOrderCcTryExp sets the "auto_order_cc_try_exp" field.
func (m *ProductStoreMutation) SetAutoOrderCcTryExp(pocte productstore.AutoOrderCcTryExp) {
	m.auto_order_cc_try_exp = &pocte
}

// AutoOrderCcTryExp returns the value of the "auto_order_cc_try_exp" field in the mutation.
func (m *ProductStoreMutation) AutoOrderCcTryExp() (r productstore.AutoOrderCcTryExp, exists bool) {
	v := m.auto_order_cc_try_exp
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoOrderCcTryExp returns the old "auto_order_cc_try_exp" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoOrderCcTryExp(ctx context.Context) (v productstore.AutoOrderCcTryExp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoOrderCcTryExp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoOrderCcTryExp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoOrderCcTryExp: %w", err)
	}
	return oldValue.AutoOrderCcTryExp, nil
}

// ClearAutoOrderCcTryExp clears the value of the "auto_order_cc_try_exp" field.
func (m *ProductStoreMutation) ClearAutoOrderCcTryExp() {
	m.auto_order_cc_try_exp = nil
	m.clearedFields[productstore.FieldAutoOrderCcTryExp] = struct{}{}
}

// AutoOrderCcTryExpCleared returns if the "auto_order_cc_try_exp" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoOrderCcTryExpCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoOrderCcTryExp]
	return ok
}

// ResetAutoOrderCcTryExp resets all changes to the "auto_order_cc_try_exp" field.
func (m *ProductStoreMutation) ResetAutoOrderCcTryExp() {
	m.auto_order_cc_try_exp = nil
	delete(m.clearedFields, productstore.FieldAutoOrderCcTryExp)
}

// SetAutoOrderCcTryOtherCards sets the "auto_order_cc_try_other_cards" field.
func (m *ProductStoreMutation) SetAutoOrderCcTryOtherCards(poctoc productstore.AutoOrderCcTryOtherCards) {
	m.auto_order_cc_try_other_cards = &poctoc
}

// AutoOrderCcTryOtherCards returns the value of the "auto_order_cc_try_other_cards" field in the mutation.
func (m *ProductStoreMutation) AutoOrderCcTryOtherCards() (r productstore.AutoOrderCcTryOtherCards, exists bool) {
	v := m.auto_order_cc_try_other_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoOrderCcTryOtherCards returns the old "auto_order_cc_try_other_cards" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoOrderCcTryOtherCards(ctx context.Context) (v productstore.AutoOrderCcTryOtherCards, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoOrderCcTryOtherCards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoOrderCcTryOtherCards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoOrderCcTryOtherCards: %w", err)
	}
	return oldValue.AutoOrderCcTryOtherCards, nil
}

// ClearAutoOrderCcTryOtherCards clears the value of the "auto_order_cc_try_other_cards" field.
func (m *ProductStoreMutation) ClearAutoOrderCcTryOtherCards() {
	m.auto_order_cc_try_other_cards = nil
	m.clearedFields[productstore.FieldAutoOrderCcTryOtherCards] = struct{}{}
}

// AutoOrderCcTryOtherCardsCleared returns if the "auto_order_cc_try_other_cards" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoOrderCcTryOtherCardsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoOrderCcTryOtherCards]
	return ok
}

// ResetAutoOrderCcTryOtherCards resets all changes to the "auto_order_cc_try_other_cards" field.
func (m *ProductStoreMutation) ResetAutoOrderCcTryOtherCards() {
	m.auto_order_cc_try_other_cards = nil
	delete(m.clearedFields, productstore.FieldAutoOrderCcTryOtherCards)
}

// SetAutoOrderCcTryLaterNsf sets the "auto_order_cc_try_later_nsf" field.
func (m *ProductStoreMutation) SetAutoOrderCcTryLaterNsf(poctln productstore.AutoOrderCcTryLaterNsf) {
	m.auto_order_cc_try_later_nsf = &poctln
}

// AutoOrderCcTryLaterNsf returns the value of the "auto_order_cc_try_later_nsf" field in the mutation.
func (m *ProductStoreMutation) AutoOrderCcTryLaterNsf() (r productstore.AutoOrderCcTryLaterNsf, exists bool) {
	v := m.auto_order_cc_try_later_nsf
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoOrderCcTryLaterNsf returns the old "auto_order_cc_try_later_nsf" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoOrderCcTryLaterNsf(ctx context.Context) (v productstore.AutoOrderCcTryLaterNsf, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoOrderCcTryLaterNsf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoOrderCcTryLaterNsf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoOrderCcTryLaterNsf: %w", err)
	}
	return oldValue.AutoOrderCcTryLaterNsf, nil
}

// ClearAutoOrderCcTryLaterNsf clears the value of the "auto_order_cc_try_later_nsf" field.
func (m *ProductStoreMutation) ClearAutoOrderCcTryLaterNsf() {
	m.auto_order_cc_try_later_nsf = nil
	m.clearedFields[productstore.FieldAutoOrderCcTryLaterNsf] = struct{}{}
}

// AutoOrderCcTryLaterNsfCleared returns if the "auto_order_cc_try_later_nsf" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoOrderCcTryLaterNsfCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoOrderCcTryLaterNsf]
	return ok
}

// ResetAutoOrderCcTryLaterNsf resets all changes to the "auto_order_cc_try_later_nsf" field.
func (m *ProductStoreMutation) ResetAutoOrderCcTryLaterNsf() {
	m.auto_order_cc_try_later_nsf = nil
	delete(m.clearedFields, productstore.FieldAutoOrderCcTryLaterNsf)
}

// SetAutoOrderCcTryLaterMax sets the "auto_order_cc_try_later_max" field.
func (m *ProductStoreMutation) SetAutoOrderCcTryLaterMax(i int) {
	m.auto_order_cc_try_later_max = &i
	m.addauto_order_cc_try_later_max = nil
}

// AutoOrderCcTryLaterMax returns the value of the "auto_order_cc_try_later_max" field in the mutation.
func (m *ProductStoreMutation) AutoOrderCcTryLaterMax() (r int, exists bool) {
	v := m.auto_order_cc_try_later_max
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoOrderCcTryLaterMax returns the old "auto_order_cc_try_later_max" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoOrderCcTryLaterMax(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoOrderCcTryLaterMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoOrderCcTryLaterMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoOrderCcTryLaterMax: %w", err)
	}
	return oldValue.AutoOrderCcTryLaterMax, nil
}

// AddAutoOrderCcTryLaterMax adds i to the "auto_order_cc_try_later_max" field.
func (m *ProductStoreMutation) AddAutoOrderCcTryLaterMax(i int) {
	if m.addauto_order_cc_try_later_max != nil {
		*m.addauto_order_cc_try_later_max += i
	} else {
		m.addauto_order_cc_try_later_max = &i
	}
}

// AddedAutoOrderCcTryLaterMax returns the value that was added to the "auto_order_cc_try_later_max" field in this mutation.
func (m *ProductStoreMutation) AddedAutoOrderCcTryLaterMax() (r int, exists bool) {
	v := m.addauto_order_cc_try_later_max
	if v == nil {
		return
	}
	return *v, true
}

// ClearAutoOrderCcTryLaterMax clears the value of the "auto_order_cc_try_later_max" field.
func (m *ProductStoreMutation) ClearAutoOrderCcTryLaterMax() {
	m.auto_order_cc_try_later_max = nil
	m.addauto_order_cc_try_later_max = nil
	m.clearedFields[productstore.FieldAutoOrderCcTryLaterMax] = struct{}{}
}

// AutoOrderCcTryLaterMaxCleared returns if the "auto_order_cc_try_later_max" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoOrderCcTryLaterMaxCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoOrderCcTryLaterMax]
	return ok
}

// ResetAutoOrderCcTryLaterMax resets all changes to the "auto_order_cc_try_later_max" field.
func (m *ProductStoreMutation) ResetAutoOrderCcTryLaterMax() {
	m.auto_order_cc_try_later_max = nil
	m.addauto_order_cc_try_later_max = nil
	delete(m.clearedFields, productstore.FieldAutoOrderCcTryLaterMax)
}

// SetStoreCreditValidDays sets the "store_credit_valid_days" field.
func (m *ProductStoreMutation) SetStoreCreditValidDays(i int) {
	m.store_credit_valid_days = &i
	m.addstore_credit_valid_days = nil
}

// StoreCreditValidDays returns the value of the "store_credit_valid_days" field in the mutation.
func (m *ProductStoreMutation) StoreCreditValidDays() (r int, exists bool) {
	v := m.store_credit_valid_days
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreCreditValidDays returns the old "store_credit_valid_days" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldStoreCreditValidDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStoreCreditValidDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStoreCreditValidDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreCreditValidDays: %w", err)
	}
	return oldValue.StoreCreditValidDays, nil
}

// AddStoreCreditValidDays adds i to the "store_credit_valid_days" field.
func (m *ProductStoreMutation) AddStoreCreditValidDays(i int) {
	if m.addstore_credit_valid_days != nil {
		*m.addstore_credit_valid_days += i
	} else {
		m.addstore_credit_valid_days = &i
	}
}

// AddedStoreCreditValidDays returns the value that was added to the "store_credit_valid_days" field in this mutation.
func (m *ProductStoreMutation) AddedStoreCreditValidDays() (r int, exists bool) {
	v := m.addstore_credit_valid_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearStoreCreditValidDays clears the value of the "store_credit_valid_days" field.
func (m *ProductStoreMutation) ClearStoreCreditValidDays() {
	m.store_credit_valid_days = nil
	m.addstore_credit_valid_days = nil
	m.clearedFields[productstore.FieldStoreCreditValidDays] = struct{}{}
}

// StoreCreditValidDaysCleared returns if the "store_credit_valid_days" field was cleared in this mutation.
func (m *ProductStoreMutation) StoreCreditValidDaysCleared() bool {
	_, ok := m.clearedFields[productstore.FieldStoreCreditValidDays]
	return ok
}

// ResetStoreCreditValidDays resets all changes to the "store_credit_valid_days" field.
func (m *ProductStoreMutation) ResetStoreCreditValidDays() {
	m.store_credit_valid_days = nil
	m.addstore_credit_valid_days = nil
	delete(m.clearedFields, productstore.FieldStoreCreditValidDays)
}

// SetAutoApproveInvoice sets the "auto_approve_invoice" field.
func (m *ProductStoreMutation) SetAutoApproveInvoice(pai productstore.AutoApproveInvoice) {
	m.auto_approve_invoice = &pai
}

// AutoApproveInvoice returns the value of the "auto_approve_invoice" field in the mutation.
func (m *ProductStoreMutation) AutoApproveInvoice() (r productstore.AutoApproveInvoice, exists bool) {
	v := m.auto_approve_invoice
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoApproveInvoice returns the old "auto_approve_invoice" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoApproveInvoice(ctx context.Context) (v productstore.AutoApproveInvoice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoApproveInvoice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoApproveInvoice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoApproveInvoice: %w", err)
	}
	return oldValue.AutoApproveInvoice, nil
}

// ClearAutoApproveInvoice clears the value of the "auto_approve_invoice" field.
func (m *ProductStoreMutation) ClearAutoApproveInvoice() {
	m.auto_approve_invoice = nil
	m.clearedFields[productstore.FieldAutoApproveInvoice] = struct{}{}
}

// AutoApproveInvoiceCleared returns if the "auto_approve_invoice" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoApproveInvoiceCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoApproveInvoice]
	return ok
}

// ResetAutoApproveInvoice resets all changes to the "auto_approve_invoice" field.
func (m *ProductStoreMutation) ResetAutoApproveInvoice() {
	m.auto_approve_invoice = nil
	delete(m.clearedFields, productstore.FieldAutoApproveInvoice)
}

// SetAutoApproveOrder sets the "auto_approve_order" field.
func (m *ProductStoreMutation) SetAutoApproveOrder(pao productstore.AutoApproveOrder) {
	m.auto_approve_order = &pao
}

// AutoApproveOrder returns the value of the "auto_approve_order" field in the mutation.
func (m *ProductStoreMutation) AutoApproveOrder() (r productstore.AutoApproveOrder, exists bool) {
	v := m.auto_approve_order
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoApproveOrder returns the old "auto_approve_order" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAutoApproveOrder(ctx context.Context) (v productstore.AutoApproveOrder, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAutoApproveOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAutoApproveOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoApproveOrder: %w", err)
	}
	return oldValue.AutoApproveOrder, nil
}

// ClearAutoApproveOrder clears the value of the "auto_approve_order" field.
func (m *ProductStoreMutation) ClearAutoApproveOrder() {
	m.auto_approve_order = nil
	m.clearedFields[productstore.FieldAutoApproveOrder] = struct{}{}
}

// AutoApproveOrderCleared returns if the "auto_approve_order" field was cleared in this mutation.
func (m *ProductStoreMutation) AutoApproveOrderCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAutoApproveOrder]
	return ok
}

// ResetAutoApproveOrder resets all changes to the "auto_approve_order" field.
func (m *ProductStoreMutation) ResetAutoApproveOrder() {
	m.auto_approve_order = nil
	delete(m.clearedFields, productstore.FieldAutoApproveOrder)
}

// SetShipIfCaptureFails sets the "ship_if_capture_fails" field.
func (m *ProductStoreMutation) SetShipIfCaptureFails(picf productstore.ShipIfCaptureFails) {
	m.ship_if_capture_fails = &picf
}

// ShipIfCaptureFails returns the value of the "ship_if_capture_fails" field in the mutation.
func (m *ProductStoreMutation) ShipIfCaptureFails() (r productstore.ShipIfCaptureFails, exists bool) {
	v := m.ship_if_capture_fails
	if v == nil {
		return
	}
	return *v, true
}

// OldShipIfCaptureFails returns the old "ship_if_capture_fails" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldShipIfCaptureFails(ctx context.Context) (v productstore.ShipIfCaptureFails, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipIfCaptureFails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipIfCaptureFails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipIfCaptureFails: %w", err)
	}
	return oldValue.ShipIfCaptureFails, nil
}

// ClearShipIfCaptureFails clears the value of the "ship_if_capture_fails" field.
func (m *ProductStoreMutation) ClearShipIfCaptureFails() {
	m.ship_if_capture_fails = nil
	m.clearedFields[productstore.FieldShipIfCaptureFails] = struct{}{}
}

// ShipIfCaptureFailsCleared returns if the "ship_if_capture_fails" field was cleared in this mutation.
func (m *ProductStoreMutation) ShipIfCaptureFailsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldShipIfCaptureFails]
	return ok
}

// ResetShipIfCaptureFails resets all changes to the "ship_if_capture_fails" field.
func (m *ProductStoreMutation) ResetShipIfCaptureFails() {
	m.ship_if_capture_fails = nil
	delete(m.clearedFields, productstore.FieldShipIfCaptureFails)
}

// SetSetOwnerUponIssuance sets the "set_owner_upon_issuance" field.
func (m *ProductStoreMutation) SetSetOwnerUponIssuance(poui productstore.SetOwnerUponIssuance) {
	m.set_owner_upon_issuance = &poui
}

// SetOwnerUponIssuance returns the value of the "set_owner_upon_issuance" field in the mutation.
func (m *ProductStoreMutation) SetOwnerUponIssuance() (r productstore.SetOwnerUponIssuance, exists bool) {
	v := m.set_owner_upon_issuance
	if v == nil {
		return
	}
	return *v, true
}

// OldSetOwnerUponIssuance returns the old "set_owner_upon_issuance" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldSetOwnerUponIssuance(ctx context.Context) (v productstore.SetOwnerUponIssuance, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSetOwnerUponIssuance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSetOwnerUponIssuance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetOwnerUponIssuance: %w", err)
	}
	return oldValue.SetOwnerUponIssuance, nil
}

// ClearSetOwnerUponIssuance clears the value of the "set_owner_upon_issuance" field.
func (m *ProductStoreMutation) ClearSetOwnerUponIssuance() {
	m.set_owner_upon_issuance = nil
	m.clearedFields[productstore.FieldSetOwnerUponIssuance] = struct{}{}
}

// SetOwnerUponIssuanceCleared returns if the "set_owner_upon_issuance" field was cleared in this mutation.
func (m *ProductStoreMutation) SetOwnerUponIssuanceCleared() bool {
	_, ok := m.clearedFields[productstore.FieldSetOwnerUponIssuance]
	return ok
}

// ResetSetOwnerUponIssuance resets all changes to the "set_owner_upon_issuance" field.
func (m *ProductStoreMutation) ResetSetOwnerUponIssuance() {
	m.set_owner_upon_issuance = nil
	delete(m.clearedFields, productstore.FieldSetOwnerUponIssuance)
}

// SetReqReturnInventoryReceive sets the "req_return_inventory_receive" field.
func (m *ProductStoreMutation) SetReqReturnInventoryReceive(prir productstore.ReqReturnInventoryReceive) {
	m.req_return_inventory_receive = &prir
}

// ReqReturnInventoryReceive returns the value of the "req_return_inventory_receive" field in the mutation.
func (m *ProductStoreMutation) ReqReturnInventoryReceive() (r productstore.ReqReturnInventoryReceive, exists bool) {
	v := m.req_return_inventory_receive
	if v == nil {
		return
	}
	return *v, true
}

// OldReqReturnInventoryReceive returns the old "req_return_inventory_receive" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldReqReturnInventoryReceive(ctx context.Context) (v productstore.ReqReturnInventoryReceive, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReqReturnInventoryReceive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReqReturnInventoryReceive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqReturnInventoryReceive: %w", err)
	}
	return oldValue.ReqReturnInventoryReceive, nil
}

// ClearReqReturnInventoryReceive clears the value of the "req_return_inventory_receive" field.
func (m *ProductStoreMutation) ClearReqReturnInventoryReceive() {
	m.req_return_inventory_receive = nil
	m.clearedFields[productstore.FieldReqReturnInventoryReceive] = struct{}{}
}

// ReqReturnInventoryReceiveCleared returns if the "req_return_inventory_receive" field was cleared in this mutation.
func (m *ProductStoreMutation) ReqReturnInventoryReceiveCleared() bool {
	_, ok := m.clearedFields[productstore.FieldReqReturnInventoryReceive]
	return ok
}

// ResetReqReturnInventoryReceive resets all changes to the "req_return_inventory_receive" field.
func (m *ProductStoreMutation) ResetReqReturnInventoryReceive() {
	m.req_return_inventory_receive = nil
	delete(m.clearedFields, productstore.FieldReqReturnInventoryReceive)
}

// SetAddToCartRemoveIncompat sets the "add_to_cart_remove_incompat" field.
func (m *ProductStoreMutation) SetAddToCartRemoveIncompat(ptcri productstore.AddToCartRemoveIncompat) {
	m.add_to_cart_remove_incompat = &ptcri
}

// AddToCartRemoveIncompat returns the value of the "add_to_cart_remove_incompat" field in the mutation.
func (m *ProductStoreMutation) AddToCartRemoveIncompat() (r productstore.AddToCartRemoveIncompat, exists bool) {
	v := m.add_to_cart_remove_incompat
	if v == nil {
		return
	}
	return *v, true
}

// OldAddToCartRemoveIncompat returns the old "add_to_cart_remove_incompat" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAddToCartRemoveIncompat(ctx context.Context) (v productstore.AddToCartRemoveIncompat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddToCartRemoveIncompat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddToCartRemoveIncompat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddToCartRemoveIncompat: %w", err)
	}
	return oldValue.AddToCartRemoveIncompat, nil
}

// ClearAddToCartRemoveIncompat clears the value of the "add_to_cart_remove_incompat" field.
func (m *ProductStoreMutation) ClearAddToCartRemoveIncompat() {
	m.add_to_cart_remove_incompat = nil
	m.clearedFields[productstore.FieldAddToCartRemoveIncompat] = struct{}{}
}

// AddToCartRemoveIncompatCleared returns if the "add_to_cart_remove_incompat" field was cleared in this mutation.
func (m *ProductStoreMutation) AddToCartRemoveIncompatCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAddToCartRemoveIncompat]
	return ok
}

// ResetAddToCartRemoveIncompat resets all changes to the "add_to_cart_remove_incompat" field.
func (m *ProductStoreMutation) ResetAddToCartRemoveIncompat() {
	m.add_to_cart_remove_incompat = nil
	delete(m.clearedFields, productstore.FieldAddToCartRemoveIncompat)
}

// SetAddToCartReplaceUpsell sets the "add_to_cart_replace_upsell" field.
func (m *ProductStoreMutation) SetAddToCartReplaceUpsell(ptcru productstore.AddToCartReplaceUpsell) {
	m.add_to_cart_replace_upsell = &ptcru
}

// AddToCartReplaceUpsell returns the value of the "add_to_cart_replace_upsell" field in the mutation.
func (m *ProductStoreMutation) AddToCartReplaceUpsell() (r productstore.AddToCartReplaceUpsell, exists bool) {
	v := m.add_to_cart_replace_upsell
	if v == nil {
		return
	}
	return *v, true
}

// OldAddToCartReplaceUpsell returns the old "add_to_cart_replace_upsell" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAddToCartReplaceUpsell(ctx context.Context) (v productstore.AddToCartReplaceUpsell, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddToCartReplaceUpsell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddToCartReplaceUpsell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddToCartReplaceUpsell: %w", err)
	}
	return oldValue.AddToCartReplaceUpsell, nil
}

// ClearAddToCartReplaceUpsell clears the value of the "add_to_cart_replace_upsell" field.
func (m *ProductStoreMutation) ClearAddToCartReplaceUpsell() {
	m.add_to_cart_replace_upsell = nil
	m.clearedFields[productstore.FieldAddToCartReplaceUpsell] = struct{}{}
}

// AddToCartReplaceUpsellCleared returns if the "add_to_cart_replace_upsell" field was cleared in this mutation.
func (m *ProductStoreMutation) AddToCartReplaceUpsellCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAddToCartReplaceUpsell]
	return ok
}

// ResetAddToCartReplaceUpsell resets all changes to the "add_to_cart_replace_upsell" field.
func (m *ProductStoreMutation) ResetAddToCartReplaceUpsell() {
	m.add_to_cart_replace_upsell = nil
	delete(m.clearedFields, productstore.FieldAddToCartReplaceUpsell)
}

// SetSplitPayPrefPerShpGrp sets the "split_pay_pref_per_shp_grp" field.
func (m *ProductStoreMutation) SetSplitPayPrefPerShpGrp(ppppsg productstore.SplitPayPrefPerShpGrp) {
	m.split_pay_pref_per_shp_grp = &ppppsg
}

// SplitPayPrefPerShpGrp returns the value of the "split_pay_pref_per_shp_grp" field in the mutation.
func (m *ProductStoreMutation) SplitPayPrefPerShpGrp() (r productstore.SplitPayPrefPerShpGrp, exists bool) {
	v := m.split_pay_pref_per_shp_grp
	if v == nil {
		return
	}
	return *v, true
}

// OldSplitPayPrefPerShpGrp returns the old "split_pay_pref_per_shp_grp" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldSplitPayPrefPerShpGrp(ctx context.Context) (v productstore.SplitPayPrefPerShpGrp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSplitPayPrefPerShpGrp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSplitPayPrefPerShpGrp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSplitPayPrefPerShpGrp: %w", err)
	}
	return oldValue.SplitPayPrefPerShpGrp, nil
}

// ClearSplitPayPrefPerShpGrp clears the value of the "split_pay_pref_per_shp_grp" field.
func (m *ProductStoreMutation) ClearSplitPayPrefPerShpGrp() {
	m.split_pay_pref_per_shp_grp = nil
	m.clearedFields[productstore.FieldSplitPayPrefPerShpGrp] = struct{}{}
}

// SplitPayPrefPerShpGrpCleared returns if the "split_pay_pref_per_shp_grp" field was cleared in this mutation.
func (m *ProductStoreMutation) SplitPayPrefPerShpGrpCleared() bool {
	_, ok := m.clearedFields[productstore.FieldSplitPayPrefPerShpGrp]
	return ok
}

// ResetSplitPayPrefPerShpGrp resets all changes to the "split_pay_pref_per_shp_grp" field.
func (m *ProductStoreMutation) ResetSplitPayPrefPerShpGrp() {
	m.split_pay_pref_per_shp_grp = nil
	delete(m.clearedFields, productstore.FieldSplitPayPrefPerShpGrp)
}

// SetManagedByLot sets the "managed_by_lot" field.
func (m *ProductStoreMutation) SetManagedByLot(pbl productstore.ManagedByLot) {
	m.managed_by_lot = &pbl
}

// ManagedByLot returns the value of the "managed_by_lot" field in the mutation.
func (m *ProductStoreMutation) ManagedByLot() (r productstore.ManagedByLot, exists bool) {
	v := m.managed_by_lot
	if v == nil {
		return
	}
	return *v, true
}

// OldManagedByLot returns the old "managed_by_lot" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldManagedByLot(ctx context.Context) (v productstore.ManagedByLot, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldManagedByLot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldManagedByLot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagedByLot: %w", err)
	}
	return oldValue.ManagedByLot, nil
}

// ClearManagedByLot clears the value of the "managed_by_lot" field.
func (m *ProductStoreMutation) ClearManagedByLot() {
	m.managed_by_lot = nil
	m.clearedFields[productstore.FieldManagedByLot] = struct{}{}
}

// ManagedByLotCleared returns if the "managed_by_lot" field was cleared in this mutation.
func (m *ProductStoreMutation) ManagedByLotCleared() bool {
	_, ok := m.clearedFields[productstore.FieldManagedByLot]
	return ok
}

// ResetManagedByLot resets all changes to the "managed_by_lot" field.
func (m *ProductStoreMutation) ResetManagedByLot() {
	m.managed_by_lot = nil
	delete(m.clearedFields, productstore.FieldManagedByLot)
}

// SetShowOutOfStockProducts sets the "show_out_of_stock_products" field.
func (m *ProductStoreMutation) SetShowOutOfStockProducts(poosp productstore.ShowOutOfStockProducts) {
	m.show_out_of_stock_products = &poosp
}

// ShowOutOfStockProducts returns the value of the "show_out_of_stock_products" field in the mutation.
func (m *ProductStoreMutation) ShowOutOfStockProducts() (r productstore.ShowOutOfStockProducts, exists bool) {
	v := m.show_out_of_stock_products
	if v == nil {
		return
	}
	return *v, true
}

// OldShowOutOfStockProducts returns the old "show_out_of_stock_products" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldShowOutOfStockProducts(ctx context.Context) (v productstore.ShowOutOfStockProducts, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowOutOfStockProducts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowOutOfStockProducts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowOutOfStockProducts: %w", err)
	}
	return oldValue.ShowOutOfStockProducts, nil
}

// ClearShowOutOfStockProducts clears the value of the "show_out_of_stock_products" field.
func (m *ProductStoreMutation) ClearShowOutOfStockProducts() {
	m.show_out_of_stock_products = nil
	m.clearedFields[productstore.FieldShowOutOfStockProducts] = struct{}{}
}

// ShowOutOfStockProductsCleared returns if the "show_out_of_stock_products" field was cleared in this mutation.
func (m *ProductStoreMutation) ShowOutOfStockProductsCleared() bool {
	_, ok := m.clearedFields[productstore.FieldShowOutOfStockProducts]
	return ok
}

// ResetShowOutOfStockProducts resets all changes to the "show_out_of_stock_products" field.
func (m *ProductStoreMutation) ResetShowOutOfStockProducts() {
	m.show_out_of_stock_products = nil
	delete(m.clearedFields, productstore.FieldShowOutOfStockProducts)
}

// SetOrderDecimalQuantity sets the "order_decimal_quantity" field.
func (m *ProductStoreMutation) SetOrderDecimalQuantity(pdq productstore.OrderDecimalQuantity) {
	m.order_decimal_quantity = &pdq
}

// OrderDecimalQuantity returns the value of the "order_decimal_quantity" field in the mutation.
func (m *ProductStoreMutation) OrderDecimalQuantity() (r productstore.OrderDecimalQuantity, exists bool) {
	v := m.order_decimal_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDecimalQuantity returns the old "order_decimal_quantity" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldOrderDecimalQuantity(ctx context.Context) (v productstore.OrderDecimalQuantity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderDecimalQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderDecimalQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDecimalQuantity: %w", err)
	}
	return oldValue.OrderDecimalQuantity, nil
}

// ClearOrderDecimalQuantity clears the value of the "order_decimal_quantity" field.
func (m *ProductStoreMutation) ClearOrderDecimalQuantity() {
	m.order_decimal_quantity = nil
	m.clearedFields[productstore.FieldOrderDecimalQuantity] = struct{}{}
}

// OrderDecimalQuantityCleared returns if the "order_decimal_quantity" field was cleared in this mutation.
func (m *ProductStoreMutation) OrderDecimalQuantityCleared() bool {
	_, ok := m.clearedFields[productstore.FieldOrderDecimalQuantity]
	return ok
}

// ResetOrderDecimalQuantity resets all changes to the "order_decimal_quantity" field.
func (m *ProductStoreMutation) ResetOrderDecimalQuantity() {
	m.order_decimal_quantity = nil
	delete(m.clearedFields, productstore.FieldOrderDecimalQuantity)
}

// SetAllowComment sets the "allow_comment" field.
func (m *ProductStoreMutation) SetAllowComment(pc productstore.AllowComment) {
	m.allow_comment = &pc
}

// AllowComment returns the value of the "allow_comment" field in the mutation.
func (m *ProductStoreMutation) AllowComment() (r productstore.AllowComment, exists bool) {
	v := m.allow_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowComment returns the old "allow_comment" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAllowComment(ctx context.Context) (v productstore.AllowComment, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllowComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllowComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowComment: %w", err)
	}
	return oldValue.AllowComment, nil
}

// ClearAllowComment clears the value of the "allow_comment" field.
func (m *ProductStoreMutation) ClearAllowComment() {
	m.allow_comment = nil
	m.clearedFields[productstore.FieldAllowComment] = struct{}{}
}

// AllowCommentCleared returns if the "allow_comment" field was cleared in this mutation.
func (m *ProductStoreMutation) AllowCommentCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAllowComment]
	return ok
}

// ResetAllowComment resets all changes to the "allow_comment" field.
func (m *ProductStoreMutation) ResetAllowComment() {
	m.allow_comment = nil
	delete(m.clearedFields, productstore.FieldAllowComment)
}

// SetAllocateInventory sets the "allocate_inventory" field.
func (m *ProductStoreMutation) SetAllocateInventory(pi productstore.AllocateInventory) {
	m.allocate_inventory = &pi
}

// AllocateInventory returns the value of the "allocate_inventory" field in the mutation.
func (m *ProductStoreMutation) AllocateInventory() (r productstore.AllocateInventory, exists bool) {
	v := m.allocate_inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocateInventory returns the old "allocate_inventory" field's value of the ProductStore entity.
// If the ProductStore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreMutation) OldAllocateInventory(ctx context.Context) (v productstore.AllocateInventory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllocateInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllocateInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocateInventory: %w", err)
	}
	return oldValue.AllocateInventory, nil
}

// ClearAllocateInventory clears the value of the "allocate_inventory" field.
func (m *ProductStoreMutation) ClearAllocateInventory() {
	m.allocate_inventory = nil
	m.clearedFields[productstore.FieldAllocateInventory] = struct{}{}
}

// AllocateInventoryCleared returns if the "allocate_inventory" field was cleared in this mutation.
func (m *ProductStoreMutation) AllocateInventoryCleared() bool {
	_, ok := m.clearedFields[productstore.FieldAllocateInventory]
	return ok
}

// ResetAllocateInventory resets all changes to the "allocate_inventory" field.
func (m *ProductStoreMutation) ResetAllocateInventory() {
	m.allocate_inventory = nil
	delete(m.clearedFields, productstore.FieldAllocateInventory)
}

// SetPrimaryProductStoreGroupID sets the "primary_product_store_group" edge to the ProductStoreGroup entity by id.
func (m *ProductStoreMutation) SetPrimaryProductStoreGroupID(id int) {
	m.primary_product_store_group = &id
}

// ClearPrimaryProductStoreGroup clears the "primary_product_store_group" edge to the ProductStoreGroup entity.
func (m *ProductStoreMutation) ClearPrimaryProductStoreGroup() {
	m.clearedprimary_product_store_group = true
}

// PrimaryProductStoreGroupCleared reports if the "primary_product_store_group" edge to the ProductStoreGroup entity was cleared.
func (m *ProductStoreMutation) PrimaryProductStoreGroupCleared() bool {
	return m.clearedprimary_product_store_group
}

// PrimaryProductStoreGroupID returns the "primary_product_store_group" edge ID in the mutation.
func (m *ProductStoreMutation) PrimaryProductStoreGroupID() (id int, exists bool) {
	if m.primary_product_store_group != nil {
		return *m.primary_product_store_group, true
	}
	return
}

// PrimaryProductStoreGroupIDs returns the "primary_product_store_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryProductStoreGroupID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) PrimaryProductStoreGroupIDs() (ids []int) {
	if id := m.primary_product_store_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryProductStoreGroup resets all changes to the "primary_product_store_group" edge.
func (m *ProductStoreMutation) ResetPrimaryProductStoreGroup() {
	m.primary_product_store_group = nil
	m.clearedprimary_product_store_group = false
}

// SetReserveOrderEnumerationID sets the "reserve_order_enumeration" edge to the Enumeration entity by id.
func (m *ProductStoreMutation) SetReserveOrderEnumerationID(id int) {
	m.reserve_order_enumeration = &id
}

// ClearReserveOrderEnumeration clears the "reserve_order_enumeration" edge to the Enumeration entity.
func (m *ProductStoreMutation) ClearReserveOrderEnumeration() {
	m.clearedreserve_order_enumeration = true
}

// ReserveOrderEnumerationCleared reports if the "reserve_order_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductStoreMutation) ReserveOrderEnumerationCleared() bool {
	return m.clearedreserve_order_enumeration
}

// ReserveOrderEnumerationID returns the "reserve_order_enumeration" edge ID in the mutation.
func (m *ProductStoreMutation) ReserveOrderEnumerationID() (id int, exists bool) {
	if m.reserve_order_enumeration != nil {
		return *m.reserve_order_enumeration, true
	}
	return
}

// ReserveOrderEnumerationIDs returns the "reserve_order_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReserveOrderEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) ReserveOrderEnumerationIDs() (ids []int) {
	if id := m.reserve_order_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReserveOrderEnumeration resets all changes to the "reserve_order_enumeration" edge.
func (m *ProductStoreMutation) ResetReserveOrderEnumeration() {
	m.reserve_order_enumeration = nil
	m.clearedreserve_order_enumeration = false
}

// SetRequirementMethodEnumerationID sets the "requirement_method_enumeration" edge to the Enumeration entity by id.
func (m *ProductStoreMutation) SetRequirementMethodEnumerationID(id int) {
	m.requirement_method_enumeration = &id
}

// ClearRequirementMethodEnumeration clears the "requirement_method_enumeration" edge to the Enumeration entity.
func (m *ProductStoreMutation) ClearRequirementMethodEnumeration() {
	m.clearedrequirement_method_enumeration = true
}

// RequirementMethodEnumerationCleared reports if the "requirement_method_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductStoreMutation) RequirementMethodEnumerationCleared() bool {
	return m.clearedrequirement_method_enumeration
}

// RequirementMethodEnumerationID returns the "requirement_method_enumeration" edge ID in the mutation.
func (m *ProductStoreMutation) RequirementMethodEnumerationID() (id int, exists bool) {
	if m.requirement_method_enumeration != nil {
		return *m.requirement_method_enumeration, true
	}
	return
}

// RequirementMethodEnumerationIDs returns the "requirement_method_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequirementMethodEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) RequirementMethodEnumerationIDs() (ids []int) {
	if id := m.requirement_method_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequirementMethodEnumeration resets all changes to the "requirement_method_enumeration" edge.
func (m *ProductStoreMutation) ResetRequirementMethodEnumeration() {
	m.requirement_method_enumeration = nil
	m.clearedrequirement_method_enumeration = false
}

// SetDefaultSalesChannelEnumerationID sets the "default_sales_channel_enumeration" edge to the Enumeration entity by id.
func (m *ProductStoreMutation) SetDefaultSalesChannelEnumerationID(id int) {
	m.default_sales_channel_enumeration = &id
}

// ClearDefaultSalesChannelEnumeration clears the "default_sales_channel_enumeration" edge to the Enumeration entity.
func (m *ProductStoreMutation) ClearDefaultSalesChannelEnumeration() {
	m.cleareddefault_sales_channel_enumeration = true
}

// DefaultSalesChannelEnumerationCleared reports if the "default_sales_channel_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductStoreMutation) DefaultSalesChannelEnumerationCleared() bool {
	return m.cleareddefault_sales_channel_enumeration
}

// DefaultSalesChannelEnumerationID returns the "default_sales_channel_enumeration" edge ID in the mutation.
func (m *ProductStoreMutation) DefaultSalesChannelEnumerationID() (id int, exists bool) {
	if m.default_sales_channel_enumeration != nil {
		return *m.default_sales_channel_enumeration, true
	}
	return
}

// DefaultSalesChannelEnumerationIDs returns the "default_sales_channel_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultSalesChannelEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) DefaultSalesChannelEnumerationIDs() (ids []int) {
	if id := m.default_sales_channel_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultSalesChannelEnumeration resets all changes to the "default_sales_channel_enumeration" edge.
func (m *ProductStoreMutation) ResetDefaultSalesChannelEnumeration() {
	m.default_sales_channel_enumeration = nil
	m.cleareddefault_sales_channel_enumeration = false
}

// SetHeaderApprovedStatusItemID sets the "header_approved_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetHeaderApprovedStatusItemID(id int) {
	m.header_approved_status_item = &id
}

// ClearHeaderApprovedStatusItem clears the "header_approved_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearHeaderApprovedStatusItem() {
	m.clearedheader_approved_status_item = true
}

// HeaderApprovedStatusItemCleared reports if the "header_approved_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) HeaderApprovedStatusItemCleared() bool {
	return m.clearedheader_approved_status_item
}

// HeaderApprovedStatusItemID returns the "header_approved_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) HeaderApprovedStatusItemID() (id int, exists bool) {
	if m.header_approved_status_item != nil {
		return *m.header_approved_status_item, true
	}
	return
}

// HeaderApprovedStatusItemIDs returns the "header_approved_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeaderApprovedStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) HeaderApprovedStatusItemIDs() (ids []int) {
	if id := m.header_approved_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHeaderApprovedStatusItem resets all changes to the "header_approved_status_item" edge.
func (m *ProductStoreMutation) ResetHeaderApprovedStatusItem() {
	m.header_approved_status_item = nil
	m.clearedheader_approved_status_item = false
}

// SetItemApprovedStatusItemID sets the "item_approved_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetItemApprovedStatusItemID(id int) {
	m.item_approved_status_item = &id
}

// ClearItemApprovedStatusItem clears the "item_approved_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearItemApprovedStatusItem() {
	m.cleareditem_approved_status_item = true
}

// ItemApprovedStatusItemCleared reports if the "item_approved_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) ItemApprovedStatusItemCleared() bool {
	return m.cleareditem_approved_status_item
}

// ItemApprovedStatusItemID returns the "item_approved_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) ItemApprovedStatusItemID() (id int, exists bool) {
	if m.item_approved_status_item != nil {
		return *m.item_approved_status_item, true
	}
	return
}

// ItemApprovedStatusItemIDs returns the "item_approved_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemApprovedStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) ItemApprovedStatusItemIDs() (ids []int) {
	if id := m.item_approved_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItemApprovedStatusItem resets all changes to the "item_approved_status_item" edge.
func (m *ProductStoreMutation) ResetItemApprovedStatusItem() {
	m.item_approved_status_item = nil
	m.cleareditem_approved_status_item = false
}

// SetDigitalItemApprovedStatusItemID sets the "digital_item_approved_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetDigitalItemApprovedStatusItemID(id int) {
	m.digital_item_approved_status_item = &id
}

// ClearDigitalItemApprovedStatusItem clears the "digital_item_approved_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearDigitalItemApprovedStatusItem() {
	m.cleareddigital_item_approved_status_item = true
}

// DigitalItemApprovedStatusItemCleared reports if the "digital_item_approved_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) DigitalItemApprovedStatusItemCleared() bool {
	return m.cleareddigital_item_approved_status_item
}

// DigitalItemApprovedStatusItemID returns the "digital_item_approved_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) DigitalItemApprovedStatusItemID() (id int, exists bool) {
	if m.digital_item_approved_status_item != nil {
		return *m.digital_item_approved_status_item, true
	}
	return
}

// DigitalItemApprovedStatusItemIDs returns the "digital_item_approved_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DigitalItemApprovedStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) DigitalItemApprovedStatusItemIDs() (ids []int) {
	if id := m.digital_item_approved_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDigitalItemApprovedStatusItem resets all changes to the "digital_item_approved_status_item" edge.
func (m *ProductStoreMutation) ResetDigitalItemApprovedStatusItem() {
	m.digital_item_approved_status_item = nil
	m.cleareddigital_item_approved_status_item = false
}

// SetHeaderDeclinedStatusItemID sets the "header_declined_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetHeaderDeclinedStatusItemID(id int) {
	m.header_declined_status_item = &id
}

// ClearHeaderDeclinedStatusItem clears the "header_declined_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearHeaderDeclinedStatusItem() {
	m.clearedheader_declined_status_item = true
}

// HeaderDeclinedStatusItemCleared reports if the "header_declined_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) HeaderDeclinedStatusItemCleared() bool {
	return m.clearedheader_declined_status_item
}

// HeaderDeclinedStatusItemID returns the "header_declined_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) HeaderDeclinedStatusItemID() (id int, exists bool) {
	if m.header_declined_status_item != nil {
		return *m.header_declined_status_item, true
	}
	return
}

// HeaderDeclinedStatusItemIDs returns the "header_declined_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeaderDeclinedStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) HeaderDeclinedStatusItemIDs() (ids []int) {
	if id := m.header_declined_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHeaderDeclinedStatusItem resets all changes to the "header_declined_status_item" edge.
func (m *ProductStoreMutation) ResetHeaderDeclinedStatusItem() {
	m.header_declined_status_item = nil
	m.clearedheader_declined_status_item = false
}

// SetItemDeclinedStatusItemID sets the "item_declined_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetItemDeclinedStatusItemID(id int) {
	m.item_declined_status_item = &id
}

// ClearItemDeclinedStatusItem clears the "item_declined_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearItemDeclinedStatusItem() {
	m.cleareditem_declined_status_item = true
}

// ItemDeclinedStatusItemCleared reports if the "item_declined_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) ItemDeclinedStatusItemCleared() bool {
	return m.cleareditem_declined_status_item
}

// ItemDeclinedStatusItemID returns the "item_declined_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) ItemDeclinedStatusItemID() (id int, exists bool) {
	if m.item_declined_status_item != nil {
		return *m.item_declined_status_item, true
	}
	return
}

// ItemDeclinedStatusItemIDs returns the "item_declined_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemDeclinedStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) ItemDeclinedStatusItemIDs() (ids []int) {
	if id := m.item_declined_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItemDeclinedStatusItem resets all changes to the "item_declined_status_item" edge.
func (m *ProductStoreMutation) ResetItemDeclinedStatusItem() {
	m.item_declined_status_item = nil
	m.cleareditem_declined_status_item = false
}

// SetHeaderCancelStatusItemID sets the "header_cancel_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetHeaderCancelStatusItemID(id int) {
	m.header_cancel_status_item = &id
}

// ClearHeaderCancelStatusItem clears the "header_cancel_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearHeaderCancelStatusItem() {
	m.clearedheader_cancel_status_item = true
}

// HeaderCancelStatusItemCleared reports if the "header_cancel_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) HeaderCancelStatusItemCleared() bool {
	return m.clearedheader_cancel_status_item
}

// HeaderCancelStatusItemID returns the "header_cancel_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) HeaderCancelStatusItemID() (id int, exists bool) {
	if m.header_cancel_status_item != nil {
		return *m.header_cancel_status_item, true
	}
	return
}

// HeaderCancelStatusItemIDs returns the "header_cancel_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HeaderCancelStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) HeaderCancelStatusItemIDs() (ids []int) {
	if id := m.header_cancel_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHeaderCancelStatusItem resets all changes to the "header_cancel_status_item" edge.
func (m *ProductStoreMutation) ResetHeaderCancelStatusItem() {
	m.header_cancel_status_item = nil
	m.clearedheader_cancel_status_item = false
}

// SetItemCancelStatusItemID sets the "item_cancel_status_item" edge to the StatusItem entity by id.
func (m *ProductStoreMutation) SetItemCancelStatusItemID(id int) {
	m.item_cancel_status_item = &id
}

// ClearItemCancelStatusItem clears the "item_cancel_status_item" edge to the StatusItem entity.
func (m *ProductStoreMutation) ClearItemCancelStatusItem() {
	m.cleareditem_cancel_status_item = true
}

// ItemCancelStatusItemCleared reports if the "item_cancel_status_item" edge to the StatusItem entity was cleared.
func (m *ProductStoreMutation) ItemCancelStatusItemCleared() bool {
	return m.cleareditem_cancel_status_item
}

// ItemCancelStatusItemID returns the "item_cancel_status_item" edge ID in the mutation.
func (m *ProductStoreMutation) ItemCancelStatusItemID() (id int, exists bool) {
	if m.item_cancel_status_item != nil {
		return *m.item_cancel_status_item, true
	}
	return
}

// ItemCancelStatusItemIDs returns the "item_cancel_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemCancelStatusItemID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) ItemCancelStatusItemIDs() (ids []int) {
	if id := m.item_cancel_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItemCancelStatusItem resets all changes to the "item_cancel_status_item" edge.
func (m *ProductStoreMutation) ResetItemCancelStatusItem() {
	m.item_cancel_status_item = nil
	m.cleareditem_cancel_status_item = false
}

// SetStoreCreditAccountEnumerationID sets the "store_credit_account_enumeration" edge to the Enumeration entity by id.
func (m *ProductStoreMutation) SetStoreCreditAccountEnumerationID(id int) {
	m.store_credit_account_enumeration = &id
}

// ClearStoreCreditAccountEnumeration clears the "store_credit_account_enumeration" edge to the Enumeration entity.
func (m *ProductStoreMutation) ClearStoreCreditAccountEnumeration() {
	m.clearedstore_credit_account_enumeration = true
}

// StoreCreditAccountEnumerationCleared reports if the "store_credit_account_enumeration" edge to the Enumeration entity was cleared.
func (m *ProductStoreMutation) StoreCreditAccountEnumerationCleared() bool {
	return m.clearedstore_credit_account_enumeration
}

// StoreCreditAccountEnumerationID returns the "store_credit_account_enumeration" edge ID in the mutation.
func (m *ProductStoreMutation) StoreCreditAccountEnumerationID() (id int, exists bool) {
	if m.store_credit_account_enumeration != nil {
		return *m.store_credit_account_enumeration, true
	}
	return
}

// StoreCreditAccountEnumerationIDs returns the "store_credit_account_enumeration" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreCreditAccountEnumerationID instead. It exists only for internal usage by the builders.
func (m *ProductStoreMutation) StoreCreditAccountEnumerationIDs() (ids []int) {
	if id := m.store_credit_account_enumeration; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStoreCreditAccountEnumeration resets all changes to the "store_credit_account_enumeration" edge.
func (m *ProductStoreMutation) ResetStoreCreditAccountEnumeration() {
	m.store_credit_account_enumeration = nil
	m.clearedstore_credit_account_enumeration = false
}

// AddOrderHeaderIDs adds the "order_headers" edge to the OrderHeader entity by ids.
func (m *ProductStoreMutation) AddOrderHeaderIDs(ids ...int) {
	if m.order_headers == nil {
		m.order_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.order_headers[ids[i]] = struct{}{}
	}
}

// ClearOrderHeaders clears the "order_headers" edge to the OrderHeader entity.
func (m *ProductStoreMutation) ClearOrderHeaders() {
	m.clearedorder_headers = true
}

// OrderHeadersCleared reports if the "order_headers" edge to the OrderHeader entity was cleared.
func (m *ProductStoreMutation) OrderHeadersCleared() bool {
	return m.clearedorder_headers
}

// RemoveOrderHeaderIDs removes the "order_headers" edge to the OrderHeader entity by IDs.
func (m *ProductStoreMutation) RemoveOrderHeaderIDs(ids ...int) {
	if m.removedorder_headers == nil {
		m.removedorder_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_headers[ids[i]] = struct{}{}
	}
}

// RemovedOrderHeaders returns the removed IDs of the "order_headers" edge to the OrderHeader entity.
func (m *ProductStoreMutation) RemovedOrderHeadersIDs() (ids []int) {
	for id := range m.removedorder_headers {
		ids = append(ids, id)
	}
	return
}

// OrderHeadersIDs returns the "order_headers" edge IDs in the mutation.
func (m *ProductStoreMutation) OrderHeadersIDs() (ids []int) {
	for id := range m.order_headers {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHeaders resets all changes to the "order_headers" edge.
func (m *ProductStoreMutation) ResetOrderHeaders() {
	m.order_headers = nil
	m.clearedorder_headers = false
	m.removedorder_headers = nil
}

// AddProductReviewIDs adds the "product_reviews" edge to the ProductReview entity by ids.
func (m *ProductStoreMutation) AddProductReviewIDs(ids ...int) {
	if m.product_reviews == nil {
		m.product_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.product_reviews[ids[i]] = struct{}{}
	}
}

// ClearProductReviews clears the "product_reviews" edge to the ProductReview entity.
func (m *ProductStoreMutation) ClearProductReviews() {
	m.clearedproduct_reviews = true
}

// ProductReviewsCleared reports if the "product_reviews" edge to the ProductReview entity was cleared.
func (m *ProductStoreMutation) ProductReviewsCleared() bool {
	return m.clearedproduct_reviews
}

// RemoveProductReviewIDs removes the "product_reviews" edge to the ProductReview entity by IDs.
func (m *ProductStoreMutation) RemoveProductReviewIDs(ids ...int) {
	if m.removedproduct_reviews == nil {
		m.removedproduct_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_reviews[ids[i]] = struct{}{}
	}
}

// RemovedProductReviews returns the removed IDs of the "product_reviews" edge to the ProductReview entity.
func (m *ProductStoreMutation) RemovedProductReviewsIDs() (ids []int) {
	for id := range m.removedproduct_reviews {
		ids = append(ids, id)
	}
	return
}

// ProductReviewsIDs returns the "product_reviews" edge IDs in the mutation.
func (m *ProductStoreMutation) ProductReviewsIDs() (ids []int) {
	for id := range m.product_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetProductReviews resets all changes to the "product_reviews" edge.
func (m *ProductStoreMutation) ResetProductReviews() {
	m.product_reviews = nil
	m.clearedproduct_reviews = false
	m.removedproduct_reviews = nil
}

// Op returns the operation name.
func (m *ProductStoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductStore).
func (m *ProductStoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductStoreMutation) Fields() []string {
	fields := make([]string, 0, 68)
	if m.create_time != nil {
		fields = append(fields, productstore.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productstore.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productstore.FieldStringRef)
	}
	if m.store_name != nil {
		fields = append(fields, productstore.FieldStoreName)
	}
	if m.company_name != nil {
		fields = append(fields, productstore.FieldCompanyName)
	}
	if m.title != nil {
		fields = append(fields, productstore.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, productstore.FieldSubtitle)
	}
	if m.pay_to_party_id != nil {
		fields = append(fields, productstore.FieldPayToPartyID)
	}
	if m.days_to_cancel_non_pay != nil {
		fields = append(fields, productstore.FieldDaysToCancelNonPay)
	}
	if m.manual_auth_is_capture != nil {
		fields = append(fields, productstore.FieldManualAuthIsCapture)
	}
	if m.prorate_shipping != nil {
		fields = append(fields, productstore.FieldProrateShipping)
	}
	if m.prorate_taxes != nil {
		fields = append(fields, productstore.FieldProrateTaxes)
	}
	if m.view_cart_on_add != nil {
		fields = append(fields, productstore.FieldViewCartOnAdd)
	}
	if m.auto_save_cart != nil {
		fields = append(fields, productstore.FieldAutoSaveCart)
	}
	if m.auto_approve_reviews != nil {
		fields = append(fields, productstore.FieldAutoApproveReviews)
	}
	if m.is_demo_store != nil {
		fields = append(fields, productstore.FieldIsDemoStore)
	}
	if m.is_immediately_fulfilled != nil {
		fields = append(fields, productstore.FieldIsImmediatelyFulfilled)
	}
	if m.inventory_facility_id != nil {
		fields = append(fields, productstore.FieldInventoryFacilityID)
	}
	if m.one_inventory_facility != nil {
		fields = append(fields, productstore.FieldOneInventoryFacility)
	}
	if m.check_inventory != nil {
		fields = append(fields, productstore.FieldCheckInventory)
	}
	if m.reserve_inventory != nil {
		fields = append(fields, productstore.FieldReserveInventory)
	}
	if m.require_inventory != nil {
		fields = append(fields, productstore.FieldRequireInventory)
	}
	if m.balance_res_on_order_creation != nil {
		fields = append(fields, productstore.FieldBalanceResOnOrderCreation)
	}
	if m.order_number_prefix != nil {
		fields = append(fields, productstore.FieldOrderNumberPrefix)
	}
	if m.default_locale_string != nil {
		fields = append(fields, productstore.FieldDefaultLocaleString)
	}
	if m.default_currency_uom_id != nil {
		fields = append(fields, productstore.FieldDefaultCurrencyUomID)
	}
	if m.default_time_zone_string != nil {
		fields = append(fields, productstore.FieldDefaultTimeZoneString)
	}
	if m.allow_password != nil {
		fields = append(fields, productstore.FieldAllowPassword)
	}
	if m.default_password != nil {
		fields = append(fields, productstore.FieldDefaultPassword)
	}
	if m.explode_order_items != nil {
		fields = append(fields, productstore.FieldExplodeOrderItems)
	}
	if m.check_gc_balance != nil {
		fields = append(fields, productstore.FieldCheckGcBalance)
	}
	if m.retry_failed_auths != nil {
		fields = append(fields, productstore.FieldRetryFailedAuths)
	}
	if m.auth_declined_message != nil {
		fields = append(fields, productstore.FieldAuthDeclinedMessage)
	}
	if m.auth_fraud_message != nil {
		fields = append(fields, productstore.FieldAuthFraudMessage)
	}
	if m.auth_error_message != nil {
		fields = append(fields, productstore.FieldAuthErrorMessage)
	}
	if m.visual_theme_id != nil {
		fields = append(fields, productstore.FieldVisualThemeID)
	}
	if m.use_primary_email_username != nil {
		fields = append(fields, productstore.FieldUsePrimaryEmailUsername)
	}
	if m.require_customer_role != nil {
		fields = append(fields, productstore.FieldRequireCustomerRole)
	}
	if m.auto_invoice_digital_items != nil {
		fields = append(fields, productstore.FieldAutoInvoiceDigitalItems)
	}
	if m.req_ship_addr_for_dig_items != nil {
		fields = append(fields, productstore.FieldReqShipAddrForDigItems)
	}
	if m.show_checkout_gift_options != nil {
		fields = append(fields, productstore.FieldShowCheckoutGiftOptions)
	}
	if m.select_payment_type_per_item != nil {
		fields = append(fields, productstore.FieldSelectPaymentTypePerItem)
	}
	if m.show_prices_with_vat_tax != nil {
		fields = append(fields, productstore.FieldShowPricesWithVatTax)
	}
	if m.show_tax_is_exempt != nil {
		fields = append(fields, productstore.FieldShowTaxIsExempt)
	}
	if m.vat_tax_auth_geo_id != nil {
		fields = append(fields, productstore.FieldVatTaxAuthGeoID)
	}
	if m.vat_tax_auth_party_id != nil {
		fields = append(fields, productstore.FieldVatTaxAuthPartyID)
	}
	if m.enable_auto_suggestion_list != nil {
		fields = append(fields, productstore.FieldEnableAutoSuggestionList)
	}
	if m.enable_dig_prod_upload != nil {
		fields = append(fields, productstore.FieldEnableDigProdUpload)
	}
	if m.prod_search_exclude_variants != nil {
		fields = append(fields, productstore.FieldProdSearchExcludeVariants)
	}
	if m.dig_prod_upload_category_id != nil {
		fields = append(fields, productstore.FieldDigProdUploadCategoryID)
	}
	if m.auto_order_cc_try_exp != nil {
		fields = append(fields, productstore.FieldAutoOrderCcTryExp)
	}
	if m.auto_order_cc_try_other_cards != nil {
		fields = append(fields, productstore.FieldAutoOrderCcTryOtherCards)
	}
	if m.auto_order_cc_try_later_nsf != nil {
		fields = append(fields, productstore.FieldAutoOrderCcTryLaterNsf)
	}
	if m.auto_order_cc_try_later_max != nil {
		fields = append(fields, productstore.FieldAutoOrderCcTryLaterMax)
	}
	if m.store_credit_valid_days != nil {
		fields = append(fields, productstore.FieldStoreCreditValidDays)
	}
	if m.auto_approve_invoice != nil {
		fields = append(fields, productstore.FieldAutoApproveInvoice)
	}
	if m.auto_approve_order != nil {
		fields = append(fields, productstore.FieldAutoApproveOrder)
	}
	if m.ship_if_capture_fails != nil {
		fields = append(fields, productstore.FieldShipIfCaptureFails)
	}
	if m.set_owner_upon_issuance != nil {
		fields = append(fields, productstore.FieldSetOwnerUponIssuance)
	}
	if m.req_return_inventory_receive != nil {
		fields = append(fields, productstore.FieldReqReturnInventoryReceive)
	}
	if m.add_to_cart_remove_incompat != nil {
		fields = append(fields, productstore.FieldAddToCartRemoveIncompat)
	}
	if m.add_to_cart_replace_upsell != nil {
		fields = append(fields, productstore.FieldAddToCartReplaceUpsell)
	}
	if m.split_pay_pref_per_shp_grp != nil {
		fields = append(fields, productstore.FieldSplitPayPrefPerShpGrp)
	}
	if m.managed_by_lot != nil {
		fields = append(fields, productstore.FieldManagedByLot)
	}
	if m.show_out_of_stock_products != nil {
		fields = append(fields, productstore.FieldShowOutOfStockProducts)
	}
	if m.order_decimal_quantity != nil {
		fields = append(fields, productstore.FieldOrderDecimalQuantity)
	}
	if m.allow_comment != nil {
		fields = append(fields, productstore.FieldAllowComment)
	}
	if m.allocate_inventory != nil {
		fields = append(fields, productstore.FieldAllocateInventory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductStoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productstore.FieldCreateTime:
		return m.CreateTime()
	case productstore.FieldUpdateTime:
		return m.UpdateTime()
	case productstore.FieldStringRef:
		return m.StringRef()
	case productstore.FieldStoreName:
		return m.StoreName()
	case productstore.FieldCompanyName:
		return m.CompanyName()
	case productstore.FieldTitle:
		return m.Title()
	case productstore.FieldSubtitle:
		return m.Subtitle()
	case productstore.FieldPayToPartyID:
		return m.PayToPartyID()
	case productstore.FieldDaysToCancelNonPay:
		return m.DaysToCancelNonPay()
	case productstore.FieldManualAuthIsCapture:
		return m.ManualAuthIsCapture()
	case productstore.FieldProrateShipping:
		return m.ProrateShipping()
	case productstore.FieldProrateTaxes:
		return m.ProrateTaxes()
	case productstore.FieldViewCartOnAdd:
		return m.ViewCartOnAdd()
	case productstore.FieldAutoSaveCart:
		return m.AutoSaveCart()
	case productstore.FieldAutoApproveReviews:
		return m.AutoApproveReviews()
	case productstore.FieldIsDemoStore:
		return m.IsDemoStore()
	case productstore.FieldIsImmediatelyFulfilled:
		return m.IsImmediatelyFulfilled()
	case productstore.FieldInventoryFacilityID:
		return m.InventoryFacilityID()
	case productstore.FieldOneInventoryFacility:
		return m.OneInventoryFacility()
	case productstore.FieldCheckInventory:
		return m.CheckInventory()
	case productstore.FieldReserveInventory:
		return m.ReserveInventory()
	case productstore.FieldRequireInventory:
		return m.RequireInventory()
	case productstore.FieldBalanceResOnOrderCreation:
		return m.BalanceResOnOrderCreation()
	case productstore.FieldOrderNumberPrefix:
		return m.OrderNumberPrefix()
	case productstore.FieldDefaultLocaleString:
		return m.DefaultLocaleString()
	case productstore.FieldDefaultCurrencyUomID:
		return m.DefaultCurrencyUomID()
	case productstore.FieldDefaultTimeZoneString:
		return m.DefaultTimeZoneString()
	case productstore.FieldAllowPassword:
		return m.AllowPassword()
	case productstore.FieldDefaultPassword:
		return m.DefaultPassword()
	case productstore.FieldExplodeOrderItems:
		return m.ExplodeOrderItems()
	case productstore.FieldCheckGcBalance:
		return m.CheckGcBalance()
	case productstore.FieldRetryFailedAuths:
		return m.RetryFailedAuths()
	case productstore.FieldAuthDeclinedMessage:
		return m.AuthDeclinedMessage()
	case productstore.FieldAuthFraudMessage:
		return m.AuthFraudMessage()
	case productstore.FieldAuthErrorMessage:
		return m.AuthErrorMessage()
	case productstore.FieldVisualThemeID:
		return m.VisualThemeID()
	case productstore.FieldUsePrimaryEmailUsername:
		return m.UsePrimaryEmailUsername()
	case productstore.FieldRequireCustomerRole:
		return m.RequireCustomerRole()
	case productstore.FieldAutoInvoiceDigitalItems:
		return m.AutoInvoiceDigitalItems()
	case productstore.FieldReqShipAddrForDigItems:
		return m.ReqShipAddrForDigItems()
	case productstore.FieldShowCheckoutGiftOptions:
		return m.ShowCheckoutGiftOptions()
	case productstore.FieldSelectPaymentTypePerItem:
		return m.SelectPaymentTypePerItem()
	case productstore.FieldShowPricesWithVatTax:
		return m.ShowPricesWithVatTax()
	case productstore.FieldShowTaxIsExempt:
		return m.ShowTaxIsExempt()
	case productstore.FieldVatTaxAuthGeoID:
		return m.VatTaxAuthGeoID()
	case productstore.FieldVatTaxAuthPartyID:
		return m.VatTaxAuthPartyID()
	case productstore.FieldEnableAutoSuggestionList:
		return m.EnableAutoSuggestionList()
	case productstore.FieldEnableDigProdUpload:
		return m.EnableDigProdUpload()
	case productstore.FieldProdSearchExcludeVariants:
		return m.ProdSearchExcludeVariants()
	case productstore.FieldDigProdUploadCategoryID:
		return m.DigProdUploadCategoryID()
	case productstore.FieldAutoOrderCcTryExp:
		return m.AutoOrderCcTryExp()
	case productstore.FieldAutoOrderCcTryOtherCards:
		return m.AutoOrderCcTryOtherCards()
	case productstore.FieldAutoOrderCcTryLaterNsf:
		return m.AutoOrderCcTryLaterNsf()
	case productstore.FieldAutoOrderCcTryLaterMax:
		return m.AutoOrderCcTryLaterMax()
	case productstore.FieldStoreCreditValidDays:
		return m.StoreCreditValidDays()
	case productstore.FieldAutoApproveInvoice:
		return m.AutoApproveInvoice()
	case productstore.FieldAutoApproveOrder:
		return m.AutoApproveOrder()
	case productstore.FieldShipIfCaptureFails:
		return m.ShipIfCaptureFails()
	case productstore.FieldSetOwnerUponIssuance:
		return m.SetOwnerUponIssuance()
	case productstore.FieldReqReturnInventoryReceive:
		return m.ReqReturnInventoryReceive()
	case productstore.FieldAddToCartRemoveIncompat:
		return m.AddToCartRemoveIncompat()
	case productstore.FieldAddToCartReplaceUpsell:
		return m.AddToCartReplaceUpsell()
	case productstore.FieldSplitPayPrefPerShpGrp:
		return m.SplitPayPrefPerShpGrp()
	case productstore.FieldManagedByLot:
		return m.ManagedByLot()
	case productstore.FieldShowOutOfStockProducts:
		return m.ShowOutOfStockProducts()
	case productstore.FieldOrderDecimalQuantity:
		return m.OrderDecimalQuantity()
	case productstore.FieldAllowComment:
		return m.AllowComment()
	case productstore.FieldAllocateInventory:
		return m.AllocateInventory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductStoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productstore.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productstore.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productstore.FieldStringRef:
		return m.OldStringRef(ctx)
	case productstore.FieldStoreName:
		return m.OldStoreName(ctx)
	case productstore.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case productstore.FieldTitle:
		return m.OldTitle(ctx)
	case productstore.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case productstore.FieldPayToPartyID:
		return m.OldPayToPartyID(ctx)
	case productstore.FieldDaysToCancelNonPay:
		return m.OldDaysToCancelNonPay(ctx)
	case productstore.FieldManualAuthIsCapture:
		return m.OldManualAuthIsCapture(ctx)
	case productstore.FieldProrateShipping:
		return m.OldProrateShipping(ctx)
	case productstore.FieldProrateTaxes:
		return m.OldProrateTaxes(ctx)
	case productstore.FieldViewCartOnAdd:
		return m.OldViewCartOnAdd(ctx)
	case productstore.FieldAutoSaveCart:
		return m.OldAutoSaveCart(ctx)
	case productstore.FieldAutoApproveReviews:
		return m.OldAutoApproveReviews(ctx)
	case productstore.FieldIsDemoStore:
		return m.OldIsDemoStore(ctx)
	case productstore.FieldIsImmediatelyFulfilled:
		return m.OldIsImmediatelyFulfilled(ctx)
	case productstore.FieldInventoryFacilityID:
		return m.OldInventoryFacilityID(ctx)
	case productstore.FieldOneInventoryFacility:
		return m.OldOneInventoryFacility(ctx)
	case productstore.FieldCheckInventory:
		return m.OldCheckInventory(ctx)
	case productstore.FieldReserveInventory:
		return m.OldReserveInventory(ctx)
	case productstore.FieldRequireInventory:
		return m.OldRequireInventory(ctx)
	case productstore.FieldBalanceResOnOrderCreation:
		return m.OldBalanceResOnOrderCreation(ctx)
	case productstore.FieldOrderNumberPrefix:
		return m.OldOrderNumberPrefix(ctx)
	case productstore.FieldDefaultLocaleString:
		return m.OldDefaultLocaleString(ctx)
	case productstore.FieldDefaultCurrencyUomID:
		return m.OldDefaultCurrencyUomID(ctx)
	case productstore.FieldDefaultTimeZoneString:
		return m.OldDefaultTimeZoneString(ctx)
	case productstore.FieldAllowPassword:
		return m.OldAllowPassword(ctx)
	case productstore.FieldDefaultPassword:
		return m.OldDefaultPassword(ctx)
	case productstore.FieldExplodeOrderItems:
		return m.OldExplodeOrderItems(ctx)
	case productstore.FieldCheckGcBalance:
		return m.OldCheckGcBalance(ctx)
	case productstore.FieldRetryFailedAuths:
		return m.OldRetryFailedAuths(ctx)
	case productstore.FieldAuthDeclinedMessage:
		return m.OldAuthDeclinedMessage(ctx)
	case productstore.FieldAuthFraudMessage:
		return m.OldAuthFraudMessage(ctx)
	case productstore.FieldAuthErrorMessage:
		return m.OldAuthErrorMessage(ctx)
	case productstore.FieldVisualThemeID:
		return m.OldVisualThemeID(ctx)
	case productstore.FieldUsePrimaryEmailUsername:
		return m.OldUsePrimaryEmailUsername(ctx)
	case productstore.FieldRequireCustomerRole:
		return m.OldRequireCustomerRole(ctx)
	case productstore.FieldAutoInvoiceDigitalItems:
		return m.OldAutoInvoiceDigitalItems(ctx)
	case productstore.FieldReqShipAddrForDigItems:
		return m.OldReqShipAddrForDigItems(ctx)
	case productstore.FieldShowCheckoutGiftOptions:
		return m.OldShowCheckoutGiftOptions(ctx)
	case productstore.FieldSelectPaymentTypePerItem:
		return m.OldSelectPaymentTypePerItem(ctx)
	case productstore.FieldShowPricesWithVatTax:
		return m.OldShowPricesWithVatTax(ctx)
	case productstore.FieldShowTaxIsExempt:
		return m.OldShowTaxIsExempt(ctx)
	case productstore.FieldVatTaxAuthGeoID:
		return m.OldVatTaxAuthGeoID(ctx)
	case productstore.FieldVatTaxAuthPartyID:
		return m.OldVatTaxAuthPartyID(ctx)
	case productstore.FieldEnableAutoSuggestionList:
		return m.OldEnableAutoSuggestionList(ctx)
	case productstore.FieldEnableDigProdUpload:
		return m.OldEnableDigProdUpload(ctx)
	case productstore.FieldProdSearchExcludeVariants:
		return m.OldProdSearchExcludeVariants(ctx)
	case productstore.FieldDigProdUploadCategoryID:
		return m.OldDigProdUploadCategoryID(ctx)
	case productstore.FieldAutoOrderCcTryExp:
		return m.OldAutoOrderCcTryExp(ctx)
	case productstore.FieldAutoOrderCcTryOtherCards:
		return m.OldAutoOrderCcTryOtherCards(ctx)
	case productstore.FieldAutoOrderCcTryLaterNsf:
		return m.OldAutoOrderCcTryLaterNsf(ctx)
	case productstore.FieldAutoOrderCcTryLaterMax:
		return m.OldAutoOrderCcTryLaterMax(ctx)
	case productstore.FieldStoreCreditValidDays:
		return m.OldStoreCreditValidDays(ctx)
	case productstore.FieldAutoApproveInvoice:
		return m.OldAutoApproveInvoice(ctx)
	case productstore.FieldAutoApproveOrder:
		return m.OldAutoApproveOrder(ctx)
	case productstore.FieldShipIfCaptureFails:
		return m.OldShipIfCaptureFails(ctx)
	case productstore.FieldSetOwnerUponIssuance:
		return m.OldSetOwnerUponIssuance(ctx)
	case productstore.FieldReqReturnInventoryReceive:
		return m.OldReqReturnInventoryReceive(ctx)
	case productstore.FieldAddToCartRemoveIncompat:
		return m.OldAddToCartRemoveIncompat(ctx)
	case productstore.FieldAddToCartReplaceUpsell:
		return m.OldAddToCartReplaceUpsell(ctx)
	case productstore.FieldSplitPayPrefPerShpGrp:
		return m.OldSplitPayPrefPerShpGrp(ctx)
	case productstore.FieldManagedByLot:
		return m.OldManagedByLot(ctx)
	case productstore.FieldShowOutOfStockProducts:
		return m.OldShowOutOfStockProducts(ctx)
	case productstore.FieldOrderDecimalQuantity:
		return m.OldOrderDecimalQuantity(ctx)
	case productstore.FieldAllowComment:
		return m.OldAllowComment(ctx)
	case productstore.FieldAllocateInventory:
		return m.OldAllocateInventory(ctx)
	}
	return nil, fmt.Errorf("unknown ProductStore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductStoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productstore.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productstore.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productstore.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productstore.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	case productstore.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case productstore.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case productstore.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case productstore.FieldPayToPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayToPartyID(v)
		return nil
	case productstore.FieldDaysToCancelNonPay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDaysToCancelNonPay(v)
		return nil
	case productstore.FieldManualAuthIsCapture:
		v, ok := value.(productstore.ManualAuthIsCapture)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManualAuthIsCapture(v)
		return nil
	case productstore.FieldProrateShipping:
		v, ok := value.(productstore.ProrateShipping)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProrateShipping(v)
		return nil
	case productstore.FieldProrateTaxes:
		v, ok := value.(productstore.ProrateTaxes)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProrateTaxes(v)
		return nil
	case productstore.FieldViewCartOnAdd:
		v, ok := value.(productstore.ViewCartOnAdd)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCartOnAdd(v)
		return nil
	case productstore.FieldAutoSaveCart:
		v, ok := value.(productstore.AutoSaveCart)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSaveCart(v)
		return nil
	case productstore.FieldAutoApproveReviews:
		v, ok := value.(productstore.AutoApproveReviews)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoApproveReviews(v)
		return nil
	case productstore.FieldIsDemoStore:
		v, ok := value.(productstore.IsDemoStore)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDemoStore(v)
		return nil
	case productstore.FieldIsImmediatelyFulfilled:
		v, ok := value.(productstore.IsImmediatelyFulfilled)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsImmediatelyFulfilled(v)
		return nil
	case productstore.FieldInventoryFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryFacilityID(v)
		return nil
	case productstore.FieldOneInventoryFacility:
		v, ok := value.(productstore.OneInventoryFacility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOneInventoryFacility(v)
		return nil
	case productstore.FieldCheckInventory:
		v, ok := value.(productstore.CheckInventory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInventory(v)
		return nil
	case productstore.FieldReserveInventory:
		v, ok := value.(productstore.ReserveInventory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserveInventory(v)
		return nil
	case productstore.FieldRequireInventory:
		v, ok := value.(productstore.RequireInventory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireInventory(v)
		return nil
	case productstore.FieldBalanceResOnOrderCreation:
		v, ok := value.(productstore.BalanceResOnOrderCreation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceResOnOrderCreation(v)
		return nil
	case productstore.FieldOrderNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumberPrefix(v)
		return nil
	case productstore.FieldDefaultLocaleString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultLocaleString(v)
		return nil
	case productstore.FieldDefaultCurrencyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultCurrencyUomID(v)
		return nil
	case productstore.FieldDefaultTimeZoneString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTimeZoneString(v)
		return nil
	case productstore.FieldAllowPassword:
		v, ok := value.(productstore.AllowPassword)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowPassword(v)
		return nil
	case productstore.FieldDefaultPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultPassword(v)
		return nil
	case productstore.FieldExplodeOrderItems:
		v, ok := value.(productstore.ExplodeOrderItems)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExplodeOrderItems(v)
		return nil
	case productstore.FieldCheckGcBalance:
		v, ok := value.(productstore.CheckGcBalance)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckGcBalance(v)
		return nil
	case productstore.FieldRetryFailedAuths:
		v, ok := value.(productstore.RetryFailedAuths)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryFailedAuths(v)
		return nil
	case productstore.FieldAuthDeclinedMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthDeclinedMessage(v)
		return nil
	case productstore.FieldAuthFraudMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthFraudMessage(v)
		return nil
	case productstore.FieldAuthErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthErrorMessage(v)
		return nil
	case productstore.FieldVisualThemeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisualThemeID(v)
		return nil
	case productstore.FieldUsePrimaryEmailUsername:
		v, ok := value.(productstore.UsePrimaryEmailUsername)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsePrimaryEmailUsername(v)
		return nil
	case productstore.FieldRequireCustomerRole:
		v, ok := value.(productstore.RequireCustomerRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireCustomerRole(v)
		return nil
	case productstore.FieldAutoInvoiceDigitalItems:
		v, ok := value.(productstore.AutoInvoiceDigitalItems)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoInvoiceDigitalItems(v)
		return nil
	case productstore.FieldReqShipAddrForDigItems:
		v, ok := value.(productstore.ReqShipAddrForDigItems)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqShipAddrForDigItems(v)
		return nil
	case productstore.FieldShowCheckoutGiftOptions:
		v, ok := value.(productstore.ShowCheckoutGiftOptions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowCheckoutGiftOptions(v)
		return nil
	case productstore.FieldSelectPaymentTypePerItem:
		v, ok := value.(productstore.SelectPaymentTypePerItem)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectPaymentTypePerItem(v)
		return nil
	case productstore.FieldShowPricesWithVatTax:
		v, ok := value.(productstore.ShowPricesWithVatTax)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowPricesWithVatTax(v)
		return nil
	case productstore.FieldShowTaxIsExempt:
		v, ok := value.(productstore.ShowTaxIsExempt)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowTaxIsExempt(v)
		return nil
	case productstore.FieldVatTaxAuthGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatTaxAuthGeoID(v)
		return nil
	case productstore.FieldVatTaxAuthPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatTaxAuthPartyID(v)
		return nil
	case productstore.FieldEnableAutoSuggestionList:
		v, ok := value.(productstore.EnableAutoSuggestionList)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoSuggestionList(v)
		return nil
	case productstore.FieldEnableDigProdUpload:
		v, ok := value.(productstore.EnableDigProdUpload)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableDigProdUpload(v)
		return nil
	case productstore.FieldProdSearchExcludeVariants:
		v, ok := value.(productstore.ProdSearchExcludeVariants)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProdSearchExcludeVariants(v)
		return nil
	case productstore.FieldDigProdUploadCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigProdUploadCategoryID(v)
		return nil
	case productstore.FieldAutoOrderCcTryExp:
		v, ok := value.(productstore.AutoOrderCcTryExp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoOrderCcTryExp(v)
		return nil
	case productstore.FieldAutoOrderCcTryOtherCards:
		v, ok := value.(productstore.AutoOrderCcTryOtherCards)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoOrderCcTryOtherCards(v)
		return nil
	case productstore.FieldAutoOrderCcTryLaterNsf:
		v, ok := value.(productstore.AutoOrderCcTryLaterNsf)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoOrderCcTryLaterNsf(v)
		return nil
	case productstore.FieldAutoOrderCcTryLaterMax:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoOrderCcTryLaterMax(v)
		return nil
	case productstore.FieldStoreCreditValidDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreCreditValidDays(v)
		return nil
	case productstore.FieldAutoApproveInvoice:
		v, ok := value.(productstore.AutoApproveInvoice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoApproveInvoice(v)
		return nil
	case productstore.FieldAutoApproveOrder:
		v, ok := value.(productstore.AutoApproveOrder)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoApproveOrder(v)
		return nil
	case productstore.FieldShipIfCaptureFails:
		v, ok := value.(productstore.ShipIfCaptureFails)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipIfCaptureFails(v)
		return nil
	case productstore.FieldSetOwnerUponIssuance:
		v, ok := value.(productstore.SetOwnerUponIssuance)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetOwnerUponIssuance(v)
		return nil
	case productstore.FieldReqReturnInventoryReceive:
		v, ok := value.(productstore.ReqReturnInventoryReceive)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqReturnInventoryReceive(v)
		return nil
	case productstore.FieldAddToCartRemoveIncompat:
		v, ok := value.(productstore.AddToCartRemoveIncompat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddToCartRemoveIncompat(v)
		return nil
	case productstore.FieldAddToCartReplaceUpsell:
		v, ok := value.(productstore.AddToCartReplaceUpsell)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddToCartReplaceUpsell(v)
		return nil
	case productstore.FieldSplitPayPrefPerShpGrp:
		v, ok := value.(productstore.SplitPayPrefPerShpGrp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSplitPayPrefPerShpGrp(v)
		return nil
	case productstore.FieldManagedByLot:
		v, ok := value.(productstore.ManagedByLot)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagedByLot(v)
		return nil
	case productstore.FieldShowOutOfStockProducts:
		v, ok := value.(productstore.ShowOutOfStockProducts)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowOutOfStockProducts(v)
		return nil
	case productstore.FieldOrderDecimalQuantity:
		v, ok := value.(productstore.OrderDecimalQuantity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDecimalQuantity(v)
		return nil
	case productstore.FieldAllowComment:
		v, ok := value.(productstore.AllowComment)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowComment(v)
		return nil
	case productstore.FieldAllocateInventory:
		v, ok := value.(productstore.AllocateInventory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocateInventory(v)
		return nil
	}
	return fmt.Errorf("unknown ProductStore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductStoreMutation) AddedFields() []string {
	var fields []string
	if m.addpay_to_party_id != nil {
		fields = append(fields, productstore.FieldPayToPartyID)
	}
	if m.adddays_to_cancel_non_pay != nil {
		fields = append(fields, productstore.FieldDaysToCancelNonPay)
	}
	if m.addinventory_facility_id != nil {
		fields = append(fields, productstore.FieldInventoryFacilityID)
	}
	if m.adddefault_currency_uom_id != nil {
		fields = append(fields, productstore.FieldDefaultCurrencyUomID)
	}
	if m.addvisual_theme_id != nil {
		fields = append(fields, productstore.FieldVisualThemeID)
	}
	if m.addvat_tax_auth_geo_id != nil {
		fields = append(fields, productstore.FieldVatTaxAuthGeoID)
	}
	if m.addvat_tax_auth_party_id != nil {
		fields = append(fields, productstore.FieldVatTaxAuthPartyID)
	}
	if m.adddig_prod_upload_category_id != nil {
		fields = append(fields, productstore.FieldDigProdUploadCategoryID)
	}
	if m.addauto_order_cc_try_later_max != nil {
		fields = append(fields, productstore.FieldAutoOrderCcTryLaterMax)
	}
	if m.addstore_credit_valid_days != nil {
		fields = append(fields, productstore.FieldStoreCreditValidDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductStoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productstore.FieldPayToPartyID:
		return m.AddedPayToPartyID()
	case productstore.FieldDaysToCancelNonPay:
		return m.AddedDaysToCancelNonPay()
	case productstore.FieldInventoryFacilityID:
		return m.AddedInventoryFacilityID()
	case productstore.FieldDefaultCurrencyUomID:
		return m.AddedDefaultCurrencyUomID()
	case productstore.FieldVisualThemeID:
		return m.AddedVisualThemeID()
	case productstore.FieldVatTaxAuthGeoID:
		return m.AddedVatTaxAuthGeoID()
	case productstore.FieldVatTaxAuthPartyID:
		return m.AddedVatTaxAuthPartyID()
	case productstore.FieldDigProdUploadCategoryID:
		return m.AddedDigProdUploadCategoryID()
	case productstore.FieldAutoOrderCcTryLaterMax:
		return m.AddedAutoOrderCcTryLaterMax()
	case productstore.FieldStoreCreditValidDays:
		return m.AddedStoreCreditValidDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductStoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productstore.FieldPayToPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayToPartyID(v)
		return nil
	case productstore.FieldDaysToCancelNonPay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDaysToCancelNonPay(v)
		return nil
	case productstore.FieldInventoryFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInventoryFacilityID(v)
		return nil
	case productstore.FieldDefaultCurrencyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultCurrencyUomID(v)
		return nil
	case productstore.FieldVisualThemeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVisualThemeID(v)
		return nil
	case productstore.FieldVatTaxAuthGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatTaxAuthGeoID(v)
		return nil
	case productstore.FieldVatTaxAuthPartyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVatTaxAuthPartyID(v)
		return nil
	case productstore.FieldDigProdUploadCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDigProdUploadCategoryID(v)
		return nil
	case productstore.FieldAutoOrderCcTryLaterMax:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAutoOrderCcTryLaterMax(v)
		return nil
	case productstore.FieldStoreCreditValidDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStoreCreditValidDays(v)
		return nil
	}
	return fmt.Errorf("unknown ProductStore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductStoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productstore.FieldStringRef) {
		fields = append(fields, productstore.FieldStringRef)
	}
	if m.FieldCleared(productstore.FieldStoreName) {
		fields = append(fields, productstore.FieldStoreName)
	}
	if m.FieldCleared(productstore.FieldCompanyName) {
		fields = append(fields, productstore.FieldCompanyName)
	}
	if m.FieldCleared(productstore.FieldTitle) {
		fields = append(fields, productstore.FieldTitle)
	}
	if m.FieldCleared(productstore.FieldSubtitle) {
		fields = append(fields, productstore.FieldSubtitle)
	}
	if m.FieldCleared(productstore.FieldPayToPartyID) {
		fields = append(fields, productstore.FieldPayToPartyID)
	}
	if m.FieldCleared(productstore.FieldDaysToCancelNonPay) {
		fields = append(fields, productstore.FieldDaysToCancelNonPay)
	}
	if m.FieldCleared(productstore.FieldManualAuthIsCapture) {
		fields = append(fields, productstore.FieldManualAuthIsCapture)
	}
	if m.FieldCleared(productstore.FieldProrateShipping) {
		fields = append(fields, productstore.FieldProrateShipping)
	}
	if m.FieldCleared(productstore.FieldProrateTaxes) {
		fields = append(fields, productstore.FieldProrateTaxes)
	}
	if m.FieldCleared(productstore.FieldViewCartOnAdd) {
		fields = append(fields, productstore.FieldViewCartOnAdd)
	}
	if m.FieldCleared(productstore.FieldAutoSaveCart) {
		fields = append(fields, productstore.FieldAutoSaveCart)
	}
	if m.FieldCleared(productstore.FieldAutoApproveReviews) {
		fields = append(fields, productstore.FieldAutoApproveReviews)
	}
	if m.FieldCleared(productstore.FieldIsDemoStore) {
		fields = append(fields, productstore.FieldIsDemoStore)
	}
	if m.FieldCleared(productstore.FieldIsImmediatelyFulfilled) {
		fields = append(fields, productstore.FieldIsImmediatelyFulfilled)
	}
	if m.FieldCleared(productstore.FieldInventoryFacilityID) {
		fields = append(fields, productstore.FieldInventoryFacilityID)
	}
	if m.FieldCleared(productstore.FieldOneInventoryFacility) {
		fields = append(fields, productstore.FieldOneInventoryFacility)
	}
	if m.FieldCleared(productstore.FieldCheckInventory) {
		fields = append(fields, productstore.FieldCheckInventory)
	}
	if m.FieldCleared(productstore.FieldReserveInventory) {
		fields = append(fields, productstore.FieldReserveInventory)
	}
	if m.FieldCleared(productstore.FieldRequireInventory) {
		fields = append(fields, productstore.FieldRequireInventory)
	}
	if m.FieldCleared(productstore.FieldBalanceResOnOrderCreation) {
		fields = append(fields, productstore.FieldBalanceResOnOrderCreation)
	}
	if m.FieldCleared(productstore.FieldOrderNumberPrefix) {
		fields = append(fields, productstore.FieldOrderNumberPrefix)
	}
	if m.FieldCleared(productstore.FieldDefaultLocaleString) {
		fields = append(fields, productstore.FieldDefaultLocaleString)
	}
	if m.FieldCleared(productstore.FieldDefaultCurrencyUomID) {
		fields = append(fields, productstore.FieldDefaultCurrencyUomID)
	}
	if m.FieldCleared(productstore.FieldDefaultTimeZoneString) {
		fields = append(fields, productstore.FieldDefaultTimeZoneString)
	}
	if m.FieldCleared(productstore.FieldAllowPassword) {
		fields = append(fields, productstore.FieldAllowPassword)
	}
	if m.FieldCleared(productstore.FieldDefaultPassword) {
		fields = append(fields, productstore.FieldDefaultPassword)
	}
	if m.FieldCleared(productstore.FieldExplodeOrderItems) {
		fields = append(fields, productstore.FieldExplodeOrderItems)
	}
	if m.FieldCleared(productstore.FieldCheckGcBalance) {
		fields = append(fields, productstore.FieldCheckGcBalance)
	}
	if m.FieldCleared(productstore.FieldRetryFailedAuths) {
		fields = append(fields, productstore.FieldRetryFailedAuths)
	}
	if m.FieldCleared(productstore.FieldAuthDeclinedMessage) {
		fields = append(fields, productstore.FieldAuthDeclinedMessage)
	}
	if m.FieldCleared(productstore.FieldAuthFraudMessage) {
		fields = append(fields, productstore.FieldAuthFraudMessage)
	}
	if m.FieldCleared(productstore.FieldAuthErrorMessage) {
		fields = append(fields, productstore.FieldAuthErrorMessage)
	}
	if m.FieldCleared(productstore.FieldVisualThemeID) {
		fields = append(fields, productstore.FieldVisualThemeID)
	}
	if m.FieldCleared(productstore.FieldUsePrimaryEmailUsername) {
		fields = append(fields, productstore.FieldUsePrimaryEmailUsername)
	}
	if m.FieldCleared(productstore.FieldRequireCustomerRole) {
		fields = append(fields, productstore.FieldRequireCustomerRole)
	}
	if m.FieldCleared(productstore.FieldAutoInvoiceDigitalItems) {
		fields = append(fields, productstore.FieldAutoInvoiceDigitalItems)
	}
	if m.FieldCleared(productstore.FieldReqShipAddrForDigItems) {
		fields = append(fields, productstore.FieldReqShipAddrForDigItems)
	}
	if m.FieldCleared(productstore.FieldShowCheckoutGiftOptions) {
		fields = append(fields, productstore.FieldShowCheckoutGiftOptions)
	}
	if m.FieldCleared(productstore.FieldSelectPaymentTypePerItem) {
		fields = append(fields, productstore.FieldSelectPaymentTypePerItem)
	}
	if m.FieldCleared(productstore.FieldShowPricesWithVatTax) {
		fields = append(fields, productstore.FieldShowPricesWithVatTax)
	}
	if m.FieldCleared(productstore.FieldShowTaxIsExempt) {
		fields = append(fields, productstore.FieldShowTaxIsExempt)
	}
	if m.FieldCleared(productstore.FieldVatTaxAuthGeoID) {
		fields = append(fields, productstore.FieldVatTaxAuthGeoID)
	}
	if m.FieldCleared(productstore.FieldVatTaxAuthPartyID) {
		fields = append(fields, productstore.FieldVatTaxAuthPartyID)
	}
	if m.FieldCleared(productstore.FieldEnableAutoSuggestionList) {
		fields = append(fields, productstore.FieldEnableAutoSuggestionList)
	}
	if m.FieldCleared(productstore.FieldEnableDigProdUpload) {
		fields = append(fields, productstore.FieldEnableDigProdUpload)
	}
	if m.FieldCleared(productstore.FieldProdSearchExcludeVariants) {
		fields = append(fields, productstore.FieldProdSearchExcludeVariants)
	}
	if m.FieldCleared(productstore.FieldDigProdUploadCategoryID) {
		fields = append(fields, productstore.FieldDigProdUploadCategoryID)
	}
	if m.FieldCleared(productstore.FieldAutoOrderCcTryExp) {
		fields = append(fields, productstore.FieldAutoOrderCcTryExp)
	}
	if m.FieldCleared(productstore.FieldAutoOrderCcTryOtherCards) {
		fields = append(fields, productstore.FieldAutoOrderCcTryOtherCards)
	}
	if m.FieldCleared(productstore.FieldAutoOrderCcTryLaterNsf) {
		fields = append(fields, productstore.FieldAutoOrderCcTryLaterNsf)
	}
	if m.FieldCleared(productstore.FieldAutoOrderCcTryLaterMax) {
		fields = append(fields, productstore.FieldAutoOrderCcTryLaterMax)
	}
	if m.FieldCleared(productstore.FieldStoreCreditValidDays) {
		fields = append(fields, productstore.FieldStoreCreditValidDays)
	}
	if m.FieldCleared(productstore.FieldAutoApproveInvoice) {
		fields = append(fields, productstore.FieldAutoApproveInvoice)
	}
	if m.FieldCleared(productstore.FieldAutoApproveOrder) {
		fields = append(fields, productstore.FieldAutoApproveOrder)
	}
	if m.FieldCleared(productstore.FieldShipIfCaptureFails) {
		fields = append(fields, productstore.FieldShipIfCaptureFails)
	}
	if m.FieldCleared(productstore.FieldSetOwnerUponIssuance) {
		fields = append(fields, productstore.FieldSetOwnerUponIssuance)
	}
	if m.FieldCleared(productstore.FieldReqReturnInventoryReceive) {
		fields = append(fields, productstore.FieldReqReturnInventoryReceive)
	}
	if m.FieldCleared(productstore.FieldAddToCartRemoveIncompat) {
		fields = append(fields, productstore.FieldAddToCartRemoveIncompat)
	}
	if m.FieldCleared(productstore.FieldAddToCartReplaceUpsell) {
		fields = append(fields, productstore.FieldAddToCartReplaceUpsell)
	}
	if m.FieldCleared(productstore.FieldSplitPayPrefPerShpGrp) {
		fields = append(fields, productstore.FieldSplitPayPrefPerShpGrp)
	}
	if m.FieldCleared(productstore.FieldManagedByLot) {
		fields = append(fields, productstore.FieldManagedByLot)
	}
	if m.FieldCleared(productstore.FieldShowOutOfStockProducts) {
		fields = append(fields, productstore.FieldShowOutOfStockProducts)
	}
	if m.FieldCleared(productstore.FieldOrderDecimalQuantity) {
		fields = append(fields, productstore.FieldOrderDecimalQuantity)
	}
	if m.FieldCleared(productstore.FieldAllowComment) {
		fields = append(fields, productstore.FieldAllowComment)
	}
	if m.FieldCleared(productstore.FieldAllocateInventory) {
		fields = append(fields, productstore.FieldAllocateInventory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductStoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductStoreMutation) ClearField(name string) error {
	switch name {
	case productstore.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productstore.FieldStoreName:
		m.ClearStoreName()
		return nil
	case productstore.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	case productstore.FieldTitle:
		m.ClearTitle()
		return nil
	case productstore.FieldSubtitle:
		m.ClearSubtitle()
		return nil
	case productstore.FieldPayToPartyID:
		m.ClearPayToPartyID()
		return nil
	case productstore.FieldDaysToCancelNonPay:
		m.ClearDaysToCancelNonPay()
		return nil
	case productstore.FieldManualAuthIsCapture:
		m.ClearManualAuthIsCapture()
		return nil
	case productstore.FieldProrateShipping:
		m.ClearProrateShipping()
		return nil
	case productstore.FieldProrateTaxes:
		m.ClearProrateTaxes()
		return nil
	case productstore.FieldViewCartOnAdd:
		m.ClearViewCartOnAdd()
		return nil
	case productstore.FieldAutoSaveCart:
		m.ClearAutoSaveCart()
		return nil
	case productstore.FieldAutoApproveReviews:
		m.ClearAutoApproveReviews()
		return nil
	case productstore.FieldIsDemoStore:
		m.ClearIsDemoStore()
		return nil
	case productstore.FieldIsImmediatelyFulfilled:
		m.ClearIsImmediatelyFulfilled()
		return nil
	case productstore.FieldInventoryFacilityID:
		m.ClearInventoryFacilityID()
		return nil
	case productstore.FieldOneInventoryFacility:
		m.ClearOneInventoryFacility()
		return nil
	case productstore.FieldCheckInventory:
		m.ClearCheckInventory()
		return nil
	case productstore.FieldReserveInventory:
		m.ClearReserveInventory()
		return nil
	case productstore.FieldRequireInventory:
		m.ClearRequireInventory()
		return nil
	case productstore.FieldBalanceResOnOrderCreation:
		m.ClearBalanceResOnOrderCreation()
		return nil
	case productstore.FieldOrderNumberPrefix:
		m.ClearOrderNumberPrefix()
		return nil
	case productstore.FieldDefaultLocaleString:
		m.ClearDefaultLocaleString()
		return nil
	case productstore.FieldDefaultCurrencyUomID:
		m.ClearDefaultCurrencyUomID()
		return nil
	case productstore.FieldDefaultTimeZoneString:
		m.ClearDefaultTimeZoneString()
		return nil
	case productstore.FieldAllowPassword:
		m.ClearAllowPassword()
		return nil
	case productstore.FieldDefaultPassword:
		m.ClearDefaultPassword()
		return nil
	case productstore.FieldExplodeOrderItems:
		m.ClearExplodeOrderItems()
		return nil
	case productstore.FieldCheckGcBalance:
		m.ClearCheckGcBalance()
		return nil
	case productstore.FieldRetryFailedAuths:
		m.ClearRetryFailedAuths()
		return nil
	case productstore.FieldAuthDeclinedMessage:
		m.ClearAuthDeclinedMessage()
		return nil
	case productstore.FieldAuthFraudMessage:
		m.ClearAuthFraudMessage()
		return nil
	case productstore.FieldAuthErrorMessage:
		m.ClearAuthErrorMessage()
		return nil
	case productstore.FieldVisualThemeID:
		m.ClearVisualThemeID()
		return nil
	case productstore.FieldUsePrimaryEmailUsername:
		m.ClearUsePrimaryEmailUsername()
		return nil
	case productstore.FieldRequireCustomerRole:
		m.ClearRequireCustomerRole()
		return nil
	case productstore.FieldAutoInvoiceDigitalItems:
		m.ClearAutoInvoiceDigitalItems()
		return nil
	case productstore.FieldReqShipAddrForDigItems:
		m.ClearReqShipAddrForDigItems()
		return nil
	case productstore.FieldShowCheckoutGiftOptions:
		m.ClearShowCheckoutGiftOptions()
		return nil
	case productstore.FieldSelectPaymentTypePerItem:
		m.ClearSelectPaymentTypePerItem()
		return nil
	case productstore.FieldShowPricesWithVatTax:
		m.ClearShowPricesWithVatTax()
		return nil
	case productstore.FieldShowTaxIsExempt:
		m.ClearShowTaxIsExempt()
		return nil
	case productstore.FieldVatTaxAuthGeoID:
		m.ClearVatTaxAuthGeoID()
		return nil
	case productstore.FieldVatTaxAuthPartyID:
		m.ClearVatTaxAuthPartyID()
		return nil
	case productstore.FieldEnableAutoSuggestionList:
		m.ClearEnableAutoSuggestionList()
		return nil
	case productstore.FieldEnableDigProdUpload:
		m.ClearEnableDigProdUpload()
		return nil
	case productstore.FieldProdSearchExcludeVariants:
		m.ClearProdSearchExcludeVariants()
		return nil
	case productstore.FieldDigProdUploadCategoryID:
		m.ClearDigProdUploadCategoryID()
		return nil
	case productstore.FieldAutoOrderCcTryExp:
		m.ClearAutoOrderCcTryExp()
		return nil
	case productstore.FieldAutoOrderCcTryOtherCards:
		m.ClearAutoOrderCcTryOtherCards()
		return nil
	case productstore.FieldAutoOrderCcTryLaterNsf:
		m.ClearAutoOrderCcTryLaterNsf()
		return nil
	case productstore.FieldAutoOrderCcTryLaterMax:
		m.ClearAutoOrderCcTryLaterMax()
		return nil
	case productstore.FieldStoreCreditValidDays:
		m.ClearStoreCreditValidDays()
		return nil
	case productstore.FieldAutoApproveInvoice:
		m.ClearAutoApproveInvoice()
		return nil
	case productstore.FieldAutoApproveOrder:
		m.ClearAutoApproveOrder()
		return nil
	case productstore.FieldShipIfCaptureFails:
		m.ClearShipIfCaptureFails()
		return nil
	case productstore.FieldSetOwnerUponIssuance:
		m.ClearSetOwnerUponIssuance()
		return nil
	case productstore.FieldReqReturnInventoryReceive:
		m.ClearReqReturnInventoryReceive()
		return nil
	case productstore.FieldAddToCartRemoveIncompat:
		m.ClearAddToCartRemoveIncompat()
		return nil
	case productstore.FieldAddToCartReplaceUpsell:
		m.ClearAddToCartReplaceUpsell()
		return nil
	case productstore.FieldSplitPayPrefPerShpGrp:
		m.ClearSplitPayPrefPerShpGrp()
		return nil
	case productstore.FieldManagedByLot:
		m.ClearManagedByLot()
		return nil
	case productstore.FieldShowOutOfStockProducts:
		m.ClearShowOutOfStockProducts()
		return nil
	case productstore.FieldOrderDecimalQuantity:
		m.ClearOrderDecimalQuantity()
		return nil
	case productstore.FieldAllowComment:
		m.ClearAllowComment()
		return nil
	case productstore.FieldAllocateInventory:
		m.ClearAllocateInventory()
		return nil
	}
	return fmt.Errorf("unknown ProductStore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductStoreMutation) ResetField(name string) error {
	switch name {
	case productstore.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productstore.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productstore.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productstore.FieldStoreName:
		m.ResetStoreName()
		return nil
	case productstore.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case productstore.FieldTitle:
		m.ResetTitle()
		return nil
	case productstore.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case productstore.FieldPayToPartyID:
		m.ResetPayToPartyID()
		return nil
	case productstore.FieldDaysToCancelNonPay:
		m.ResetDaysToCancelNonPay()
		return nil
	case productstore.FieldManualAuthIsCapture:
		m.ResetManualAuthIsCapture()
		return nil
	case productstore.FieldProrateShipping:
		m.ResetProrateShipping()
		return nil
	case productstore.FieldProrateTaxes:
		m.ResetProrateTaxes()
		return nil
	case productstore.FieldViewCartOnAdd:
		m.ResetViewCartOnAdd()
		return nil
	case productstore.FieldAutoSaveCart:
		m.ResetAutoSaveCart()
		return nil
	case productstore.FieldAutoApproveReviews:
		m.ResetAutoApproveReviews()
		return nil
	case productstore.FieldIsDemoStore:
		m.ResetIsDemoStore()
		return nil
	case productstore.FieldIsImmediatelyFulfilled:
		m.ResetIsImmediatelyFulfilled()
		return nil
	case productstore.FieldInventoryFacilityID:
		m.ResetInventoryFacilityID()
		return nil
	case productstore.FieldOneInventoryFacility:
		m.ResetOneInventoryFacility()
		return nil
	case productstore.FieldCheckInventory:
		m.ResetCheckInventory()
		return nil
	case productstore.FieldReserveInventory:
		m.ResetReserveInventory()
		return nil
	case productstore.FieldRequireInventory:
		m.ResetRequireInventory()
		return nil
	case productstore.FieldBalanceResOnOrderCreation:
		m.ResetBalanceResOnOrderCreation()
		return nil
	case productstore.FieldOrderNumberPrefix:
		m.ResetOrderNumberPrefix()
		return nil
	case productstore.FieldDefaultLocaleString:
		m.ResetDefaultLocaleString()
		return nil
	case productstore.FieldDefaultCurrencyUomID:
		m.ResetDefaultCurrencyUomID()
		return nil
	case productstore.FieldDefaultTimeZoneString:
		m.ResetDefaultTimeZoneString()
		return nil
	case productstore.FieldAllowPassword:
		m.ResetAllowPassword()
		return nil
	case productstore.FieldDefaultPassword:
		m.ResetDefaultPassword()
		return nil
	case productstore.FieldExplodeOrderItems:
		m.ResetExplodeOrderItems()
		return nil
	case productstore.FieldCheckGcBalance:
		m.ResetCheckGcBalance()
		return nil
	case productstore.FieldRetryFailedAuths:
		m.ResetRetryFailedAuths()
		return nil
	case productstore.FieldAuthDeclinedMessage:
		m.ResetAuthDeclinedMessage()
		return nil
	case productstore.FieldAuthFraudMessage:
		m.ResetAuthFraudMessage()
		return nil
	case productstore.FieldAuthErrorMessage:
		m.ResetAuthErrorMessage()
		return nil
	case productstore.FieldVisualThemeID:
		m.ResetVisualThemeID()
		return nil
	case productstore.FieldUsePrimaryEmailUsername:
		m.ResetUsePrimaryEmailUsername()
		return nil
	case productstore.FieldRequireCustomerRole:
		m.ResetRequireCustomerRole()
		return nil
	case productstore.FieldAutoInvoiceDigitalItems:
		m.ResetAutoInvoiceDigitalItems()
		return nil
	case productstore.FieldReqShipAddrForDigItems:
		m.ResetReqShipAddrForDigItems()
		return nil
	case productstore.FieldShowCheckoutGiftOptions:
		m.ResetShowCheckoutGiftOptions()
		return nil
	case productstore.FieldSelectPaymentTypePerItem:
		m.ResetSelectPaymentTypePerItem()
		return nil
	case productstore.FieldShowPricesWithVatTax:
		m.ResetShowPricesWithVatTax()
		return nil
	case productstore.FieldShowTaxIsExempt:
		m.ResetShowTaxIsExempt()
		return nil
	case productstore.FieldVatTaxAuthGeoID:
		m.ResetVatTaxAuthGeoID()
		return nil
	case productstore.FieldVatTaxAuthPartyID:
		m.ResetVatTaxAuthPartyID()
		return nil
	case productstore.FieldEnableAutoSuggestionList:
		m.ResetEnableAutoSuggestionList()
		return nil
	case productstore.FieldEnableDigProdUpload:
		m.ResetEnableDigProdUpload()
		return nil
	case productstore.FieldProdSearchExcludeVariants:
		m.ResetProdSearchExcludeVariants()
		return nil
	case productstore.FieldDigProdUploadCategoryID:
		m.ResetDigProdUploadCategoryID()
		return nil
	case productstore.FieldAutoOrderCcTryExp:
		m.ResetAutoOrderCcTryExp()
		return nil
	case productstore.FieldAutoOrderCcTryOtherCards:
		m.ResetAutoOrderCcTryOtherCards()
		return nil
	case productstore.FieldAutoOrderCcTryLaterNsf:
		m.ResetAutoOrderCcTryLaterNsf()
		return nil
	case productstore.FieldAutoOrderCcTryLaterMax:
		m.ResetAutoOrderCcTryLaterMax()
		return nil
	case productstore.FieldStoreCreditValidDays:
		m.ResetStoreCreditValidDays()
		return nil
	case productstore.FieldAutoApproveInvoice:
		m.ResetAutoApproveInvoice()
		return nil
	case productstore.FieldAutoApproveOrder:
		m.ResetAutoApproveOrder()
		return nil
	case productstore.FieldShipIfCaptureFails:
		m.ResetShipIfCaptureFails()
		return nil
	case productstore.FieldSetOwnerUponIssuance:
		m.ResetSetOwnerUponIssuance()
		return nil
	case productstore.FieldReqReturnInventoryReceive:
		m.ResetReqReturnInventoryReceive()
		return nil
	case productstore.FieldAddToCartRemoveIncompat:
		m.ResetAddToCartRemoveIncompat()
		return nil
	case productstore.FieldAddToCartReplaceUpsell:
		m.ResetAddToCartReplaceUpsell()
		return nil
	case productstore.FieldSplitPayPrefPerShpGrp:
		m.ResetSplitPayPrefPerShpGrp()
		return nil
	case productstore.FieldManagedByLot:
		m.ResetManagedByLot()
		return nil
	case productstore.FieldShowOutOfStockProducts:
		m.ResetShowOutOfStockProducts()
		return nil
	case productstore.FieldOrderDecimalQuantity:
		m.ResetOrderDecimalQuantity()
		return nil
	case productstore.FieldAllowComment:
		m.ResetAllowComment()
		return nil
	case productstore.FieldAllocateInventory:
		m.ResetAllocateInventory()
		return nil
	}
	return fmt.Errorf("unknown ProductStore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductStoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.primary_product_store_group != nil {
		edges = append(edges, productstore.EdgePrimaryProductStoreGroup)
	}
	if m.reserve_order_enumeration != nil {
		edges = append(edges, productstore.EdgeReserveOrderEnumeration)
	}
	if m.requirement_method_enumeration != nil {
		edges = append(edges, productstore.EdgeRequirementMethodEnumeration)
	}
	if m.default_sales_channel_enumeration != nil {
		edges = append(edges, productstore.EdgeDefaultSalesChannelEnumeration)
	}
	if m.header_approved_status_item != nil {
		edges = append(edges, productstore.EdgeHeaderApprovedStatusItem)
	}
	if m.item_approved_status_item != nil {
		edges = append(edges, productstore.EdgeItemApprovedStatusItem)
	}
	if m.digital_item_approved_status_item != nil {
		edges = append(edges, productstore.EdgeDigitalItemApprovedStatusItem)
	}
	if m.header_declined_status_item != nil {
		edges = append(edges, productstore.EdgeHeaderDeclinedStatusItem)
	}
	if m.item_declined_status_item != nil {
		edges = append(edges, productstore.EdgeItemDeclinedStatusItem)
	}
	if m.header_cancel_status_item != nil {
		edges = append(edges, productstore.EdgeHeaderCancelStatusItem)
	}
	if m.item_cancel_status_item != nil {
		edges = append(edges, productstore.EdgeItemCancelStatusItem)
	}
	if m.store_credit_account_enumeration != nil {
		edges = append(edges, productstore.EdgeStoreCreditAccountEnumeration)
	}
	if m.order_headers != nil {
		edges = append(edges, productstore.EdgeOrderHeaders)
	}
	if m.product_reviews != nil {
		edges = append(edges, productstore.EdgeProductReviews)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductStoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productstore.EdgePrimaryProductStoreGroup:
		if id := m.primary_product_store_group; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeReserveOrderEnumeration:
		if id := m.reserve_order_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeRequirementMethodEnumeration:
		if id := m.requirement_method_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeDefaultSalesChannelEnumeration:
		if id := m.default_sales_channel_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeHeaderApprovedStatusItem:
		if id := m.header_approved_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeItemApprovedStatusItem:
		if id := m.item_approved_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeDigitalItemApprovedStatusItem:
		if id := m.digital_item_approved_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeHeaderDeclinedStatusItem:
		if id := m.header_declined_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeItemDeclinedStatusItem:
		if id := m.item_declined_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeHeaderCancelStatusItem:
		if id := m.header_cancel_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeItemCancelStatusItem:
		if id := m.item_cancel_status_item; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeStoreCreditAccountEnumeration:
		if id := m.store_credit_account_enumeration; id != nil {
			return []ent.Value{*id}
		}
	case productstore.EdgeOrderHeaders:
		ids := make([]ent.Value, 0, len(m.order_headers))
		for id := range m.order_headers {
			ids = append(ids, id)
		}
		return ids
	case productstore.EdgeProductReviews:
		ids := make([]ent.Value, 0, len(m.product_reviews))
		for id := range m.product_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductStoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedorder_headers != nil {
		edges = append(edges, productstore.EdgeOrderHeaders)
	}
	if m.removedproduct_reviews != nil {
		edges = append(edges, productstore.EdgeProductReviews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductStoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productstore.EdgeOrderHeaders:
		ids := make([]ent.Value, 0, len(m.removedorder_headers))
		for id := range m.removedorder_headers {
			ids = append(ids, id)
		}
		return ids
	case productstore.EdgeProductReviews:
		ids := make([]ent.Value, 0, len(m.removedproduct_reviews))
		for id := range m.removedproduct_reviews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductStoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedprimary_product_store_group {
		edges = append(edges, productstore.EdgePrimaryProductStoreGroup)
	}
	if m.clearedreserve_order_enumeration {
		edges = append(edges, productstore.EdgeReserveOrderEnumeration)
	}
	if m.clearedrequirement_method_enumeration {
		edges = append(edges, productstore.EdgeRequirementMethodEnumeration)
	}
	if m.cleareddefault_sales_channel_enumeration {
		edges = append(edges, productstore.EdgeDefaultSalesChannelEnumeration)
	}
	if m.clearedheader_approved_status_item {
		edges = append(edges, productstore.EdgeHeaderApprovedStatusItem)
	}
	if m.cleareditem_approved_status_item {
		edges = append(edges, productstore.EdgeItemApprovedStatusItem)
	}
	if m.cleareddigital_item_approved_status_item {
		edges = append(edges, productstore.EdgeDigitalItemApprovedStatusItem)
	}
	if m.clearedheader_declined_status_item {
		edges = append(edges, productstore.EdgeHeaderDeclinedStatusItem)
	}
	if m.cleareditem_declined_status_item {
		edges = append(edges, productstore.EdgeItemDeclinedStatusItem)
	}
	if m.clearedheader_cancel_status_item {
		edges = append(edges, productstore.EdgeHeaderCancelStatusItem)
	}
	if m.cleareditem_cancel_status_item {
		edges = append(edges, productstore.EdgeItemCancelStatusItem)
	}
	if m.clearedstore_credit_account_enumeration {
		edges = append(edges, productstore.EdgeStoreCreditAccountEnumeration)
	}
	if m.clearedorder_headers {
		edges = append(edges, productstore.EdgeOrderHeaders)
	}
	if m.clearedproduct_reviews {
		edges = append(edges, productstore.EdgeProductReviews)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductStoreMutation) EdgeCleared(name string) bool {
	switch name {
	case productstore.EdgePrimaryProductStoreGroup:
		return m.clearedprimary_product_store_group
	case productstore.EdgeReserveOrderEnumeration:
		return m.clearedreserve_order_enumeration
	case productstore.EdgeRequirementMethodEnumeration:
		return m.clearedrequirement_method_enumeration
	case productstore.EdgeDefaultSalesChannelEnumeration:
		return m.cleareddefault_sales_channel_enumeration
	case productstore.EdgeHeaderApprovedStatusItem:
		return m.clearedheader_approved_status_item
	case productstore.EdgeItemApprovedStatusItem:
		return m.cleareditem_approved_status_item
	case productstore.EdgeDigitalItemApprovedStatusItem:
		return m.cleareddigital_item_approved_status_item
	case productstore.EdgeHeaderDeclinedStatusItem:
		return m.clearedheader_declined_status_item
	case productstore.EdgeItemDeclinedStatusItem:
		return m.cleareditem_declined_status_item
	case productstore.EdgeHeaderCancelStatusItem:
		return m.clearedheader_cancel_status_item
	case productstore.EdgeItemCancelStatusItem:
		return m.cleareditem_cancel_status_item
	case productstore.EdgeStoreCreditAccountEnumeration:
		return m.clearedstore_credit_account_enumeration
	case productstore.EdgeOrderHeaders:
		return m.clearedorder_headers
	case productstore.EdgeProductReviews:
		return m.clearedproduct_reviews
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductStoreMutation) ClearEdge(name string) error {
	switch name {
	case productstore.EdgePrimaryProductStoreGroup:
		m.ClearPrimaryProductStoreGroup()
		return nil
	case productstore.EdgeReserveOrderEnumeration:
		m.ClearReserveOrderEnumeration()
		return nil
	case productstore.EdgeRequirementMethodEnumeration:
		m.ClearRequirementMethodEnumeration()
		return nil
	case productstore.EdgeDefaultSalesChannelEnumeration:
		m.ClearDefaultSalesChannelEnumeration()
		return nil
	case productstore.EdgeHeaderApprovedStatusItem:
		m.ClearHeaderApprovedStatusItem()
		return nil
	case productstore.EdgeItemApprovedStatusItem:
		m.ClearItemApprovedStatusItem()
		return nil
	case productstore.EdgeDigitalItemApprovedStatusItem:
		m.ClearDigitalItemApprovedStatusItem()
		return nil
	case productstore.EdgeHeaderDeclinedStatusItem:
		m.ClearHeaderDeclinedStatusItem()
		return nil
	case productstore.EdgeItemDeclinedStatusItem:
		m.ClearItemDeclinedStatusItem()
		return nil
	case productstore.EdgeHeaderCancelStatusItem:
		m.ClearHeaderCancelStatusItem()
		return nil
	case productstore.EdgeItemCancelStatusItem:
		m.ClearItemCancelStatusItem()
		return nil
	case productstore.EdgeStoreCreditAccountEnumeration:
		m.ClearStoreCreditAccountEnumeration()
		return nil
	}
	return fmt.Errorf("unknown ProductStore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductStoreMutation) ResetEdge(name string) error {
	switch name {
	case productstore.EdgePrimaryProductStoreGroup:
		m.ResetPrimaryProductStoreGroup()
		return nil
	case productstore.EdgeReserveOrderEnumeration:
		m.ResetReserveOrderEnumeration()
		return nil
	case productstore.EdgeRequirementMethodEnumeration:
		m.ResetRequirementMethodEnumeration()
		return nil
	case productstore.EdgeDefaultSalesChannelEnumeration:
		m.ResetDefaultSalesChannelEnumeration()
		return nil
	case productstore.EdgeHeaderApprovedStatusItem:
		m.ResetHeaderApprovedStatusItem()
		return nil
	case productstore.EdgeItemApprovedStatusItem:
		m.ResetItemApprovedStatusItem()
		return nil
	case productstore.EdgeDigitalItemApprovedStatusItem:
		m.ResetDigitalItemApprovedStatusItem()
		return nil
	case productstore.EdgeHeaderDeclinedStatusItem:
		m.ResetHeaderDeclinedStatusItem()
		return nil
	case productstore.EdgeItemDeclinedStatusItem:
		m.ResetItemDeclinedStatusItem()
		return nil
	case productstore.EdgeHeaderCancelStatusItem:
		m.ResetHeaderCancelStatusItem()
		return nil
	case productstore.EdgeItemCancelStatusItem:
		m.ResetItemCancelStatusItem()
		return nil
	case productstore.EdgeStoreCreditAccountEnumeration:
		m.ResetStoreCreditAccountEnumeration()
		return nil
	case productstore.EdgeOrderHeaders:
		m.ResetOrderHeaders()
		return nil
	case productstore.EdgeProductReviews:
		m.ResetProductReviews()
		return nil
	}
	return fmt.Errorf("unknown ProductStore edge %s", name)
}

// ProductStoreGroupMutation represents an operation that mutates the ProductStoreGroup nodes in the graph.
type ProductStoreGroupMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	create_time                    *time.Time
	update_time                    *time.Time
	string_ref                     *string
	product_store_group_type_id    *int
	addproduct_store_group_type_id *int
	product_store_group_name       *string
	description                    *string
	clearedFields                  map[string]struct{}
	parent                         *int
	clearedparent                  bool
	children                       map[int]struct{}
	removedchildren                map[int]struct{}
	clearedchildren                bool
	product_prices                 map[int]struct{}
	removedproduct_prices          map[int]struct{}
	clearedproduct_prices          bool
	primary_product_stores         map[int]struct{}
	removedprimary_product_stores  map[int]struct{}
	clearedprimary_product_stores  bool
	done                           bool
	oldValue                       func(context.Context) (*ProductStoreGroup, error)
	predicates                     []predicate.ProductStoreGroup
}

var _ ent.Mutation = (*ProductStoreGroupMutation)(nil)

// productstoregroupOption allows management of the mutation configuration using functional options.
type productstoregroupOption func(*ProductStoreGroupMutation)

// newProductStoreGroupMutation creates new mutation for the ProductStoreGroup entity.
func newProductStoreGroupMutation(c config, op Op, opts ...productstoregroupOption) *ProductStoreGroupMutation {
	m := &ProductStoreGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeProductStoreGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductStoreGroupID sets the ID field of the mutation.
func withProductStoreGroupID(id int) productstoregroupOption {
	return func(m *ProductStoreGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductStoreGroup
		)
		m.oldValue = func(ctx context.Context) (*ProductStoreGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductStoreGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductStoreGroup sets the old ProductStoreGroup of the mutation.
func withProductStoreGroup(node *ProductStoreGroup) productstoregroupOption {
	return func(m *ProductStoreGroupMutation) {
		m.oldValue = func(context.Context) (*ProductStoreGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductStoreGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductStoreGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductStoreGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductStoreGroupMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductStoreGroupMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductStoreGroup entity.
// If the ProductStoreGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreGroupMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductStoreGroupMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductStoreGroupMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductStoreGroupMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductStoreGroup entity.
// If the ProductStoreGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreGroupMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductStoreGroupMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductStoreGroupMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductStoreGroupMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductStoreGroup entity.
// If the ProductStoreGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreGroupMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductStoreGroupMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[productstoregroup.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductStoreGroupMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[productstoregroup.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductStoreGroupMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, productstoregroup.FieldStringRef)
}

// SetProductStoreGroupTypeID sets the "product_store_group_type_id" field.
func (m *ProductStoreGroupMutation) SetProductStoreGroupTypeID(i int) {
	m.product_store_group_type_id = &i
	m.addproduct_store_group_type_id = nil
}

// ProductStoreGroupTypeID returns the value of the "product_store_group_type_id" field in the mutation.
func (m *ProductStoreGroupMutation) ProductStoreGroupTypeID() (r int, exists bool) {
	v := m.product_store_group_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductStoreGroupTypeID returns the old "product_store_group_type_id" field's value of the ProductStoreGroup entity.
// If the ProductStoreGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreGroupMutation) OldProductStoreGroupTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductStoreGroupTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductStoreGroupTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductStoreGroupTypeID: %w", err)
	}
	return oldValue.ProductStoreGroupTypeID, nil
}

// AddProductStoreGroupTypeID adds i to the "product_store_group_type_id" field.
func (m *ProductStoreGroupMutation) AddProductStoreGroupTypeID(i int) {
	if m.addproduct_store_group_type_id != nil {
		*m.addproduct_store_group_type_id += i
	} else {
		m.addproduct_store_group_type_id = &i
	}
}

// AddedProductStoreGroupTypeID returns the value that was added to the "product_store_group_type_id" field in this mutation.
func (m *ProductStoreGroupMutation) AddedProductStoreGroupTypeID() (r int, exists bool) {
	v := m.addproduct_store_group_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductStoreGroupTypeID clears the value of the "product_store_group_type_id" field.
func (m *ProductStoreGroupMutation) ClearProductStoreGroupTypeID() {
	m.product_store_group_type_id = nil
	m.addproduct_store_group_type_id = nil
	m.clearedFields[productstoregroup.FieldProductStoreGroupTypeID] = struct{}{}
}

// ProductStoreGroupTypeIDCleared returns if the "product_store_group_type_id" field was cleared in this mutation.
func (m *ProductStoreGroupMutation) ProductStoreGroupTypeIDCleared() bool {
	_, ok := m.clearedFields[productstoregroup.FieldProductStoreGroupTypeID]
	return ok
}

// ResetProductStoreGroupTypeID resets all changes to the "product_store_group_type_id" field.
func (m *ProductStoreGroupMutation) ResetProductStoreGroupTypeID() {
	m.product_store_group_type_id = nil
	m.addproduct_store_group_type_id = nil
	delete(m.clearedFields, productstoregroup.FieldProductStoreGroupTypeID)
}

// SetProductStoreGroupName sets the "product_store_group_name" field.
func (m *ProductStoreGroupMutation) SetProductStoreGroupName(s string) {
	m.product_store_group_name = &s
}

// ProductStoreGroupName returns the value of the "product_store_group_name" field in the mutation.
func (m *ProductStoreGroupMutation) ProductStoreGroupName() (r string, exists bool) {
	v := m.product_store_group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductStoreGroupName returns the old "product_store_group_name" field's value of the ProductStoreGroup entity.
// If the ProductStoreGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreGroupMutation) OldProductStoreGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductStoreGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductStoreGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductStoreGroupName: %w", err)
	}
	return oldValue.ProductStoreGroupName, nil
}

// ClearProductStoreGroupName clears the value of the "product_store_group_name" field.
func (m *ProductStoreGroupMutation) ClearProductStoreGroupName() {
	m.product_store_group_name = nil
	m.clearedFields[productstoregroup.FieldProductStoreGroupName] = struct{}{}
}

// ProductStoreGroupNameCleared returns if the "product_store_group_name" field was cleared in this mutation.
func (m *ProductStoreGroupMutation) ProductStoreGroupNameCleared() bool {
	_, ok := m.clearedFields[productstoregroup.FieldProductStoreGroupName]
	return ok
}

// ResetProductStoreGroupName resets all changes to the "product_store_group_name" field.
func (m *ProductStoreGroupMutation) ResetProductStoreGroupName() {
	m.product_store_group_name = nil
	delete(m.clearedFields, productstoregroup.FieldProductStoreGroupName)
}

// SetDescription sets the "description" field.
func (m *ProductStoreGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductStoreGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductStoreGroup entity.
// If the ProductStoreGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductStoreGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductStoreGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productstoregroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductStoreGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productstoregroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductStoreGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productstoregroup.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductStoreGroup entity by id.
func (m *ProductStoreGroupMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductStoreGroup entity.
func (m *ProductStoreGroupMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductStoreGroup entity was cleared.
func (m *ProductStoreGroupMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductStoreGroupMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductStoreGroupMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductStoreGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductStoreGroup entity by ids.
func (m *ProductStoreGroupMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductStoreGroup entity.
func (m *ProductStoreGroupMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductStoreGroup entity was cleared.
func (m *ProductStoreGroupMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductStoreGroup entity by IDs.
func (m *ProductStoreGroupMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductStoreGroup entity.
func (m *ProductStoreGroupMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductStoreGroupMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductStoreGroupMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductPriceIDs adds the "product_prices" edge to the ProductPrice entity by ids.
func (m *ProductStoreGroupMutation) AddProductPriceIDs(ids ...int) {
	if m.product_prices == nil {
		m.product_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.product_prices[ids[i]] = struct{}{}
	}
}

// ClearProductPrices clears the "product_prices" edge to the ProductPrice entity.
func (m *ProductStoreGroupMutation) ClearProductPrices() {
	m.clearedproduct_prices = true
}

// ProductPricesCleared reports if the "product_prices" edge to the ProductPrice entity was cleared.
func (m *ProductStoreGroupMutation) ProductPricesCleared() bool {
	return m.clearedproduct_prices
}

// RemoveProductPriceIDs removes the "product_prices" edge to the ProductPrice entity by IDs.
func (m *ProductStoreGroupMutation) RemoveProductPriceIDs(ids ...int) {
	if m.removedproduct_prices == nil {
		m.removedproduct_prices = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_prices[ids[i]] = struct{}{}
	}
}

// RemovedProductPrices returns the removed IDs of the "product_prices" edge to the ProductPrice entity.
func (m *ProductStoreGroupMutation) RemovedProductPricesIDs() (ids []int) {
	for id := range m.removedproduct_prices {
		ids = append(ids, id)
	}
	return
}

// ProductPricesIDs returns the "product_prices" edge IDs in the mutation.
func (m *ProductStoreGroupMutation) ProductPricesIDs() (ids []int) {
	for id := range m.product_prices {
		ids = append(ids, id)
	}
	return
}

// ResetProductPrices resets all changes to the "product_prices" edge.
func (m *ProductStoreGroupMutation) ResetProductPrices() {
	m.product_prices = nil
	m.clearedproduct_prices = false
	m.removedproduct_prices = nil
}

// AddPrimaryProductStoreIDs adds the "primary_product_stores" edge to the ProductStore entity by ids.
func (m *ProductStoreGroupMutation) AddPrimaryProductStoreIDs(ids ...int) {
	if m.primary_product_stores == nil {
		m.primary_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.primary_product_stores[ids[i]] = struct{}{}
	}
}

// ClearPrimaryProductStores clears the "primary_product_stores" edge to the ProductStore entity.
func (m *ProductStoreGroupMutation) ClearPrimaryProductStores() {
	m.clearedprimary_product_stores = true
}

// PrimaryProductStoresCleared reports if the "primary_product_stores" edge to the ProductStore entity was cleared.
func (m *ProductStoreGroupMutation) PrimaryProductStoresCleared() bool {
	return m.clearedprimary_product_stores
}

// RemovePrimaryProductStoreIDs removes the "primary_product_stores" edge to the ProductStore entity by IDs.
func (m *ProductStoreGroupMutation) RemovePrimaryProductStoreIDs(ids ...int) {
	if m.removedprimary_product_stores == nil {
		m.removedprimary_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedprimary_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedPrimaryProductStores returns the removed IDs of the "primary_product_stores" edge to the ProductStore entity.
func (m *ProductStoreGroupMutation) RemovedPrimaryProductStoresIDs() (ids []int) {
	for id := range m.removedprimary_product_stores {
		ids = append(ids, id)
	}
	return
}

// PrimaryProductStoresIDs returns the "primary_product_stores" edge IDs in the mutation.
func (m *ProductStoreGroupMutation) PrimaryProductStoresIDs() (ids []int) {
	for id := range m.primary_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetPrimaryProductStores resets all changes to the "primary_product_stores" edge.
func (m *ProductStoreGroupMutation) ResetPrimaryProductStores() {
	m.primary_product_stores = nil
	m.clearedprimary_product_stores = false
	m.removedprimary_product_stores = nil
}

// Op returns the operation name.
func (m *ProductStoreGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductStoreGroup).
func (m *ProductStoreGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductStoreGroupMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, productstoregroup.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, productstoregroup.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, productstoregroup.FieldStringRef)
	}
	if m.product_store_group_type_id != nil {
		fields = append(fields, productstoregroup.FieldProductStoreGroupTypeID)
	}
	if m.product_store_group_name != nil {
		fields = append(fields, productstoregroup.FieldProductStoreGroupName)
	}
	if m.description != nil {
		fields = append(fields, productstoregroup.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductStoreGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productstoregroup.FieldCreateTime:
		return m.CreateTime()
	case productstoregroup.FieldUpdateTime:
		return m.UpdateTime()
	case productstoregroup.FieldStringRef:
		return m.StringRef()
	case productstoregroup.FieldProductStoreGroupTypeID:
		return m.ProductStoreGroupTypeID()
	case productstoregroup.FieldProductStoreGroupName:
		return m.ProductStoreGroupName()
	case productstoregroup.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductStoreGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productstoregroup.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case productstoregroup.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case productstoregroup.FieldStringRef:
		return m.OldStringRef(ctx)
	case productstoregroup.FieldProductStoreGroupTypeID:
		return m.OldProductStoreGroupTypeID(ctx)
	case productstoregroup.FieldProductStoreGroupName:
		return m.OldProductStoreGroupName(ctx)
	case productstoregroup.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductStoreGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductStoreGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productstoregroup.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case productstoregroup.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case productstoregroup.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case productstoregroup.FieldProductStoreGroupTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductStoreGroupTypeID(v)
		return nil
	case productstoregroup.FieldProductStoreGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductStoreGroupName(v)
		return nil
	case productstoregroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductStoreGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductStoreGroupMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_store_group_type_id != nil {
		fields = append(fields, productstoregroup.FieldProductStoreGroupTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductStoreGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productstoregroup.FieldProductStoreGroupTypeID:
		return m.AddedProductStoreGroupTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductStoreGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productstoregroup.FieldProductStoreGroupTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductStoreGroupTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductStoreGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductStoreGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productstoregroup.FieldStringRef) {
		fields = append(fields, productstoregroup.FieldStringRef)
	}
	if m.FieldCleared(productstoregroup.FieldProductStoreGroupTypeID) {
		fields = append(fields, productstoregroup.FieldProductStoreGroupTypeID)
	}
	if m.FieldCleared(productstoregroup.FieldProductStoreGroupName) {
		fields = append(fields, productstoregroup.FieldProductStoreGroupName)
	}
	if m.FieldCleared(productstoregroup.FieldDescription) {
		fields = append(fields, productstoregroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductStoreGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductStoreGroupMutation) ClearField(name string) error {
	switch name {
	case productstoregroup.FieldStringRef:
		m.ClearStringRef()
		return nil
	case productstoregroup.FieldProductStoreGroupTypeID:
		m.ClearProductStoreGroupTypeID()
		return nil
	case productstoregroup.FieldProductStoreGroupName:
		m.ClearProductStoreGroupName()
		return nil
	case productstoregroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductStoreGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductStoreGroupMutation) ResetField(name string) error {
	switch name {
	case productstoregroup.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case productstoregroup.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case productstoregroup.FieldStringRef:
		m.ResetStringRef()
		return nil
	case productstoregroup.FieldProductStoreGroupTypeID:
		m.ResetProductStoreGroupTypeID()
		return nil
	case productstoregroup.FieldProductStoreGroupName:
		m.ResetProductStoreGroupName()
		return nil
	case productstoregroup.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductStoreGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductStoreGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, productstoregroup.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, productstoregroup.EdgeChildren)
	}
	if m.product_prices != nil {
		edges = append(edges, productstoregroup.EdgeProductPrices)
	}
	if m.primary_product_stores != nil {
		edges = append(edges, productstoregroup.EdgePrimaryProductStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductStoreGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productstoregroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case productstoregroup.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case productstoregroup.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.product_prices))
		for id := range m.product_prices {
			ids = append(ids, id)
		}
		return ids
	case productstoregroup.EdgePrimaryProductStores:
		ids := make([]ent.Value, 0, len(m.primary_product_stores))
		for id := range m.primary_product_stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductStoreGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, productstoregroup.EdgeChildren)
	}
	if m.removedproduct_prices != nil {
		edges = append(edges, productstoregroup.EdgeProductPrices)
	}
	if m.removedprimary_product_stores != nil {
		edges = append(edges, productstoregroup.EdgePrimaryProductStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductStoreGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productstoregroup.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case productstoregroup.EdgeProductPrices:
		ids := make([]ent.Value, 0, len(m.removedproduct_prices))
		for id := range m.removedproduct_prices {
			ids = append(ids, id)
		}
		return ids
	case productstoregroup.EdgePrimaryProductStores:
		ids := make([]ent.Value, 0, len(m.removedprimary_product_stores))
		for id := range m.removedprimary_product_stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductStoreGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, productstoregroup.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, productstoregroup.EdgeChildren)
	}
	if m.clearedproduct_prices {
		edges = append(edges, productstoregroup.EdgeProductPrices)
	}
	if m.clearedprimary_product_stores {
		edges = append(edges, productstoregroup.EdgePrimaryProductStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductStoreGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case productstoregroup.EdgeParent:
		return m.clearedparent
	case productstoregroup.EdgeChildren:
		return m.clearedchildren
	case productstoregroup.EdgeProductPrices:
		return m.clearedproduct_prices
	case productstoregroup.EdgePrimaryProductStores:
		return m.clearedprimary_product_stores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductStoreGroupMutation) ClearEdge(name string) error {
	switch name {
	case productstoregroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductStoreGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductStoreGroupMutation) ResetEdge(name string) error {
	switch name {
	case productstoregroup.EdgeParent:
		m.ResetParent()
		return nil
	case productstoregroup.EdgeChildren:
		m.ResetChildren()
		return nil
	case productstoregroup.EdgeProductPrices:
		m.ResetProductPrices()
		return nil
	case productstoregroup.EdgePrimaryProductStores:
		m.ResetPrimaryProductStores()
		return nil
	}
	return fmt.Errorf("unknown ProductStoreGroup edge %s", name)
}

// ProductTypeMutation represents an operation that mutates the ProductType nodes in the graph.
type ProductTypeMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	update_time                *time.Time
	string_ref                 *string
	is_physical                *producttype.IsPhysical
	is_digital                 *producttype.IsDigital
	has_table                  *producttype.HasTable
	description                *string
	clearedFields              map[string]struct{}
	parent                     *int
	clearedparent              bool
	children                   map[int]struct{}
	removedchildren            map[int]struct{}
	clearedchildren            bool
	products                   map[int]struct{}
	removedproducts            map[int]struct{}
	clearedproducts            bool
	child_product_types        map[int]struct{}
	removedchild_product_types map[int]struct{}
	clearedchild_product_types bool
	done                       bool
	oldValue                   func(context.Context) (*ProductType, error)
	predicates                 []predicate.ProductType
}

var _ ent.Mutation = (*ProductTypeMutation)(nil)

// producttypeOption allows management of the mutation configuration using functional options.
type producttypeOption func(*ProductTypeMutation)

// newProductTypeMutation creates new mutation for the ProductType entity.
func newProductTypeMutation(c config, op Op, opts ...producttypeOption) *ProductTypeMutation {
	m := &ProductTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeProductType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductTypeID sets the ID field of the mutation.
func withProductTypeID(id int) producttypeOption {
	return func(m *ProductTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductType
		)
		m.oldValue = func(ctx context.Context) (*ProductType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductType sets the old ProductType of the mutation.
func withProductType(node *ProductType) producttypeOption {
	return func(m *ProductTypeMutation) {
		m.oldValue = func(context.Context) (*ProductType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ProductTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ProductTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ProductTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ProductTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ProductTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ProductTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ProductTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ProductTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ProductTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[producttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ProductTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[producttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ProductTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, producttype.FieldStringRef)
}

// SetIsPhysical sets the "is_physical" field.
func (m *ProductTypeMutation) SetIsPhysical(pp producttype.IsPhysical) {
	m.is_physical = &pp
}

// IsPhysical returns the value of the "is_physical" field in the mutation.
func (m *ProductTypeMutation) IsPhysical() (r producttype.IsPhysical, exists bool) {
	v := m.is_physical
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPhysical returns the old "is_physical" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldIsPhysical(ctx context.Context) (v producttype.IsPhysical, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsPhysical is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsPhysical requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPhysical: %w", err)
	}
	return oldValue.IsPhysical, nil
}

// ClearIsPhysical clears the value of the "is_physical" field.
func (m *ProductTypeMutation) ClearIsPhysical() {
	m.is_physical = nil
	m.clearedFields[producttype.FieldIsPhysical] = struct{}{}
}

// IsPhysicalCleared returns if the "is_physical" field was cleared in this mutation.
func (m *ProductTypeMutation) IsPhysicalCleared() bool {
	_, ok := m.clearedFields[producttype.FieldIsPhysical]
	return ok
}

// ResetIsPhysical resets all changes to the "is_physical" field.
func (m *ProductTypeMutation) ResetIsPhysical() {
	m.is_physical = nil
	delete(m.clearedFields, producttype.FieldIsPhysical)
}

// SetIsDigital sets the "is_digital" field.
func (m *ProductTypeMutation) SetIsDigital(pd producttype.IsDigital) {
	m.is_digital = &pd
}

// IsDigital returns the value of the "is_digital" field in the mutation.
func (m *ProductTypeMutation) IsDigital() (r producttype.IsDigital, exists bool) {
	v := m.is_digital
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDigital returns the old "is_digital" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldIsDigital(ctx context.Context) (v producttype.IsDigital, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDigital is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDigital requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDigital: %w", err)
	}
	return oldValue.IsDigital, nil
}

// ClearIsDigital clears the value of the "is_digital" field.
func (m *ProductTypeMutation) ClearIsDigital() {
	m.is_digital = nil
	m.clearedFields[producttype.FieldIsDigital] = struct{}{}
}

// IsDigitalCleared returns if the "is_digital" field was cleared in this mutation.
func (m *ProductTypeMutation) IsDigitalCleared() bool {
	_, ok := m.clearedFields[producttype.FieldIsDigital]
	return ok
}

// ResetIsDigital resets all changes to the "is_digital" field.
func (m *ProductTypeMutation) ResetIsDigital() {
	m.is_digital = nil
	delete(m.clearedFields, producttype.FieldIsDigital)
}

// SetHasTable sets the "has_table" field.
func (m *ProductTypeMutation) SetHasTable(pt producttype.HasTable) {
	m.has_table = &pt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ProductTypeMutation) HasTable() (r producttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldHasTable(ctx context.Context) (v producttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ProductTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[producttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ProductTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[producttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ProductTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, producttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ProductTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductType entity.
// If the ProductType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[producttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[producttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, producttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ProductType entity by id.
func (m *ProductTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ProductType entity.
func (m *ProductTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ProductType entity was cleared.
func (m *ProductTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ProductTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ProductTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ProductTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ProductType entity by ids.
func (m *ProductTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ProductType entity.
func (m *ProductTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ProductType entity was cleared.
func (m *ProductTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ProductType entity by IDs.
func (m *ProductTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ProductType entity.
func (m *ProductTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ProductTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ProductTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductTypeMutation) AddProductIDs(ids ...int) {
	if m.products == nil {
		m.products = make(map[int]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductTypeMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductTypeMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductTypeMutation) RemoveProductIDs(ids ...int) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductTypeMutation) RemovedProductsIDs() (ids []int) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductTypeMutation) ProductsIDs() (ids []int) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductTypeMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// AddChildProductTypeIDs adds the "child_product_types" edge to the ProductType entity by ids.
func (m *ProductTypeMutation) AddChildProductTypeIDs(ids ...int) {
	if m.child_product_types == nil {
		m.child_product_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_product_types[ids[i]] = struct{}{}
	}
}

// ClearChildProductTypes clears the "child_product_types" edge to the ProductType entity.
func (m *ProductTypeMutation) ClearChildProductTypes() {
	m.clearedchild_product_types = true
}

// ChildProductTypesCleared reports if the "child_product_types" edge to the ProductType entity was cleared.
func (m *ProductTypeMutation) ChildProductTypesCleared() bool {
	return m.clearedchild_product_types
}

// RemoveChildProductTypeIDs removes the "child_product_types" edge to the ProductType entity by IDs.
func (m *ProductTypeMutation) RemoveChildProductTypeIDs(ids ...int) {
	if m.removedchild_product_types == nil {
		m.removedchild_product_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_product_types[ids[i]] = struct{}{}
	}
}

// RemovedChildProductTypes returns the removed IDs of the "child_product_types" edge to the ProductType entity.
func (m *ProductTypeMutation) RemovedChildProductTypesIDs() (ids []int) {
	for id := range m.removedchild_product_types {
		ids = append(ids, id)
	}
	return
}

// ChildProductTypesIDs returns the "child_product_types" edge IDs in the mutation.
func (m *ProductTypeMutation) ChildProductTypesIDs() (ids []int) {
	for id := range m.child_product_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildProductTypes resets all changes to the "child_product_types" edge.
func (m *ProductTypeMutation) ResetChildProductTypes() {
	m.child_product_types = nil
	m.clearedchild_product_types = false
	m.removedchild_product_types = nil
}

// Op returns the operation name.
func (m *ProductTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProductType).
func (m *ProductTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, producttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, producttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, producttype.FieldStringRef)
	}
	if m.is_physical != nil {
		fields = append(fields, producttype.FieldIsPhysical)
	}
	if m.is_digital != nil {
		fields = append(fields, producttype.FieldIsDigital)
	}
	if m.has_table != nil {
		fields = append(fields, producttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, producttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producttype.FieldCreateTime:
		return m.CreateTime()
	case producttype.FieldUpdateTime:
		return m.UpdateTime()
	case producttype.FieldStringRef:
		return m.StringRef()
	case producttype.FieldIsPhysical:
		return m.IsPhysical()
	case producttype.FieldIsDigital:
		return m.IsDigital()
	case producttype.FieldHasTable:
		return m.HasTable()
	case producttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case producttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case producttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case producttype.FieldIsPhysical:
		return m.OldIsPhysical(ctx)
	case producttype.FieldIsDigital:
		return m.OldIsDigital(ctx)
	case producttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case producttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ProductType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case producttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case producttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case producttype.FieldIsPhysical:
		v, ok := value.(producttype.IsPhysical)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPhysical(v)
		return nil
	case producttype.FieldIsDigital:
		v, ok := value.(producttype.IsDigital)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDigital(v)
		return nil
	case producttype.FieldHasTable:
		v, ok := value.(producttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case producttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ProductType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(producttype.FieldStringRef) {
		fields = append(fields, producttype.FieldStringRef)
	}
	if m.FieldCleared(producttype.FieldIsPhysical) {
		fields = append(fields, producttype.FieldIsPhysical)
	}
	if m.FieldCleared(producttype.FieldIsDigital) {
		fields = append(fields, producttype.FieldIsDigital)
	}
	if m.FieldCleared(producttype.FieldHasTable) {
		fields = append(fields, producttype.FieldHasTable)
	}
	if m.FieldCleared(producttype.FieldDescription) {
		fields = append(fields, producttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductTypeMutation) ClearField(name string) error {
	switch name {
	case producttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case producttype.FieldIsPhysical:
		m.ClearIsPhysical()
		return nil
	case producttype.FieldIsDigital:
		m.ClearIsDigital()
		return nil
	case producttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case producttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductTypeMutation) ResetField(name string) error {
	switch name {
	case producttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case producttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case producttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case producttype.FieldIsPhysical:
		m.ResetIsPhysical()
		return nil
	case producttype.FieldIsDigital:
		m.ResetIsDigital()
		return nil
	case producttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case producttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ProductType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, producttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, producttype.EdgeChildren)
	}
	if m.products != nil {
		edges = append(edges, producttype.EdgeProducts)
	}
	if m.child_product_types != nil {
		edges = append(edges, producttype.EdgeChildProductTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case producttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case producttype.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	case producttype.EdgeChildProductTypes:
		ids := make([]ent.Value, 0, len(m.child_product_types))
		for id := range m.child_product_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, producttype.EdgeChildren)
	}
	if m.removedproducts != nil {
		edges = append(edges, producttype.EdgeProducts)
	}
	if m.removedchild_product_types != nil {
		edges = append(edges, producttype.EdgeChildProductTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case producttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case producttype.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	case producttype.EdgeChildProductTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_product_types))
		for id := range m.removedchild_product_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, producttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, producttype.EdgeChildren)
	}
	if m.clearedproducts {
		edges = append(edges, producttype.EdgeProducts)
	}
	if m.clearedchild_product_types {
		edges = append(edges, producttype.EdgeChildProductTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case producttype.EdgeParent:
		return m.clearedparent
	case producttype.EdgeChildren:
		return m.clearedchildren
	case producttype.EdgeProducts:
		return m.clearedproducts
	case producttype.EdgeChildProductTypes:
		return m.clearedchild_product_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductTypeMutation) ClearEdge(name string) error {
	switch name {
	case producttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ProductType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductTypeMutation) ResetEdge(name string) error {
	switch name {
	case producttype.EdgeParent:
		m.ResetParent()
		return nil
	case producttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case producttype.EdgeProducts:
		m.ResetProducts()
		return nil
	case producttype.EdgeChildProductTypes:
		m.ResetChildProductTypes()
		return nil
	}
	return fmt.Errorf("unknown ProductType edge %s", name)
}

// QuantityBreakTypeMutation represents an operation that mutates the QuantityBreakType nodes in the graph.
type QuantityBreakTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*QuantityBreakType, error)
	predicates    []predicate.QuantityBreakType
}

var _ ent.Mutation = (*QuantityBreakTypeMutation)(nil)

// quantitybreaktypeOption allows management of the mutation configuration using functional options.
type quantitybreaktypeOption func(*QuantityBreakTypeMutation)

// newQuantityBreakTypeMutation creates new mutation for the QuantityBreakType entity.
func newQuantityBreakTypeMutation(c config, op Op, opts ...quantitybreaktypeOption) *QuantityBreakTypeMutation {
	m := &QuantityBreakTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeQuantityBreakType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuantityBreakTypeID sets the ID field of the mutation.
func withQuantityBreakTypeID(id int) quantitybreaktypeOption {
	return func(m *QuantityBreakTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *QuantityBreakType
		)
		m.oldValue = func(ctx context.Context) (*QuantityBreakType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QuantityBreakType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuantityBreakType sets the old QuantityBreakType of the mutation.
func withQuantityBreakType(node *QuantityBreakType) quantitybreaktypeOption {
	return func(m *QuantityBreakTypeMutation) {
		m.oldValue = func(context.Context) (*QuantityBreakType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuantityBreakTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuantityBreakTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuantityBreakTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *QuantityBreakTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *QuantityBreakTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the QuantityBreakType entity.
// If the QuantityBreakType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuantityBreakTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *QuantityBreakTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *QuantityBreakTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *QuantityBreakTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the QuantityBreakType entity.
// If the QuantityBreakType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuantityBreakTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *QuantityBreakTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *QuantityBreakTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *QuantityBreakTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the QuantityBreakType entity.
// If the QuantityBreakType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuantityBreakTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *QuantityBreakTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[quantitybreaktype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *QuantityBreakTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[quantitybreaktype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *QuantityBreakTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, quantitybreaktype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *QuantityBreakTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *QuantityBreakTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the QuantityBreakType entity.
// If the QuantityBreakType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuantityBreakTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *QuantityBreakTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[quantitybreaktype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *QuantityBreakTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[quantitybreaktype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *QuantityBreakTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, quantitybreaktype.FieldDescription)
}

// Op returns the operation name.
func (m *QuantityBreakTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (QuantityBreakType).
func (m *QuantityBreakTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuantityBreakTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, quantitybreaktype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, quantitybreaktype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, quantitybreaktype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, quantitybreaktype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuantityBreakTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case quantitybreaktype.FieldCreateTime:
		return m.CreateTime()
	case quantitybreaktype.FieldUpdateTime:
		return m.UpdateTime()
	case quantitybreaktype.FieldStringRef:
		return m.StringRef()
	case quantitybreaktype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuantityBreakTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case quantitybreaktype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case quantitybreaktype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case quantitybreaktype.FieldStringRef:
		return m.OldStringRef(ctx)
	case quantitybreaktype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown QuantityBreakType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuantityBreakTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case quantitybreaktype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case quantitybreaktype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case quantitybreaktype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case quantitybreaktype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown QuantityBreakType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuantityBreakTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuantityBreakTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuantityBreakTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown QuantityBreakType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuantityBreakTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(quantitybreaktype.FieldStringRef) {
		fields = append(fields, quantitybreaktype.FieldStringRef)
	}
	if m.FieldCleared(quantitybreaktype.FieldDescription) {
		fields = append(fields, quantitybreaktype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuantityBreakTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuantityBreakTypeMutation) ClearField(name string) error {
	switch name {
	case quantitybreaktype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case quantitybreaktype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown QuantityBreakType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuantityBreakTypeMutation) ResetField(name string) error {
	switch name {
	case quantitybreaktype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case quantitybreaktype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case quantitybreaktype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case quantitybreaktype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown QuantityBreakType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuantityBreakTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuantityBreakTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuantityBreakTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuantityBreakTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuantityBreakTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuantityBreakTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuantityBreakTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown QuantityBreakType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuantityBreakTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown QuantityBreakType edge %s", name)
}

// RejectionReasonMutation represents an operation that mutates the RejectionReason nodes in the graph.
type RejectionReasonMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RejectionReason, error)
	predicates    []predicate.RejectionReason
}

var _ ent.Mutation = (*RejectionReasonMutation)(nil)

// rejectionreasonOption allows management of the mutation configuration using functional options.
type rejectionreasonOption func(*RejectionReasonMutation)

// newRejectionReasonMutation creates new mutation for the RejectionReason entity.
func newRejectionReasonMutation(c config, op Op, opts ...rejectionreasonOption) *RejectionReasonMutation {
	m := &RejectionReasonMutation{
		config:        c,
		op:            op,
		typ:           TypeRejectionReason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRejectionReasonID sets the ID field of the mutation.
func withRejectionReasonID(id int) rejectionreasonOption {
	return func(m *RejectionReasonMutation) {
		var (
			err   error
			once  sync.Once
			value *RejectionReason
		)
		m.oldValue = func(ctx context.Context) (*RejectionReason, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RejectionReason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRejectionReason sets the old RejectionReason of the mutation.
func withRejectionReason(node *RejectionReason) rejectionreasonOption {
	return func(m *RejectionReasonMutation) {
		m.oldValue = func(context.Context) (*RejectionReason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RejectionReasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RejectionReasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RejectionReasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *RejectionReasonMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RejectionReasonMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RejectionReason entity.
// If the RejectionReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectionReasonMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RejectionReasonMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RejectionReasonMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RejectionReasonMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the RejectionReason entity.
// If the RejectionReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectionReasonMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RejectionReasonMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *RejectionReasonMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *RejectionReasonMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the RejectionReason entity.
// If the RejectionReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectionReasonMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *RejectionReasonMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[rejectionreason.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *RejectionReasonMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[rejectionreason.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *RejectionReasonMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, rejectionreason.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *RejectionReasonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RejectionReasonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RejectionReason entity.
// If the RejectionReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RejectionReasonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RejectionReasonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[rejectionreason.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RejectionReasonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[rejectionreason.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RejectionReasonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, rejectionreason.FieldDescription)
}

// Op returns the operation name.
func (m *RejectionReasonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RejectionReason).
func (m *RejectionReasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RejectionReasonMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, rejectionreason.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, rejectionreason.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, rejectionreason.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, rejectionreason.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RejectionReasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rejectionreason.FieldCreateTime:
		return m.CreateTime()
	case rejectionreason.FieldUpdateTime:
		return m.UpdateTime()
	case rejectionreason.FieldStringRef:
		return m.StringRef()
	case rejectionreason.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RejectionReasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rejectionreason.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case rejectionreason.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case rejectionreason.FieldStringRef:
		return m.OldStringRef(ctx)
	case rejectionreason.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown RejectionReason field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RejectionReasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rejectionreason.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case rejectionreason.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case rejectionreason.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case rejectionreason.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown RejectionReason field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RejectionReasonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RejectionReasonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RejectionReasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RejectionReason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RejectionReasonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rejectionreason.FieldStringRef) {
		fields = append(fields, rejectionreason.FieldStringRef)
	}
	if m.FieldCleared(rejectionreason.FieldDescription) {
		fields = append(fields, rejectionreason.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RejectionReasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RejectionReasonMutation) ClearField(name string) error {
	switch name {
	case rejectionreason.FieldStringRef:
		m.ClearStringRef()
		return nil
	case rejectionreason.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown RejectionReason nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RejectionReasonMutation) ResetField(name string) error {
	switch name {
	case rejectionreason.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case rejectionreason.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case rejectionreason.FieldStringRef:
		m.ResetStringRef()
		return nil
	case rejectionreason.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown RejectionReason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RejectionReasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RejectionReasonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RejectionReasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RejectionReasonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RejectionReasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RejectionReasonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RejectionReasonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RejectionReason unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RejectionReasonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RejectionReason edge %s", name)
}

// RoleTypeMutation represents an operation that mutates the RoleType nodes in the graph.
type RoleTypeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	string_ref              *string
	has_table               *roletype.HasTable
	description             *string
	clearedFields           map[string]struct{}
	parent                  *int
	clearedparent           bool
	children                map[int]struct{}
	removedchildren         map[int]struct{}
	clearedchildren         bool
	order_roles             map[int]struct{}
	removedorder_roles      map[int]struct{}
	clearedorder_roles      bool
	child_role_types        map[int]struct{}
	removedchild_role_types map[int]struct{}
	clearedchild_role_types bool
	done                    bool
	oldValue                func(context.Context) (*RoleType, error)
	predicates              []predicate.RoleType
}

var _ ent.Mutation = (*RoleTypeMutation)(nil)

// roletypeOption allows management of the mutation configuration using functional options.
type roletypeOption func(*RoleTypeMutation)

// newRoleTypeMutation creates new mutation for the RoleType entity.
func newRoleTypeMutation(c config, op Op, opts ...roletypeOption) *RoleTypeMutation {
	m := &RoleTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleTypeID sets the ID field of the mutation.
func withRoleTypeID(id int) roletypeOption {
	return func(m *RoleTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *RoleType
		)
		m.oldValue = func(ctx context.Context) (*RoleType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RoleType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoleType sets the old RoleType of the mutation.
func withRoleType(node *RoleType) roletypeOption {
	return func(m *RoleTypeMutation) {
		m.oldValue = func(context.Context) (*RoleType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *RoleTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RoleTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RoleType entity.
// If the RoleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RoleTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RoleTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RoleTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the RoleType entity.
// If the RoleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RoleTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *RoleTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *RoleTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the RoleType entity.
// If the RoleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *RoleTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[roletype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *RoleTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[roletype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *RoleTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, roletype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *RoleTypeMutation) SetHasTable(rt roletype.HasTable) {
	m.has_table = &rt
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *RoleTypeMutation) HasTable() (r roletype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the RoleType entity.
// If the RoleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleTypeMutation) OldHasTable(ctx context.Context) (v roletype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *RoleTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[roletype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *RoleTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[roletype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *RoleTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, roletype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *RoleTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RoleType entity.
// If the RoleType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[roletype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[roletype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, roletype.FieldDescription)
}

// SetParentID sets the "parent" edge to the RoleType entity by id.
func (m *RoleTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the RoleType entity.
func (m *RoleTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the RoleType entity was cleared.
func (m *RoleTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *RoleTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *RoleTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *RoleTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the RoleType entity by ids.
func (m *RoleTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the RoleType entity.
func (m *RoleTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the RoleType entity was cleared.
func (m *RoleTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the RoleType entity by IDs.
func (m *RoleTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the RoleType entity.
func (m *RoleTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *RoleTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *RoleTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddOrderRoleIDs adds the "order_roles" edge to the OrderRole entity by ids.
func (m *RoleTypeMutation) AddOrderRoleIDs(ids ...int) {
	if m.order_roles == nil {
		m.order_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.order_roles[ids[i]] = struct{}{}
	}
}

// ClearOrderRoles clears the "order_roles" edge to the OrderRole entity.
func (m *RoleTypeMutation) ClearOrderRoles() {
	m.clearedorder_roles = true
}

// OrderRolesCleared reports if the "order_roles" edge to the OrderRole entity was cleared.
func (m *RoleTypeMutation) OrderRolesCleared() bool {
	return m.clearedorder_roles
}

// RemoveOrderRoleIDs removes the "order_roles" edge to the OrderRole entity by IDs.
func (m *RoleTypeMutation) RemoveOrderRoleIDs(ids ...int) {
	if m.removedorder_roles == nil {
		m.removedorder_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_roles[ids[i]] = struct{}{}
	}
}

// RemovedOrderRoles returns the removed IDs of the "order_roles" edge to the OrderRole entity.
func (m *RoleTypeMutation) RemovedOrderRolesIDs() (ids []int) {
	for id := range m.removedorder_roles {
		ids = append(ids, id)
	}
	return
}

// OrderRolesIDs returns the "order_roles" edge IDs in the mutation.
func (m *RoleTypeMutation) OrderRolesIDs() (ids []int) {
	for id := range m.order_roles {
		ids = append(ids, id)
	}
	return
}

// ResetOrderRoles resets all changes to the "order_roles" edge.
func (m *RoleTypeMutation) ResetOrderRoles() {
	m.order_roles = nil
	m.clearedorder_roles = false
	m.removedorder_roles = nil
}

// AddChildRoleTypeIDs adds the "child_role_types" edge to the RoleType entity by ids.
func (m *RoleTypeMutation) AddChildRoleTypeIDs(ids ...int) {
	if m.child_role_types == nil {
		m.child_role_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_role_types[ids[i]] = struct{}{}
	}
}

// ClearChildRoleTypes clears the "child_role_types" edge to the RoleType entity.
func (m *RoleTypeMutation) ClearChildRoleTypes() {
	m.clearedchild_role_types = true
}

// ChildRoleTypesCleared reports if the "child_role_types" edge to the RoleType entity was cleared.
func (m *RoleTypeMutation) ChildRoleTypesCleared() bool {
	return m.clearedchild_role_types
}

// RemoveChildRoleTypeIDs removes the "child_role_types" edge to the RoleType entity by IDs.
func (m *RoleTypeMutation) RemoveChildRoleTypeIDs(ids ...int) {
	if m.removedchild_role_types == nil {
		m.removedchild_role_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_role_types[ids[i]] = struct{}{}
	}
}

// RemovedChildRoleTypes returns the removed IDs of the "child_role_types" edge to the RoleType entity.
func (m *RoleTypeMutation) RemovedChildRoleTypesIDs() (ids []int) {
	for id := range m.removedchild_role_types {
		ids = append(ids, id)
	}
	return
}

// ChildRoleTypesIDs returns the "child_role_types" edge IDs in the mutation.
func (m *RoleTypeMutation) ChildRoleTypesIDs() (ids []int) {
	for id := range m.child_role_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildRoleTypes resets all changes to the "child_role_types" edge.
func (m *RoleTypeMutation) ResetChildRoleTypes() {
	m.child_role_types = nil
	m.clearedchild_role_types = false
	m.removedchild_role_types = nil
}

// Op returns the operation name.
func (m *RoleTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RoleType).
func (m *RoleTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, roletype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, roletype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, roletype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, roletype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, roletype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roletype.FieldCreateTime:
		return m.CreateTime()
	case roletype.FieldUpdateTime:
		return m.UpdateTime()
	case roletype.FieldStringRef:
		return m.StringRef()
	case roletype.FieldHasTable:
		return m.HasTable()
	case roletype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roletype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case roletype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case roletype.FieldStringRef:
		return m.OldStringRef(ctx)
	case roletype.FieldHasTable:
		return m.OldHasTable(ctx)
	case roletype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown RoleType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roletype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case roletype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case roletype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case roletype.FieldHasTable:
		v, ok := value.(roletype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case roletype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown RoleType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RoleType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(roletype.FieldStringRef) {
		fields = append(fields, roletype.FieldStringRef)
	}
	if m.FieldCleared(roletype.FieldHasTable) {
		fields = append(fields, roletype.FieldHasTable)
	}
	if m.FieldCleared(roletype.FieldDescription) {
		fields = append(fields, roletype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleTypeMutation) ClearField(name string) error {
	switch name {
	case roletype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case roletype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case roletype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown RoleType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleTypeMutation) ResetField(name string) error {
	switch name {
	case roletype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case roletype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case roletype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case roletype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case roletype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown RoleType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, roletype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, roletype.EdgeChildren)
	}
	if m.order_roles != nil {
		edges = append(edges, roletype.EdgeOrderRoles)
	}
	if m.child_role_types != nil {
		edges = append(edges, roletype.EdgeChildRoleTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roletype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case roletype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case roletype.EdgeOrderRoles:
		ids := make([]ent.Value, 0, len(m.order_roles))
		for id := range m.order_roles {
			ids = append(ids, id)
		}
		return ids
	case roletype.EdgeChildRoleTypes:
		ids := make([]ent.Value, 0, len(m.child_role_types))
		for id := range m.child_role_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, roletype.EdgeChildren)
	}
	if m.removedorder_roles != nil {
		edges = append(edges, roletype.EdgeOrderRoles)
	}
	if m.removedchild_role_types != nil {
		edges = append(edges, roletype.EdgeChildRoleTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roletype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case roletype.EdgeOrderRoles:
		ids := make([]ent.Value, 0, len(m.removedorder_roles))
		for id := range m.removedorder_roles {
			ids = append(ids, id)
		}
		return ids
	case roletype.EdgeChildRoleTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_role_types))
		for id := range m.removedchild_role_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, roletype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, roletype.EdgeChildren)
	}
	if m.clearedorder_roles {
		edges = append(edges, roletype.EdgeOrderRoles)
	}
	if m.clearedchild_role_types {
		edges = append(edges, roletype.EdgeChildRoleTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case roletype.EdgeParent:
		return m.clearedparent
	case roletype.EdgeChildren:
		return m.clearedchildren
	case roletype.EdgeOrderRoles:
		return m.clearedorder_roles
	case roletype.EdgeChildRoleTypes:
		return m.clearedchild_role_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleTypeMutation) ClearEdge(name string) error {
	switch name {
	case roletype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown RoleType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleTypeMutation) ResetEdge(name string) error {
	switch name {
	case roletype.EdgeParent:
		m.ResetParent()
		return nil
	case roletype.EdgeChildren:
		m.ResetChildren()
		return nil
	case roletype.EdgeOrderRoles:
		m.ResetOrderRoles()
		return nil
	case roletype.EdgeChildRoleTypes:
		m.ResetChildRoleTypes()
		return nil
	}
	return fmt.Errorf("unknown RoleType edge %s", name)
}

// ShipmentContactMechTypeMutation represents an operation that mutates the ShipmentContactMechType nodes in the graph.
type ShipmentContactMechTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShipmentContactMechType, error)
	predicates    []predicate.ShipmentContactMechType
}

var _ ent.Mutation = (*ShipmentContactMechTypeMutation)(nil)

// shipmentcontactmechtypeOption allows management of the mutation configuration using functional options.
type shipmentcontactmechtypeOption func(*ShipmentContactMechTypeMutation)

// newShipmentContactMechTypeMutation creates new mutation for the ShipmentContactMechType entity.
func newShipmentContactMechTypeMutation(c config, op Op, opts ...shipmentcontactmechtypeOption) *ShipmentContactMechTypeMutation {
	m := &ShipmentContactMechTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentContactMechType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentContactMechTypeID sets the ID field of the mutation.
func withShipmentContactMechTypeID(id int) shipmentcontactmechtypeOption {
	return func(m *ShipmentContactMechTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentContactMechType
		)
		m.oldValue = func(ctx context.Context) (*ShipmentContactMechType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentContactMechType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentContactMechType sets the old ShipmentContactMechType of the mutation.
func withShipmentContactMechType(node *ShipmentContactMechType) shipmentcontactmechtypeOption {
	return func(m *ShipmentContactMechTypeMutation) {
		m.oldValue = func(context.Context) (*ShipmentContactMechType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentContactMechTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentContactMechTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentContactMechTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentContactMechTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentContactMechTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentContactMechType entity.
// If the ShipmentContactMechType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentContactMechTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentContactMechTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentContactMechTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentContactMechTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentContactMechType entity.
// If the ShipmentContactMechType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentContactMechTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentContactMechTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentContactMechTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentContactMechTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentContactMechType entity.
// If the ShipmentContactMechType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentContactMechTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentContactMechTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentcontactmechtype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentContactMechTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentcontactmechtype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentContactMechTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentcontactmechtype.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ShipmentContactMechTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentContactMechTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentContactMechType entity.
// If the ShipmentContactMechType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentContactMechTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShipmentContactMechTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shipmentcontactmechtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShipmentContactMechTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shipmentcontactmechtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentContactMechTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shipmentcontactmechtype.FieldDescription)
}

// Op returns the operation name.
func (m *ShipmentContactMechTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentContactMechType).
func (m *ShipmentContactMechTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentContactMechTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, shipmentcontactmechtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentcontactmechtype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentcontactmechtype.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, shipmentcontactmechtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentContactMechTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcontactmechtype.FieldCreateTime:
		return m.CreateTime()
	case shipmentcontactmechtype.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentcontactmechtype.FieldStringRef:
		return m.StringRef()
	case shipmentcontactmechtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentContactMechTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcontactmechtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentcontactmechtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentcontactmechtype.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentcontactmechtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentContactMechType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentContactMechTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcontactmechtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentcontactmechtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentcontactmechtype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentcontactmechtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentContactMechType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentContactMechTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentContactMechTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentContactMechTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentContactMechType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentContactMechTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentcontactmechtype.FieldStringRef) {
		fields = append(fields, shipmentcontactmechtype.FieldStringRef)
	}
	if m.FieldCleared(shipmentcontactmechtype.FieldDescription) {
		fields = append(fields, shipmentcontactmechtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentContactMechTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentContactMechTypeMutation) ClearField(name string) error {
	switch name {
	case shipmentcontactmechtype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentcontactmechtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentContactMechType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentContactMechTypeMutation) ResetField(name string) error {
	switch name {
	case shipmentcontactmechtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentcontactmechtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentcontactmechtype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentcontactmechtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentContactMechType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentContactMechTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentContactMechTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentContactMechTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentContactMechTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentContactMechTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentContactMechTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentContactMechTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShipmentContactMechType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentContactMechTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShipmentContactMechType edge %s", name)
}

// ShipmentGatewayConfigMutation represents an operation that mutates the ShipmentGatewayConfig nodes in the graph.
type ShipmentGatewayConfigMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	update_time                         *time.Time
	string_ref                          *string
	description                         *string
	clearedFields                       map[string]struct{}
	shipment_gateway_config_type        *int
	clearedshipment_gateway_config_type bool
	shipment_gateway_dhl                *int
	clearedshipment_gateway_dhl         bool
	shipment_gateway_fedex              *int
	clearedshipment_gateway_fedex       bool
	shipment_gateway_ups                *int
	clearedshipment_gateway_ups         bool
	shipment_gateway_usps               *int
	clearedshipment_gateway_usps        bool
	done                                bool
	oldValue                            func(context.Context) (*ShipmentGatewayConfig, error)
	predicates                          []predicate.ShipmentGatewayConfig
}

var _ ent.Mutation = (*ShipmentGatewayConfigMutation)(nil)

// shipmentgatewayconfigOption allows management of the mutation configuration using functional options.
type shipmentgatewayconfigOption func(*ShipmentGatewayConfigMutation)

// newShipmentGatewayConfigMutation creates new mutation for the ShipmentGatewayConfig entity.
func newShipmentGatewayConfigMutation(c config, op Op, opts ...shipmentgatewayconfigOption) *ShipmentGatewayConfigMutation {
	m := &ShipmentGatewayConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGatewayConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGatewayConfigID sets the ID field of the mutation.
func withShipmentGatewayConfigID(id int) shipmentgatewayconfigOption {
	return func(m *ShipmentGatewayConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGatewayConfig
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGatewayConfig, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGatewayConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGatewayConfig sets the old ShipmentGatewayConfig of the mutation.
func withShipmentGatewayConfig(node *ShipmentGatewayConfig) shipmentgatewayconfigOption {
	return func(m *ShipmentGatewayConfigMutation) {
		m.oldValue = func(context.Context) (*ShipmentGatewayConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGatewayConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGatewayConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGatewayConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentGatewayConfigMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentGatewayConfigMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentGatewayConfig entity.
// If the ShipmentGatewayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentGatewayConfigMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentGatewayConfigMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentGatewayConfigMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentGatewayConfig entity.
// If the ShipmentGatewayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentGatewayConfigMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentGatewayConfigMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentGatewayConfigMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentGatewayConfig entity.
// If the ShipmentGatewayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentGatewayConfigMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentgatewayconfig.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentGatewayConfigMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayconfig.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentGatewayConfigMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentgatewayconfig.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *ShipmentGatewayConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentGatewayConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentGatewayConfig entity.
// If the ShipmentGatewayConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShipmentGatewayConfigMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shipmentgatewayconfig.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShipmentGatewayConfigMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayconfig.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentGatewayConfigMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shipmentgatewayconfig.FieldDescription)
}

// SetShipmentGatewayConfigTypeID sets the "shipment_gateway_config_type" edge to the ShipmentGatewayConfigType entity by id.
func (m *ShipmentGatewayConfigMutation) SetShipmentGatewayConfigTypeID(id int) {
	m.shipment_gateway_config_type = &id
}

// ClearShipmentGatewayConfigType clears the "shipment_gateway_config_type" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigMutation) ClearShipmentGatewayConfigType() {
	m.clearedshipment_gateway_config_type = true
}

// ShipmentGatewayConfigTypeCleared reports if the "shipment_gateway_config_type" edge to the ShipmentGatewayConfigType entity was cleared.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayConfigTypeCleared() bool {
	return m.clearedshipment_gateway_config_type
}

// ShipmentGatewayConfigTypeID returns the "shipment_gateway_config_type" edge ID in the mutation.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayConfigTypeID() (id int, exists bool) {
	if m.shipment_gateway_config_type != nil {
		return *m.shipment_gateway_config_type, true
	}
	return
}

// ShipmentGatewayConfigTypeIDs returns the "shipment_gateway_config_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayConfigTypeID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayConfigTypeIDs() (ids []int) {
	if id := m.shipment_gateway_config_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayConfigType resets all changes to the "shipment_gateway_config_type" edge.
func (m *ShipmentGatewayConfigMutation) ResetShipmentGatewayConfigType() {
	m.shipment_gateway_config_type = nil
	m.clearedshipment_gateway_config_type = false
}

// SetShipmentGatewayDhlID sets the "shipment_gateway_dhl" edge to the ShipmentGatewayDhl entity by id.
func (m *ShipmentGatewayConfigMutation) SetShipmentGatewayDhlID(id int) {
	m.shipment_gateway_dhl = &id
}

// ClearShipmentGatewayDhl clears the "shipment_gateway_dhl" edge to the ShipmentGatewayDhl entity.
func (m *ShipmentGatewayConfigMutation) ClearShipmentGatewayDhl() {
	m.clearedshipment_gateway_dhl = true
}

// ShipmentGatewayDhlCleared reports if the "shipment_gateway_dhl" edge to the ShipmentGatewayDhl entity was cleared.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayDhlCleared() bool {
	return m.clearedshipment_gateway_dhl
}

// ShipmentGatewayDhlID returns the "shipment_gateway_dhl" edge ID in the mutation.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayDhlID() (id int, exists bool) {
	if m.shipment_gateway_dhl != nil {
		return *m.shipment_gateway_dhl, true
	}
	return
}

// ShipmentGatewayDhlIDs returns the "shipment_gateway_dhl" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayDhlID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayDhlIDs() (ids []int) {
	if id := m.shipment_gateway_dhl; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayDhl resets all changes to the "shipment_gateway_dhl" edge.
func (m *ShipmentGatewayConfigMutation) ResetShipmentGatewayDhl() {
	m.shipment_gateway_dhl = nil
	m.clearedshipment_gateway_dhl = false
}

// SetShipmentGatewayFedexID sets the "shipment_gateway_fedex" edge to the ShipmentGatewayFedex entity by id.
func (m *ShipmentGatewayConfigMutation) SetShipmentGatewayFedexID(id int) {
	m.shipment_gateway_fedex = &id
}

// ClearShipmentGatewayFedex clears the "shipment_gateway_fedex" edge to the ShipmentGatewayFedex entity.
func (m *ShipmentGatewayConfigMutation) ClearShipmentGatewayFedex() {
	m.clearedshipment_gateway_fedex = true
}

// ShipmentGatewayFedexCleared reports if the "shipment_gateway_fedex" edge to the ShipmentGatewayFedex entity was cleared.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayFedexCleared() bool {
	return m.clearedshipment_gateway_fedex
}

// ShipmentGatewayFedexID returns the "shipment_gateway_fedex" edge ID in the mutation.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayFedexID() (id int, exists bool) {
	if m.shipment_gateway_fedex != nil {
		return *m.shipment_gateway_fedex, true
	}
	return
}

// ShipmentGatewayFedexIDs returns the "shipment_gateway_fedex" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayFedexID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayFedexIDs() (ids []int) {
	if id := m.shipment_gateway_fedex; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayFedex resets all changes to the "shipment_gateway_fedex" edge.
func (m *ShipmentGatewayConfigMutation) ResetShipmentGatewayFedex() {
	m.shipment_gateway_fedex = nil
	m.clearedshipment_gateway_fedex = false
}

// SetShipmentGatewayUpsID sets the "shipment_gateway_ups" edge to the ShipmentGatewayUps entity by id.
func (m *ShipmentGatewayConfigMutation) SetShipmentGatewayUpsID(id int) {
	m.shipment_gateway_ups = &id
}

// ClearShipmentGatewayUps clears the "shipment_gateway_ups" edge to the ShipmentGatewayUps entity.
func (m *ShipmentGatewayConfigMutation) ClearShipmentGatewayUps() {
	m.clearedshipment_gateway_ups = true
}

// ShipmentGatewayUpsCleared reports if the "shipment_gateway_ups" edge to the ShipmentGatewayUps entity was cleared.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayUpsCleared() bool {
	return m.clearedshipment_gateway_ups
}

// ShipmentGatewayUpsID returns the "shipment_gateway_ups" edge ID in the mutation.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayUpsID() (id int, exists bool) {
	if m.shipment_gateway_ups != nil {
		return *m.shipment_gateway_ups, true
	}
	return
}

// ShipmentGatewayUpsIDs returns the "shipment_gateway_ups" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayUpsID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayUpsIDs() (ids []int) {
	if id := m.shipment_gateway_ups; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayUps resets all changes to the "shipment_gateway_ups" edge.
func (m *ShipmentGatewayConfigMutation) ResetShipmentGatewayUps() {
	m.shipment_gateway_ups = nil
	m.clearedshipment_gateway_ups = false
}

// SetShipmentGatewayUspsID sets the "shipment_gateway_usps" edge to the ShipmentGatewayUsps entity by id.
func (m *ShipmentGatewayConfigMutation) SetShipmentGatewayUspsID(id int) {
	m.shipment_gateway_usps = &id
}

// ClearShipmentGatewayUsps clears the "shipment_gateway_usps" edge to the ShipmentGatewayUsps entity.
func (m *ShipmentGatewayConfigMutation) ClearShipmentGatewayUsps() {
	m.clearedshipment_gateway_usps = true
}

// ShipmentGatewayUspsCleared reports if the "shipment_gateway_usps" edge to the ShipmentGatewayUsps entity was cleared.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayUspsCleared() bool {
	return m.clearedshipment_gateway_usps
}

// ShipmentGatewayUspsID returns the "shipment_gateway_usps" edge ID in the mutation.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayUspsID() (id int, exists bool) {
	if m.shipment_gateway_usps != nil {
		return *m.shipment_gateway_usps, true
	}
	return
}

// ShipmentGatewayUspsIDs returns the "shipment_gateway_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayUspsID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayConfigMutation) ShipmentGatewayUspsIDs() (ids []int) {
	if id := m.shipment_gateway_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayUsps resets all changes to the "shipment_gateway_usps" edge.
func (m *ShipmentGatewayConfigMutation) ResetShipmentGatewayUsps() {
	m.shipment_gateway_usps = nil
	m.clearedshipment_gateway_usps = false
}

// Op returns the operation name.
func (m *ShipmentGatewayConfigMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentGatewayConfig).
func (m *ShipmentGatewayConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGatewayConfigMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, shipmentgatewayconfig.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentgatewayconfig.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentgatewayconfig.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, shipmentgatewayconfig.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGatewayConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayconfig.FieldCreateTime:
		return m.CreateTime()
	case shipmentgatewayconfig.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentgatewayconfig.FieldStringRef:
		return m.StringRef()
	case shipmentgatewayconfig.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGatewayConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgatewayconfig.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentgatewayconfig.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentgatewayconfig.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentgatewayconfig.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGatewayConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayconfig.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentgatewayconfig.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentgatewayconfig.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentgatewayconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGatewayConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGatewayConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentGatewayConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGatewayConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentgatewayconfig.FieldStringRef) {
		fields = append(fields, shipmentgatewayconfig.FieldStringRef)
	}
	if m.FieldCleared(shipmentgatewayconfig.FieldDescription) {
		fields = append(fields, shipmentgatewayconfig.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGatewayConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGatewayConfigMutation) ClearField(name string) error {
	switch name {
	case shipmentgatewayconfig.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentgatewayconfig.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGatewayConfigMutation) ResetField(name string) error {
	switch name {
	case shipmentgatewayconfig.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentgatewayconfig.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentgatewayconfig.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentgatewayconfig.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGatewayConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.shipment_gateway_config_type != nil {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayConfigType)
	}
	if m.shipment_gateway_dhl != nil {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayDhl)
	}
	if m.shipment_gateway_fedex != nil {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayFedex)
	}
	if m.shipment_gateway_ups != nil {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayUps)
	}
	if m.shipment_gateway_usps != nil {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayUsps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGatewayConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewayconfig.EdgeShipmentGatewayConfigType:
		if id := m.shipment_gateway_config_type; id != nil {
			return []ent.Value{*id}
		}
	case shipmentgatewayconfig.EdgeShipmentGatewayDhl:
		if id := m.shipment_gateway_dhl; id != nil {
			return []ent.Value{*id}
		}
	case shipmentgatewayconfig.EdgeShipmentGatewayFedex:
		if id := m.shipment_gateway_fedex; id != nil {
			return []ent.Value{*id}
		}
	case shipmentgatewayconfig.EdgeShipmentGatewayUps:
		if id := m.shipment_gateway_ups; id != nil {
			return []ent.Value{*id}
		}
	case shipmentgatewayconfig.EdgeShipmentGatewayUsps:
		if id := m.shipment_gateway_usps; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGatewayConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGatewayConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGatewayConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedshipment_gateway_config_type {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayConfigType)
	}
	if m.clearedshipment_gateway_dhl {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayDhl)
	}
	if m.clearedshipment_gateway_fedex {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayFedex)
	}
	if m.clearedshipment_gateway_ups {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayUps)
	}
	if m.clearedshipment_gateway_usps {
		edges = append(edges, shipmentgatewayconfig.EdgeShipmentGatewayUsps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGatewayConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgatewayconfig.EdgeShipmentGatewayConfigType:
		return m.clearedshipment_gateway_config_type
	case shipmentgatewayconfig.EdgeShipmentGatewayDhl:
		return m.clearedshipment_gateway_dhl
	case shipmentgatewayconfig.EdgeShipmentGatewayFedex:
		return m.clearedshipment_gateway_fedex
	case shipmentgatewayconfig.EdgeShipmentGatewayUps:
		return m.clearedshipment_gateway_ups
	case shipmentgatewayconfig.EdgeShipmentGatewayUsps:
		return m.clearedshipment_gateway_usps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGatewayConfigMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgatewayconfig.EdgeShipmentGatewayConfigType:
		m.ClearShipmentGatewayConfigType()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayDhl:
		m.ClearShipmentGatewayDhl()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayFedex:
		m.ClearShipmentGatewayFedex()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayUps:
		m.ClearShipmentGatewayUps()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayUsps:
		m.ClearShipmentGatewayUsps()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGatewayConfigMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgatewayconfig.EdgeShipmentGatewayConfigType:
		m.ResetShipmentGatewayConfigType()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayDhl:
		m.ResetShipmentGatewayDhl()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayFedex:
		m.ResetShipmentGatewayFedex()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayUps:
		m.ResetShipmentGatewayUps()
		return nil
	case shipmentgatewayconfig.EdgeShipmentGatewayUsps:
		m.ResetShipmentGatewayUsps()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfig edge %s", name)
}

// ShipmentGatewayConfigTypeMutation represents an operation that mutates the ShipmentGatewayConfigType nodes in the graph.
type ShipmentGatewayConfigTypeMutation struct {
	config
	op                                           Op
	typ                                          string
	id                                           *int
	create_time                                  *time.Time
	update_time                                  *time.Time
	string_ref                                   *string
	has_table                                    *shipmentgatewayconfigtype.HasTable
	description                                  *string
	clearedFields                                map[string]struct{}
	parent                                       *int
	clearedparent                                bool
	children                                     map[int]struct{}
	removedchildren                              map[int]struct{}
	clearedchildren                              bool
	sibling_shipment_gateway_config_types        map[int]struct{}
	removedsibling_shipment_gateway_config_types map[int]struct{}
	clearedsibling_shipment_gateway_config_types bool
	shipment_gateway_configs                     map[int]struct{}
	removedshipment_gateway_configs              map[int]struct{}
	clearedshipment_gateway_configs              bool
	child_shipment_gateway_config_types          map[int]struct{}
	removedchild_shipment_gateway_config_types   map[int]struct{}
	clearedchild_shipment_gateway_config_types   bool
	done                                         bool
	oldValue                                     func(context.Context) (*ShipmentGatewayConfigType, error)
	predicates                                   []predicate.ShipmentGatewayConfigType
}

var _ ent.Mutation = (*ShipmentGatewayConfigTypeMutation)(nil)

// shipmentgatewayconfigtypeOption allows management of the mutation configuration using functional options.
type shipmentgatewayconfigtypeOption func(*ShipmentGatewayConfigTypeMutation)

// newShipmentGatewayConfigTypeMutation creates new mutation for the ShipmentGatewayConfigType entity.
func newShipmentGatewayConfigTypeMutation(c config, op Op, opts ...shipmentgatewayconfigtypeOption) *ShipmentGatewayConfigTypeMutation {
	m := &ShipmentGatewayConfigTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGatewayConfigType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGatewayConfigTypeID sets the ID field of the mutation.
func withShipmentGatewayConfigTypeID(id int) shipmentgatewayconfigtypeOption {
	return func(m *ShipmentGatewayConfigTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGatewayConfigType
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGatewayConfigType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGatewayConfigType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGatewayConfigType sets the old ShipmentGatewayConfigType of the mutation.
func withShipmentGatewayConfigType(node *ShipmentGatewayConfigType) shipmentgatewayconfigtypeOption {
	return func(m *ShipmentGatewayConfigTypeMutation) {
		m.oldValue = func(context.Context) (*ShipmentGatewayConfigType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGatewayConfigTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGatewayConfigTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGatewayConfigTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentGatewayConfigTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentGatewayConfigType entity.
// If the ShipmentGatewayConfigType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentGatewayConfigTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentGatewayConfigTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentGatewayConfigType entity.
// If the ShipmentGatewayConfigType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentGatewayConfigTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentGatewayConfigTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentGatewayConfigType entity.
// If the ShipmentGatewayConfigType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentGatewayConfigTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentgatewayconfigtype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayconfigtype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentGatewayConfigTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentgatewayconfigtype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ShipmentGatewayConfigTypeMutation) SetHasTable(st shipmentgatewayconfigtype.HasTable) {
	m.has_table = &st
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) HasTable() (r shipmentgatewayconfigtype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ShipmentGatewayConfigType entity.
// If the ShipmentGatewayConfigType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigTypeMutation) OldHasTable(ctx context.Context) (v shipmentgatewayconfigtype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ShipmentGatewayConfigTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[shipmentgatewayconfigtype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayconfigtype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ShipmentGatewayConfigTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, shipmentgatewayconfigtype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ShipmentGatewayConfigTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentGatewayConfigType entity.
// If the ShipmentGatewayConfigType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayConfigTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShipmentGatewayConfigTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shipmentgatewayconfigtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayconfigtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentGatewayConfigTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shipmentgatewayconfigtype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ShipmentGatewayConfigType entity by id.
func (m *ShipmentGatewayConfigTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ShipmentGatewayConfigType entity was cleared.
func (m *ShipmentGatewayConfigTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayConfigTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ShipmentGatewayConfigTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ShipmentGatewayConfigType entity by ids.
func (m *ShipmentGatewayConfigTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ShipmentGatewayConfigType entity was cleared.
func (m *ShipmentGatewayConfigTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ShipmentGatewayConfigType entity by IDs.
func (m *ShipmentGatewayConfigTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ShipmentGatewayConfigTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddSiblingShipmentGatewayConfigTypeIDs adds the "sibling_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity by ids.
func (m *ShipmentGatewayConfigTypeMutation) AddSiblingShipmentGatewayConfigTypeIDs(ids ...int) {
	if m.sibling_shipment_gateway_config_types == nil {
		m.sibling_shipment_gateway_config_types = make(map[int]struct{})
	}
	for i := range ids {
		m.sibling_shipment_gateway_config_types[ids[i]] = struct{}{}
	}
}

// ClearSiblingShipmentGatewayConfigTypes clears the "sibling_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) ClearSiblingShipmentGatewayConfigTypes() {
	m.clearedsibling_shipment_gateway_config_types = true
}

// SiblingShipmentGatewayConfigTypesCleared reports if the "sibling_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity was cleared.
func (m *ShipmentGatewayConfigTypeMutation) SiblingShipmentGatewayConfigTypesCleared() bool {
	return m.clearedsibling_shipment_gateway_config_types
}

// RemoveSiblingShipmentGatewayConfigTypeIDs removes the "sibling_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity by IDs.
func (m *ShipmentGatewayConfigTypeMutation) RemoveSiblingShipmentGatewayConfigTypeIDs(ids ...int) {
	if m.removedsibling_shipment_gateway_config_types == nil {
		m.removedsibling_shipment_gateway_config_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsibling_shipment_gateway_config_types[ids[i]] = struct{}{}
	}
}

// RemovedSiblingShipmentGatewayConfigTypes returns the removed IDs of the "sibling_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) RemovedSiblingShipmentGatewayConfigTypesIDs() (ids []int) {
	for id := range m.removedsibling_shipment_gateway_config_types {
		ids = append(ids, id)
	}
	return
}

// SiblingShipmentGatewayConfigTypesIDs returns the "sibling_shipment_gateway_config_types" edge IDs in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) SiblingShipmentGatewayConfigTypesIDs() (ids []int) {
	for id := range m.sibling_shipment_gateway_config_types {
		ids = append(ids, id)
	}
	return
}

// ResetSiblingShipmentGatewayConfigTypes resets all changes to the "sibling_shipment_gateway_config_types" edge.
func (m *ShipmentGatewayConfigTypeMutation) ResetSiblingShipmentGatewayConfigTypes() {
	m.sibling_shipment_gateway_config_types = nil
	m.clearedsibling_shipment_gateway_config_types = false
	m.removedsibling_shipment_gateway_config_types = nil
}

// AddShipmentGatewayConfigIDs adds the "shipment_gateway_configs" edge to the ShipmentGatewayConfig entity by ids.
func (m *ShipmentGatewayConfigTypeMutation) AddShipmentGatewayConfigIDs(ids ...int) {
	if m.shipment_gateway_configs == nil {
		m.shipment_gateway_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.shipment_gateway_configs[ids[i]] = struct{}{}
	}
}

// ClearShipmentGatewayConfigs clears the "shipment_gateway_configs" edge to the ShipmentGatewayConfig entity.
func (m *ShipmentGatewayConfigTypeMutation) ClearShipmentGatewayConfigs() {
	m.clearedshipment_gateway_configs = true
}

// ShipmentGatewayConfigsCleared reports if the "shipment_gateway_configs" edge to the ShipmentGatewayConfig entity was cleared.
func (m *ShipmentGatewayConfigTypeMutation) ShipmentGatewayConfigsCleared() bool {
	return m.clearedshipment_gateway_configs
}

// RemoveShipmentGatewayConfigIDs removes the "shipment_gateway_configs" edge to the ShipmentGatewayConfig entity by IDs.
func (m *ShipmentGatewayConfigTypeMutation) RemoveShipmentGatewayConfigIDs(ids ...int) {
	if m.removedshipment_gateway_configs == nil {
		m.removedshipment_gateway_configs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedshipment_gateway_configs[ids[i]] = struct{}{}
	}
}

// RemovedShipmentGatewayConfigs returns the removed IDs of the "shipment_gateway_configs" edge to the ShipmentGatewayConfig entity.
func (m *ShipmentGatewayConfigTypeMutation) RemovedShipmentGatewayConfigsIDs() (ids []int) {
	for id := range m.removedshipment_gateway_configs {
		ids = append(ids, id)
	}
	return
}

// ShipmentGatewayConfigsIDs returns the "shipment_gateway_configs" edge IDs in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) ShipmentGatewayConfigsIDs() (ids []int) {
	for id := range m.shipment_gateway_configs {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentGatewayConfigs resets all changes to the "shipment_gateway_configs" edge.
func (m *ShipmentGatewayConfigTypeMutation) ResetShipmentGatewayConfigs() {
	m.shipment_gateway_configs = nil
	m.clearedshipment_gateway_configs = false
	m.removedshipment_gateway_configs = nil
}

// AddChildShipmentGatewayConfigTypeIDs adds the "child_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity by ids.
func (m *ShipmentGatewayConfigTypeMutation) AddChildShipmentGatewayConfigTypeIDs(ids ...int) {
	if m.child_shipment_gateway_config_types == nil {
		m.child_shipment_gateway_config_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_shipment_gateway_config_types[ids[i]] = struct{}{}
	}
}

// ClearChildShipmentGatewayConfigTypes clears the "child_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) ClearChildShipmentGatewayConfigTypes() {
	m.clearedchild_shipment_gateway_config_types = true
}

// ChildShipmentGatewayConfigTypesCleared reports if the "child_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity was cleared.
func (m *ShipmentGatewayConfigTypeMutation) ChildShipmentGatewayConfigTypesCleared() bool {
	return m.clearedchild_shipment_gateway_config_types
}

// RemoveChildShipmentGatewayConfigTypeIDs removes the "child_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity by IDs.
func (m *ShipmentGatewayConfigTypeMutation) RemoveChildShipmentGatewayConfigTypeIDs(ids ...int) {
	if m.removedchild_shipment_gateway_config_types == nil {
		m.removedchild_shipment_gateway_config_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_shipment_gateway_config_types[ids[i]] = struct{}{}
	}
}

// RemovedChildShipmentGatewayConfigTypes returns the removed IDs of the "child_shipment_gateway_config_types" edge to the ShipmentGatewayConfigType entity.
func (m *ShipmentGatewayConfigTypeMutation) RemovedChildShipmentGatewayConfigTypesIDs() (ids []int) {
	for id := range m.removedchild_shipment_gateway_config_types {
		ids = append(ids, id)
	}
	return
}

// ChildShipmentGatewayConfigTypesIDs returns the "child_shipment_gateway_config_types" edge IDs in the mutation.
func (m *ShipmentGatewayConfigTypeMutation) ChildShipmentGatewayConfigTypesIDs() (ids []int) {
	for id := range m.child_shipment_gateway_config_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildShipmentGatewayConfigTypes resets all changes to the "child_shipment_gateway_config_types" edge.
func (m *ShipmentGatewayConfigTypeMutation) ResetChildShipmentGatewayConfigTypes() {
	m.child_shipment_gateway_config_types = nil
	m.clearedchild_shipment_gateway_config_types = false
	m.removedchild_shipment_gateway_config_types = nil
}

// Op returns the operation name.
func (m *ShipmentGatewayConfigTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentGatewayConfigType).
func (m *ShipmentGatewayConfigTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGatewayConfigTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, shipmentgatewayconfigtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentgatewayconfigtype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentgatewayconfigtype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, shipmentgatewayconfigtype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, shipmentgatewayconfigtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGatewayConfigTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayconfigtype.FieldCreateTime:
		return m.CreateTime()
	case shipmentgatewayconfigtype.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentgatewayconfigtype.FieldStringRef:
		return m.StringRef()
	case shipmentgatewayconfigtype.FieldHasTable:
		return m.HasTable()
	case shipmentgatewayconfigtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGatewayConfigTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgatewayconfigtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentgatewayconfigtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentgatewayconfigtype.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentgatewayconfigtype.FieldHasTable:
		return m.OldHasTable(ctx)
	case shipmentgatewayconfigtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGatewayConfigType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayConfigTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayconfigtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentgatewayconfigtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentgatewayconfigtype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentgatewayconfigtype.FieldHasTable:
		v, ok := value.(shipmentgatewayconfigtype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case shipmentgatewayconfigtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfigType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGatewayConfigTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGatewayConfigTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayConfigTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentGatewayConfigType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGatewayConfigTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentgatewayconfigtype.FieldStringRef) {
		fields = append(fields, shipmentgatewayconfigtype.FieldStringRef)
	}
	if m.FieldCleared(shipmentgatewayconfigtype.FieldHasTable) {
		fields = append(fields, shipmentgatewayconfigtype.FieldHasTable)
	}
	if m.FieldCleared(shipmentgatewayconfigtype.FieldDescription) {
		fields = append(fields, shipmentgatewayconfigtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGatewayConfigTypeMutation) ClearField(name string) error {
	switch name {
	case shipmentgatewayconfigtype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentgatewayconfigtype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case shipmentgatewayconfigtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfigType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGatewayConfigTypeMutation) ResetField(name string) error {
	switch name {
	case shipmentgatewayconfigtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentgatewayconfigtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentgatewayconfigtype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentgatewayconfigtype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case shipmentgatewayconfigtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfigType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.parent != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeChildren)
	}
	if m.sibling_shipment_gateway_config_types != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes)
	}
	if m.shipment_gateway_configs != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs)
	}
	if m.child_shipment_gateway_config_types != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewayconfigtype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case shipmentgatewayconfigtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes:
		ids := make([]ent.Value, 0, len(m.sibling_shipment_gateway_config_types))
		for id := range m.sibling_shipment_gateway_config_types {
			ids = append(ids, id)
		}
		return ids
	case shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs:
		ids := make([]ent.Value, 0, len(m.shipment_gateway_configs))
		for id := range m.shipment_gateway_configs {
			ids = append(ids, id)
		}
		return ids
	case shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes:
		ids := make([]ent.Value, 0, len(m.child_shipment_gateway_config_types))
		for id := range m.child_shipment_gateway_config_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeChildren)
	}
	if m.removedsibling_shipment_gateway_config_types != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes)
	}
	if m.removedshipment_gateway_configs != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs)
	}
	if m.removedchild_shipment_gateway_config_types != nil {
		edges = append(edges, shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewayconfigtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes:
		ids := make([]ent.Value, 0, len(m.removedsibling_shipment_gateway_config_types))
		for id := range m.removedsibling_shipment_gateway_config_types {
			ids = append(ids, id)
		}
		return ids
	case shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs:
		ids := make([]ent.Value, 0, len(m.removedshipment_gateway_configs))
		for id := range m.removedshipment_gateway_configs {
			ids = append(ids, id)
		}
		return ids
	case shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_shipment_gateway_config_types))
		for id := range m.removedchild_shipment_gateway_config_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedparent {
		edges = append(edges, shipmentgatewayconfigtype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, shipmentgatewayconfigtype.EdgeChildren)
	}
	if m.clearedsibling_shipment_gateway_config_types {
		edges = append(edges, shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes)
	}
	if m.clearedshipment_gateway_configs {
		edges = append(edges, shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs)
	}
	if m.clearedchild_shipment_gateway_config_types {
		edges = append(edges, shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGatewayConfigTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgatewayconfigtype.EdgeParent:
		return m.clearedparent
	case shipmentgatewayconfigtype.EdgeChildren:
		return m.clearedchildren
	case shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes:
		return m.clearedsibling_shipment_gateway_config_types
	case shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs:
		return m.clearedshipment_gateway_configs
	case shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes:
		return m.clearedchild_shipment_gateway_config_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGatewayConfigTypeMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgatewayconfigtype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfigType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGatewayConfigTypeMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgatewayconfigtype.EdgeParent:
		m.ResetParent()
		return nil
	case shipmentgatewayconfigtype.EdgeChildren:
		m.ResetChildren()
		return nil
	case shipmentgatewayconfigtype.EdgeSiblingShipmentGatewayConfigTypes:
		m.ResetSiblingShipmentGatewayConfigTypes()
		return nil
	case shipmentgatewayconfigtype.EdgeShipmentGatewayConfigs:
		m.ResetShipmentGatewayConfigs()
		return nil
	case shipmentgatewayconfigtype.EdgeChildShipmentGatewayConfigTypes:
		m.ResetChildShipmentGatewayConfigTypes()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayConfigType edge %s", name)
}

// ShipmentGatewayDhlMutation represents an operation that mutates the ShipmentGatewayDhl nodes in the graph.
type ShipmentGatewayDhlMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	create_time                    *time.Time
	update_time                    *time.Time
	string_ref                     *string
	connect_url                    *string
	connect_timeout                *int
	addconnect_timeout             *int
	head_version                   *string
	head_action                    *string
	access_user_id                 *string
	access_password                *string
	access_account_nbr             *string
	access_shipping_key            *string
	label_image_format             *string
	rate_estimate_template         *string
	clearedFields                  map[string]struct{}
	shipment_gateway_config        *int
	clearedshipment_gateway_config bool
	done                           bool
	oldValue                       func(context.Context) (*ShipmentGatewayDhl, error)
	predicates                     []predicate.ShipmentGatewayDhl
}

var _ ent.Mutation = (*ShipmentGatewayDhlMutation)(nil)

// shipmentgatewaydhlOption allows management of the mutation configuration using functional options.
type shipmentgatewaydhlOption func(*ShipmentGatewayDhlMutation)

// newShipmentGatewayDhlMutation creates new mutation for the ShipmentGatewayDhl entity.
func newShipmentGatewayDhlMutation(c config, op Op, opts ...shipmentgatewaydhlOption) *ShipmentGatewayDhlMutation {
	m := &ShipmentGatewayDhlMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGatewayDhl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGatewayDhlID sets the ID field of the mutation.
func withShipmentGatewayDhlID(id int) shipmentgatewaydhlOption {
	return func(m *ShipmentGatewayDhlMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGatewayDhl
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGatewayDhl, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGatewayDhl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGatewayDhl sets the old ShipmentGatewayDhl of the mutation.
func withShipmentGatewayDhl(node *ShipmentGatewayDhl) shipmentgatewaydhlOption {
	return func(m *ShipmentGatewayDhlMutation) {
		m.oldValue = func(context.Context) (*ShipmentGatewayDhl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGatewayDhlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGatewayDhlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGatewayDhlMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentGatewayDhlMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentGatewayDhlMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentGatewayDhlMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentGatewayDhlMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentGatewayDhlMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentGatewayDhlMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentGatewayDhlMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentGatewayDhlMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentGatewayDhlMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentgatewaydhl.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentGatewayDhlMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldStringRef)
}

// SetConnectURL sets the "connect_url" field.
func (m *ShipmentGatewayDhlMutation) SetConnectURL(s string) {
	m.connect_url = &s
}

// ConnectURL returns the value of the "connect_url" field in the mutation.
func (m *ShipmentGatewayDhlMutation) ConnectURL() (r string, exists bool) {
	v := m.connect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectURL returns the old "connect_url" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldConnectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectURL: %w", err)
	}
	return oldValue.ConnectURL, nil
}

// ClearConnectURL clears the value of the "connect_url" field.
func (m *ShipmentGatewayDhlMutation) ClearConnectURL() {
	m.connect_url = nil
	m.clearedFields[shipmentgatewaydhl.FieldConnectURL] = struct{}{}
}

// ConnectURLCleared returns if the "connect_url" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) ConnectURLCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldConnectURL]
	return ok
}

// ResetConnectURL resets all changes to the "connect_url" field.
func (m *ShipmentGatewayDhlMutation) ResetConnectURL() {
	m.connect_url = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldConnectURL)
}

// SetConnectTimeout sets the "connect_timeout" field.
func (m *ShipmentGatewayDhlMutation) SetConnectTimeout(i int) {
	m.connect_timeout = &i
	m.addconnect_timeout = nil
}

// ConnectTimeout returns the value of the "connect_timeout" field in the mutation.
func (m *ShipmentGatewayDhlMutation) ConnectTimeout() (r int, exists bool) {
	v := m.connect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectTimeout returns the old "connect_timeout" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldConnectTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectTimeout: %w", err)
	}
	return oldValue.ConnectTimeout, nil
}

// AddConnectTimeout adds i to the "connect_timeout" field.
func (m *ShipmentGatewayDhlMutation) AddConnectTimeout(i int) {
	if m.addconnect_timeout != nil {
		*m.addconnect_timeout += i
	} else {
		m.addconnect_timeout = &i
	}
}

// AddedConnectTimeout returns the value that was added to the "connect_timeout" field in this mutation.
func (m *ShipmentGatewayDhlMutation) AddedConnectTimeout() (r int, exists bool) {
	v := m.addconnect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearConnectTimeout clears the value of the "connect_timeout" field.
func (m *ShipmentGatewayDhlMutation) ClearConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	m.clearedFields[shipmentgatewaydhl.FieldConnectTimeout] = struct{}{}
}

// ConnectTimeoutCleared returns if the "connect_timeout" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) ConnectTimeoutCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldConnectTimeout]
	return ok
}

// ResetConnectTimeout resets all changes to the "connect_timeout" field.
func (m *ShipmentGatewayDhlMutation) ResetConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldConnectTimeout)
}

// SetHeadVersion sets the "head_version" field.
func (m *ShipmentGatewayDhlMutation) SetHeadVersion(s string) {
	m.head_version = &s
}

// HeadVersion returns the value of the "head_version" field in the mutation.
func (m *ShipmentGatewayDhlMutation) HeadVersion() (r string, exists bool) {
	v := m.head_version
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadVersion returns the old "head_version" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldHeadVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeadVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeadVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadVersion: %w", err)
	}
	return oldValue.HeadVersion, nil
}

// ClearHeadVersion clears the value of the "head_version" field.
func (m *ShipmentGatewayDhlMutation) ClearHeadVersion() {
	m.head_version = nil
	m.clearedFields[shipmentgatewaydhl.FieldHeadVersion] = struct{}{}
}

// HeadVersionCleared returns if the "head_version" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) HeadVersionCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldHeadVersion]
	return ok
}

// ResetHeadVersion resets all changes to the "head_version" field.
func (m *ShipmentGatewayDhlMutation) ResetHeadVersion() {
	m.head_version = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldHeadVersion)
}

// SetHeadAction sets the "head_action" field.
func (m *ShipmentGatewayDhlMutation) SetHeadAction(s string) {
	m.head_action = &s
}

// HeadAction returns the value of the "head_action" field in the mutation.
func (m *ShipmentGatewayDhlMutation) HeadAction() (r string, exists bool) {
	v := m.head_action
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadAction returns the old "head_action" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldHeadAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeadAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeadAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadAction: %w", err)
	}
	return oldValue.HeadAction, nil
}

// ClearHeadAction clears the value of the "head_action" field.
func (m *ShipmentGatewayDhlMutation) ClearHeadAction() {
	m.head_action = nil
	m.clearedFields[shipmentgatewaydhl.FieldHeadAction] = struct{}{}
}

// HeadActionCleared returns if the "head_action" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) HeadActionCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldHeadAction]
	return ok
}

// ResetHeadAction resets all changes to the "head_action" field.
func (m *ShipmentGatewayDhlMutation) ResetHeadAction() {
	m.head_action = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldHeadAction)
}

// SetAccessUserID sets the "access_user_id" field.
func (m *ShipmentGatewayDhlMutation) SetAccessUserID(s string) {
	m.access_user_id = &s
}

// AccessUserID returns the value of the "access_user_id" field in the mutation.
func (m *ShipmentGatewayDhlMutation) AccessUserID() (r string, exists bool) {
	v := m.access_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessUserID returns the old "access_user_id" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldAccessUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessUserID: %w", err)
	}
	return oldValue.AccessUserID, nil
}

// ClearAccessUserID clears the value of the "access_user_id" field.
func (m *ShipmentGatewayDhlMutation) ClearAccessUserID() {
	m.access_user_id = nil
	m.clearedFields[shipmentgatewaydhl.FieldAccessUserID] = struct{}{}
}

// AccessUserIDCleared returns if the "access_user_id" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) AccessUserIDCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldAccessUserID]
	return ok
}

// ResetAccessUserID resets all changes to the "access_user_id" field.
func (m *ShipmentGatewayDhlMutation) ResetAccessUserID() {
	m.access_user_id = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldAccessUserID)
}

// SetAccessPassword sets the "access_password" field.
func (m *ShipmentGatewayDhlMutation) SetAccessPassword(s string) {
	m.access_password = &s
}

// AccessPassword returns the value of the "access_password" field in the mutation.
func (m *ShipmentGatewayDhlMutation) AccessPassword() (r string, exists bool) {
	v := m.access_password
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessPassword returns the old "access_password" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldAccessPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessPassword: %w", err)
	}
	return oldValue.AccessPassword, nil
}

// ClearAccessPassword clears the value of the "access_password" field.
func (m *ShipmentGatewayDhlMutation) ClearAccessPassword() {
	m.access_password = nil
	m.clearedFields[shipmentgatewaydhl.FieldAccessPassword] = struct{}{}
}

// AccessPasswordCleared returns if the "access_password" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) AccessPasswordCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldAccessPassword]
	return ok
}

// ResetAccessPassword resets all changes to the "access_password" field.
func (m *ShipmentGatewayDhlMutation) ResetAccessPassword() {
	m.access_password = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldAccessPassword)
}

// SetAccessAccountNbr sets the "access_account_nbr" field.
func (m *ShipmentGatewayDhlMutation) SetAccessAccountNbr(s string) {
	m.access_account_nbr = &s
}

// AccessAccountNbr returns the value of the "access_account_nbr" field in the mutation.
func (m *ShipmentGatewayDhlMutation) AccessAccountNbr() (r string, exists bool) {
	v := m.access_account_nbr
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessAccountNbr returns the old "access_account_nbr" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldAccessAccountNbr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessAccountNbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessAccountNbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessAccountNbr: %w", err)
	}
	return oldValue.AccessAccountNbr, nil
}

// ClearAccessAccountNbr clears the value of the "access_account_nbr" field.
func (m *ShipmentGatewayDhlMutation) ClearAccessAccountNbr() {
	m.access_account_nbr = nil
	m.clearedFields[shipmentgatewaydhl.FieldAccessAccountNbr] = struct{}{}
}

// AccessAccountNbrCleared returns if the "access_account_nbr" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) AccessAccountNbrCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldAccessAccountNbr]
	return ok
}

// ResetAccessAccountNbr resets all changes to the "access_account_nbr" field.
func (m *ShipmentGatewayDhlMutation) ResetAccessAccountNbr() {
	m.access_account_nbr = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldAccessAccountNbr)
}

// SetAccessShippingKey sets the "access_shipping_key" field.
func (m *ShipmentGatewayDhlMutation) SetAccessShippingKey(s string) {
	m.access_shipping_key = &s
}

// AccessShippingKey returns the value of the "access_shipping_key" field in the mutation.
func (m *ShipmentGatewayDhlMutation) AccessShippingKey() (r string, exists bool) {
	v := m.access_shipping_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessShippingKey returns the old "access_shipping_key" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldAccessShippingKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessShippingKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessShippingKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessShippingKey: %w", err)
	}
	return oldValue.AccessShippingKey, nil
}

// ClearAccessShippingKey clears the value of the "access_shipping_key" field.
func (m *ShipmentGatewayDhlMutation) ClearAccessShippingKey() {
	m.access_shipping_key = nil
	m.clearedFields[shipmentgatewaydhl.FieldAccessShippingKey] = struct{}{}
}

// AccessShippingKeyCleared returns if the "access_shipping_key" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) AccessShippingKeyCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldAccessShippingKey]
	return ok
}

// ResetAccessShippingKey resets all changes to the "access_shipping_key" field.
func (m *ShipmentGatewayDhlMutation) ResetAccessShippingKey() {
	m.access_shipping_key = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldAccessShippingKey)
}

// SetLabelImageFormat sets the "label_image_format" field.
func (m *ShipmentGatewayDhlMutation) SetLabelImageFormat(s string) {
	m.label_image_format = &s
}

// LabelImageFormat returns the value of the "label_image_format" field in the mutation.
func (m *ShipmentGatewayDhlMutation) LabelImageFormat() (r string, exists bool) {
	v := m.label_image_format
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelImageFormat returns the old "label_image_format" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldLabelImageFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabelImageFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabelImageFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelImageFormat: %w", err)
	}
	return oldValue.LabelImageFormat, nil
}

// ClearLabelImageFormat clears the value of the "label_image_format" field.
func (m *ShipmentGatewayDhlMutation) ClearLabelImageFormat() {
	m.label_image_format = nil
	m.clearedFields[shipmentgatewaydhl.FieldLabelImageFormat] = struct{}{}
}

// LabelImageFormatCleared returns if the "label_image_format" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) LabelImageFormatCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldLabelImageFormat]
	return ok
}

// ResetLabelImageFormat resets all changes to the "label_image_format" field.
func (m *ShipmentGatewayDhlMutation) ResetLabelImageFormat() {
	m.label_image_format = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldLabelImageFormat)
}

// SetRateEstimateTemplate sets the "rate_estimate_template" field.
func (m *ShipmentGatewayDhlMutation) SetRateEstimateTemplate(s string) {
	m.rate_estimate_template = &s
}

// RateEstimateTemplate returns the value of the "rate_estimate_template" field in the mutation.
func (m *ShipmentGatewayDhlMutation) RateEstimateTemplate() (r string, exists bool) {
	v := m.rate_estimate_template
	if v == nil {
		return
	}
	return *v, true
}

// OldRateEstimateTemplate returns the old "rate_estimate_template" field's value of the ShipmentGatewayDhl entity.
// If the ShipmentGatewayDhl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayDhlMutation) OldRateEstimateTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRateEstimateTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRateEstimateTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateEstimateTemplate: %w", err)
	}
	return oldValue.RateEstimateTemplate, nil
}

// ClearRateEstimateTemplate clears the value of the "rate_estimate_template" field.
func (m *ShipmentGatewayDhlMutation) ClearRateEstimateTemplate() {
	m.rate_estimate_template = nil
	m.clearedFields[shipmentgatewaydhl.FieldRateEstimateTemplate] = struct{}{}
}

// RateEstimateTemplateCleared returns if the "rate_estimate_template" field was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) RateEstimateTemplateCleared() bool {
	_, ok := m.clearedFields[shipmentgatewaydhl.FieldRateEstimateTemplate]
	return ok
}

// ResetRateEstimateTemplate resets all changes to the "rate_estimate_template" field.
func (m *ShipmentGatewayDhlMutation) ResetRateEstimateTemplate() {
	m.rate_estimate_template = nil
	delete(m.clearedFields, shipmentgatewaydhl.FieldRateEstimateTemplate)
}

// SetShipmentGatewayConfigID sets the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity by id.
func (m *ShipmentGatewayDhlMutation) SetShipmentGatewayConfigID(id int) {
	m.shipment_gateway_config = &id
}

// ClearShipmentGatewayConfig clears the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity.
func (m *ShipmentGatewayDhlMutation) ClearShipmentGatewayConfig() {
	m.clearedshipment_gateway_config = true
}

// ShipmentGatewayConfigCleared reports if the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity was cleared.
func (m *ShipmentGatewayDhlMutation) ShipmentGatewayConfigCleared() bool {
	return m.clearedshipment_gateway_config
}

// ShipmentGatewayConfigID returns the "shipment_gateway_config" edge ID in the mutation.
func (m *ShipmentGatewayDhlMutation) ShipmentGatewayConfigID() (id int, exists bool) {
	if m.shipment_gateway_config != nil {
		return *m.shipment_gateway_config, true
	}
	return
}

// ShipmentGatewayConfigIDs returns the "shipment_gateway_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayConfigID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayDhlMutation) ShipmentGatewayConfigIDs() (ids []int) {
	if id := m.shipment_gateway_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayConfig resets all changes to the "shipment_gateway_config" edge.
func (m *ShipmentGatewayDhlMutation) ResetShipmentGatewayConfig() {
	m.shipment_gateway_config = nil
	m.clearedshipment_gateway_config = false
}

// Op returns the operation name.
func (m *ShipmentGatewayDhlMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentGatewayDhl).
func (m *ShipmentGatewayDhlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGatewayDhlMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, shipmentgatewaydhl.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentgatewaydhl.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentgatewaydhl.FieldStringRef)
	}
	if m.connect_url != nil {
		fields = append(fields, shipmentgatewaydhl.FieldConnectURL)
	}
	if m.connect_timeout != nil {
		fields = append(fields, shipmentgatewaydhl.FieldConnectTimeout)
	}
	if m.head_version != nil {
		fields = append(fields, shipmentgatewaydhl.FieldHeadVersion)
	}
	if m.head_action != nil {
		fields = append(fields, shipmentgatewaydhl.FieldHeadAction)
	}
	if m.access_user_id != nil {
		fields = append(fields, shipmentgatewaydhl.FieldAccessUserID)
	}
	if m.access_password != nil {
		fields = append(fields, shipmentgatewaydhl.FieldAccessPassword)
	}
	if m.access_account_nbr != nil {
		fields = append(fields, shipmentgatewaydhl.FieldAccessAccountNbr)
	}
	if m.access_shipping_key != nil {
		fields = append(fields, shipmentgatewaydhl.FieldAccessShippingKey)
	}
	if m.label_image_format != nil {
		fields = append(fields, shipmentgatewaydhl.FieldLabelImageFormat)
	}
	if m.rate_estimate_template != nil {
		fields = append(fields, shipmentgatewaydhl.FieldRateEstimateTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGatewayDhlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewaydhl.FieldCreateTime:
		return m.CreateTime()
	case shipmentgatewaydhl.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentgatewaydhl.FieldStringRef:
		return m.StringRef()
	case shipmentgatewaydhl.FieldConnectURL:
		return m.ConnectURL()
	case shipmentgatewaydhl.FieldConnectTimeout:
		return m.ConnectTimeout()
	case shipmentgatewaydhl.FieldHeadVersion:
		return m.HeadVersion()
	case shipmentgatewaydhl.FieldHeadAction:
		return m.HeadAction()
	case shipmentgatewaydhl.FieldAccessUserID:
		return m.AccessUserID()
	case shipmentgatewaydhl.FieldAccessPassword:
		return m.AccessPassword()
	case shipmentgatewaydhl.FieldAccessAccountNbr:
		return m.AccessAccountNbr()
	case shipmentgatewaydhl.FieldAccessShippingKey:
		return m.AccessShippingKey()
	case shipmentgatewaydhl.FieldLabelImageFormat:
		return m.LabelImageFormat()
	case shipmentgatewaydhl.FieldRateEstimateTemplate:
		return m.RateEstimateTemplate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGatewayDhlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgatewaydhl.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentgatewaydhl.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentgatewaydhl.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentgatewaydhl.FieldConnectURL:
		return m.OldConnectURL(ctx)
	case shipmentgatewaydhl.FieldConnectTimeout:
		return m.OldConnectTimeout(ctx)
	case shipmentgatewaydhl.FieldHeadVersion:
		return m.OldHeadVersion(ctx)
	case shipmentgatewaydhl.FieldHeadAction:
		return m.OldHeadAction(ctx)
	case shipmentgatewaydhl.FieldAccessUserID:
		return m.OldAccessUserID(ctx)
	case shipmentgatewaydhl.FieldAccessPassword:
		return m.OldAccessPassword(ctx)
	case shipmentgatewaydhl.FieldAccessAccountNbr:
		return m.OldAccessAccountNbr(ctx)
	case shipmentgatewaydhl.FieldAccessShippingKey:
		return m.OldAccessShippingKey(ctx)
	case shipmentgatewaydhl.FieldLabelImageFormat:
		return m.OldLabelImageFormat(ctx)
	case shipmentgatewaydhl.FieldRateEstimateTemplate:
		return m.OldRateEstimateTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGatewayDhl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayDhlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewaydhl.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentgatewaydhl.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentgatewaydhl.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentgatewaydhl.FieldConnectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectURL(v)
		return nil
	case shipmentgatewaydhl.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectTimeout(v)
		return nil
	case shipmentgatewaydhl.FieldHeadVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadVersion(v)
		return nil
	case shipmentgatewaydhl.FieldHeadAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadAction(v)
		return nil
	case shipmentgatewaydhl.FieldAccessUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessUserID(v)
		return nil
	case shipmentgatewaydhl.FieldAccessPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessPassword(v)
		return nil
	case shipmentgatewaydhl.FieldAccessAccountNbr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessAccountNbr(v)
		return nil
	case shipmentgatewaydhl.FieldAccessShippingKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessShippingKey(v)
		return nil
	case shipmentgatewaydhl.FieldLabelImageFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelImageFormat(v)
		return nil
	case shipmentgatewaydhl.FieldRateEstimateTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateEstimateTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayDhl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGatewayDhlMutation) AddedFields() []string {
	var fields []string
	if m.addconnect_timeout != nil {
		fields = append(fields, shipmentgatewaydhl.FieldConnectTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGatewayDhlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewaydhl.FieldConnectTimeout:
		return m.AddedConnectTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayDhlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewaydhl.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnectTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayDhl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGatewayDhlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentgatewaydhl.FieldStringRef) {
		fields = append(fields, shipmentgatewaydhl.FieldStringRef)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldConnectURL) {
		fields = append(fields, shipmentgatewaydhl.FieldConnectURL)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldConnectTimeout) {
		fields = append(fields, shipmentgatewaydhl.FieldConnectTimeout)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldHeadVersion) {
		fields = append(fields, shipmentgatewaydhl.FieldHeadVersion)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldHeadAction) {
		fields = append(fields, shipmentgatewaydhl.FieldHeadAction)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldAccessUserID) {
		fields = append(fields, shipmentgatewaydhl.FieldAccessUserID)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldAccessPassword) {
		fields = append(fields, shipmentgatewaydhl.FieldAccessPassword)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldAccessAccountNbr) {
		fields = append(fields, shipmentgatewaydhl.FieldAccessAccountNbr)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldAccessShippingKey) {
		fields = append(fields, shipmentgatewaydhl.FieldAccessShippingKey)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldLabelImageFormat) {
		fields = append(fields, shipmentgatewaydhl.FieldLabelImageFormat)
	}
	if m.FieldCleared(shipmentgatewaydhl.FieldRateEstimateTemplate) {
		fields = append(fields, shipmentgatewaydhl.FieldRateEstimateTemplate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGatewayDhlMutation) ClearField(name string) error {
	switch name {
	case shipmentgatewaydhl.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentgatewaydhl.FieldConnectURL:
		m.ClearConnectURL()
		return nil
	case shipmentgatewaydhl.FieldConnectTimeout:
		m.ClearConnectTimeout()
		return nil
	case shipmentgatewaydhl.FieldHeadVersion:
		m.ClearHeadVersion()
		return nil
	case shipmentgatewaydhl.FieldHeadAction:
		m.ClearHeadAction()
		return nil
	case shipmentgatewaydhl.FieldAccessUserID:
		m.ClearAccessUserID()
		return nil
	case shipmentgatewaydhl.FieldAccessPassword:
		m.ClearAccessPassword()
		return nil
	case shipmentgatewaydhl.FieldAccessAccountNbr:
		m.ClearAccessAccountNbr()
		return nil
	case shipmentgatewaydhl.FieldAccessShippingKey:
		m.ClearAccessShippingKey()
		return nil
	case shipmentgatewaydhl.FieldLabelImageFormat:
		m.ClearLabelImageFormat()
		return nil
	case shipmentgatewaydhl.FieldRateEstimateTemplate:
		m.ClearRateEstimateTemplate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayDhl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGatewayDhlMutation) ResetField(name string) error {
	switch name {
	case shipmentgatewaydhl.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentgatewaydhl.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentgatewaydhl.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentgatewaydhl.FieldConnectURL:
		m.ResetConnectURL()
		return nil
	case shipmentgatewaydhl.FieldConnectTimeout:
		m.ResetConnectTimeout()
		return nil
	case shipmentgatewaydhl.FieldHeadVersion:
		m.ResetHeadVersion()
		return nil
	case shipmentgatewaydhl.FieldHeadAction:
		m.ResetHeadAction()
		return nil
	case shipmentgatewaydhl.FieldAccessUserID:
		m.ResetAccessUserID()
		return nil
	case shipmentgatewaydhl.FieldAccessPassword:
		m.ResetAccessPassword()
		return nil
	case shipmentgatewaydhl.FieldAccessAccountNbr:
		m.ResetAccessAccountNbr()
		return nil
	case shipmentgatewaydhl.FieldAccessShippingKey:
		m.ResetAccessShippingKey()
		return nil
	case shipmentgatewaydhl.FieldLabelImageFormat:
		m.ResetLabelImageFormat()
		return nil
	case shipmentgatewaydhl.FieldRateEstimateTemplate:
		m.ResetRateEstimateTemplate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayDhl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGatewayDhlMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.shipment_gateway_config != nil {
		edges = append(edges, shipmentgatewaydhl.EdgeShipmentGatewayConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGatewayDhlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewaydhl.EdgeShipmentGatewayConfig:
		if id := m.shipment_gateway_config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGatewayDhlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGatewayDhlMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshipment_gateway_config {
		edges = append(edges, shipmentgatewaydhl.EdgeShipmentGatewayConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGatewayDhlMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgatewaydhl.EdgeShipmentGatewayConfig:
		return m.clearedshipment_gateway_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGatewayDhlMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgatewaydhl.EdgeShipmentGatewayConfig:
		m.ClearShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayDhl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGatewayDhlMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgatewaydhl.EdgeShipmentGatewayConfig:
		m.ResetShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayDhl edge %s", name)
}

// ShipmentGatewayFedexMutation represents an operation that mutates the ShipmentGatewayFedex nodes in the graph.
type ShipmentGatewayFedexMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	create_time                    *time.Time
	update_time                    *time.Time
	string_ref                     *string
	connect_url                    *string
	connect_soap_url               *string
	connect_timeout                *int
	addconnect_timeout             *int
	access_account_nbr             *string
	access_meter_number            *string
	access_user_key                *string
	access_user_pwd                *string
	label_image_type               *string
	default_dropoff_type           *string
	default_packaging_type         *string
	template_shipment              *string
	template_subscription          *string
	rate_estimate_template         *string
	clearedFields                  map[string]struct{}
	shipment_gateway_config        *int
	clearedshipment_gateway_config bool
	done                           bool
	oldValue                       func(context.Context) (*ShipmentGatewayFedex, error)
	predicates                     []predicate.ShipmentGatewayFedex
}

var _ ent.Mutation = (*ShipmentGatewayFedexMutation)(nil)

// shipmentgatewayfedexOption allows management of the mutation configuration using functional options.
type shipmentgatewayfedexOption func(*ShipmentGatewayFedexMutation)

// newShipmentGatewayFedexMutation creates new mutation for the ShipmentGatewayFedex entity.
func newShipmentGatewayFedexMutation(c config, op Op, opts ...shipmentgatewayfedexOption) *ShipmentGatewayFedexMutation {
	m := &ShipmentGatewayFedexMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGatewayFedex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGatewayFedexID sets the ID field of the mutation.
func withShipmentGatewayFedexID(id int) shipmentgatewayfedexOption {
	return func(m *ShipmentGatewayFedexMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGatewayFedex
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGatewayFedex, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGatewayFedex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGatewayFedex sets the old ShipmentGatewayFedex of the mutation.
func withShipmentGatewayFedex(node *ShipmentGatewayFedex) shipmentgatewayfedexOption {
	return func(m *ShipmentGatewayFedexMutation) {
		m.oldValue = func(context.Context) (*ShipmentGatewayFedex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGatewayFedexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGatewayFedexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGatewayFedexMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentGatewayFedexMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentGatewayFedexMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentGatewayFedexMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentGatewayFedexMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentGatewayFedexMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentGatewayFedexMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentGatewayFedexMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentGatewayFedexMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentGatewayFedexMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentgatewayfedex.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentGatewayFedexMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldStringRef)
}

// SetConnectURL sets the "connect_url" field.
func (m *ShipmentGatewayFedexMutation) SetConnectURL(s string) {
	m.connect_url = &s
}

// ConnectURL returns the value of the "connect_url" field in the mutation.
func (m *ShipmentGatewayFedexMutation) ConnectURL() (r string, exists bool) {
	v := m.connect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectURL returns the old "connect_url" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldConnectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectURL: %w", err)
	}
	return oldValue.ConnectURL, nil
}

// ClearConnectURL clears the value of the "connect_url" field.
func (m *ShipmentGatewayFedexMutation) ClearConnectURL() {
	m.connect_url = nil
	m.clearedFields[shipmentgatewayfedex.FieldConnectURL] = struct{}{}
}

// ConnectURLCleared returns if the "connect_url" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) ConnectURLCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldConnectURL]
	return ok
}

// ResetConnectURL resets all changes to the "connect_url" field.
func (m *ShipmentGatewayFedexMutation) ResetConnectURL() {
	m.connect_url = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldConnectURL)
}

// SetConnectSoapURL sets the "connect_soap_url" field.
func (m *ShipmentGatewayFedexMutation) SetConnectSoapURL(s string) {
	m.connect_soap_url = &s
}

// ConnectSoapURL returns the value of the "connect_soap_url" field in the mutation.
func (m *ShipmentGatewayFedexMutation) ConnectSoapURL() (r string, exists bool) {
	v := m.connect_soap_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectSoapURL returns the old "connect_soap_url" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldConnectSoapURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectSoapURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectSoapURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectSoapURL: %w", err)
	}
	return oldValue.ConnectSoapURL, nil
}

// ClearConnectSoapURL clears the value of the "connect_soap_url" field.
func (m *ShipmentGatewayFedexMutation) ClearConnectSoapURL() {
	m.connect_soap_url = nil
	m.clearedFields[shipmentgatewayfedex.FieldConnectSoapURL] = struct{}{}
}

// ConnectSoapURLCleared returns if the "connect_soap_url" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) ConnectSoapURLCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldConnectSoapURL]
	return ok
}

// ResetConnectSoapURL resets all changes to the "connect_soap_url" field.
func (m *ShipmentGatewayFedexMutation) ResetConnectSoapURL() {
	m.connect_soap_url = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldConnectSoapURL)
}

// SetConnectTimeout sets the "connect_timeout" field.
func (m *ShipmentGatewayFedexMutation) SetConnectTimeout(i int) {
	m.connect_timeout = &i
	m.addconnect_timeout = nil
}

// ConnectTimeout returns the value of the "connect_timeout" field in the mutation.
func (m *ShipmentGatewayFedexMutation) ConnectTimeout() (r int, exists bool) {
	v := m.connect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectTimeout returns the old "connect_timeout" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldConnectTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectTimeout: %w", err)
	}
	return oldValue.ConnectTimeout, nil
}

// AddConnectTimeout adds i to the "connect_timeout" field.
func (m *ShipmentGatewayFedexMutation) AddConnectTimeout(i int) {
	if m.addconnect_timeout != nil {
		*m.addconnect_timeout += i
	} else {
		m.addconnect_timeout = &i
	}
}

// AddedConnectTimeout returns the value that was added to the "connect_timeout" field in this mutation.
func (m *ShipmentGatewayFedexMutation) AddedConnectTimeout() (r int, exists bool) {
	v := m.addconnect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearConnectTimeout clears the value of the "connect_timeout" field.
func (m *ShipmentGatewayFedexMutation) ClearConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	m.clearedFields[shipmentgatewayfedex.FieldConnectTimeout] = struct{}{}
}

// ConnectTimeoutCleared returns if the "connect_timeout" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) ConnectTimeoutCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldConnectTimeout]
	return ok
}

// ResetConnectTimeout resets all changes to the "connect_timeout" field.
func (m *ShipmentGatewayFedexMutation) ResetConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldConnectTimeout)
}

// SetAccessAccountNbr sets the "access_account_nbr" field.
func (m *ShipmentGatewayFedexMutation) SetAccessAccountNbr(s string) {
	m.access_account_nbr = &s
}

// AccessAccountNbr returns the value of the "access_account_nbr" field in the mutation.
func (m *ShipmentGatewayFedexMutation) AccessAccountNbr() (r string, exists bool) {
	v := m.access_account_nbr
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessAccountNbr returns the old "access_account_nbr" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldAccessAccountNbr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessAccountNbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessAccountNbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessAccountNbr: %w", err)
	}
	return oldValue.AccessAccountNbr, nil
}

// ClearAccessAccountNbr clears the value of the "access_account_nbr" field.
func (m *ShipmentGatewayFedexMutation) ClearAccessAccountNbr() {
	m.access_account_nbr = nil
	m.clearedFields[shipmentgatewayfedex.FieldAccessAccountNbr] = struct{}{}
}

// AccessAccountNbrCleared returns if the "access_account_nbr" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) AccessAccountNbrCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldAccessAccountNbr]
	return ok
}

// ResetAccessAccountNbr resets all changes to the "access_account_nbr" field.
func (m *ShipmentGatewayFedexMutation) ResetAccessAccountNbr() {
	m.access_account_nbr = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldAccessAccountNbr)
}

// SetAccessMeterNumber sets the "access_meter_number" field.
func (m *ShipmentGatewayFedexMutation) SetAccessMeterNumber(s string) {
	m.access_meter_number = &s
}

// AccessMeterNumber returns the value of the "access_meter_number" field in the mutation.
func (m *ShipmentGatewayFedexMutation) AccessMeterNumber() (r string, exists bool) {
	v := m.access_meter_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessMeterNumber returns the old "access_meter_number" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldAccessMeterNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessMeterNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessMeterNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessMeterNumber: %w", err)
	}
	return oldValue.AccessMeterNumber, nil
}

// ClearAccessMeterNumber clears the value of the "access_meter_number" field.
func (m *ShipmentGatewayFedexMutation) ClearAccessMeterNumber() {
	m.access_meter_number = nil
	m.clearedFields[shipmentgatewayfedex.FieldAccessMeterNumber] = struct{}{}
}

// AccessMeterNumberCleared returns if the "access_meter_number" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) AccessMeterNumberCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldAccessMeterNumber]
	return ok
}

// ResetAccessMeterNumber resets all changes to the "access_meter_number" field.
func (m *ShipmentGatewayFedexMutation) ResetAccessMeterNumber() {
	m.access_meter_number = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldAccessMeterNumber)
}

// SetAccessUserKey sets the "access_user_key" field.
func (m *ShipmentGatewayFedexMutation) SetAccessUserKey(s string) {
	m.access_user_key = &s
}

// AccessUserKey returns the value of the "access_user_key" field in the mutation.
func (m *ShipmentGatewayFedexMutation) AccessUserKey() (r string, exists bool) {
	v := m.access_user_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessUserKey returns the old "access_user_key" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldAccessUserKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessUserKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessUserKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessUserKey: %w", err)
	}
	return oldValue.AccessUserKey, nil
}

// ClearAccessUserKey clears the value of the "access_user_key" field.
func (m *ShipmentGatewayFedexMutation) ClearAccessUserKey() {
	m.access_user_key = nil
	m.clearedFields[shipmentgatewayfedex.FieldAccessUserKey] = struct{}{}
}

// AccessUserKeyCleared returns if the "access_user_key" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) AccessUserKeyCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldAccessUserKey]
	return ok
}

// ResetAccessUserKey resets all changes to the "access_user_key" field.
func (m *ShipmentGatewayFedexMutation) ResetAccessUserKey() {
	m.access_user_key = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldAccessUserKey)
}

// SetAccessUserPwd sets the "access_user_pwd" field.
func (m *ShipmentGatewayFedexMutation) SetAccessUserPwd(s string) {
	m.access_user_pwd = &s
}

// AccessUserPwd returns the value of the "access_user_pwd" field in the mutation.
func (m *ShipmentGatewayFedexMutation) AccessUserPwd() (r string, exists bool) {
	v := m.access_user_pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessUserPwd returns the old "access_user_pwd" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldAccessUserPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessUserPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessUserPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessUserPwd: %w", err)
	}
	return oldValue.AccessUserPwd, nil
}

// ClearAccessUserPwd clears the value of the "access_user_pwd" field.
func (m *ShipmentGatewayFedexMutation) ClearAccessUserPwd() {
	m.access_user_pwd = nil
	m.clearedFields[shipmentgatewayfedex.FieldAccessUserPwd] = struct{}{}
}

// AccessUserPwdCleared returns if the "access_user_pwd" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) AccessUserPwdCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldAccessUserPwd]
	return ok
}

// ResetAccessUserPwd resets all changes to the "access_user_pwd" field.
func (m *ShipmentGatewayFedexMutation) ResetAccessUserPwd() {
	m.access_user_pwd = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldAccessUserPwd)
}

// SetLabelImageType sets the "label_image_type" field.
func (m *ShipmentGatewayFedexMutation) SetLabelImageType(s string) {
	m.label_image_type = &s
}

// LabelImageType returns the value of the "label_image_type" field in the mutation.
func (m *ShipmentGatewayFedexMutation) LabelImageType() (r string, exists bool) {
	v := m.label_image_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelImageType returns the old "label_image_type" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldLabelImageType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLabelImageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLabelImageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelImageType: %w", err)
	}
	return oldValue.LabelImageType, nil
}

// ClearLabelImageType clears the value of the "label_image_type" field.
func (m *ShipmentGatewayFedexMutation) ClearLabelImageType() {
	m.label_image_type = nil
	m.clearedFields[shipmentgatewayfedex.FieldLabelImageType] = struct{}{}
}

// LabelImageTypeCleared returns if the "label_image_type" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) LabelImageTypeCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldLabelImageType]
	return ok
}

// ResetLabelImageType resets all changes to the "label_image_type" field.
func (m *ShipmentGatewayFedexMutation) ResetLabelImageType() {
	m.label_image_type = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldLabelImageType)
}

// SetDefaultDropoffType sets the "default_dropoff_type" field.
func (m *ShipmentGatewayFedexMutation) SetDefaultDropoffType(s string) {
	m.default_dropoff_type = &s
}

// DefaultDropoffType returns the value of the "default_dropoff_type" field in the mutation.
func (m *ShipmentGatewayFedexMutation) DefaultDropoffType() (r string, exists bool) {
	v := m.default_dropoff_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultDropoffType returns the old "default_dropoff_type" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldDefaultDropoffType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultDropoffType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultDropoffType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultDropoffType: %w", err)
	}
	return oldValue.DefaultDropoffType, nil
}

// ClearDefaultDropoffType clears the value of the "default_dropoff_type" field.
func (m *ShipmentGatewayFedexMutation) ClearDefaultDropoffType() {
	m.default_dropoff_type = nil
	m.clearedFields[shipmentgatewayfedex.FieldDefaultDropoffType] = struct{}{}
}

// DefaultDropoffTypeCleared returns if the "default_dropoff_type" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) DefaultDropoffTypeCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldDefaultDropoffType]
	return ok
}

// ResetDefaultDropoffType resets all changes to the "default_dropoff_type" field.
func (m *ShipmentGatewayFedexMutation) ResetDefaultDropoffType() {
	m.default_dropoff_type = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldDefaultDropoffType)
}

// SetDefaultPackagingType sets the "default_packaging_type" field.
func (m *ShipmentGatewayFedexMutation) SetDefaultPackagingType(s string) {
	m.default_packaging_type = &s
}

// DefaultPackagingType returns the value of the "default_packaging_type" field in the mutation.
func (m *ShipmentGatewayFedexMutation) DefaultPackagingType() (r string, exists bool) {
	v := m.default_packaging_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultPackagingType returns the old "default_packaging_type" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldDefaultPackagingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultPackagingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultPackagingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultPackagingType: %w", err)
	}
	return oldValue.DefaultPackagingType, nil
}

// ClearDefaultPackagingType clears the value of the "default_packaging_type" field.
func (m *ShipmentGatewayFedexMutation) ClearDefaultPackagingType() {
	m.default_packaging_type = nil
	m.clearedFields[shipmentgatewayfedex.FieldDefaultPackagingType] = struct{}{}
}

// DefaultPackagingTypeCleared returns if the "default_packaging_type" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) DefaultPackagingTypeCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldDefaultPackagingType]
	return ok
}

// ResetDefaultPackagingType resets all changes to the "default_packaging_type" field.
func (m *ShipmentGatewayFedexMutation) ResetDefaultPackagingType() {
	m.default_packaging_type = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldDefaultPackagingType)
}

// SetTemplateShipment sets the "template_shipment" field.
func (m *ShipmentGatewayFedexMutation) SetTemplateShipment(s string) {
	m.template_shipment = &s
}

// TemplateShipment returns the value of the "template_shipment" field in the mutation.
func (m *ShipmentGatewayFedexMutation) TemplateShipment() (r string, exists bool) {
	v := m.template_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateShipment returns the old "template_shipment" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldTemplateShipment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplateShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplateShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateShipment: %w", err)
	}
	return oldValue.TemplateShipment, nil
}

// ClearTemplateShipment clears the value of the "template_shipment" field.
func (m *ShipmentGatewayFedexMutation) ClearTemplateShipment() {
	m.template_shipment = nil
	m.clearedFields[shipmentgatewayfedex.FieldTemplateShipment] = struct{}{}
}

// TemplateShipmentCleared returns if the "template_shipment" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) TemplateShipmentCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldTemplateShipment]
	return ok
}

// ResetTemplateShipment resets all changes to the "template_shipment" field.
func (m *ShipmentGatewayFedexMutation) ResetTemplateShipment() {
	m.template_shipment = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldTemplateShipment)
}

// SetTemplateSubscription sets the "template_subscription" field.
func (m *ShipmentGatewayFedexMutation) SetTemplateSubscription(s string) {
	m.template_subscription = &s
}

// TemplateSubscription returns the value of the "template_subscription" field in the mutation.
func (m *ShipmentGatewayFedexMutation) TemplateSubscription() (r string, exists bool) {
	v := m.template_subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateSubscription returns the old "template_subscription" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldTemplateSubscription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplateSubscription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplateSubscription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateSubscription: %w", err)
	}
	return oldValue.TemplateSubscription, nil
}

// ClearTemplateSubscription clears the value of the "template_subscription" field.
func (m *ShipmentGatewayFedexMutation) ClearTemplateSubscription() {
	m.template_subscription = nil
	m.clearedFields[shipmentgatewayfedex.FieldTemplateSubscription] = struct{}{}
}

// TemplateSubscriptionCleared returns if the "template_subscription" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) TemplateSubscriptionCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldTemplateSubscription]
	return ok
}

// ResetTemplateSubscription resets all changes to the "template_subscription" field.
func (m *ShipmentGatewayFedexMutation) ResetTemplateSubscription() {
	m.template_subscription = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldTemplateSubscription)
}

// SetRateEstimateTemplate sets the "rate_estimate_template" field.
func (m *ShipmentGatewayFedexMutation) SetRateEstimateTemplate(s string) {
	m.rate_estimate_template = &s
}

// RateEstimateTemplate returns the value of the "rate_estimate_template" field in the mutation.
func (m *ShipmentGatewayFedexMutation) RateEstimateTemplate() (r string, exists bool) {
	v := m.rate_estimate_template
	if v == nil {
		return
	}
	return *v, true
}

// OldRateEstimateTemplate returns the old "rate_estimate_template" field's value of the ShipmentGatewayFedex entity.
// If the ShipmentGatewayFedex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayFedexMutation) OldRateEstimateTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRateEstimateTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRateEstimateTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateEstimateTemplate: %w", err)
	}
	return oldValue.RateEstimateTemplate, nil
}

// ClearRateEstimateTemplate clears the value of the "rate_estimate_template" field.
func (m *ShipmentGatewayFedexMutation) ClearRateEstimateTemplate() {
	m.rate_estimate_template = nil
	m.clearedFields[shipmentgatewayfedex.FieldRateEstimateTemplate] = struct{}{}
}

// RateEstimateTemplateCleared returns if the "rate_estimate_template" field was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) RateEstimateTemplateCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayfedex.FieldRateEstimateTemplate]
	return ok
}

// ResetRateEstimateTemplate resets all changes to the "rate_estimate_template" field.
func (m *ShipmentGatewayFedexMutation) ResetRateEstimateTemplate() {
	m.rate_estimate_template = nil
	delete(m.clearedFields, shipmentgatewayfedex.FieldRateEstimateTemplate)
}

// SetShipmentGatewayConfigID sets the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity by id.
func (m *ShipmentGatewayFedexMutation) SetShipmentGatewayConfigID(id int) {
	m.shipment_gateway_config = &id
}

// ClearShipmentGatewayConfig clears the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity.
func (m *ShipmentGatewayFedexMutation) ClearShipmentGatewayConfig() {
	m.clearedshipment_gateway_config = true
}

// ShipmentGatewayConfigCleared reports if the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity was cleared.
func (m *ShipmentGatewayFedexMutation) ShipmentGatewayConfigCleared() bool {
	return m.clearedshipment_gateway_config
}

// ShipmentGatewayConfigID returns the "shipment_gateway_config" edge ID in the mutation.
func (m *ShipmentGatewayFedexMutation) ShipmentGatewayConfigID() (id int, exists bool) {
	if m.shipment_gateway_config != nil {
		return *m.shipment_gateway_config, true
	}
	return
}

// ShipmentGatewayConfigIDs returns the "shipment_gateway_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayConfigID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayFedexMutation) ShipmentGatewayConfigIDs() (ids []int) {
	if id := m.shipment_gateway_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayConfig resets all changes to the "shipment_gateway_config" edge.
func (m *ShipmentGatewayFedexMutation) ResetShipmentGatewayConfig() {
	m.shipment_gateway_config = nil
	m.clearedshipment_gateway_config = false
}

// Op returns the operation name.
func (m *ShipmentGatewayFedexMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentGatewayFedex).
func (m *ShipmentGatewayFedexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGatewayFedexMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, shipmentgatewayfedex.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentgatewayfedex.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentgatewayfedex.FieldStringRef)
	}
	if m.connect_url != nil {
		fields = append(fields, shipmentgatewayfedex.FieldConnectURL)
	}
	if m.connect_soap_url != nil {
		fields = append(fields, shipmentgatewayfedex.FieldConnectSoapURL)
	}
	if m.connect_timeout != nil {
		fields = append(fields, shipmentgatewayfedex.FieldConnectTimeout)
	}
	if m.access_account_nbr != nil {
		fields = append(fields, shipmentgatewayfedex.FieldAccessAccountNbr)
	}
	if m.access_meter_number != nil {
		fields = append(fields, shipmentgatewayfedex.FieldAccessMeterNumber)
	}
	if m.access_user_key != nil {
		fields = append(fields, shipmentgatewayfedex.FieldAccessUserKey)
	}
	if m.access_user_pwd != nil {
		fields = append(fields, shipmentgatewayfedex.FieldAccessUserPwd)
	}
	if m.label_image_type != nil {
		fields = append(fields, shipmentgatewayfedex.FieldLabelImageType)
	}
	if m.default_dropoff_type != nil {
		fields = append(fields, shipmentgatewayfedex.FieldDefaultDropoffType)
	}
	if m.default_packaging_type != nil {
		fields = append(fields, shipmentgatewayfedex.FieldDefaultPackagingType)
	}
	if m.template_shipment != nil {
		fields = append(fields, shipmentgatewayfedex.FieldTemplateShipment)
	}
	if m.template_subscription != nil {
		fields = append(fields, shipmentgatewayfedex.FieldTemplateSubscription)
	}
	if m.rate_estimate_template != nil {
		fields = append(fields, shipmentgatewayfedex.FieldRateEstimateTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGatewayFedexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayfedex.FieldCreateTime:
		return m.CreateTime()
	case shipmentgatewayfedex.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentgatewayfedex.FieldStringRef:
		return m.StringRef()
	case shipmentgatewayfedex.FieldConnectURL:
		return m.ConnectURL()
	case shipmentgatewayfedex.FieldConnectSoapURL:
		return m.ConnectSoapURL()
	case shipmentgatewayfedex.FieldConnectTimeout:
		return m.ConnectTimeout()
	case shipmentgatewayfedex.FieldAccessAccountNbr:
		return m.AccessAccountNbr()
	case shipmentgatewayfedex.FieldAccessMeterNumber:
		return m.AccessMeterNumber()
	case shipmentgatewayfedex.FieldAccessUserKey:
		return m.AccessUserKey()
	case shipmentgatewayfedex.FieldAccessUserPwd:
		return m.AccessUserPwd()
	case shipmentgatewayfedex.FieldLabelImageType:
		return m.LabelImageType()
	case shipmentgatewayfedex.FieldDefaultDropoffType:
		return m.DefaultDropoffType()
	case shipmentgatewayfedex.FieldDefaultPackagingType:
		return m.DefaultPackagingType()
	case shipmentgatewayfedex.FieldTemplateShipment:
		return m.TemplateShipment()
	case shipmentgatewayfedex.FieldTemplateSubscription:
		return m.TemplateSubscription()
	case shipmentgatewayfedex.FieldRateEstimateTemplate:
		return m.RateEstimateTemplate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGatewayFedexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgatewayfedex.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentgatewayfedex.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentgatewayfedex.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentgatewayfedex.FieldConnectURL:
		return m.OldConnectURL(ctx)
	case shipmentgatewayfedex.FieldConnectSoapURL:
		return m.OldConnectSoapURL(ctx)
	case shipmentgatewayfedex.FieldConnectTimeout:
		return m.OldConnectTimeout(ctx)
	case shipmentgatewayfedex.FieldAccessAccountNbr:
		return m.OldAccessAccountNbr(ctx)
	case shipmentgatewayfedex.FieldAccessMeterNumber:
		return m.OldAccessMeterNumber(ctx)
	case shipmentgatewayfedex.FieldAccessUserKey:
		return m.OldAccessUserKey(ctx)
	case shipmentgatewayfedex.FieldAccessUserPwd:
		return m.OldAccessUserPwd(ctx)
	case shipmentgatewayfedex.FieldLabelImageType:
		return m.OldLabelImageType(ctx)
	case shipmentgatewayfedex.FieldDefaultDropoffType:
		return m.OldDefaultDropoffType(ctx)
	case shipmentgatewayfedex.FieldDefaultPackagingType:
		return m.OldDefaultPackagingType(ctx)
	case shipmentgatewayfedex.FieldTemplateShipment:
		return m.OldTemplateShipment(ctx)
	case shipmentgatewayfedex.FieldTemplateSubscription:
		return m.OldTemplateSubscription(ctx)
	case shipmentgatewayfedex.FieldRateEstimateTemplate:
		return m.OldRateEstimateTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGatewayFedex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayFedexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayfedex.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentgatewayfedex.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentgatewayfedex.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentgatewayfedex.FieldConnectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectURL(v)
		return nil
	case shipmentgatewayfedex.FieldConnectSoapURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectSoapURL(v)
		return nil
	case shipmentgatewayfedex.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectTimeout(v)
		return nil
	case shipmentgatewayfedex.FieldAccessAccountNbr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessAccountNbr(v)
		return nil
	case shipmentgatewayfedex.FieldAccessMeterNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessMeterNumber(v)
		return nil
	case shipmentgatewayfedex.FieldAccessUserKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessUserKey(v)
		return nil
	case shipmentgatewayfedex.FieldAccessUserPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessUserPwd(v)
		return nil
	case shipmentgatewayfedex.FieldLabelImageType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelImageType(v)
		return nil
	case shipmentgatewayfedex.FieldDefaultDropoffType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultDropoffType(v)
		return nil
	case shipmentgatewayfedex.FieldDefaultPackagingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultPackagingType(v)
		return nil
	case shipmentgatewayfedex.FieldTemplateShipment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateShipment(v)
		return nil
	case shipmentgatewayfedex.FieldTemplateSubscription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateSubscription(v)
		return nil
	case shipmentgatewayfedex.FieldRateEstimateTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateEstimateTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayFedex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGatewayFedexMutation) AddedFields() []string {
	var fields []string
	if m.addconnect_timeout != nil {
		fields = append(fields, shipmentgatewayfedex.FieldConnectTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGatewayFedexMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayfedex.FieldConnectTimeout:
		return m.AddedConnectTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayFedexMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayfedex.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnectTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayFedex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGatewayFedexMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentgatewayfedex.FieldStringRef) {
		fields = append(fields, shipmentgatewayfedex.FieldStringRef)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldConnectURL) {
		fields = append(fields, shipmentgatewayfedex.FieldConnectURL)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldConnectSoapURL) {
		fields = append(fields, shipmentgatewayfedex.FieldConnectSoapURL)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldConnectTimeout) {
		fields = append(fields, shipmentgatewayfedex.FieldConnectTimeout)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldAccessAccountNbr) {
		fields = append(fields, shipmentgatewayfedex.FieldAccessAccountNbr)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldAccessMeterNumber) {
		fields = append(fields, shipmentgatewayfedex.FieldAccessMeterNumber)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldAccessUserKey) {
		fields = append(fields, shipmentgatewayfedex.FieldAccessUserKey)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldAccessUserPwd) {
		fields = append(fields, shipmentgatewayfedex.FieldAccessUserPwd)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldLabelImageType) {
		fields = append(fields, shipmentgatewayfedex.FieldLabelImageType)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldDefaultDropoffType) {
		fields = append(fields, shipmentgatewayfedex.FieldDefaultDropoffType)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldDefaultPackagingType) {
		fields = append(fields, shipmentgatewayfedex.FieldDefaultPackagingType)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldTemplateShipment) {
		fields = append(fields, shipmentgatewayfedex.FieldTemplateShipment)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldTemplateSubscription) {
		fields = append(fields, shipmentgatewayfedex.FieldTemplateSubscription)
	}
	if m.FieldCleared(shipmentgatewayfedex.FieldRateEstimateTemplate) {
		fields = append(fields, shipmentgatewayfedex.FieldRateEstimateTemplate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGatewayFedexMutation) ClearField(name string) error {
	switch name {
	case shipmentgatewayfedex.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentgatewayfedex.FieldConnectURL:
		m.ClearConnectURL()
		return nil
	case shipmentgatewayfedex.FieldConnectSoapURL:
		m.ClearConnectSoapURL()
		return nil
	case shipmentgatewayfedex.FieldConnectTimeout:
		m.ClearConnectTimeout()
		return nil
	case shipmentgatewayfedex.FieldAccessAccountNbr:
		m.ClearAccessAccountNbr()
		return nil
	case shipmentgatewayfedex.FieldAccessMeterNumber:
		m.ClearAccessMeterNumber()
		return nil
	case shipmentgatewayfedex.FieldAccessUserKey:
		m.ClearAccessUserKey()
		return nil
	case shipmentgatewayfedex.FieldAccessUserPwd:
		m.ClearAccessUserPwd()
		return nil
	case shipmentgatewayfedex.FieldLabelImageType:
		m.ClearLabelImageType()
		return nil
	case shipmentgatewayfedex.FieldDefaultDropoffType:
		m.ClearDefaultDropoffType()
		return nil
	case shipmentgatewayfedex.FieldDefaultPackagingType:
		m.ClearDefaultPackagingType()
		return nil
	case shipmentgatewayfedex.FieldTemplateShipment:
		m.ClearTemplateShipment()
		return nil
	case shipmentgatewayfedex.FieldTemplateSubscription:
		m.ClearTemplateSubscription()
		return nil
	case shipmentgatewayfedex.FieldRateEstimateTemplate:
		m.ClearRateEstimateTemplate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayFedex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGatewayFedexMutation) ResetField(name string) error {
	switch name {
	case shipmentgatewayfedex.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentgatewayfedex.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentgatewayfedex.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentgatewayfedex.FieldConnectURL:
		m.ResetConnectURL()
		return nil
	case shipmentgatewayfedex.FieldConnectSoapURL:
		m.ResetConnectSoapURL()
		return nil
	case shipmentgatewayfedex.FieldConnectTimeout:
		m.ResetConnectTimeout()
		return nil
	case shipmentgatewayfedex.FieldAccessAccountNbr:
		m.ResetAccessAccountNbr()
		return nil
	case shipmentgatewayfedex.FieldAccessMeterNumber:
		m.ResetAccessMeterNumber()
		return nil
	case shipmentgatewayfedex.FieldAccessUserKey:
		m.ResetAccessUserKey()
		return nil
	case shipmentgatewayfedex.FieldAccessUserPwd:
		m.ResetAccessUserPwd()
		return nil
	case shipmentgatewayfedex.FieldLabelImageType:
		m.ResetLabelImageType()
		return nil
	case shipmentgatewayfedex.FieldDefaultDropoffType:
		m.ResetDefaultDropoffType()
		return nil
	case shipmentgatewayfedex.FieldDefaultPackagingType:
		m.ResetDefaultPackagingType()
		return nil
	case shipmentgatewayfedex.FieldTemplateShipment:
		m.ResetTemplateShipment()
		return nil
	case shipmentgatewayfedex.FieldTemplateSubscription:
		m.ResetTemplateSubscription()
		return nil
	case shipmentgatewayfedex.FieldRateEstimateTemplate:
		m.ResetRateEstimateTemplate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayFedex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGatewayFedexMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.shipment_gateway_config != nil {
		edges = append(edges, shipmentgatewayfedex.EdgeShipmentGatewayConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGatewayFedexMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewayfedex.EdgeShipmentGatewayConfig:
		if id := m.shipment_gateway_config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGatewayFedexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGatewayFedexMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshipment_gateway_config {
		edges = append(edges, shipmentgatewayfedex.EdgeShipmentGatewayConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGatewayFedexMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgatewayfedex.EdgeShipmentGatewayConfig:
		return m.clearedshipment_gateway_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGatewayFedexMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgatewayfedex.EdgeShipmentGatewayConfig:
		m.ClearShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayFedex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGatewayFedexMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgatewayfedex.EdgeShipmentGatewayConfig:
		m.ResetShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayFedex edge %s", name)
}

// ShipmentGatewayUpsMutation represents an operation that mutates the ShipmentGatewayUps nodes in the graph.
type ShipmentGatewayUpsMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	create_time                    *time.Time
	update_time                    *time.Time
	string_ref                     *string
	connect_url                    *string
	connect_timeout                *int
	addconnect_timeout             *int
	shipper_number                 *string
	bill_shipper_account_number    *string
	access_license_number          *string
	access_user_id                 *string
	access_password                *string
	save_cert_info                 *string
	save_cert_path                 *string
	shipper_pickup_type            *string
	customer_classification        *string
	max_estimate_weight            *float64
	addmax_estimate_weight         *float64
	min_estimate_weight            *float64
	addmin_estimate_weight         *float64
	cod_allow_cod                  *string
	cod_surcharge_amount           *float64
	addcod_surcharge_amount        *float64
	cod_surcharge_currency_uom_id  *string
	cod_surcharge_apply_to_package *string
	cod_funds_code                 *string
	default_return_label_memo      *string
	default_return_label_subject   *string
	clearedFields                  map[string]struct{}
	shipment_gateway_config        *int
	clearedshipment_gateway_config bool
	done                           bool
	oldValue                       func(context.Context) (*ShipmentGatewayUps, error)
	predicates                     []predicate.ShipmentGatewayUps
}

var _ ent.Mutation = (*ShipmentGatewayUpsMutation)(nil)

// shipmentgatewayupsOption allows management of the mutation configuration using functional options.
type shipmentgatewayupsOption func(*ShipmentGatewayUpsMutation)

// newShipmentGatewayUpsMutation creates new mutation for the ShipmentGatewayUps entity.
func newShipmentGatewayUpsMutation(c config, op Op, opts ...shipmentgatewayupsOption) *ShipmentGatewayUpsMutation {
	m := &ShipmentGatewayUpsMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGatewayUps,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGatewayUpsID sets the ID field of the mutation.
func withShipmentGatewayUpsID(id int) shipmentgatewayupsOption {
	return func(m *ShipmentGatewayUpsMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGatewayUps
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGatewayUps, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGatewayUps.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGatewayUps sets the old ShipmentGatewayUps of the mutation.
func withShipmentGatewayUps(node *ShipmentGatewayUps) shipmentgatewayupsOption {
	return func(m *ShipmentGatewayUpsMutation) {
		m.oldValue = func(context.Context) (*ShipmentGatewayUps, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGatewayUpsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGatewayUpsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGatewayUpsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentGatewayUpsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentGatewayUpsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentGatewayUpsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentGatewayUpsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentGatewayUpsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentGatewayUpsMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentGatewayUpsMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentGatewayUpsMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentgatewayups.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentGatewayUpsMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentgatewayups.FieldStringRef)
}

// SetConnectURL sets the "connect_url" field.
func (m *ShipmentGatewayUpsMutation) SetConnectURL(s string) {
	m.connect_url = &s
}

// ConnectURL returns the value of the "connect_url" field in the mutation.
func (m *ShipmentGatewayUpsMutation) ConnectURL() (r string, exists bool) {
	v := m.connect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectURL returns the old "connect_url" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldConnectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectURL: %w", err)
	}
	return oldValue.ConnectURL, nil
}

// ClearConnectURL clears the value of the "connect_url" field.
func (m *ShipmentGatewayUpsMutation) ClearConnectURL() {
	m.connect_url = nil
	m.clearedFields[shipmentgatewayups.FieldConnectURL] = struct{}{}
}

// ConnectURLCleared returns if the "connect_url" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) ConnectURLCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldConnectURL]
	return ok
}

// ResetConnectURL resets all changes to the "connect_url" field.
func (m *ShipmentGatewayUpsMutation) ResetConnectURL() {
	m.connect_url = nil
	delete(m.clearedFields, shipmentgatewayups.FieldConnectURL)
}

// SetConnectTimeout sets the "connect_timeout" field.
func (m *ShipmentGatewayUpsMutation) SetConnectTimeout(i int) {
	m.connect_timeout = &i
	m.addconnect_timeout = nil
}

// ConnectTimeout returns the value of the "connect_timeout" field in the mutation.
func (m *ShipmentGatewayUpsMutation) ConnectTimeout() (r int, exists bool) {
	v := m.connect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectTimeout returns the old "connect_timeout" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldConnectTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectTimeout: %w", err)
	}
	return oldValue.ConnectTimeout, nil
}

// AddConnectTimeout adds i to the "connect_timeout" field.
func (m *ShipmentGatewayUpsMutation) AddConnectTimeout(i int) {
	if m.addconnect_timeout != nil {
		*m.addconnect_timeout += i
	} else {
		m.addconnect_timeout = &i
	}
}

// AddedConnectTimeout returns the value that was added to the "connect_timeout" field in this mutation.
func (m *ShipmentGatewayUpsMutation) AddedConnectTimeout() (r int, exists bool) {
	v := m.addconnect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearConnectTimeout clears the value of the "connect_timeout" field.
func (m *ShipmentGatewayUpsMutation) ClearConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	m.clearedFields[shipmentgatewayups.FieldConnectTimeout] = struct{}{}
}

// ConnectTimeoutCleared returns if the "connect_timeout" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) ConnectTimeoutCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldConnectTimeout]
	return ok
}

// ResetConnectTimeout resets all changes to the "connect_timeout" field.
func (m *ShipmentGatewayUpsMutation) ResetConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	delete(m.clearedFields, shipmentgatewayups.FieldConnectTimeout)
}

// SetShipperNumber sets the "shipper_number" field.
func (m *ShipmentGatewayUpsMutation) SetShipperNumber(s string) {
	m.shipper_number = &s
}

// ShipperNumber returns the value of the "shipper_number" field in the mutation.
func (m *ShipmentGatewayUpsMutation) ShipperNumber() (r string, exists bool) {
	v := m.shipper_number
	if v == nil {
		return
	}
	return *v, true
}

// OldShipperNumber returns the old "shipper_number" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldShipperNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipperNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipperNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipperNumber: %w", err)
	}
	return oldValue.ShipperNumber, nil
}

// ClearShipperNumber clears the value of the "shipper_number" field.
func (m *ShipmentGatewayUpsMutation) ClearShipperNumber() {
	m.shipper_number = nil
	m.clearedFields[shipmentgatewayups.FieldShipperNumber] = struct{}{}
}

// ShipperNumberCleared returns if the "shipper_number" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) ShipperNumberCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldShipperNumber]
	return ok
}

// ResetShipperNumber resets all changes to the "shipper_number" field.
func (m *ShipmentGatewayUpsMutation) ResetShipperNumber() {
	m.shipper_number = nil
	delete(m.clearedFields, shipmentgatewayups.FieldShipperNumber)
}

// SetBillShipperAccountNumber sets the "bill_shipper_account_number" field.
func (m *ShipmentGatewayUpsMutation) SetBillShipperAccountNumber(s string) {
	m.bill_shipper_account_number = &s
}

// BillShipperAccountNumber returns the value of the "bill_shipper_account_number" field in the mutation.
func (m *ShipmentGatewayUpsMutation) BillShipperAccountNumber() (r string, exists bool) {
	v := m.bill_shipper_account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBillShipperAccountNumber returns the old "bill_shipper_account_number" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldBillShipperAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillShipperAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillShipperAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillShipperAccountNumber: %w", err)
	}
	return oldValue.BillShipperAccountNumber, nil
}

// ClearBillShipperAccountNumber clears the value of the "bill_shipper_account_number" field.
func (m *ShipmentGatewayUpsMutation) ClearBillShipperAccountNumber() {
	m.bill_shipper_account_number = nil
	m.clearedFields[shipmentgatewayups.FieldBillShipperAccountNumber] = struct{}{}
}

// BillShipperAccountNumberCleared returns if the "bill_shipper_account_number" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) BillShipperAccountNumberCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldBillShipperAccountNumber]
	return ok
}

// ResetBillShipperAccountNumber resets all changes to the "bill_shipper_account_number" field.
func (m *ShipmentGatewayUpsMutation) ResetBillShipperAccountNumber() {
	m.bill_shipper_account_number = nil
	delete(m.clearedFields, shipmentgatewayups.FieldBillShipperAccountNumber)
}

// SetAccessLicenseNumber sets the "access_license_number" field.
func (m *ShipmentGatewayUpsMutation) SetAccessLicenseNumber(s string) {
	m.access_license_number = &s
}

// AccessLicenseNumber returns the value of the "access_license_number" field in the mutation.
func (m *ShipmentGatewayUpsMutation) AccessLicenseNumber() (r string, exists bool) {
	v := m.access_license_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessLicenseNumber returns the old "access_license_number" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldAccessLicenseNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessLicenseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessLicenseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessLicenseNumber: %w", err)
	}
	return oldValue.AccessLicenseNumber, nil
}

// ClearAccessLicenseNumber clears the value of the "access_license_number" field.
func (m *ShipmentGatewayUpsMutation) ClearAccessLicenseNumber() {
	m.access_license_number = nil
	m.clearedFields[shipmentgatewayups.FieldAccessLicenseNumber] = struct{}{}
}

// AccessLicenseNumberCleared returns if the "access_license_number" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) AccessLicenseNumberCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldAccessLicenseNumber]
	return ok
}

// ResetAccessLicenseNumber resets all changes to the "access_license_number" field.
func (m *ShipmentGatewayUpsMutation) ResetAccessLicenseNumber() {
	m.access_license_number = nil
	delete(m.clearedFields, shipmentgatewayups.FieldAccessLicenseNumber)
}

// SetAccessUserID sets the "access_user_id" field.
func (m *ShipmentGatewayUpsMutation) SetAccessUserID(s string) {
	m.access_user_id = &s
}

// AccessUserID returns the value of the "access_user_id" field in the mutation.
func (m *ShipmentGatewayUpsMutation) AccessUserID() (r string, exists bool) {
	v := m.access_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessUserID returns the old "access_user_id" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldAccessUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessUserID: %w", err)
	}
	return oldValue.AccessUserID, nil
}

// ClearAccessUserID clears the value of the "access_user_id" field.
func (m *ShipmentGatewayUpsMutation) ClearAccessUserID() {
	m.access_user_id = nil
	m.clearedFields[shipmentgatewayups.FieldAccessUserID] = struct{}{}
}

// AccessUserIDCleared returns if the "access_user_id" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) AccessUserIDCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldAccessUserID]
	return ok
}

// ResetAccessUserID resets all changes to the "access_user_id" field.
func (m *ShipmentGatewayUpsMutation) ResetAccessUserID() {
	m.access_user_id = nil
	delete(m.clearedFields, shipmentgatewayups.FieldAccessUserID)
}

// SetAccessPassword sets the "access_password" field.
func (m *ShipmentGatewayUpsMutation) SetAccessPassword(s string) {
	m.access_password = &s
}

// AccessPassword returns the value of the "access_password" field in the mutation.
func (m *ShipmentGatewayUpsMutation) AccessPassword() (r string, exists bool) {
	v := m.access_password
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessPassword returns the old "access_password" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldAccessPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessPassword: %w", err)
	}
	return oldValue.AccessPassword, nil
}

// ClearAccessPassword clears the value of the "access_password" field.
func (m *ShipmentGatewayUpsMutation) ClearAccessPassword() {
	m.access_password = nil
	m.clearedFields[shipmentgatewayups.FieldAccessPassword] = struct{}{}
}

// AccessPasswordCleared returns if the "access_password" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) AccessPasswordCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldAccessPassword]
	return ok
}

// ResetAccessPassword resets all changes to the "access_password" field.
func (m *ShipmentGatewayUpsMutation) ResetAccessPassword() {
	m.access_password = nil
	delete(m.clearedFields, shipmentgatewayups.FieldAccessPassword)
}

// SetSaveCertInfo sets the "save_cert_info" field.
func (m *ShipmentGatewayUpsMutation) SetSaveCertInfo(s string) {
	m.save_cert_info = &s
}

// SaveCertInfo returns the value of the "save_cert_info" field in the mutation.
func (m *ShipmentGatewayUpsMutation) SaveCertInfo() (r string, exists bool) {
	v := m.save_cert_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSaveCertInfo returns the old "save_cert_info" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldSaveCertInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSaveCertInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSaveCertInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaveCertInfo: %w", err)
	}
	return oldValue.SaveCertInfo, nil
}

// ClearSaveCertInfo clears the value of the "save_cert_info" field.
func (m *ShipmentGatewayUpsMutation) ClearSaveCertInfo() {
	m.save_cert_info = nil
	m.clearedFields[shipmentgatewayups.FieldSaveCertInfo] = struct{}{}
}

// SaveCertInfoCleared returns if the "save_cert_info" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) SaveCertInfoCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldSaveCertInfo]
	return ok
}

// ResetSaveCertInfo resets all changes to the "save_cert_info" field.
func (m *ShipmentGatewayUpsMutation) ResetSaveCertInfo() {
	m.save_cert_info = nil
	delete(m.clearedFields, shipmentgatewayups.FieldSaveCertInfo)
}

// SetSaveCertPath sets the "save_cert_path" field.
func (m *ShipmentGatewayUpsMutation) SetSaveCertPath(s string) {
	m.save_cert_path = &s
}

// SaveCertPath returns the value of the "save_cert_path" field in the mutation.
func (m *ShipmentGatewayUpsMutation) SaveCertPath() (r string, exists bool) {
	v := m.save_cert_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSaveCertPath returns the old "save_cert_path" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldSaveCertPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSaveCertPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSaveCertPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaveCertPath: %w", err)
	}
	return oldValue.SaveCertPath, nil
}

// ClearSaveCertPath clears the value of the "save_cert_path" field.
func (m *ShipmentGatewayUpsMutation) ClearSaveCertPath() {
	m.save_cert_path = nil
	m.clearedFields[shipmentgatewayups.FieldSaveCertPath] = struct{}{}
}

// SaveCertPathCleared returns if the "save_cert_path" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) SaveCertPathCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldSaveCertPath]
	return ok
}

// ResetSaveCertPath resets all changes to the "save_cert_path" field.
func (m *ShipmentGatewayUpsMutation) ResetSaveCertPath() {
	m.save_cert_path = nil
	delete(m.clearedFields, shipmentgatewayups.FieldSaveCertPath)
}

// SetShipperPickupType sets the "shipper_pickup_type" field.
func (m *ShipmentGatewayUpsMutation) SetShipperPickupType(s string) {
	m.shipper_pickup_type = &s
}

// ShipperPickupType returns the value of the "shipper_pickup_type" field in the mutation.
func (m *ShipmentGatewayUpsMutation) ShipperPickupType() (r string, exists bool) {
	v := m.shipper_pickup_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShipperPickupType returns the old "shipper_pickup_type" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldShipperPickupType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipperPickupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipperPickupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipperPickupType: %w", err)
	}
	return oldValue.ShipperPickupType, nil
}

// ClearShipperPickupType clears the value of the "shipper_pickup_type" field.
func (m *ShipmentGatewayUpsMutation) ClearShipperPickupType() {
	m.shipper_pickup_type = nil
	m.clearedFields[shipmentgatewayups.FieldShipperPickupType] = struct{}{}
}

// ShipperPickupTypeCleared returns if the "shipper_pickup_type" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) ShipperPickupTypeCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldShipperPickupType]
	return ok
}

// ResetShipperPickupType resets all changes to the "shipper_pickup_type" field.
func (m *ShipmentGatewayUpsMutation) ResetShipperPickupType() {
	m.shipper_pickup_type = nil
	delete(m.clearedFields, shipmentgatewayups.FieldShipperPickupType)
}

// SetCustomerClassification sets the "customer_classification" field.
func (m *ShipmentGatewayUpsMutation) SetCustomerClassification(s string) {
	m.customer_classification = &s
}

// CustomerClassification returns the value of the "customer_classification" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CustomerClassification() (r string, exists bool) {
	v := m.customer_classification
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerClassification returns the old "customer_classification" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCustomerClassification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCustomerClassification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCustomerClassification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerClassification: %w", err)
	}
	return oldValue.CustomerClassification, nil
}

// ClearCustomerClassification clears the value of the "customer_classification" field.
func (m *ShipmentGatewayUpsMutation) ClearCustomerClassification() {
	m.customer_classification = nil
	m.clearedFields[shipmentgatewayups.FieldCustomerClassification] = struct{}{}
}

// CustomerClassificationCleared returns if the "customer_classification" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) CustomerClassificationCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldCustomerClassification]
	return ok
}

// ResetCustomerClassification resets all changes to the "customer_classification" field.
func (m *ShipmentGatewayUpsMutation) ResetCustomerClassification() {
	m.customer_classification = nil
	delete(m.clearedFields, shipmentgatewayups.FieldCustomerClassification)
}

// SetMaxEstimateWeight sets the "max_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) SetMaxEstimateWeight(f float64) {
	m.max_estimate_weight = &f
	m.addmax_estimate_weight = nil
}

// MaxEstimateWeight returns the value of the "max_estimate_weight" field in the mutation.
func (m *ShipmentGatewayUpsMutation) MaxEstimateWeight() (r float64, exists bool) {
	v := m.max_estimate_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxEstimateWeight returns the old "max_estimate_weight" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldMaxEstimateWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxEstimateWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxEstimateWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxEstimateWeight: %w", err)
	}
	return oldValue.MaxEstimateWeight, nil
}

// AddMaxEstimateWeight adds f to the "max_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) AddMaxEstimateWeight(f float64) {
	if m.addmax_estimate_weight != nil {
		*m.addmax_estimate_weight += f
	} else {
		m.addmax_estimate_weight = &f
	}
}

// AddedMaxEstimateWeight returns the value that was added to the "max_estimate_weight" field in this mutation.
func (m *ShipmentGatewayUpsMutation) AddedMaxEstimateWeight() (r float64, exists bool) {
	v := m.addmax_estimate_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxEstimateWeight clears the value of the "max_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) ClearMaxEstimateWeight() {
	m.max_estimate_weight = nil
	m.addmax_estimate_weight = nil
	m.clearedFields[shipmentgatewayups.FieldMaxEstimateWeight] = struct{}{}
}

// MaxEstimateWeightCleared returns if the "max_estimate_weight" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) MaxEstimateWeightCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldMaxEstimateWeight]
	return ok
}

// ResetMaxEstimateWeight resets all changes to the "max_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) ResetMaxEstimateWeight() {
	m.max_estimate_weight = nil
	m.addmax_estimate_weight = nil
	delete(m.clearedFields, shipmentgatewayups.FieldMaxEstimateWeight)
}

// SetMinEstimateWeight sets the "min_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) SetMinEstimateWeight(f float64) {
	m.min_estimate_weight = &f
	m.addmin_estimate_weight = nil
}

// MinEstimateWeight returns the value of the "min_estimate_weight" field in the mutation.
func (m *ShipmentGatewayUpsMutation) MinEstimateWeight() (r float64, exists bool) {
	v := m.min_estimate_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMinEstimateWeight returns the old "min_estimate_weight" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldMinEstimateWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinEstimateWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinEstimateWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinEstimateWeight: %w", err)
	}
	return oldValue.MinEstimateWeight, nil
}

// AddMinEstimateWeight adds f to the "min_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) AddMinEstimateWeight(f float64) {
	if m.addmin_estimate_weight != nil {
		*m.addmin_estimate_weight += f
	} else {
		m.addmin_estimate_weight = &f
	}
}

// AddedMinEstimateWeight returns the value that was added to the "min_estimate_weight" field in this mutation.
func (m *ShipmentGatewayUpsMutation) AddedMinEstimateWeight() (r float64, exists bool) {
	v := m.addmin_estimate_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinEstimateWeight clears the value of the "min_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) ClearMinEstimateWeight() {
	m.min_estimate_weight = nil
	m.addmin_estimate_weight = nil
	m.clearedFields[shipmentgatewayups.FieldMinEstimateWeight] = struct{}{}
}

// MinEstimateWeightCleared returns if the "min_estimate_weight" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) MinEstimateWeightCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldMinEstimateWeight]
	return ok
}

// ResetMinEstimateWeight resets all changes to the "min_estimate_weight" field.
func (m *ShipmentGatewayUpsMutation) ResetMinEstimateWeight() {
	m.min_estimate_weight = nil
	m.addmin_estimate_weight = nil
	delete(m.clearedFields, shipmentgatewayups.FieldMinEstimateWeight)
}

// SetCodAllowCod sets the "cod_allow_cod" field.
func (m *ShipmentGatewayUpsMutation) SetCodAllowCod(s string) {
	m.cod_allow_cod = &s
}

// CodAllowCod returns the value of the "cod_allow_cod" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CodAllowCod() (r string, exists bool) {
	v := m.cod_allow_cod
	if v == nil {
		return
	}
	return *v, true
}

// OldCodAllowCod returns the old "cod_allow_cod" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCodAllowCod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCodAllowCod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCodAllowCod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodAllowCod: %w", err)
	}
	return oldValue.CodAllowCod, nil
}

// ClearCodAllowCod clears the value of the "cod_allow_cod" field.
func (m *ShipmentGatewayUpsMutation) ClearCodAllowCod() {
	m.cod_allow_cod = nil
	m.clearedFields[shipmentgatewayups.FieldCodAllowCod] = struct{}{}
}

// CodAllowCodCleared returns if the "cod_allow_cod" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) CodAllowCodCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldCodAllowCod]
	return ok
}

// ResetCodAllowCod resets all changes to the "cod_allow_cod" field.
func (m *ShipmentGatewayUpsMutation) ResetCodAllowCod() {
	m.cod_allow_cod = nil
	delete(m.clearedFields, shipmentgatewayups.FieldCodAllowCod)
}

// SetCodSurchargeAmount sets the "cod_surcharge_amount" field.
func (m *ShipmentGatewayUpsMutation) SetCodSurchargeAmount(f float64) {
	m.cod_surcharge_amount = &f
	m.addcod_surcharge_amount = nil
}

// CodSurchargeAmount returns the value of the "cod_surcharge_amount" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CodSurchargeAmount() (r float64, exists bool) {
	v := m.cod_surcharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCodSurchargeAmount returns the old "cod_surcharge_amount" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCodSurchargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCodSurchargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCodSurchargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodSurchargeAmount: %w", err)
	}
	return oldValue.CodSurchargeAmount, nil
}

// AddCodSurchargeAmount adds f to the "cod_surcharge_amount" field.
func (m *ShipmentGatewayUpsMutation) AddCodSurchargeAmount(f float64) {
	if m.addcod_surcharge_amount != nil {
		*m.addcod_surcharge_amount += f
	} else {
		m.addcod_surcharge_amount = &f
	}
}

// AddedCodSurchargeAmount returns the value that was added to the "cod_surcharge_amount" field in this mutation.
func (m *ShipmentGatewayUpsMutation) AddedCodSurchargeAmount() (r float64, exists bool) {
	v := m.addcod_surcharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCodSurchargeAmount clears the value of the "cod_surcharge_amount" field.
func (m *ShipmentGatewayUpsMutation) ClearCodSurchargeAmount() {
	m.cod_surcharge_amount = nil
	m.addcod_surcharge_amount = nil
	m.clearedFields[shipmentgatewayups.FieldCodSurchargeAmount] = struct{}{}
}

// CodSurchargeAmountCleared returns if the "cod_surcharge_amount" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) CodSurchargeAmountCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldCodSurchargeAmount]
	return ok
}

// ResetCodSurchargeAmount resets all changes to the "cod_surcharge_amount" field.
func (m *ShipmentGatewayUpsMutation) ResetCodSurchargeAmount() {
	m.cod_surcharge_amount = nil
	m.addcod_surcharge_amount = nil
	delete(m.clearedFields, shipmentgatewayups.FieldCodSurchargeAmount)
}

// SetCodSurchargeCurrencyUomID sets the "cod_surcharge_currency_uom_id" field.
func (m *ShipmentGatewayUpsMutation) SetCodSurchargeCurrencyUomID(s string) {
	m.cod_surcharge_currency_uom_id = &s
}

// CodSurchargeCurrencyUomID returns the value of the "cod_surcharge_currency_uom_id" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CodSurchargeCurrencyUomID() (r string, exists bool) {
	v := m.cod_surcharge_currency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCodSurchargeCurrencyUomID returns the old "cod_surcharge_currency_uom_id" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCodSurchargeCurrencyUomID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCodSurchargeCurrencyUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCodSurchargeCurrencyUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodSurchargeCurrencyUomID: %w", err)
	}
	return oldValue.CodSurchargeCurrencyUomID, nil
}

// ClearCodSurchargeCurrencyUomID clears the value of the "cod_surcharge_currency_uom_id" field.
func (m *ShipmentGatewayUpsMutation) ClearCodSurchargeCurrencyUomID() {
	m.cod_surcharge_currency_uom_id = nil
	m.clearedFields[shipmentgatewayups.FieldCodSurchargeCurrencyUomID] = struct{}{}
}

// CodSurchargeCurrencyUomIDCleared returns if the "cod_surcharge_currency_uom_id" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) CodSurchargeCurrencyUomIDCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldCodSurchargeCurrencyUomID]
	return ok
}

// ResetCodSurchargeCurrencyUomID resets all changes to the "cod_surcharge_currency_uom_id" field.
func (m *ShipmentGatewayUpsMutation) ResetCodSurchargeCurrencyUomID() {
	m.cod_surcharge_currency_uom_id = nil
	delete(m.clearedFields, shipmentgatewayups.FieldCodSurchargeCurrencyUomID)
}

// SetCodSurchargeApplyToPackage sets the "cod_surcharge_apply_to_package" field.
func (m *ShipmentGatewayUpsMutation) SetCodSurchargeApplyToPackage(s string) {
	m.cod_surcharge_apply_to_package = &s
}

// CodSurchargeApplyToPackage returns the value of the "cod_surcharge_apply_to_package" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CodSurchargeApplyToPackage() (r string, exists bool) {
	v := m.cod_surcharge_apply_to_package
	if v == nil {
		return
	}
	return *v, true
}

// OldCodSurchargeApplyToPackage returns the old "cod_surcharge_apply_to_package" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCodSurchargeApplyToPackage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCodSurchargeApplyToPackage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCodSurchargeApplyToPackage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodSurchargeApplyToPackage: %w", err)
	}
	return oldValue.CodSurchargeApplyToPackage, nil
}

// ClearCodSurchargeApplyToPackage clears the value of the "cod_surcharge_apply_to_package" field.
func (m *ShipmentGatewayUpsMutation) ClearCodSurchargeApplyToPackage() {
	m.cod_surcharge_apply_to_package = nil
	m.clearedFields[shipmentgatewayups.FieldCodSurchargeApplyToPackage] = struct{}{}
}

// CodSurchargeApplyToPackageCleared returns if the "cod_surcharge_apply_to_package" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) CodSurchargeApplyToPackageCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldCodSurchargeApplyToPackage]
	return ok
}

// ResetCodSurchargeApplyToPackage resets all changes to the "cod_surcharge_apply_to_package" field.
func (m *ShipmentGatewayUpsMutation) ResetCodSurchargeApplyToPackage() {
	m.cod_surcharge_apply_to_package = nil
	delete(m.clearedFields, shipmentgatewayups.FieldCodSurchargeApplyToPackage)
}

// SetCodFundsCode sets the "cod_funds_code" field.
func (m *ShipmentGatewayUpsMutation) SetCodFundsCode(s string) {
	m.cod_funds_code = &s
}

// CodFundsCode returns the value of the "cod_funds_code" field in the mutation.
func (m *ShipmentGatewayUpsMutation) CodFundsCode() (r string, exists bool) {
	v := m.cod_funds_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCodFundsCode returns the old "cod_funds_code" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldCodFundsCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCodFundsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCodFundsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodFundsCode: %w", err)
	}
	return oldValue.CodFundsCode, nil
}

// ClearCodFundsCode clears the value of the "cod_funds_code" field.
func (m *ShipmentGatewayUpsMutation) ClearCodFundsCode() {
	m.cod_funds_code = nil
	m.clearedFields[shipmentgatewayups.FieldCodFundsCode] = struct{}{}
}

// CodFundsCodeCleared returns if the "cod_funds_code" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) CodFundsCodeCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldCodFundsCode]
	return ok
}

// ResetCodFundsCode resets all changes to the "cod_funds_code" field.
func (m *ShipmentGatewayUpsMutation) ResetCodFundsCode() {
	m.cod_funds_code = nil
	delete(m.clearedFields, shipmentgatewayups.FieldCodFundsCode)
}

// SetDefaultReturnLabelMemo sets the "default_return_label_memo" field.
func (m *ShipmentGatewayUpsMutation) SetDefaultReturnLabelMemo(s string) {
	m.default_return_label_memo = &s
}

// DefaultReturnLabelMemo returns the value of the "default_return_label_memo" field in the mutation.
func (m *ShipmentGatewayUpsMutation) DefaultReturnLabelMemo() (r string, exists bool) {
	v := m.default_return_label_memo
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultReturnLabelMemo returns the old "default_return_label_memo" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldDefaultReturnLabelMemo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultReturnLabelMemo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultReturnLabelMemo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultReturnLabelMemo: %w", err)
	}
	return oldValue.DefaultReturnLabelMemo, nil
}

// ClearDefaultReturnLabelMemo clears the value of the "default_return_label_memo" field.
func (m *ShipmentGatewayUpsMutation) ClearDefaultReturnLabelMemo() {
	m.default_return_label_memo = nil
	m.clearedFields[shipmentgatewayups.FieldDefaultReturnLabelMemo] = struct{}{}
}

// DefaultReturnLabelMemoCleared returns if the "default_return_label_memo" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) DefaultReturnLabelMemoCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldDefaultReturnLabelMemo]
	return ok
}

// ResetDefaultReturnLabelMemo resets all changes to the "default_return_label_memo" field.
func (m *ShipmentGatewayUpsMutation) ResetDefaultReturnLabelMemo() {
	m.default_return_label_memo = nil
	delete(m.clearedFields, shipmentgatewayups.FieldDefaultReturnLabelMemo)
}

// SetDefaultReturnLabelSubject sets the "default_return_label_subject" field.
func (m *ShipmentGatewayUpsMutation) SetDefaultReturnLabelSubject(s string) {
	m.default_return_label_subject = &s
}

// DefaultReturnLabelSubject returns the value of the "default_return_label_subject" field in the mutation.
func (m *ShipmentGatewayUpsMutation) DefaultReturnLabelSubject() (r string, exists bool) {
	v := m.default_return_label_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultReturnLabelSubject returns the old "default_return_label_subject" field's value of the ShipmentGatewayUps entity.
// If the ShipmentGatewayUps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUpsMutation) OldDefaultReturnLabelSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultReturnLabelSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultReturnLabelSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultReturnLabelSubject: %w", err)
	}
	return oldValue.DefaultReturnLabelSubject, nil
}

// ClearDefaultReturnLabelSubject clears the value of the "default_return_label_subject" field.
func (m *ShipmentGatewayUpsMutation) ClearDefaultReturnLabelSubject() {
	m.default_return_label_subject = nil
	m.clearedFields[shipmentgatewayups.FieldDefaultReturnLabelSubject] = struct{}{}
}

// DefaultReturnLabelSubjectCleared returns if the "default_return_label_subject" field was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) DefaultReturnLabelSubjectCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayups.FieldDefaultReturnLabelSubject]
	return ok
}

// ResetDefaultReturnLabelSubject resets all changes to the "default_return_label_subject" field.
func (m *ShipmentGatewayUpsMutation) ResetDefaultReturnLabelSubject() {
	m.default_return_label_subject = nil
	delete(m.clearedFields, shipmentgatewayups.FieldDefaultReturnLabelSubject)
}

// SetShipmentGatewayConfigID sets the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity by id.
func (m *ShipmentGatewayUpsMutation) SetShipmentGatewayConfigID(id int) {
	m.shipment_gateway_config = &id
}

// ClearShipmentGatewayConfig clears the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity.
func (m *ShipmentGatewayUpsMutation) ClearShipmentGatewayConfig() {
	m.clearedshipment_gateway_config = true
}

// ShipmentGatewayConfigCleared reports if the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity was cleared.
func (m *ShipmentGatewayUpsMutation) ShipmentGatewayConfigCleared() bool {
	return m.clearedshipment_gateway_config
}

// ShipmentGatewayConfigID returns the "shipment_gateway_config" edge ID in the mutation.
func (m *ShipmentGatewayUpsMutation) ShipmentGatewayConfigID() (id int, exists bool) {
	if m.shipment_gateway_config != nil {
		return *m.shipment_gateway_config, true
	}
	return
}

// ShipmentGatewayConfigIDs returns the "shipment_gateway_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayConfigID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayUpsMutation) ShipmentGatewayConfigIDs() (ids []int) {
	if id := m.shipment_gateway_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayConfig resets all changes to the "shipment_gateway_config" edge.
func (m *ShipmentGatewayUpsMutation) ResetShipmentGatewayConfig() {
	m.shipment_gateway_config = nil
	m.clearedshipment_gateway_config = false
}

// Op returns the operation name.
func (m *ShipmentGatewayUpsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentGatewayUps).
func (m *ShipmentGatewayUpsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGatewayUpsMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.create_time != nil {
		fields = append(fields, shipmentgatewayups.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentgatewayups.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentgatewayups.FieldStringRef)
	}
	if m.connect_url != nil {
		fields = append(fields, shipmentgatewayups.FieldConnectURL)
	}
	if m.connect_timeout != nil {
		fields = append(fields, shipmentgatewayups.FieldConnectTimeout)
	}
	if m.shipper_number != nil {
		fields = append(fields, shipmentgatewayups.FieldShipperNumber)
	}
	if m.bill_shipper_account_number != nil {
		fields = append(fields, shipmentgatewayups.FieldBillShipperAccountNumber)
	}
	if m.access_license_number != nil {
		fields = append(fields, shipmentgatewayups.FieldAccessLicenseNumber)
	}
	if m.access_user_id != nil {
		fields = append(fields, shipmentgatewayups.FieldAccessUserID)
	}
	if m.access_password != nil {
		fields = append(fields, shipmentgatewayups.FieldAccessPassword)
	}
	if m.save_cert_info != nil {
		fields = append(fields, shipmentgatewayups.FieldSaveCertInfo)
	}
	if m.save_cert_path != nil {
		fields = append(fields, shipmentgatewayups.FieldSaveCertPath)
	}
	if m.shipper_pickup_type != nil {
		fields = append(fields, shipmentgatewayups.FieldShipperPickupType)
	}
	if m.customer_classification != nil {
		fields = append(fields, shipmentgatewayups.FieldCustomerClassification)
	}
	if m.max_estimate_weight != nil {
		fields = append(fields, shipmentgatewayups.FieldMaxEstimateWeight)
	}
	if m.min_estimate_weight != nil {
		fields = append(fields, shipmentgatewayups.FieldMinEstimateWeight)
	}
	if m.cod_allow_cod != nil {
		fields = append(fields, shipmentgatewayups.FieldCodAllowCod)
	}
	if m.cod_surcharge_amount != nil {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeAmount)
	}
	if m.cod_surcharge_currency_uom_id != nil {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeCurrencyUomID)
	}
	if m.cod_surcharge_apply_to_package != nil {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeApplyToPackage)
	}
	if m.cod_funds_code != nil {
		fields = append(fields, shipmentgatewayups.FieldCodFundsCode)
	}
	if m.default_return_label_memo != nil {
		fields = append(fields, shipmentgatewayups.FieldDefaultReturnLabelMemo)
	}
	if m.default_return_label_subject != nil {
		fields = append(fields, shipmentgatewayups.FieldDefaultReturnLabelSubject)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGatewayUpsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayups.FieldCreateTime:
		return m.CreateTime()
	case shipmentgatewayups.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentgatewayups.FieldStringRef:
		return m.StringRef()
	case shipmentgatewayups.FieldConnectURL:
		return m.ConnectURL()
	case shipmentgatewayups.FieldConnectTimeout:
		return m.ConnectTimeout()
	case shipmentgatewayups.FieldShipperNumber:
		return m.ShipperNumber()
	case shipmentgatewayups.FieldBillShipperAccountNumber:
		return m.BillShipperAccountNumber()
	case shipmentgatewayups.FieldAccessLicenseNumber:
		return m.AccessLicenseNumber()
	case shipmentgatewayups.FieldAccessUserID:
		return m.AccessUserID()
	case shipmentgatewayups.FieldAccessPassword:
		return m.AccessPassword()
	case shipmentgatewayups.FieldSaveCertInfo:
		return m.SaveCertInfo()
	case shipmentgatewayups.FieldSaveCertPath:
		return m.SaveCertPath()
	case shipmentgatewayups.FieldShipperPickupType:
		return m.ShipperPickupType()
	case shipmentgatewayups.FieldCustomerClassification:
		return m.CustomerClassification()
	case shipmentgatewayups.FieldMaxEstimateWeight:
		return m.MaxEstimateWeight()
	case shipmentgatewayups.FieldMinEstimateWeight:
		return m.MinEstimateWeight()
	case shipmentgatewayups.FieldCodAllowCod:
		return m.CodAllowCod()
	case shipmentgatewayups.FieldCodSurchargeAmount:
		return m.CodSurchargeAmount()
	case shipmentgatewayups.FieldCodSurchargeCurrencyUomID:
		return m.CodSurchargeCurrencyUomID()
	case shipmentgatewayups.FieldCodSurchargeApplyToPackage:
		return m.CodSurchargeApplyToPackage()
	case shipmentgatewayups.FieldCodFundsCode:
		return m.CodFundsCode()
	case shipmentgatewayups.FieldDefaultReturnLabelMemo:
		return m.DefaultReturnLabelMemo()
	case shipmentgatewayups.FieldDefaultReturnLabelSubject:
		return m.DefaultReturnLabelSubject()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGatewayUpsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgatewayups.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentgatewayups.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentgatewayups.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentgatewayups.FieldConnectURL:
		return m.OldConnectURL(ctx)
	case shipmentgatewayups.FieldConnectTimeout:
		return m.OldConnectTimeout(ctx)
	case shipmentgatewayups.FieldShipperNumber:
		return m.OldShipperNumber(ctx)
	case shipmentgatewayups.FieldBillShipperAccountNumber:
		return m.OldBillShipperAccountNumber(ctx)
	case shipmentgatewayups.FieldAccessLicenseNumber:
		return m.OldAccessLicenseNumber(ctx)
	case shipmentgatewayups.FieldAccessUserID:
		return m.OldAccessUserID(ctx)
	case shipmentgatewayups.FieldAccessPassword:
		return m.OldAccessPassword(ctx)
	case shipmentgatewayups.FieldSaveCertInfo:
		return m.OldSaveCertInfo(ctx)
	case shipmentgatewayups.FieldSaveCertPath:
		return m.OldSaveCertPath(ctx)
	case shipmentgatewayups.FieldShipperPickupType:
		return m.OldShipperPickupType(ctx)
	case shipmentgatewayups.FieldCustomerClassification:
		return m.OldCustomerClassification(ctx)
	case shipmentgatewayups.FieldMaxEstimateWeight:
		return m.OldMaxEstimateWeight(ctx)
	case shipmentgatewayups.FieldMinEstimateWeight:
		return m.OldMinEstimateWeight(ctx)
	case shipmentgatewayups.FieldCodAllowCod:
		return m.OldCodAllowCod(ctx)
	case shipmentgatewayups.FieldCodSurchargeAmount:
		return m.OldCodSurchargeAmount(ctx)
	case shipmentgatewayups.FieldCodSurchargeCurrencyUomID:
		return m.OldCodSurchargeCurrencyUomID(ctx)
	case shipmentgatewayups.FieldCodSurchargeApplyToPackage:
		return m.OldCodSurchargeApplyToPackage(ctx)
	case shipmentgatewayups.FieldCodFundsCode:
		return m.OldCodFundsCode(ctx)
	case shipmentgatewayups.FieldDefaultReturnLabelMemo:
		return m.OldDefaultReturnLabelMemo(ctx)
	case shipmentgatewayups.FieldDefaultReturnLabelSubject:
		return m.OldDefaultReturnLabelSubject(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGatewayUps field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayUpsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayups.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentgatewayups.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentgatewayups.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentgatewayups.FieldConnectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectURL(v)
		return nil
	case shipmentgatewayups.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectTimeout(v)
		return nil
	case shipmentgatewayups.FieldShipperNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipperNumber(v)
		return nil
	case shipmentgatewayups.FieldBillShipperAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillShipperAccountNumber(v)
		return nil
	case shipmentgatewayups.FieldAccessLicenseNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessLicenseNumber(v)
		return nil
	case shipmentgatewayups.FieldAccessUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessUserID(v)
		return nil
	case shipmentgatewayups.FieldAccessPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessPassword(v)
		return nil
	case shipmentgatewayups.FieldSaveCertInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaveCertInfo(v)
		return nil
	case shipmentgatewayups.FieldSaveCertPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaveCertPath(v)
		return nil
	case shipmentgatewayups.FieldShipperPickupType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipperPickupType(v)
		return nil
	case shipmentgatewayups.FieldCustomerClassification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerClassification(v)
		return nil
	case shipmentgatewayups.FieldMaxEstimateWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxEstimateWeight(v)
		return nil
	case shipmentgatewayups.FieldMinEstimateWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinEstimateWeight(v)
		return nil
	case shipmentgatewayups.FieldCodAllowCod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodAllowCod(v)
		return nil
	case shipmentgatewayups.FieldCodSurchargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodSurchargeAmount(v)
		return nil
	case shipmentgatewayups.FieldCodSurchargeCurrencyUomID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodSurchargeCurrencyUomID(v)
		return nil
	case shipmentgatewayups.FieldCodSurchargeApplyToPackage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodSurchargeApplyToPackage(v)
		return nil
	case shipmentgatewayups.FieldCodFundsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodFundsCode(v)
		return nil
	case shipmentgatewayups.FieldDefaultReturnLabelMemo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultReturnLabelMemo(v)
		return nil
	case shipmentgatewayups.FieldDefaultReturnLabelSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultReturnLabelSubject(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUps field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGatewayUpsMutation) AddedFields() []string {
	var fields []string
	if m.addconnect_timeout != nil {
		fields = append(fields, shipmentgatewayups.FieldConnectTimeout)
	}
	if m.addmax_estimate_weight != nil {
		fields = append(fields, shipmentgatewayups.FieldMaxEstimateWeight)
	}
	if m.addmin_estimate_weight != nil {
		fields = append(fields, shipmentgatewayups.FieldMinEstimateWeight)
	}
	if m.addcod_surcharge_amount != nil {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGatewayUpsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayups.FieldConnectTimeout:
		return m.AddedConnectTimeout()
	case shipmentgatewayups.FieldMaxEstimateWeight:
		return m.AddedMaxEstimateWeight()
	case shipmentgatewayups.FieldMinEstimateWeight:
		return m.AddedMinEstimateWeight()
	case shipmentgatewayups.FieldCodSurchargeAmount:
		return m.AddedCodSurchargeAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayUpsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayups.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnectTimeout(v)
		return nil
	case shipmentgatewayups.FieldMaxEstimateWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxEstimateWeight(v)
		return nil
	case shipmentgatewayups.FieldMinEstimateWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinEstimateWeight(v)
		return nil
	case shipmentgatewayups.FieldCodSurchargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCodSurchargeAmount(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUps numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGatewayUpsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentgatewayups.FieldStringRef) {
		fields = append(fields, shipmentgatewayups.FieldStringRef)
	}
	if m.FieldCleared(shipmentgatewayups.FieldConnectURL) {
		fields = append(fields, shipmentgatewayups.FieldConnectURL)
	}
	if m.FieldCleared(shipmentgatewayups.FieldConnectTimeout) {
		fields = append(fields, shipmentgatewayups.FieldConnectTimeout)
	}
	if m.FieldCleared(shipmentgatewayups.FieldShipperNumber) {
		fields = append(fields, shipmentgatewayups.FieldShipperNumber)
	}
	if m.FieldCleared(shipmentgatewayups.FieldBillShipperAccountNumber) {
		fields = append(fields, shipmentgatewayups.FieldBillShipperAccountNumber)
	}
	if m.FieldCleared(shipmentgatewayups.FieldAccessLicenseNumber) {
		fields = append(fields, shipmentgatewayups.FieldAccessLicenseNumber)
	}
	if m.FieldCleared(shipmentgatewayups.FieldAccessUserID) {
		fields = append(fields, shipmentgatewayups.FieldAccessUserID)
	}
	if m.FieldCleared(shipmentgatewayups.FieldAccessPassword) {
		fields = append(fields, shipmentgatewayups.FieldAccessPassword)
	}
	if m.FieldCleared(shipmentgatewayups.FieldSaveCertInfo) {
		fields = append(fields, shipmentgatewayups.FieldSaveCertInfo)
	}
	if m.FieldCleared(shipmentgatewayups.FieldSaveCertPath) {
		fields = append(fields, shipmentgatewayups.FieldSaveCertPath)
	}
	if m.FieldCleared(shipmentgatewayups.FieldShipperPickupType) {
		fields = append(fields, shipmentgatewayups.FieldShipperPickupType)
	}
	if m.FieldCleared(shipmentgatewayups.FieldCustomerClassification) {
		fields = append(fields, shipmentgatewayups.FieldCustomerClassification)
	}
	if m.FieldCleared(shipmentgatewayups.FieldMaxEstimateWeight) {
		fields = append(fields, shipmentgatewayups.FieldMaxEstimateWeight)
	}
	if m.FieldCleared(shipmentgatewayups.FieldMinEstimateWeight) {
		fields = append(fields, shipmentgatewayups.FieldMinEstimateWeight)
	}
	if m.FieldCleared(shipmentgatewayups.FieldCodAllowCod) {
		fields = append(fields, shipmentgatewayups.FieldCodAllowCod)
	}
	if m.FieldCleared(shipmentgatewayups.FieldCodSurchargeAmount) {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeAmount)
	}
	if m.FieldCleared(shipmentgatewayups.FieldCodSurchargeCurrencyUomID) {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeCurrencyUomID)
	}
	if m.FieldCleared(shipmentgatewayups.FieldCodSurchargeApplyToPackage) {
		fields = append(fields, shipmentgatewayups.FieldCodSurchargeApplyToPackage)
	}
	if m.FieldCleared(shipmentgatewayups.FieldCodFundsCode) {
		fields = append(fields, shipmentgatewayups.FieldCodFundsCode)
	}
	if m.FieldCleared(shipmentgatewayups.FieldDefaultReturnLabelMemo) {
		fields = append(fields, shipmentgatewayups.FieldDefaultReturnLabelMemo)
	}
	if m.FieldCleared(shipmentgatewayups.FieldDefaultReturnLabelSubject) {
		fields = append(fields, shipmentgatewayups.FieldDefaultReturnLabelSubject)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGatewayUpsMutation) ClearField(name string) error {
	switch name {
	case shipmentgatewayups.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentgatewayups.FieldConnectURL:
		m.ClearConnectURL()
		return nil
	case shipmentgatewayups.FieldConnectTimeout:
		m.ClearConnectTimeout()
		return nil
	case shipmentgatewayups.FieldShipperNumber:
		m.ClearShipperNumber()
		return nil
	case shipmentgatewayups.FieldBillShipperAccountNumber:
		m.ClearBillShipperAccountNumber()
		return nil
	case shipmentgatewayups.FieldAccessLicenseNumber:
		m.ClearAccessLicenseNumber()
		return nil
	case shipmentgatewayups.FieldAccessUserID:
		m.ClearAccessUserID()
		return nil
	case shipmentgatewayups.FieldAccessPassword:
		m.ClearAccessPassword()
		return nil
	case shipmentgatewayups.FieldSaveCertInfo:
		m.ClearSaveCertInfo()
		return nil
	case shipmentgatewayups.FieldSaveCertPath:
		m.ClearSaveCertPath()
		return nil
	case shipmentgatewayups.FieldShipperPickupType:
		m.ClearShipperPickupType()
		return nil
	case shipmentgatewayups.FieldCustomerClassification:
		m.ClearCustomerClassification()
		return nil
	case shipmentgatewayups.FieldMaxEstimateWeight:
		m.ClearMaxEstimateWeight()
		return nil
	case shipmentgatewayups.FieldMinEstimateWeight:
		m.ClearMinEstimateWeight()
		return nil
	case shipmentgatewayups.FieldCodAllowCod:
		m.ClearCodAllowCod()
		return nil
	case shipmentgatewayups.FieldCodSurchargeAmount:
		m.ClearCodSurchargeAmount()
		return nil
	case shipmentgatewayups.FieldCodSurchargeCurrencyUomID:
		m.ClearCodSurchargeCurrencyUomID()
		return nil
	case shipmentgatewayups.FieldCodSurchargeApplyToPackage:
		m.ClearCodSurchargeApplyToPackage()
		return nil
	case shipmentgatewayups.FieldCodFundsCode:
		m.ClearCodFundsCode()
		return nil
	case shipmentgatewayups.FieldDefaultReturnLabelMemo:
		m.ClearDefaultReturnLabelMemo()
		return nil
	case shipmentgatewayups.FieldDefaultReturnLabelSubject:
		m.ClearDefaultReturnLabelSubject()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUps nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGatewayUpsMutation) ResetField(name string) error {
	switch name {
	case shipmentgatewayups.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentgatewayups.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentgatewayups.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentgatewayups.FieldConnectURL:
		m.ResetConnectURL()
		return nil
	case shipmentgatewayups.FieldConnectTimeout:
		m.ResetConnectTimeout()
		return nil
	case shipmentgatewayups.FieldShipperNumber:
		m.ResetShipperNumber()
		return nil
	case shipmentgatewayups.FieldBillShipperAccountNumber:
		m.ResetBillShipperAccountNumber()
		return nil
	case shipmentgatewayups.FieldAccessLicenseNumber:
		m.ResetAccessLicenseNumber()
		return nil
	case shipmentgatewayups.FieldAccessUserID:
		m.ResetAccessUserID()
		return nil
	case shipmentgatewayups.FieldAccessPassword:
		m.ResetAccessPassword()
		return nil
	case shipmentgatewayups.FieldSaveCertInfo:
		m.ResetSaveCertInfo()
		return nil
	case shipmentgatewayups.FieldSaveCertPath:
		m.ResetSaveCertPath()
		return nil
	case shipmentgatewayups.FieldShipperPickupType:
		m.ResetShipperPickupType()
		return nil
	case shipmentgatewayups.FieldCustomerClassification:
		m.ResetCustomerClassification()
		return nil
	case shipmentgatewayups.FieldMaxEstimateWeight:
		m.ResetMaxEstimateWeight()
		return nil
	case shipmentgatewayups.FieldMinEstimateWeight:
		m.ResetMinEstimateWeight()
		return nil
	case shipmentgatewayups.FieldCodAllowCod:
		m.ResetCodAllowCod()
		return nil
	case shipmentgatewayups.FieldCodSurchargeAmount:
		m.ResetCodSurchargeAmount()
		return nil
	case shipmentgatewayups.FieldCodSurchargeCurrencyUomID:
		m.ResetCodSurchargeCurrencyUomID()
		return nil
	case shipmentgatewayups.FieldCodSurchargeApplyToPackage:
		m.ResetCodSurchargeApplyToPackage()
		return nil
	case shipmentgatewayups.FieldCodFundsCode:
		m.ResetCodFundsCode()
		return nil
	case shipmentgatewayups.FieldDefaultReturnLabelMemo:
		m.ResetDefaultReturnLabelMemo()
		return nil
	case shipmentgatewayups.FieldDefaultReturnLabelSubject:
		m.ResetDefaultReturnLabelSubject()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUps field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGatewayUpsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.shipment_gateway_config != nil {
		edges = append(edges, shipmentgatewayups.EdgeShipmentGatewayConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGatewayUpsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewayups.EdgeShipmentGatewayConfig:
		if id := m.shipment_gateway_config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGatewayUpsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGatewayUpsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshipment_gateway_config {
		edges = append(edges, shipmentgatewayups.EdgeShipmentGatewayConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGatewayUpsMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgatewayups.EdgeShipmentGatewayConfig:
		return m.clearedshipment_gateway_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGatewayUpsMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgatewayups.EdgeShipmentGatewayConfig:
		m.ClearShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUps unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGatewayUpsMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgatewayups.EdgeShipmentGatewayConfig:
		m.ResetShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUps edge %s", name)
}

// ShipmentGatewayUspsMutation represents an operation that mutates the ShipmentGatewayUsps nodes in the graph.
type ShipmentGatewayUspsMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	create_time                    *time.Time
	update_time                    *time.Time
	string_ref                     *string
	connect_url                    *string
	connect_url_labels             *string
	connect_timeout                *int
	addconnect_timeout             *int
	access_user_id                 *string
	access_password                *string
	max_estimate_weight            *int
	addmax_estimate_weight         *int
	test                           *string
	clearedFields                  map[string]struct{}
	shipment_gateway_config        *int
	clearedshipment_gateway_config bool
	done                           bool
	oldValue                       func(context.Context) (*ShipmentGatewayUsps, error)
	predicates                     []predicate.ShipmentGatewayUsps
}

var _ ent.Mutation = (*ShipmentGatewayUspsMutation)(nil)

// shipmentgatewayuspsOption allows management of the mutation configuration using functional options.
type shipmentgatewayuspsOption func(*ShipmentGatewayUspsMutation)

// newShipmentGatewayUspsMutation creates new mutation for the ShipmentGatewayUsps entity.
func newShipmentGatewayUspsMutation(c config, op Op, opts ...shipmentgatewayuspsOption) *ShipmentGatewayUspsMutation {
	m := &ShipmentGatewayUspsMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGatewayUsps,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGatewayUspsID sets the ID field of the mutation.
func withShipmentGatewayUspsID(id int) shipmentgatewayuspsOption {
	return func(m *ShipmentGatewayUspsMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGatewayUsps
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGatewayUsps, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGatewayUsps.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGatewayUsps sets the old ShipmentGatewayUsps of the mutation.
func withShipmentGatewayUsps(node *ShipmentGatewayUsps) shipmentgatewayuspsOption {
	return func(m *ShipmentGatewayUspsMutation) {
		m.oldValue = func(context.Context) (*ShipmentGatewayUsps, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGatewayUspsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGatewayUspsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGatewayUspsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentGatewayUspsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentGatewayUspsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentGatewayUspsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentGatewayUspsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentGatewayUspsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentGatewayUspsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentGatewayUspsMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentGatewayUspsMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentGatewayUspsMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmentgatewayusps.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentGatewayUspsMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldStringRef)
}

// SetConnectURL sets the "connect_url" field.
func (m *ShipmentGatewayUspsMutation) SetConnectURL(s string) {
	m.connect_url = &s
}

// ConnectURL returns the value of the "connect_url" field in the mutation.
func (m *ShipmentGatewayUspsMutation) ConnectURL() (r string, exists bool) {
	v := m.connect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectURL returns the old "connect_url" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldConnectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectURL: %w", err)
	}
	return oldValue.ConnectURL, nil
}

// ClearConnectURL clears the value of the "connect_url" field.
func (m *ShipmentGatewayUspsMutation) ClearConnectURL() {
	m.connect_url = nil
	m.clearedFields[shipmentgatewayusps.FieldConnectURL] = struct{}{}
}

// ConnectURLCleared returns if the "connect_url" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) ConnectURLCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldConnectURL]
	return ok
}

// ResetConnectURL resets all changes to the "connect_url" field.
func (m *ShipmentGatewayUspsMutation) ResetConnectURL() {
	m.connect_url = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldConnectURL)
}

// SetConnectURLLabels sets the "connect_url_labels" field.
func (m *ShipmentGatewayUspsMutation) SetConnectURLLabels(s string) {
	m.connect_url_labels = &s
}

// ConnectURLLabels returns the value of the "connect_url_labels" field in the mutation.
func (m *ShipmentGatewayUspsMutation) ConnectURLLabels() (r string, exists bool) {
	v := m.connect_url_labels
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectURLLabels returns the old "connect_url_labels" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldConnectURLLabels(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectURLLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectURLLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectURLLabels: %w", err)
	}
	return oldValue.ConnectURLLabels, nil
}

// ClearConnectURLLabels clears the value of the "connect_url_labels" field.
func (m *ShipmentGatewayUspsMutation) ClearConnectURLLabels() {
	m.connect_url_labels = nil
	m.clearedFields[shipmentgatewayusps.FieldConnectURLLabels] = struct{}{}
}

// ConnectURLLabelsCleared returns if the "connect_url_labels" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) ConnectURLLabelsCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldConnectURLLabels]
	return ok
}

// ResetConnectURLLabels resets all changes to the "connect_url_labels" field.
func (m *ShipmentGatewayUspsMutation) ResetConnectURLLabels() {
	m.connect_url_labels = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldConnectURLLabels)
}

// SetConnectTimeout sets the "connect_timeout" field.
func (m *ShipmentGatewayUspsMutation) SetConnectTimeout(i int) {
	m.connect_timeout = &i
	m.addconnect_timeout = nil
}

// ConnectTimeout returns the value of the "connect_timeout" field in the mutation.
func (m *ShipmentGatewayUspsMutation) ConnectTimeout() (r int, exists bool) {
	v := m.connect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectTimeout returns the old "connect_timeout" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldConnectTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConnectTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConnectTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectTimeout: %w", err)
	}
	return oldValue.ConnectTimeout, nil
}

// AddConnectTimeout adds i to the "connect_timeout" field.
func (m *ShipmentGatewayUspsMutation) AddConnectTimeout(i int) {
	if m.addconnect_timeout != nil {
		*m.addconnect_timeout += i
	} else {
		m.addconnect_timeout = &i
	}
}

// AddedConnectTimeout returns the value that was added to the "connect_timeout" field in this mutation.
func (m *ShipmentGatewayUspsMutation) AddedConnectTimeout() (r int, exists bool) {
	v := m.addconnect_timeout
	if v == nil {
		return
	}
	return *v, true
}

// ClearConnectTimeout clears the value of the "connect_timeout" field.
func (m *ShipmentGatewayUspsMutation) ClearConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	m.clearedFields[shipmentgatewayusps.FieldConnectTimeout] = struct{}{}
}

// ConnectTimeoutCleared returns if the "connect_timeout" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) ConnectTimeoutCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldConnectTimeout]
	return ok
}

// ResetConnectTimeout resets all changes to the "connect_timeout" field.
func (m *ShipmentGatewayUspsMutation) ResetConnectTimeout() {
	m.connect_timeout = nil
	m.addconnect_timeout = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldConnectTimeout)
}

// SetAccessUserID sets the "access_user_id" field.
func (m *ShipmentGatewayUspsMutation) SetAccessUserID(s string) {
	m.access_user_id = &s
}

// AccessUserID returns the value of the "access_user_id" field in the mutation.
func (m *ShipmentGatewayUspsMutation) AccessUserID() (r string, exists bool) {
	v := m.access_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessUserID returns the old "access_user_id" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldAccessUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessUserID: %w", err)
	}
	return oldValue.AccessUserID, nil
}

// ClearAccessUserID clears the value of the "access_user_id" field.
func (m *ShipmentGatewayUspsMutation) ClearAccessUserID() {
	m.access_user_id = nil
	m.clearedFields[shipmentgatewayusps.FieldAccessUserID] = struct{}{}
}

// AccessUserIDCleared returns if the "access_user_id" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) AccessUserIDCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldAccessUserID]
	return ok
}

// ResetAccessUserID resets all changes to the "access_user_id" field.
func (m *ShipmentGatewayUspsMutation) ResetAccessUserID() {
	m.access_user_id = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldAccessUserID)
}

// SetAccessPassword sets the "access_password" field.
func (m *ShipmentGatewayUspsMutation) SetAccessPassword(s string) {
	m.access_password = &s
}

// AccessPassword returns the value of the "access_password" field in the mutation.
func (m *ShipmentGatewayUspsMutation) AccessPassword() (r string, exists bool) {
	v := m.access_password
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessPassword returns the old "access_password" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldAccessPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccessPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccessPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessPassword: %w", err)
	}
	return oldValue.AccessPassword, nil
}

// ClearAccessPassword clears the value of the "access_password" field.
func (m *ShipmentGatewayUspsMutation) ClearAccessPassword() {
	m.access_password = nil
	m.clearedFields[shipmentgatewayusps.FieldAccessPassword] = struct{}{}
}

// AccessPasswordCleared returns if the "access_password" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) AccessPasswordCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldAccessPassword]
	return ok
}

// ResetAccessPassword resets all changes to the "access_password" field.
func (m *ShipmentGatewayUspsMutation) ResetAccessPassword() {
	m.access_password = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldAccessPassword)
}

// SetMaxEstimateWeight sets the "max_estimate_weight" field.
func (m *ShipmentGatewayUspsMutation) SetMaxEstimateWeight(i int) {
	m.max_estimate_weight = &i
	m.addmax_estimate_weight = nil
}

// MaxEstimateWeight returns the value of the "max_estimate_weight" field in the mutation.
func (m *ShipmentGatewayUspsMutation) MaxEstimateWeight() (r int, exists bool) {
	v := m.max_estimate_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxEstimateWeight returns the old "max_estimate_weight" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldMaxEstimateWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaxEstimateWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaxEstimateWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxEstimateWeight: %w", err)
	}
	return oldValue.MaxEstimateWeight, nil
}

// AddMaxEstimateWeight adds i to the "max_estimate_weight" field.
func (m *ShipmentGatewayUspsMutation) AddMaxEstimateWeight(i int) {
	if m.addmax_estimate_weight != nil {
		*m.addmax_estimate_weight += i
	} else {
		m.addmax_estimate_weight = &i
	}
}

// AddedMaxEstimateWeight returns the value that was added to the "max_estimate_weight" field in this mutation.
func (m *ShipmentGatewayUspsMutation) AddedMaxEstimateWeight() (r int, exists bool) {
	v := m.addmax_estimate_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxEstimateWeight clears the value of the "max_estimate_weight" field.
func (m *ShipmentGatewayUspsMutation) ClearMaxEstimateWeight() {
	m.max_estimate_weight = nil
	m.addmax_estimate_weight = nil
	m.clearedFields[shipmentgatewayusps.FieldMaxEstimateWeight] = struct{}{}
}

// MaxEstimateWeightCleared returns if the "max_estimate_weight" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) MaxEstimateWeightCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldMaxEstimateWeight]
	return ok
}

// ResetMaxEstimateWeight resets all changes to the "max_estimate_weight" field.
func (m *ShipmentGatewayUspsMutation) ResetMaxEstimateWeight() {
	m.max_estimate_weight = nil
	m.addmax_estimate_weight = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldMaxEstimateWeight)
}

// SetTest sets the "test" field.
func (m *ShipmentGatewayUspsMutation) SetTest(s string) {
	m.test = &s
}

// Test returns the value of the "test" field in the mutation.
func (m *ShipmentGatewayUspsMutation) Test() (r string, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTest returns the old "test" field's value of the ShipmentGatewayUsps entity.
// If the ShipmentGatewayUsps object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGatewayUspsMutation) OldTest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTest: %w", err)
	}
	return oldValue.Test, nil
}

// ClearTest clears the value of the "test" field.
func (m *ShipmentGatewayUspsMutation) ClearTest() {
	m.test = nil
	m.clearedFields[shipmentgatewayusps.FieldTest] = struct{}{}
}

// TestCleared returns if the "test" field was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) TestCleared() bool {
	_, ok := m.clearedFields[shipmentgatewayusps.FieldTest]
	return ok
}

// ResetTest resets all changes to the "test" field.
func (m *ShipmentGatewayUspsMutation) ResetTest() {
	m.test = nil
	delete(m.clearedFields, shipmentgatewayusps.FieldTest)
}

// SetShipmentGatewayConfigID sets the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity by id.
func (m *ShipmentGatewayUspsMutation) SetShipmentGatewayConfigID(id int) {
	m.shipment_gateway_config = &id
}

// ClearShipmentGatewayConfig clears the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity.
func (m *ShipmentGatewayUspsMutation) ClearShipmentGatewayConfig() {
	m.clearedshipment_gateway_config = true
}

// ShipmentGatewayConfigCleared reports if the "shipment_gateway_config" edge to the ShipmentGatewayConfig entity was cleared.
func (m *ShipmentGatewayUspsMutation) ShipmentGatewayConfigCleared() bool {
	return m.clearedshipment_gateway_config
}

// ShipmentGatewayConfigID returns the "shipment_gateway_config" edge ID in the mutation.
func (m *ShipmentGatewayUspsMutation) ShipmentGatewayConfigID() (id int, exists bool) {
	if m.shipment_gateway_config != nil {
		return *m.shipment_gateway_config, true
	}
	return
}

// ShipmentGatewayConfigIDs returns the "shipment_gateway_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGatewayConfigID instead. It exists only for internal usage by the builders.
func (m *ShipmentGatewayUspsMutation) ShipmentGatewayConfigIDs() (ids []int) {
	if id := m.shipment_gateway_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGatewayConfig resets all changes to the "shipment_gateway_config" edge.
func (m *ShipmentGatewayUspsMutation) ResetShipmentGatewayConfig() {
	m.shipment_gateway_config = nil
	m.clearedshipment_gateway_config = false
}

// Op returns the operation name.
func (m *ShipmentGatewayUspsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentGatewayUsps).
func (m *ShipmentGatewayUspsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGatewayUspsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, shipmentgatewayusps.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmentgatewayusps.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmentgatewayusps.FieldStringRef)
	}
	if m.connect_url != nil {
		fields = append(fields, shipmentgatewayusps.FieldConnectURL)
	}
	if m.connect_url_labels != nil {
		fields = append(fields, shipmentgatewayusps.FieldConnectURLLabels)
	}
	if m.connect_timeout != nil {
		fields = append(fields, shipmentgatewayusps.FieldConnectTimeout)
	}
	if m.access_user_id != nil {
		fields = append(fields, shipmentgatewayusps.FieldAccessUserID)
	}
	if m.access_password != nil {
		fields = append(fields, shipmentgatewayusps.FieldAccessPassword)
	}
	if m.max_estimate_weight != nil {
		fields = append(fields, shipmentgatewayusps.FieldMaxEstimateWeight)
	}
	if m.test != nil {
		fields = append(fields, shipmentgatewayusps.FieldTest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGatewayUspsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayusps.FieldCreateTime:
		return m.CreateTime()
	case shipmentgatewayusps.FieldUpdateTime:
		return m.UpdateTime()
	case shipmentgatewayusps.FieldStringRef:
		return m.StringRef()
	case shipmentgatewayusps.FieldConnectURL:
		return m.ConnectURL()
	case shipmentgatewayusps.FieldConnectURLLabels:
		return m.ConnectURLLabels()
	case shipmentgatewayusps.FieldConnectTimeout:
		return m.ConnectTimeout()
	case shipmentgatewayusps.FieldAccessUserID:
		return m.AccessUserID()
	case shipmentgatewayusps.FieldAccessPassword:
		return m.AccessPassword()
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		return m.MaxEstimateWeight()
	case shipmentgatewayusps.FieldTest:
		return m.Test()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGatewayUspsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgatewayusps.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmentgatewayusps.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmentgatewayusps.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmentgatewayusps.FieldConnectURL:
		return m.OldConnectURL(ctx)
	case shipmentgatewayusps.FieldConnectURLLabels:
		return m.OldConnectURLLabels(ctx)
	case shipmentgatewayusps.FieldConnectTimeout:
		return m.OldConnectTimeout(ctx)
	case shipmentgatewayusps.FieldAccessUserID:
		return m.OldAccessUserID(ctx)
	case shipmentgatewayusps.FieldAccessPassword:
		return m.OldAccessPassword(ctx)
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		return m.OldMaxEstimateWeight(ctx)
	case shipmentgatewayusps.FieldTest:
		return m.OldTest(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGatewayUsps field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayUspsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayusps.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmentgatewayusps.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmentgatewayusps.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmentgatewayusps.FieldConnectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectURL(v)
		return nil
	case shipmentgatewayusps.FieldConnectURLLabels:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectURLLabels(v)
		return nil
	case shipmentgatewayusps.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectTimeout(v)
		return nil
	case shipmentgatewayusps.FieldAccessUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessUserID(v)
		return nil
	case shipmentgatewayusps.FieldAccessPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessPassword(v)
		return nil
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxEstimateWeight(v)
		return nil
	case shipmentgatewayusps.FieldTest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTest(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUsps field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGatewayUspsMutation) AddedFields() []string {
	var fields []string
	if m.addconnect_timeout != nil {
		fields = append(fields, shipmentgatewayusps.FieldConnectTimeout)
	}
	if m.addmax_estimate_weight != nil {
		fields = append(fields, shipmentgatewayusps.FieldMaxEstimateWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGatewayUspsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentgatewayusps.FieldConnectTimeout:
		return m.AddedConnectTimeout()
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		return m.AddedMaxEstimateWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGatewayUspsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentgatewayusps.FieldConnectTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConnectTimeout(v)
		return nil
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxEstimateWeight(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUsps numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGatewayUspsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentgatewayusps.FieldStringRef) {
		fields = append(fields, shipmentgatewayusps.FieldStringRef)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldConnectURL) {
		fields = append(fields, shipmentgatewayusps.FieldConnectURL)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldConnectURLLabels) {
		fields = append(fields, shipmentgatewayusps.FieldConnectURLLabels)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldConnectTimeout) {
		fields = append(fields, shipmentgatewayusps.FieldConnectTimeout)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldAccessUserID) {
		fields = append(fields, shipmentgatewayusps.FieldAccessUserID)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldAccessPassword) {
		fields = append(fields, shipmentgatewayusps.FieldAccessPassword)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldMaxEstimateWeight) {
		fields = append(fields, shipmentgatewayusps.FieldMaxEstimateWeight)
	}
	if m.FieldCleared(shipmentgatewayusps.FieldTest) {
		fields = append(fields, shipmentgatewayusps.FieldTest)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGatewayUspsMutation) ClearField(name string) error {
	switch name {
	case shipmentgatewayusps.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmentgatewayusps.FieldConnectURL:
		m.ClearConnectURL()
		return nil
	case shipmentgatewayusps.FieldConnectURLLabels:
		m.ClearConnectURLLabels()
		return nil
	case shipmentgatewayusps.FieldConnectTimeout:
		m.ClearConnectTimeout()
		return nil
	case shipmentgatewayusps.FieldAccessUserID:
		m.ClearAccessUserID()
		return nil
	case shipmentgatewayusps.FieldAccessPassword:
		m.ClearAccessPassword()
		return nil
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		m.ClearMaxEstimateWeight()
		return nil
	case shipmentgatewayusps.FieldTest:
		m.ClearTest()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUsps nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGatewayUspsMutation) ResetField(name string) error {
	switch name {
	case shipmentgatewayusps.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmentgatewayusps.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmentgatewayusps.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmentgatewayusps.FieldConnectURL:
		m.ResetConnectURL()
		return nil
	case shipmentgatewayusps.FieldConnectURLLabels:
		m.ResetConnectURLLabels()
		return nil
	case shipmentgatewayusps.FieldConnectTimeout:
		m.ResetConnectTimeout()
		return nil
	case shipmentgatewayusps.FieldAccessUserID:
		m.ResetAccessUserID()
		return nil
	case shipmentgatewayusps.FieldAccessPassword:
		m.ResetAccessPassword()
		return nil
	case shipmentgatewayusps.FieldMaxEstimateWeight:
		m.ResetMaxEstimateWeight()
		return nil
	case shipmentgatewayusps.FieldTest:
		m.ResetTest()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUsps field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGatewayUspsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.shipment_gateway_config != nil {
		edges = append(edges, shipmentgatewayusps.EdgeShipmentGatewayConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGatewayUspsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgatewayusps.EdgeShipmentGatewayConfig:
		if id := m.shipment_gateway_config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGatewayUspsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGatewayUspsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedshipment_gateway_config {
		edges = append(edges, shipmentgatewayusps.EdgeShipmentGatewayConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGatewayUspsMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgatewayusps.EdgeShipmentGatewayConfig:
		return m.clearedshipment_gateway_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGatewayUspsMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgatewayusps.EdgeShipmentGatewayConfig:
		m.ClearShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUsps unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGatewayUspsMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgatewayusps.EdgeShipmentGatewayConfig:
		m.ResetShipmentGatewayConfig()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGatewayUsps edge %s", name)
}

// ShipmentTypeMutation represents an operation that mutates the ShipmentType nodes in the graph.
type ShipmentTypeMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	string_ref                  *string
	has_table                   *shipmenttype.HasTable
	description                 *string
	clearedFields               map[string]struct{}
	parent                      *int
	clearedparent               bool
	children                    map[int]struct{}
	removedchildren             map[int]struct{}
	clearedchildren             bool
	child_shipment_types        map[int]struct{}
	removedchild_shipment_types map[int]struct{}
	clearedchild_shipment_types bool
	done                        bool
	oldValue                    func(context.Context) (*ShipmentType, error)
	predicates                  []predicate.ShipmentType
}

var _ ent.Mutation = (*ShipmentTypeMutation)(nil)

// shipmenttypeOption allows management of the mutation configuration using functional options.
type shipmenttypeOption func(*ShipmentTypeMutation)

// newShipmentTypeMutation creates new mutation for the ShipmentType entity.
func newShipmentTypeMutation(c config, op Op, opts ...shipmenttypeOption) *ShipmentTypeMutation {
	m := &ShipmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentTypeID sets the ID field of the mutation.
func withShipmentTypeID(id int) shipmenttypeOption {
	return func(m *ShipmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentType
		)
		m.oldValue = func(ctx context.Context) (*ShipmentType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentType sets the old ShipmentType of the mutation.
func withShipmentType(node *ShipmentType) shipmenttypeOption {
	return func(m *ShipmentTypeMutation) {
		m.oldValue = func(context.Context) (*ShipmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ShipmentTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ShipmentTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ShipmentTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ShipmentTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ShipmentTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ShipmentTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *ShipmentTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *ShipmentTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *ShipmentTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[shipmenttype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *ShipmentTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[shipmenttype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *ShipmentTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, shipmenttype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *ShipmentTypeMutation) SetHasTable(st shipmenttype.HasTable) {
	m.has_table = &st
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *ShipmentTypeMutation) HasTable() (r shipmenttype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldHasTable(ctx context.Context) (v shipmenttype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *ShipmentTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[shipmenttype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *ShipmentTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[shipmenttype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *ShipmentTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, shipmenttype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *ShipmentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShipmentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shipmenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShipmentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shipmenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shipmenttype.FieldDescription)
}

// SetParentID sets the "parent" edge to the ShipmentType entity by id.
func (m *ShipmentTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ShipmentType entity.
func (m *ShipmentTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ShipmentType entity was cleared.
func (m *ShipmentTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ShipmentTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ShipmentTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ShipmentTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the ShipmentType entity by ids.
func (m *ShipmentTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the ShipmentType entity.
func (m *ShipmentTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the ShipmentType entity was cleared.
func (m *ShipmentTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the ShipmentType entity by IDs.
func (m *ShipmentTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the ShipmentType entity.
func (m *ShipmentTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *ShipmentTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *ShipmentTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildShipmentTypeIDs adds the "child_shipment_types" edge to the ShipmentType entity by ids.
func (m *ShipmentTypeMutation) AddChildShipmentTypeIDs(ids ...int) {
	if m.child_shipment_types == nil {
		m.child_shipment_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_shipment_types[ids[i]] = struct{}{}
	}
}

// ClearChildShipmentTypes clears the "child_shipment_types" edge to the ShipmentType entity.
func (m *ShipmentTypeMutation) ClearChildShipmentTypes() {
	m.clearedchild_shipment_types = true
}

// ChildShipmentTypesCleared reports if the "child_shipment_types" edge to the ShipmentType entity was cleared.
func (m *ShipmentTypeMutation) ChildShipmentTypesCleared() bool {
	return m.clearedchild_shipment_types
}

// RemoveChildShipmentTypeIDs removes the "child_shipment_types" edge to the ShipmentType entity by IDs.
func (m *ShipmentTypeMutation) RemoveChildShipmentTypeIDs(ids ...int) {
	if m.removedchild_shipment_types == nil {
		m.removedchild_shipment_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_shipment_types[ids[i]] = struct{}{}
	}
}

// RemovedChildShipmentTypes returns the removed IDs of the "child_shipment_types" edge to the ShipmentType entity.
func (m *ShipmentTypeMutation) RemovedChildShipmentTypesIDs() (ids []int) {
	for id := range m.removedchild_shipment_types {
		ids = append(ids, id)
	}
	return
}

// ChildShipmentTypesIDs returns the "child_shipment_types" edge IDs in the mutation.
func (m *ShipmentTypeMutation) ChildShipmentTypesIDs() (ids []int) {
	for id := range m.child_shipment_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildShipmentTypes resets all changes to the "child_shipment_types" edge.
func (m *ShipmentTypeMutation) ResetChildShipmentTypes() {
	m.child_shipment_types = nil
	m.clearedchild_shipment_types = false
	m.removedchild_shipment_types = nil
}

// Op returns the operation name.
func (m *ShipmentTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShipmentType).
func (m *ShipmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, shipmenttype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, shipmenttype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, shipmenttype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, shipmenttype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, shipmenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmenttype.FieldCreateTime:
		return m.CreateTime()
	case shipmenttype.FieldUpdateTime:
		return m.UpdateTime()
	case shipmenttype.FieldStringRef:
		return m.StringRef()
	case shipmenttype.FieldHasTable:
		return m.HasTable()
	case shipmenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmenttype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case shipmenttype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case shipmenttype.FieldStringRef:
		return m.OldStringRef(ctx)
	case shipmenttype.FieldHasTable:
		return m.OldHasTable(ctx)
	case shipmenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmenttype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case shipmenttype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case shipmenttype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case shipmenttype.FieldHasTable:
		v, ok := value.(shipmenttype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case shipmenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmenttype.FieldStringRef) {
		fields = append(fields, shipmenttype.FieldStringRef)
	}
	if m.FieldCleared(shipmenttype.FieldHasTable) {
		fields = append(fields, shipmenttype.FieldHasTable)
	}
	if m.FieldCleared(shipmenttype.FieldDescription) {
		fields = append(fields, shipmenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentTypeMutation) ClearField(name string) error {
	switch name {
	case shipmenttype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case shipmenttype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case shipmenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentTypeMutation) ResetField(name string) error {
	switch name {
	case shipmenttype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case shipmenttype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case shipmenttype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case shipmenttype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case shipmenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, shipmenttype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, shipmenttype.EdgeChildren)
	}
	if m.child_shipment_types != nil {
		edges = append(edges, shipmenttype.EdgeChildShipmentTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmenttype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case shipmenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case shipmenttype.EdgeChildShipmentTypes:
		ids := make([]ent.Value, 0, len(m.child_shipment_types))
		for id := range m.child_shipment_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, shipmenttype.EdgeChildren)
	}
	if m.removedchild_shipment_types != nil {
		edges = append(edges, shipmenttype.EdgeChildShipmentTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipmenttype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case shipmenttype.EdgeChildShipmentTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_shipment_types))
		for id := range m.removedchild_shipment_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, shipmenttype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, shipmenttype.EdgeChildren)
	}
	if m.clearedchild_shipment_types {
		edges = append(edges, shipmenttype.EdgeChildShipmentTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmenttype.EdgeParent:
		return m.clearedparent
	case shipmenttype.EdgeChildren:
		return m.clearedchildren
	case shipmenttype.EdgeChildShipmentTypes:
		return m.clearedchild_shipment_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentTypeMutation) ClearEdge(name string) error {
	switch name {
	case shipmenttype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case shipmenttype.EdgeParent:
		m.ResetParent()
		return nil
	case shipmenttype.EdgeChildren:
		m.ResetChildren()
		return nil
	case shipmenttype.EdgeChildShipmentTypes:
		m.ResetChildShipmentTypes()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType edge %s", name)
}

// StatusItemMutation represents an operation that mutates the StatusItem nodes in the graph.
type StatusItemMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	create_time                                 *time.Time
	update_time                                 *time.Time
	string_ref                                  *string
	status_code                                 *string
	sequence_id                                 *int
	addsequence_id                              *int
	description                                 *string
	clearedFields                               map[string]struct{}
	status_type                                 *int
	clearedstatus_type                          bool
	order_headers                               map[int]struct{}
	removedorder_headers                        map[int]struct{}
	clearedorder_headers                        bool
	sync_order_headers                          map[int]struct{}
	removedsync_order_headers                   map[int]struct{}
	clearedsync_order_headers                   bool
	order_items                                 map[int]struct{}
	removedorder_items                          map[int]struct{}
	clearedorder_items                          bool
	sync_order_items                            map[int]struct{}
	removedsync_order_items                     map[int]struct{}
	clearedsync_order_items                     bool
	order_payment_preferences                   map[int]struct{}
	removedorder_payment_preferences            map[int]struct{}
	clearedorder_payment_preferences            bool
	order_statuses                              map[int]struct{}
	removedorder_statuses                       map[int]struct{}
	clearedorder_statuses                       bool
	product_reviews                             map[int]struct{}
	removedproduct_reviews                      map[int]struct{}
	clearedproduct_reviews                      bool
	header_approved_product_stores              map[int]struct{}
	removedheader_approved_product_stores       map[int]struct{}
	clearedheader_approved_product_stores       bool
	item_approved_product_stores                map[int]struct{}
	removeditem_approved_product_stores         map[int]struct{}
	cleareditem_approved_product_stores         bool
	digital_item_approved_product_stores        map[int]struct{}
	removeddigital_item_approved_product_stores map[int]struct{}
	cleareddigital_item_approved_product_stores bool
	header_declined_product_stores              map[int]struct{}
	removedheader_declined_product_stores       map[int]struct{}
	clearedheader_declined_product_stores       bool
	item_declined_product_stores                map[int]struct{}
	removeditem_declined_product_stores         map[int]struct{}
	cleareditem_declined_product_stores         bool
	header_cancel_product_stores                map[int]struct{}
	removedheader_cancel_product_stores         map[int]struct{}
	clearedheader_cancel_product_stores         bool
	item_cancel_product_stores                  map[int]struct{}
	removeditem_cancel_product_stores           map[int]struct{}
	cleareditem_cancel_product_stores           bool
	main_status_valid_changes                   map[int]struct{}
	removedmain_status_valid_changes            map[int]struct{}
	clearedmain_status_valid_changes            bool
	to_status_valid_changes                     map[int]struct{}
	removedto_status_valid_changes              map[int]struct{}
	clearedto_status_valid_changes              bool
	done                                        bool
	oldValue                                    func(context.Context) (*StatusItem, error)
	predicates                                  []predicate.StatusItem
}

var _ ent.Mutation = (*StatusItemMutation)(nil)

// statusitemOption allows management of the mutation configuration using functional options.
type statusitemOption func(*StatusItemMutation)

// newStatusItemMutation creates new mutation for the StatusItem entity.
func newStatusItemMutation(c config, op Op, opts ...statusitemOption) *StatusItemMutation {
	m := &StatusItemMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusItemID sets the ID field of the mutation.
func withStatusItemID(id int) statusitemOption {
	return func(m *StatusItemMutation) {
		var (
			err   error
			once  sync.Once
			value *StatusItem
		)
		m.oldValue = func(ctx context.Context) (*StatusItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatusItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusItem sets the old StatusItem of the mutation.
func withStatusItem(node *StatusItem) statusitemOption {
	return func(m *StatusItemMutation) {
		m.oldValue = func(context.Context) (*StatusItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *StatusItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatusItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatusItem entity.
// If the StatusItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatusItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StatusItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StatusItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the StatusItem entity.
// If the StatusItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StatusItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *StatusItemMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *StatusItemMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the StatusItem entity.
// If the StatusItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusItemMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *StatusItemMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[statusitem.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *StatusItemMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[statusitem.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *StatusItemMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, statusitem.FieldStringRef)
}

// SetStatusCode sets the "status_code" field.
func (m *StatusItemMutation) SetStatusCode(s string) {
	m.status_code = &s
}

// StatusCode returns the value of the "status_code" field in the mutation.
func (m *StatusItemMutation) StatusCode() (r string, exists bool) {
	v := m.status_code
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCode returns the old "status_code" field's value of the StatusItem entity.
// If the StatusItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusItemMutation) OldStatusCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCode: %w", err)
	}
	return oldValue.StatusCode, nil
}

// ClearStatusCode clears the value of the "status_code" field.
func (m *StatusItemMutation) ClearStatusCode() {
	m.status_code = nil
	m.clearedFields[statusitem.FieldStatusCode] = struct{}{}
}

// StatusCodeCleared returns if the "status_code" field was cleared in this mutation.
func (m *StatusItemMutation) StatusCodeCleared() bool {
	_, ok := m.clearedFields[statusitem.FieldStatusCode]
	return ok
}

// ResetStatusCode resets all changes to the "status_code" field.
func (m *StatusItemMutation) ResetStatusCode() {
	m.status_code = nil
	delete(m.clearedFields, statusitem.FieldStatusCode)
}

// SetSequenceID sets the "sequence_id" field.
func (m *StatusItemMutation) SetSequenceID(i int) {
	m.sequence_id = &i
	m.addsequence_id = nil
}

// SequenceID returns the value of the "sequence_id" field in the mutation.
func (m *StatusItemMutation) SequenceID() (r int, exists bool) {
	v := m.sequence_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceID returns the old "sequence_id" field's value of the StatusItem entity.
// If the StatusItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusItemMutation) OldSequenceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceID: %w", err)
	}
	return oldValue.SequenceID, nil
}

// AddSequenceID adds i to the "sequence_id" field.
func (m *StatusItemMutation) AddSequenceID(i int) {
	if m.addsequence_id != nil {
		*m.addsequence_id += i
	} else {
		m.addsequence_id = &i
	}
}

// AddedSequenceID returns the value that was added to the "sequence_id" field in this mutation.
func (m *StatusItemMutation) AddedSequenceID() (r int, exists bool) {
	v := m.addsequence_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceID clears the value of the "sequence_id" field.
func (m *StatusItemMutation) ClearSequenceID() {
	m.sequence_id = nil
	m.addsequence_id = nil
	m.clearedFields[statusitem.FieldSequenceID] = struct{}{}
}

// SequenceIDCleared returns if the "sequence_id" field was cleared in this mutation.
func (m *StatusItemMutation) SequenceIDCleared() bool {
	_, ok := m.clearedFields[statusitem.FieldSequenceID]
	return ok
}

// ResetSequenceID resets all changes to the "sequence_id" field.
func (m *StatusItemMutation) ResetSequenceID() {
	m.sequence_id = nil
	m.addsequence_id = nil
	delete(m.clearedFields, statusitem.FieldSequenceID)
}

// SetDescription sets the "description" field.
func (m *StatusItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StatusItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StatusItem entity.
// If the StatusItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StatusItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[statusitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StatusItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[statusitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StatusItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, statusitem.FieldDescription)
}

// SetStatusTypeID sets the "status_type" edge to the StatusType entity by id.
func (m *StatusItemMutation) SetStatusTypeID(id int) {
	m.status_type = &id
}

// ClearStatusType clears the "status_type" edge to the StatusType entity.
func (m *StatusItemMutation) ClearStatusType() {
	m.clearedstatus_type = true
}

// StatusTypeCleared reports if the "status_type" edge to the StatusType entity was cleared.
func (m *StatusItemMutation) StatusTypeCleared() bool {
	return m.clearedstatus_type
}

// StatusTypeID returns the "status_type" edge ID in the mutation.
func (m *StatusItemMutation) StatusTypeID() (id int, exists bool) {
	if m.status_type != nil {
		return *m.status_type, true
	}
	return
}

// StatusTypeIDs returns the "status_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusTypeID instead. It exists only for internal usage by the builders.
func (m *StatusItemMutation) StatusTypeIDs() (ids []int) {
	if id := m.status_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusType resets all changes to the "status_type" edge.
func (m *StatusItemMutation) ResetStatusType() {
	m.status_type = nil
	m.clearedstatus_type = false
}

// AddOrderHeaderIDs adds the "order_headers" edge to the OrderHeader entity by ids.
func (m *StatusItemMutation) AddOrderHeaderIDs(ids ...int) {
	if m.order_headers == nil {
		m.order_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.order_headers[ids[i]] = struct{}{}
	}
}

// ClearOrderHeaders clears the "order_headers" edge to the OrderHeader entity.
func (m *StatusItemMutation) ClearOrderHeaders() {
	m.clearedorder_headers = true
}

// OrderHeadersCleared reports if the "order_headers" edge to the OrderHeader entity was cleared.
func (m *StatusItemMutation) OrderHeadersCleared() bool {
	return m.clearedorder_headers
}

// RemoveOrderHeaderIDs removes the "order_headers" edge to the OrderHeader entity by IDs.
func (m *StatusItemMutation) RemoveOrderHeaderIDs(ids ...int) {
	if m.removedorder_headers == nil {
		m.removedorder_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_headers[ids[i]] = struct{}{}
	}
}

// RemovedOrderHeaders returns the removed IDs of the "order_headers" edge to the OrderHeader entity.
func (m *StatusItemMutation) RemovedOrderHeadersIDs() (ids []int) {
	for id := range m.removedorder_headers {
		ids = append(ids, id)
	}
	return
}

// OrderHeadersIDs returns the "order_headers" edge IDs in the mutation.
func (m *StatusItemMutation) OrderHeadersIDs() (ids []int) {
	for id := range m.order_headers {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHeaders resets all changes to the "order_headers" edge.
func (m *StatusItemMutation) ResetOrderHeaders() {
	m.order_headers = nil
	m.clearedorder_headers = false
	m.removedorder_headers = nil
}

// AddSyncOrderHeaderIDs adds the "sync_order_headers" edge to the OrderHeader entity by ids.
func (m *StatusItemMutation) AddSyncOrderHeaderIDs(ids ...int) {
	if m.sync_order_headers == nil {
		m.sync_order_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.sync_order_headers[ids[i]] = struct{}{}
	}
}

// ClearSyncOrderHeaders clears the "sync_order_headers" edge to the OrderHeader entity.
func (m *StatusItemMutation) ClearSyncOrderHeaders() {
	m.clearedsync_order_headers = true
}

// SyncOrderHeadersCleared reports if the "sync_order_headers" edge to the OrderHeader entity was cleared.
func (m *StatusItemMutation) SyncOrderHeadersCleared() bool {
	return m.clearedsync_order_headers
}

// RemoveSyncOrderHeaderIDs removes the "sync_order_headers" edge to the OrderHeader entity by IDs.
func (m *StatusItemMutation) RemoveSyncOrderHeaderIDs(ids ...int) {
	if m.removedsync_order_headers == nil {
		m.removedsync_order_headers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsync_order_headers[ids[i]] = struct{}{}
	}
}

// RemovedSyncOrderHeaders returns the removed IDs of the "sync_order_headers" edge to the OrderHeader entity.
func (m *StatusItemMutation) RemovedSyncOrderHeadersIDs() (ids []int) {
	for id := range m.removedsync_order_headers {
		ids = append(ids, id)
	}
	return
}

// SyncOrderHeadersIDs returns the "sync_order_headers" edge IDs in the mutation.
func (m *StatusItemMutation) SyncOrderHeadersIDs() (ids []int) {
	for id := range m.sync_order_headers {
		ids = append(ids, id)
	}
	return
}

// ResetSyncOrderHeaders resets all changes to the "sync_order_headers" edge.
func (m *StatusItemMutation) ResetSyncOrderHeaders() {
	m.sync_order_headers = nil
	m.clearedsync_order_headers = false
	m.removedsync_order_headers = nil
}

// AddOrderItemIDs adds the "order_items" edge to the OrderItem entity by ids.
func (m *StatusItemMutation) AddOrderItemIDs(ids ...int) {
	if m.order_items == nil {
		m.order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.order_items[ids[i]] = struct{}{}
	}
}

// ClearOrderItems clears the "order_items" edge to the OrderItem entity.
func (m *StatusItemMutation) ClearOrderItems() {
	m.clearedorder_items = true
}

// OrderItemsCleared reports if the "order_items" edge to the OrderItem entity was cleared.
func (m *StatusItemMutation) OrderItemsCleared() bool {
	return m.clearedorder_items
}

// RemoveOrderItemIDs removes the "order_items" edge to the OrderItem entity by IDs.
func (m *StatusItemMutation) RemoveOrderItemIDs(ids ...int) {
	if m.removedorder_items == nil {
		m.removedorder_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_items[ids[i]] = struct{}{}
	}
}

// RemovedOrderItems returns the removed IDs of the "order_items" edge to the OrderItem entity.
func (m *StatusItemMutation) RemovedOrderItemsIDs() (ids []int) {
	for id := range m.removedorder_items {
		ids = append(ids, id)
	}
	return
}

// OrderItemsIDs returns the "order_items" edge IDs in the mutation.
func (m *StatusItemMutation) OrderItemsIDs() (ids []int) {
	for id := range m.order_items {
		ids = append(ids, id)
	}
	return
}

// ResetOrderItems resets all changes to the "order_items" edge.
func (m *StatusItemMutation) ResetOrderItems() {
	m.order_items = nil
	m.clearedorder_items = false
	m.removedorder_items = nil
}

// AddSyncOrderItemIDs adds the "sync_order_items" edge to the OrderItem entity by ids.
func (m *StatusItemMutation) AddSyncOrderItemIDs(ids ...int) {
	if m.sync_order_items == nil {
		m.sync_order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.sync_order_items[ids[i]] = struct{}{}
	}
}

// ClearSyncOrderItems clears the "sync_order_items" edge to the OrderItem entity.
func (m *StatusItemMutation) ClearSyncOrderItems() {
	m.clearedsync_order_items = true
}

// SyncOrderItemsCleared reports if the "sync_order_items" edge to the OrderItem entity was cleared.
func (m *StatusItemMutation) SyncOrderItemsCleared() bool {
	return m.clearedsync_order_items
}

// RemoveSyncOrderItemIDs removes the "sync_order_items" edge to the OrderItem entity by IDs.
func (m *StatusItemMutation) RemoveSyncOrderItemIDs(ids ...int) {
	if m.removedsync_order_items == nil {
		m.removedsync_order_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsync_order_items[ids[i]] = struct{}{}
	}
}

// RemovedSyncOrderItems returns the removed IDs of the "sync_order_items" edge to the OrderItem entity.
func (m *StatusItemMutation) RemovedSyncOrderItemsIDs() (ids []int) {
	for id := range m.removedsync_order_items {
		ids = append(ids, id)
	}
	return
}

// SyncOrderItemsIDs returns the "sync_order_items" edge IDs in the mutation.
func (m *StatusItemMutation) SyncOrderItemsIDs() (ids []int) {
	for id := range m.sync_order_items {
		ids = append(ids, id)
	}
	return
}

// ResetSyncOrderItems resets all changes to the "sync_order_items" edge.
func (m *StatusItemMutation) ResetSyncOrderItems() {
	m.sync_order_items = nil
	m.clearedsync_order_items = false
	m.removedsync_order_items = nil
}

// AddOrderPaymentPreferenceIDs adds the "order_payment_preferences" edge to the OrderPaymentPreference entity by ids.
func (m *StatusItemMutation) AddOrderPaymentPreferenceIDs(ids ...int) {
	if m.order_payment_preferences == nil {
		m.order_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.order_payment_preferences[ids[i]] = struct{}{}
	}
}

// ClearOrderPaymentPreferences clears the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *StatusItemMutation) ClearOrderPaymentPreferences() {
	m.clearedorder_payment_preferences = true
}

// OrderPaymentPreferencesCleared reports if the "order_payment_preferences" edge to the OrderPaymentPreference entity was cleared.
func (m *StatusItemMutation) OrderPaymentPreferencesCleared() bool {
	return m.clearedorder_payment_preferences
}

// RemoveOrderPaymentPreferenceIDs removes the "order_payment_preferences" edge to the OrderPaymentPreference entity by IDs.
func (m *StatusItemMutation) RemoveOrderPaymentPreferenceIDs(ids ...int) {
	if m.removedorder_payment_preferences == nil {
		m.removedorder_payment_preferences = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_payment_preferences[ids[i]] = struct{}{}
	}
}

// RemovedOrderPaymentPreferences returns the removed IDs of the "order_payment_preferences" edge to the OrderPaymentPreference entity.
func (m *StatusItemMutation) RemovedOrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.removedorder_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// OrderPaymentPreferencesIDs returns the "order_payment_preferences" edge IDs in the mutation.
func (m *StatusItemMutation) OrderPaymentPreferencesIDs() (ids []int) {
	for id := range m.order_payment_preferences {
		ids = append(ids, id)
	}
	return
}

// ResetOrderPaymentPreferences resets all changes to the "order_payment_preferences" edge.
func (m *StatusItemMutation) ResetOrderPaymentPreferences() {
	m.order_payment_preferences = nil
	m.clearedorder_payment_preferences = false
	m.removedorder_payment_preferences = nil
}

// AddOrderStatusIDs adds the "order_statuses" edge to the OrderStatus entity by ids.
func (m *StatusItemMutation) AddOrderStatusIDs(ids ...int) {
	if m.order_statuses == nil {
		m.order_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.order_statuses[ids[i]] = struct{}{}
	}
}

// ClearOrderStatuses clears the "order_statuses" edge to the OrderStatus entity.
func (m *StatusItemMutation) ClearOrderStatuses() {
	m.clearedorder_statuses = true
}

// OrderStatusesCleared reports if the "order_statuses" edge to the OrderStatus entity was cleared.
func (m *StatusItemMutation) OrderStatusesCleared() bool {
	return m.clearedorder_statuses
}

// RemoveOrderStatusIDs removes the "order_statuses" edge to the OrderStatus entity by IDs.
func (m *StatusItemMutation) RemoveOrderStatusIDs(ids ...int) {
	if m.removedorder_statuses == nil {
		m.removedorder_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder_statuses[ids[i]] = struct{}{}
	}
}

// RemovedOrderStatuses returns the removed IDs of the "order_statuses" edge to the OrderStatus entity.
func (m *StatusItemMutation) RemovedOrderStatusesIDs() (ids []int) {
	for id := range m.removedorder_statuses {
		ids = append(ids, id)
	}
	return
}

// OrderStatusesIDs returns the "order_statuses" edge IDs in the mutation.
func (m *StatusItemMutation) OrderStatusesIDs() (ids []int) {
	for id := range m.order_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetOrderStatuses resets all changes to the "order_statuses" edge.
func (m *StatusItemMutation) ResetOrderStatuses() {
	m.order_statuses = nil
	m.clearedorder_statuses = false
	m.removedorder_statuses = nil
}

// AddProductReviewIDs adds the "product_reviews" edge to the ProductReview entity by ids.
func (m *StatusItemMutation) AddProductReviewIDs(ids ...int) {
	if m.product_reviews == nil {
		m.product_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.product_reviews[ids[i]] = struct{}{}
	}
}

// ClearProductReviews clears the "product_reviews" edge to the ProductReview entity.
func (m *StatusItemMutation) ClearProductReviews() {
	m.clearedproduct_reviews = true
}

// ProductReviewsCleared reports if the "product_reviews" edge to the ProductReview entity was cleared.
func (m *StatusItemMutation) ProductReviewsCleared() bool {
	return m.clearedproduct_reviews
}

// RemoveProductReviewIDs removes the "product_reviews" edge to the ProductReview entity by IDs.
func (m *StatusItemMutation) RemoveProductReviewIDs(ids ...int) {
	if m.removedproduct_reviews == nil {
		m.removedproduct_reviews = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproduct_reviews[ids[i]] = struct{}{}
	}
}

// RemovedProductReviews returns the removed IDs of the "product_reviews" edge to the ProductReview entity.
func (m *StatusItemMutation) RemovedProductReviewsIDs() (ids []int) {
	for id := range m.removedproduct_reviews {
		ids = append(ids, id)
	}
	return
}

// ProductReviewsIDs returns the "product_reviews" edge IDs in the mutation.
func (m *StatusItemMutation) ProductReviewsIDs() (ids []int) {
	for id := range m.product_reviews {
		ids = append(ids, id)
	}
	return
}

// ResetProductReviews resets all changes to the "product_reviews" edge.
func (m *StatusItemMutation) ResetProductReviews() {
	m.product_reviews = nil
	m.clearedproduct_reviews = false
	m.removedproduct_reviews = nil
}

// AddHeaderApprovedProductStoreIDs adds the "header_approved_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddHeaderApprovedProductStoreIDs(ids ...int) {
	if m.header_approved_product_stores == nil {
		m.header_approved_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.header_approved_product_stores[ids[i]] = struct{}{}
	}
}

// ClearHeaderApprovedProductStores clears the "header_approved_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearHeaderApprovedProductStores() {
	m.clearedheader_approved_product_stores = true
}

// HeaderApprovedProductStoresCleared reports if the "header_approved_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) HeaderApprovedProductStoresCleared() bool {
	return m.clearedheader_approved_product_stores
}

// RemoveHeaderApprovedProductStoreIDs removes the "header_approved_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveHeaderApprovedProductStoreIDs(ids ...int) {
	if m.removedheader_approved_product_stores == nil {
		m.removedheader_approved_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedheader_approved_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedHeaderApprovedProductStores returns the removed IDs of the "header_approved_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedHeaderApprovedProductStoresIDs() (ids []int) {
	for id := range m.removedheader_approved_product_stores {
		ids = append(ids, id)
	}
	return
}

// HeaderApprovedProductStoresIDs returns the "header_approved_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) HeaderApprovedProductStoresIDs() (ids []int) {
	for id := range m.header_approved_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetHeaderApprovedProductStores resets all changes to the "header_approved_product_stores" edge.
func (m *StatusItemMutation) ResetHeaderApprovedProductStores() {
	m.header_approved_product_stores = nil
	m.clearedheader_approved_product_stores = false
	m.removedheader_approved_product_stores = nil
}

// AddItemApprovedProductStoreIDs adds the "item_approved_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddItemApprovedProductStoreIDs(ids ...int) {
	if m.item_approved_product_stores == nil {
		m.item_approved_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.item_approved_product_stores[ids[i]] = struct{}{}
	}
}

// ClearItemApprovedProductStores clears the "item_approved_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearItemApprovedProductStores() {
	m.cleareditem_approved_product_stores = true
}

// ItemApprovedProductStoresCleared reports if the "item_approved_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) ItemApprovedProductStoresCleared() bool {
	return m.cleareditem_approved_product_stores
}

// RemoveItemApprovedProductStoreIDs removes the "item_approved_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveItemApprovedProductStoreIDs(ids ...int) {
	if m.removeditem_approved_product_stores == nil {
		m.removeditem_approved_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removeditem_approved_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedItemApprovedProductStores returns the removed IDs of the "item_approved_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedItemApprovedProductStoresIDs() (ids []int) {
	for id := range m.removeditem_approved_product_stores {
		ids = append(ids, id)
	}
	return
}

// ItemApprovedProductStoresIDs returns the "item_approved_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) ItemApprovedProductStoresIDs() (ids []int) {
	for id := range m.item_approved_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetItemApprovedProductStores resets all changes to the "item_approved_product_stores" edge.
func (m *StatusItemMutation) ResetItemApprovedProductStores() {
	m.item_approved_product_stores = nil
	m.cleareditem_approved_product_stores = false
	m.removeditem_approved_product_stores = nil
}

// AddDigitalItemApprovedProductStoreIDs adds the "digital_item_approved_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddDigitalItemApprovedProductStoreIDs(ids ...int) {
	if m.digital_item_approved_product_stores == nil {
		m.digital_item_approved_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.digital_item_approved_product_stores[ids[i]] = struct{}{}
	}
}

// ClearDigitalItemApprovedProductStores clears the "digital_item_approved_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearDigitalItemApprovedProductStores() {
	m.cleareddigital_item_approved_product_stores = true
}

// DigitalItemApprovedProductStoresCleared reports if the "digital_item_approved_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) DigitalItemApprovedProductStoresCleared() bool {
	return m.cleareddigital_item_approved_product_stores
}

// RemoveDigitalItemApprovedProductStoreIDs removes the "digital_item_approved_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveDigitalItemApprovedProductStoreIDs(ids ...int) {
	if m.removeddigital_item_approved_product_stores == nil {
		m.removeddigital_item_approved_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddigital_item_approved_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedDigitalItemApprovedProductStores returns the removed IDs of the "digital_item_approved_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedDigitalItemApprovedProductStoresIDs() (ids []int) {
	for id := range m.removeddigital_item_approved_product_stores {
		ids = append(ids, id)
	}
	return
}

// DigitalItemApprovedProductStoresIDs returns the "digital_item_approved_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) DigitalItemApprovedProductStoresIDs() (ids []int) {
	for id := range m.digital_item_approved_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetDigitalItemApprovedProductStores resets all changes to the "digital_item_approved_product_stores" edge.
func (m *StatusItemMutation) ResetDigitalItemApprovedProductStores() {
	m.digital_item_approved_product_stores = nil
	m.cleareddigital_item_approved_product_stores = false
	m.removeddigital_item_approved_product_stores = nil
}

// AddHeaderDeclinedProductStoreIDs adds the "header_declined_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddHeaderDeclinedProductStoreIDs(ids ...int) {
	if m.header_declined_product_stores == nil {
		m.header_declined_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.header_declined_product_stores[ids[i]] = struct{}{}
	}
}

// ClearHeaderDeclinedProductStores clears the "header_declined_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearHeaderDeclinedProductStores() {
	m.clearedheader_declined_product_stores = true
}

// HeaderDeclinedProductStoresCleared reports if the "header_declined_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) HeaderDeclinedProductStoresCleared() bool {
	return m.clearedheader_declined_product_stores
}

// RemoveHeaderDeclinedProductStoreIDs removes the "header_declined_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveHeaderDeclinedProductStoreIDs(ids ...int) {
	if m.removedheader_declined_product_stores == nil {
		m.removedheader_declined_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedheader_declined_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedHeaderDeclinedProductStores returns the removed IDs of the "header_declined_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedHeaderDeclinedProductStoresIDs() (ids []int) {
	for id := range m.removedheader_declined_product_stores {
		ids = append(ids, id)
	}
	return
}

// HeaderDeclinedProductStoresIDs returns the "header_declined_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) HeaderDeclinedProductStoresIDs() (ids []int) {
	for id := range m.header_declined_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetHeaderDeclinedProductStores resets all changes to the "header_declined_product_stores" edge.
func (m *StatusItemMutation) ResetHeaderDeclinedProductStores() {
	m.header_declined_product_stores = nil
	m.clearedheader_declined_product_stores = false
	m.removedheader_declined_product_stores = nil
}

// AddItemDeclinedProductStoreIDs adds the "item_declined_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddItemDeclinedProductStoreIDs(ids ...int) {
	if m.item_declined_product_stores == nil {
		m.item_declined_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.item_declined_product_stores[ids[i]] = struct{}{}
	}
}

// ClearItemDeclinedProductStores clears the "item_declined_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearItemDeclinedProductStores() {
	m.cleareditem_declined_product_stores = true
}

// ItemDeclinedProductStoresCleared reports if the "item_declined_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) ItemDeclinedProductStoresCleared() bool {
	return m.cleareditem_declined_product_stores
}

// RemoveItemDeclinedProductStoreIDs removes the "item_declined_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveItemDeclinedProductStoreIDs(ids ...int) {
	if m.removeditem_declined_product_stores == nil {
		m.removeditem_declined_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removeditem_declined_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedItemDeclinedProductStores returns the removed IDs of the "item_declined_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedItemDeclinedProductStoresIDs() (ids []int) {
	for id := range m.removeditem_declined_product_stores {
		ids = append(ids, id)
	}
	return
}

// ItemDeclinedProductStoresIDs returns the "item_declined_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) ItemDeclinedProductStoresIDs() (ids []int) {
	for id := range m.item_declined_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetItemDeclinedProductStores resets all changes to the "item_declined_product_stores" edge.
func (m *StatusItemMutation) ResetItemDeclinedProductStores() {
	m.item_declined_product_stores = nil
	m.cleareditem_declined_product_stores = false
	m.removeditem_declined_product_stores = nil
}

// AddHeaderCancelProductStoreIDs adds the "header_cancel_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddHeaderCancelProductStoreIDs(ids ...int) {
	if m.header_cancel_product_stores == nil {
		m.header_cancel_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.header_cancel_product_stores[ids[i]] = struct{}{}
	}
}

// ClearHeaderCancelProductStores clears the "header_cancel_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearHeaderCancelProductStores() {
	m.clearedheader_cancel_product_stores = true
}

// HeaderCancelProductStoresCleared reports if the "header_cancel_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) HeaderCancelProductStoresCleared() bool {
	return m.clearedheader_cancel_product_stores
}

// RemoveHeaderCancelProductStoreIDs removes the "header_cancel_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveHeaderCancelProductStoreIDs(ids ...int) {
	if m.removedheader_cancel_product_stores == nil {
		m.removedheader_cancel_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removedheader_cancel_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedHeaderCancelProductStores returns the removed IDs of the "header_cancel_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedHeaderCancelProductStoresIDs() (ids []int) {
	for id := range m.removedheader_cancel_product_stores {
		ids = append(ids, id)
	}
	return
}

// HeaderCancelProductStoresIDs returns the "header_cancel_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) HeaderCancelProductStoresIDs() (ids []int) {
	for id := range m.header_cancel_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetHeaderCancelProductStores resets all changes to the "header_cancel_product_stores" edge.
func (m *StatusItemMutation) ResetHeaderCancelProductStores() {
	m.header_cancel_product_stores = nil
	m.clearedheader_cancel_product_stores = false
	m.removedheader_cancel_product_stores = nil
}

// AddItemCancelProductStoreIDs adds the "item_cancel_product_stores" edge to the ProductStore entity by ids.
func (m *StatusItemMutation) AddItemCancelProductStoreIDs(ids ...int) {
	if m.item_cancel_product_stores == nil {
		m.item_cancel_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.item_cancel_product_stores[ids[i]] = struct{}{}
	}
}

// ClearItemCancelProductStores clears the "item_cancel_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) ClearItemCancelProductStores() {
	m.cleareditem_cancel_product_stores = true
}

// ItemCancelProductStoresCleared reports if the "item_cancel_product_stores" edge to the ProductStore entity was cleared.
func (m *StatusItemMutation) ItemCancelProductStoresCleared() bool {
	return m.cleareditem_cancel_product_stores
}

// RemoveItemCancelProductStoreIDs removes the "item_cancel_product_stores" edge to the ProductStore entity by IDs.
func (m *StatusItemMutation) RemoveItemCancelProductStoreIDs(ids ...int) {
	if m.removeditem_cancel_product_stores == nil {
		m.removeditem_cancel_product_stores = make(map[int]struct{})
	}
	for i := range ids {
		m.removeditem_cancel_product_stores[ids[i]] = struct{}{}
	}
}

// RemovedItemCancelProductStores returns the removed IDs of the "item_cancel_product_stores" edge to the ProductStore entity.
func (m *StatusItemMutation) RemovedItemCancelProductStoresIDs() (ids []int) {
	for id := range m.removeditem_cancel_product_stores {
		ids = append(ids, id)
	}
	return
}

// ItemCancelProductStoresIDs returns the "item_cancel_product_stores" edge IDs in the mutation.
func (m *StatusItemMutation) ItemCancelProductStoresIDs() (ids []int) {
	for id := range m.item_cancel_product_stores {
		ids = append(ids, id)
	}
	return
}

// ResetItemCancelProductStores resets all changes to the "item_cancel_product_stores" edge.
func (m *StatusItemMutation) ResetItemCancelProductStores() {
	m.item_cancel_product_stores = nil
	m.cleareditem_cancel_product_stores = false
	m.removeditem_cancel_product_stores = nil
}

// AddMainStatusValidChangeIDs adds the "main_status_valid_changes" edge to the StatusValidChange entity by ids.
func (m *StatusItemMutation) AddMainStatusValidChangeIDs(ids ...int) {
	if m.main_status_valid_changes == nil {
		m.main_status_valid_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.main_status_valid_changes[ids[i]] = struct{}{}
	}
}

// ClearMainStatusValidChanges clears the "main_status_valid_changes" edge to the StatusValidChange entity.
func (m *StatusItemMutation) ClearMainStatusValidChanges() {
	m.clearedmain_status_valid_changes = true
}

// MainStatusValidChangesCleared reports if the "main_status_valid_changes" edge to the StatusValidChange entity was cleared.
func (m *StatusItemMutation) MainStatusValidChangesCleared() bool {
	return m.clearedmain_status_valid_changes
}

// RemoveMainStatusValidChangeIDs removes the "main_status_valid_changes" edge to the StatusValidChange entity by IDs.
func (m *StatusItemMutation) RemoveMainStatusValidChangeIDs(ids ...int) {
	if m.removedmain_status_valid_changes == nil {
		m.removedmain_status_valid_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmain_status_valid_changes[ids[i]] = struct{}{}
	}
}

// RemovedMainStatusValidChanges returns the removed IDs of the "main_status_valid_changes" edge to the StatusValidChange entity.
func (m *StatusItemMutation) RemovedMainStatusValidChangesIDs() (ids []int) {
	for id := range m.removedmain_status_valid_changes {
		ids = append(ids, id)
	}
	return
}

// MainStatusValidChangesIDs returns the "main_status_valid_changes" edge IDs in the mutation.
func (m *StatusItemMutation) MainStatusValidChangesIDs() (ids []int) {
	for id := range m.main_status_valid_changes {
		ids = append(ids, id)
	}
	return
}

// ResetMainStatusValidChanges resets all changes to the "main_status_valid_changes" edge.
func (m *StatusItemMutation) ResetMainStatusValidChanges() {
	m.main_status_valid_changes = nil
	m.clearedmain_status_valid_changes = false
	m.removedmain_status_valid_changes = nil
}

// AddToStatusValidChangeIDs adds the "to_status_valid_changes" edge to the StatusValidChange entity by ids.
func (m *StatusItemMutation) AddToStatusValidChangeIDs(ids ...int) {
	if m.to_status_valid_changes == nil {
		m.to_status_valid_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.to_status_valid_changes[ids[i]] = struct{}{}
	}
}

// ClearToStatusValidChanges clears the "to_status_valid_changes" edge to the StatusValidChange entity.
func (m *StatusItemMutation) ClearToStatusValidChanges() {
	m.clearedto_status_valid_changes = true
}

// ToStatusValidChangesCleared reports if the "to_status_valid_changes" edge to the StatusValidChange entity was cleared.
func (m *StatusItemMutation) ToStatusValidChangesCleared() bool {
	return m.clearedto_status_valid_changes
}

// RemoveToStatusValidChangeIDs removes the "to_status_valid_changes" edge to the StatusValidChange entity by IDs.
func (m *StatusItemMutation) RemoveToStatusValidChangeIDs(ids ...int) {
	if m.removedto_status_valid_changes == nil {
		m.removedto_status_valid_changes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedto_status_valid_changes[ids[i]] = struct{}{}
	}
}

// RemovedToStatusValidChanges returns the removed IDs of the "to_status_valid_changes" edge to the StatusValidChange entity.
func (m *StatusItemMutation) RemovedToStatusValidChangesIDs() (ids []int) {
	for id := range m.removedto_status_valid_changes {
		ids = append(ids, id)
	}
	return
}

// ToStatusValidChangesIDs returns the "to_status_valid_changes" edge IDs in the mutation.
func (m *StatusItemMutation) ToStatusValidChangesIDs() (ids []int) {
	for id := range m.to_status_valid_changes {
		ids = append(ids, id)
	}
	return
}

// ResetToStatusValidChanges resets all changes to the "to_status_valid_changes" edge.
func (m *StatusItemMutation) ResetToStatusValidChanges() {
	m.to_status_valid_changes = nil
	m.clearedto_status_valid_changes = false
	m.removedto_status_valid_changes = nil
}

// Op returns the operation name.
func (m *StatusItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StatusItem).
func (m *StatusItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, statusitem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, statusitem.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, statusitem.FieldStringRef)
	}
	if m.status_code != nil {
		fields = append(fields, statusitem.FieldStatusCode)
	}
	if m.sequence_id != nil {
		fields = append(fields, statusitem.FieldSequenceID)
	}
	if m.description != nil {
		fields = append(fields, statusitem.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusitem.FieldCreateTime:
		return m.CreateTime()
	case statusitem.FieldUpdateTime:
		return m.UpdateTime()
	case statusitem.FieldStringRef:
		return m.StringRef()
	case statusitem.FieldStatusCode:
		return m.StatusCode()
	case statusitem.FieldSequenceID:
		return m.SequenceID()
	case statusitem.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusitem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case statusitem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case statusitem.FieldStringRef:
		return m.OldStringRef(ctx)
	case statusitem.FieldStatusCode:
		return m.OldStatusCode(ctx)
	case statusitem.FieldSequenceID:
		return m.OldSequenceID(ctx)
	case statusitem.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown StatusItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusitem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case statusitem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case statusitem.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case statusitem.FieldStatusCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCode(v)
		return nil
	case statusitem.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceID(v)
		return nil
	case statusitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown StatusItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusItemMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_id != nil {
		fields = append(fields, statusitem.FieldSequenceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statusitem.FieldSequenceID:
		return m.AddedSequenceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statusitem.FieldSequenceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceID(v)
		return nil
	}
	return fmt.Errorf("unknown StatusItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statusitem.FieldStringRef) {
		fields = append(fields, statusitem.FieldStringRef)
	}
	if m.FieldCleared(statusitem.FieldStatusCode) {
		fields = append(fields, statusitem.FieldStatusCode)
	}
	if m.FieldCleared(statusitem.FieldSequenceID) {
		fields = append(fields, statusitem.FieldSequenceID)
	}
	if m.FieldCleared(statusitem.FieldDescription) {
		fields = append(fields, statusitem.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusItemMutation) ClearField(name string) error {
	switch name {
	case statusitem.FieldStringRef:
		m.ClearStringRef()
		return nil
	case statusitem.FieldStatusCode:
		m.ClearStatusCode()
		return nil
	case statusitem.FieldSequenceID:
		m.ClearSequenceID()
		return nil
	case statusitem.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown StatusItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusItemMutation) ResetField(name string) error {
	switch name {
	case statusitem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case statusitem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case statusitem.FieldStringRef:
		m.ResetStringRef()
		return nil
	case statusitem.FieldStatusCode:
		m.ResetStatusCode()
		return nil
	case statusitem.FieldSequenceID:
		m.ResetSequenceID()
		return nil
	case statusitem.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown StatusItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.status_type != nil {
		edges = append(edges, statusitem.EdgeStatusType)
	}
	if m.order_headers != nil {
		edges = append(edges, statusitem.EdgeOrderHeaders)
	}
	if m.sync_order_headers != nil {
		edges = append(edges, statusitem.EdgeSyncOrderHeaders)
	}
	if m.order_items != nil {
		edges = append(edges, statusitem.EdgeOrderItems)
	}
	if m.sync_order_items != nil {
		edges = append(edges, statusitem.EdgeSyncOrderItems)
	}
	if m.order_payment_preferences != nil {
		edges = append(edges, statusitem.EdgeOrderPaymentPreferences)
	}
	if m.order_statuses != nil {
		edges = append(edges, statusitem.EdgeOrderStatuses)
	}
	if m.product_reviews != nil {
		edges = append(edges, statusitem.EdgeProductReviews)
	}
	if m.header_approved_product_stores != nil {
		edges = append(edges, statusitem.EdgeHeaderApprovedProductStores)
	}
	if m.item_approved_product_stores != nil {
		edges = append(edges, statusitem.EdgeItemApprovedProductStores)
	}
	if m.digital_item_approved_product_stores != nil {
		edges = append(edges, statusitem.EdgeDigitalItemApprovedProductStores)
	}
	if m.header_declined_product_stores != nil {
		edges = append(edges, statusitem.EdgeHeaderDeclinedProductStores)
	}
	if m.item_declined_product_stores != nil {
		edges = append(edges, statusitem.EdgeItemDeclinedProductStores)
	}
	if m.header_cancel_product_stores != nil {
		edges = append(edges, statusitem.EdgeHeaderCancelProductStores)
	}
	if m.item_cancel_product_stores != nil {
		edges = append(edges, statusitem.EdgeItemCancelProductStores)
	}
	if m.main_status_valid_changes != nil {
		edges = append(edges, statusitem.EdgeMainStatusValidChanges)
	}
	if m.to_status_valid_changes != nil {
		edges = append(edges, statusitem.EdgeToStatusValidChanges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusitem.EdgeStatusType:
		if id := m.status_type; id != nil {
			return []ent.Value{*id}
		}
	case statusitem.EdgeOrderHeaders:
		ids := make([]ent.Value, 0, len(m.order_headers))
		for id := range m.order_headers {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeSyncOrderHeaders:
		ids := make([]ent.Value, 0, len(m.sync_order_headers))
		for id := range m.sync_order_headers {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.order_items))
		for id := range m.order_items {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeSyncOrderItems:
		ids := make([]ent.Value, 0, len(m.sync_order_items))
		for id := range m.sync_order_items {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.order_payment_preferences))
		for id := range m.order_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.order_statuses))
		for id := range m.order_statuses {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeProductReviews:
		ids := make([]ent.Value, 0, len(m.product_reviews))
		for id := range m.product_reviews {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeHeaderApprovedProductStores:
		ids := make([]ent.Value, 0, len(m.header_approved_product_stores))
		for id := range m.header_approved_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeItemApprovedProductStores:
		ids := make([]ent.Value, 0, len(m.item_approved_product_stores))
		for id := range m.item_approved_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeDigitalItemApprovedProductStores:
		ids := make([]ent.Value, 0, len(m.digital_item_approved_product_stores))
		for id := range m.digital_item_approved_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeHeaderDeclinedProductStores:
		ids := make([]ent.Value, 0, len(m.header_declined_product_stores))
		for id := range m.header_declined_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeItemDeclinedProductStores:
		ids := make([]ent.Value, 0, len(m.item_declined_product_stores))
		for id := range m.item_declined_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeHeaderCancelProductStores:
		ids := make([]ent.Value, 0, len(m.header_cancel_product_stores))
		for id := range m.header_cancel_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeItemCancelProductStores:
		ids := make([]ent.Value, 0, len(m.item_cancel_product_stores))
		for id := range m.item_cancel_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeMainStatusValidChanges:
		ids := make([]ent.Value, 0, len(m.main_status_valid_changes))
		for id := range m.main_status_valid_changes {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeToStatusValidChanges:
		ids := make([]ent.Value, 0, len(m.to_status_valid_changes))
		for id := range m.to_status_valid_changes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedorder_headers != nil {
		edges = append(edges, statusitem.EdgeOrderHeaders)
	}
	if m.removedsync_order_headers != nil {
		edges = append(edges, statusitem.EdgeSyncOrderHeaders)
	}
	if m.removedorder_items != nil {
		edges = append(edges, statusitem.EdgeOrderItems)
	}
	if m.removedsync_order_items != nil {
		edges = append(edges, statusitem.EdgeSyncOrderItems)
	}
	if m.removedorder_payment_preferences != nil {
		edges = append(edges, statusitem.EdgeOrderPaymentPreferences)
	}
	if m.removedorder_statuses != nil {
		edges = append(edges, statusitem.EdgeOrderStatuses)
	}
	if m.removedproduct_reviews != nil {
		edges = append(edges, statusitem.EdgeProductReviews)
	}
	if m.removedheader_approved_product_stores != nil {
		edges = append(edges, statusitem.EdgeHeaderApprovedProductStores)
	}
	if m.removeditem_approved_product_stores != nil {
		edges = append(edges, statusitem.EdgeItemApprovedProductStores)
	}
	if m.removeddigital_item_approved_product_stores != nil {
		edges = append(edges, statusitem.EdgeDigitalItemApprovedProductStores)
	}
	if m.removedheader_declined_product_stores != nil {
		edges = append(edges, statusitem.EdgeHeaderDeclinedProductStores)
	}
	if m.removeditem_declined_product_stores != nil {
		edges = append(edges, statusitem.EdgeItemDeclinedProductStores)
	}
	if m.removedheader_cancel_product_stores != nil {
		edges = append(edges, statusitem.EdgeHeaderCancelProductStores)
	}
	if m.removeditem_cancel_product_stores != nil {
		edges = append(edges, statusitem.EdgeItemCancelProductStores)
	}
	if m.removedmain_status_valid_changes != nil {
		edges = append(edges, statusitem.EdgeMainStatusValidChanges)
	}
	if m.removedto_status_valid_changes != nil {
		edges = append(edges, statusitem.EdgeToStatusValidChanges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statusitem.EdgeOrderHeaders:
		ids := make([]ent.Value, 0, len(m.removedorder_headers))
		for id := range m.removedorder_headers {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeSyncOrderHeaders:
		ids := make([]ent.Value, 0, len(m.removedsync_order_headers))
		for id := range m.removedsync_order_headers {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeOrderItems:
		ids := make([]ent.Value, 0, len(m.removedorder_items))
		for id := range m.removedorder_items {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeSyncOrderItems:
		ids := make([]ent.Value, 0, len(m.removedsync_order_items))
		for id := range m.removedsync_order_items {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeOrderPaymentPreferences:
		ids := make([]ent.Value, 0, len(m.removedorder_payment_preferences))
		for id := range m.removedorder_payment_preferences {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeOrderStatuses:
		ids := make([]ent.Value, 0, len(m.removedorder_statuses))
		for id := range m.removedorder_statuses {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeProductReviews:
		ids := make([]ent.Value, 0, len(m.removedproduct_reviews))
		for id := range m.removedproduct_reviews {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeHeaderApprovedProductStores:
		ids := make([]ent.Value, 0, len(m.removedheader_approved_product_stores))
		for id := range m.removedheader_approved_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeItemApprovedProductStores:
		ids := make([]ent.Value, 0, len(m.removeditem_approved_product_stores))
		for id := range m.removeditem_approved_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeDigitalItemApprovedProductStores:
		ids := make([]ent.Value, 0, len(m.removeddigital_item_approved_product_stores))
		for id := range m.removeddigital_item_approved_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeHeaderDeclinedProductStores:
		ids := make([]ent.Value, 0, len(m.removedheader_declined_product_stores))
		for id := range m.removedheader_declined_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeItemDeclinedProductStores:
		ids := make([]ent.Value, 0, len(m.removeditem_declined_product_stores))
		for id := range m.removeditem_declined_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeHeaderCancelProductStores:
		ids := make([]ent.Value, 0, len(m.removedheader_cancel_product_stores))
		for id := range m.removedheader_cancel_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeItemCancelProductStores:
		ids := make([]ent.Value, 0, len(m.removeditem_cancel_product_stores))
		for id := range m.removeditem_cancel_product_stores {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeMainStatusValidChanges:
		ids := make([]ent.Value, 0, len(m.removedmain_status_valid_changes))
		for id := range m.removedmain_status_valid_changes {
			ids = append(ids, id)
		}
		return ids
	case statusitem.EdgeToStatusValidChanges:
		ids := make([]ent.Value, 0, len(m.removedto_status_valid_changes))
		for id := range m.removedto_status_valid_changes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedstatus_type {
		edges = append(edges, statusitem.EdgeStatusType)
	}
	if m.clearedorder_headers {
		edges = append(edges, statusitem.EdgeOrderHeaders)
	}
	if m.clearedsync_order_headers {
		edges = append(edges, statusitem.EdgeSyncOrderHeaders)
	}
	if m.clearedorder_items {
		edges = append(edges, statusitem.EdgeOrderItems)
	}
	if m.clearedsync_order_items {
		edges = append(edges, statusitem.EdgeSyncOrderItems)
	}
	if m.clearedorder_payment_preferences {
		edges = append(edges, statusitem.EdgeOrderPaymentPreferences)
	}
	if m.clearedorder_statuses {
		edges = append(edges, statusitem.EdgeOrderStatuses)
	}
	if m.clearedproduct_reviews {
		edges = append(edges, statusitem.EdgeProductReviews)
	}
	if m.clearedheader_approved_product_stores {
		edges = append(edges, statusitem.EdgeHeaderApprovedProductStores)
	}
	if m.cleareditem_approved_product_stores {
		edges = append(edges, statusitem.EdgeItemApprovedProductStores)
	}
	if m.cleareddigital_item_approved_product_stores {
		edges = append(edges, statusitem.EdgeDigitalItemApprovedProductStores)
	}
	if m.clearedheader_declined_product_stores {
		edges = append(edges, statusitem.EdgeHeaderDeclinedProductStores)
	}
	if m.cleareditem_declined_product_stores {
		edges = append(edges, statusitem.EdgeItemDeclinedProductStores)
	}
	if m.clearedheader_cancel_product_stores {
		edges = append(edges, statusitem.EdgeHeaderCancelProductStores)
	}
	if m.cleareditem_cancel_product_stores {
		edges = append(edges, statusitem.EdgeItemCancelProductStores)
	}
	if m.clearedmain_status_valid_changes {
		edges = append(edges, statusitem.EdgeMainStatusValidChanges)
	}
	if m.clearedto_status_valid_changes {
		edges = append(edges, statusitem.EdgeToStatusValidChanges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusItemMutation) EdgeCleared(name string) bool {
	switch name {
	case statusitem.EdgeStatusType:
		return m.clearedstatus_type
	case statusitem.EdgeOrderHeaders:
		return m.clearedorder_headers
	case statusitem.EdgeSyncOrderHeaders:
		return m.clearedsync_order_headers
	case statusitem.EdgeOrderItems:
		return m.clearedorder_items
	case statusitem.EdgeSyncOrderItems:
		return m.clearedsync_order_items
	case statusitem.EdgeOrderPaymentPreferences:
		return m.clearedorder_payment_preferences
	case statusitem.EdgeOrderStatuses:
		return m.clearedorder_statuses
	case statusitem.EdgeProductReviews:
		return m.clearedproduct_reviews
	case statusitem.EdgeHeaderApprovedProductStores:
		return m.clearedheader_approved_product_stores
	case statusitem.EdgeItemApprovedProductStores:
		return m.cleareditem_approved_product_stores
	case statusitem.EdgeDigitalItemApprovedProductStores:
		return m.cleareddigital_item_approved_product_stores
	case statusitem.EdgeHeaderDeclinedProductStores:
		return m.clearedheader_declined_product_stores
	case statusitem.EdgeItemDeclinedProductStores:
		return m.cleareditem_declined_product_stores
	case statusitem.EdgeHeaderCancelProductStores:
		return m.clearedheader_cancel_product_stores
	case statusitem.EdgeItemCancelProductStores:
		return m.cleareditem_cancel_product_stores
	case statusitem.EdgeMainStatusValidChanges:
		return m.clearedmain_status_valid_changes
	case statusitem.EdgeToStatusValidChanges:
		return m.clearedto_status_valid_changes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusItemMutation) ClearEdge(name string) error {
	switch name {
	case statusitem.EdgeStatusType:
		m.ClearStatusType()
		return nil
	}
	return fmt.Errorf("unknown StatusItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusItemMutation) ResetEdge(name string) error {
	switch name {
	case statusitem.EdgeStatusType:
		m.ResetStatusType()
		return nil
	case statusitem.EdgeOrderHeaders:
		m.ResetOrderHeaders()
		return nil
	case statusitem.EdgeSyncOrderHeaders:
		m.ResetSyncOrderHeaders()
		return nil
	case statusitem.EdgeOrderItems:
		m.ResetOrderItems()
		return nil
	case statusitem.EdgeSyncOrderItems:
		m.ResetSyncOrderItems()
		return nil
	case statusitem.EdgeOrderPaymentPreferences:
		m.ResetOrderPaymentPreferences()
		return nil
	case statusitem.EdgeOrderStatuses:
		m.ResetOrderStatuses()
		return nil
	case statusitem.EdgeProductReviews:
		m.ResetProductReviews()
		return nil
	case statusitem.EdgeHeaderApprovedProductStores:
		m.ResetHeaderApprovedProductStores()
		return nil
	case statusitem.EdgeItemApprovedProductStores:
		m.ResetItemApprovedProductStores()
		return nil
	case statusitem.EdgeDigitalItemApprovedProductStores:
		m.ResetDigitalItemApprovedProductStores()
		return nil
	case statusitem.EdgeHeaderDeclinedProductStores:
		m.ResetHeaderDeclinedProductStores()
		return nil
	case statusitem.EdgeItemDeclinedProductStores:
		m.ResetItemDeclinedProductStores()
		return nil
	case statusitem.EdgeHeaderCancelProductStores:
		m.ResetHeaderCancelProductStores()
		return nil
	case statusitem.EdgeItemCancelProductStores:
		m.ResetItemCancelProductStores()
		return nil
	case statusitem.EdgeMainStatusValidChanges:
		m.ResetMainStatusValidChanges()
		return nil
	case statusitem.EdgeToStatusValidChanges:
		m.ResetToStatusValidChanges()
		return nil
	}
	return fmt.Errorf("unknown StatusItem edge %s", name)
}

// StatusTypeMutation represents an operation that mutates the StatusType nodes in the graph.
type StatusTypeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	create_time               *time.Time
	update_time               *time.Time
	string_ref                *string
	has_table                 *statustype.HasTable
	description               *string
	clearedFields             map[string]struct{}
	parent                    *int
	clearedparent             bool
	children                  map[int]struct{}
	removedchildren           map[int]struct{}
	clearedchildren           bool
	status_items              map[int]struct{}
	removedstatus_items       map[int]struct{}
	clearedstatus_items       bool
	child_status_types        map[int]struct{}
	removedchild_status_types map[int]struct{}
	clearedchild_status_types bool
	done                      bool
	oldValue                  func(context.Context) (*StatusType, error)
	predicates                []predicate.StatusType
}

var _ ent.Mutation = (*StatusTypeMutation)(nil)

// statustypeOption allows management of the mutation configuration using functional options.
type statustypeOption func(*StatusTypeMutation)

// newStatusTypeMutation creates new mutation for the StatusType entity.
func newStatusTypeMutation(c config, op Op, opts ...statustypeOption) *StatusTypeMutation {
	m := &StatusTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusTypeID sets the ID field of the mutation.
func withStatusTypeID(id int) statustypeOption {
	return func(m *StatusTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *StatusType
		)
		m.oldValue = func(ctx context.Context) (*StatusType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatusType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusType sets the old StatusType of the mutation.
func withStatusType(node *StatusType) statustypeOption {
	return func(m *StatusTypeMutation) {
		m.oldValue = func(context.Context) (*StatusType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *StatusTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatusTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatusType entity.
// If the StatusType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatusTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StatusTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StatusTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the StatusType entity.
// If the StatusType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StatusTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *StatusTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *StatusTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the StatusType entity.
// If the StatusType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *StatusTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[statustype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *StatusTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[statustype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *StatusTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, statustype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *StatusTypeMutation) SetHasTable(st statustype.HasTable) {
	m.has_table = &st
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *StatusTypeMutation) HasTable() (r statustype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the StatusType entity.
// If the StatusType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusTypeMutation) OldHasTable(ctx context.Context) (v statustype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *StatusTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[statustype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *StatusTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[statustype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *StatusTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, statustype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *StatusTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StatusTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StatusType entity.
// If the StatusType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StatusTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[statustype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StatusTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[statustype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StatusTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, statustype.FieldDescription)
}

// SetParentID sets the "parent" edge to the StatusType entity by id.
func (m *StatusTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the StatusType entity.
func (m *StatusTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the StatusType entity was cleared.
func (m *StatusTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *StatusTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StatusTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StatusTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the StatusType entity by ids.
func (m *StatusTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the StatusType entity.
func (m *StatusTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the StatusType entity was cleared.
func (m *StatusTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the StatusType entity by IDs.
func (m *StatusTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the StatusType entity.
func (m *StatusTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *StatusTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *StatusTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddStatusItemIDs adds the "status_items" edge to the StatusItem entity by ids.
func (m *StatusTypeMutation) AddStatusItemIDs(ids ...int) {
	if m.status_items == nil {
		m.status_items = make(map[int]struct{})
	}
	for i := range ids {
		m.status_items[ids[i]] = struct{}{}
	}
}

// ClearStatusItems clears the "status_items" edge to the StatusItem entity.
func (m *StatusTypeMutation) ClearStatusItems() {
	m.clearedstatus_items = true
}

// StatusItemsCleared reports if the "status_items" edge to the StatusItem entity was cleared.
func (m *StatusTypeMutation) StatusItemsCleared() bool {
	return m.clearedstatus_items
}

// RemoveStatusItemIDs removes the "status_items" edge to the StatusItem entity by IDs.
func (m *StatusTypeMutation) RemoveStatusItemIDs(ids ...int) {
	if m.removedstatus_items == nil {
		m.removedstatus_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatus_items[ids[i]] = struct{}{}
	}
}

// RemovedStatusItems returns the removed IDs of the "status_items" edge to the StatusItem entity.
func (m *StatusTypeMutation) RemovedStatusItemsIDs() (ids []int) {
	for id := range m.removedstatus_items {
		ids = append(ids, id)
	}
	return
}

// StatusItemsIDs returns the "status_items" edge IDs in the mutation.
func (m *StatusTypeMutation) StatusItemsIDs() (ids []int) {
	for id := range m.status_items {
		ids = append(ids, id)
	}
	return
}

// ResetStatusItems resets all changes to the "status_items" edge.
func (m *StatusTypeMutation) ResetStatusItems() {
	m.status_items = nil
	m.clearedstatus_items = false
	m.removedstatus_items = nil
}

// AddChildStatusTypeIDs adds the "child_status_types" edge to the StatusType entity by ids.
func (m *StatusTypeMutation) AddChildStatusTypeIDs(ids ...int) {
	if m.child_status_types == nil {
		m.child_status_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_status_types[ids[i]] = struct{}{}
	}
}

// ClearChildStatusTypes clears the "child_status_types" edge to the StatusType entity.
func (m *StatusTypeMutation) ClearChildStatusTypes() {
	m.clearedchild_status_types = true
}

// ChildStatusTypesCleared reports if the "child_status_types" edge to the StatusType entity was cleared.
func (m *StatusTypeMutation) ChildStatusTypesCleared() bool {
	return m.clearedchild_status_types
}

// RemoveChildStatusTypeIDs removes the "child_status_types" edge to the StatusType entity by IDs.
func (m *StatusTypeMutation) RemoveChildStatusTypeIDs(ids ...int) {
	if m.removedchild_status_types == nil {
		m.removedchild_status_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_status_types[ids[i]] = struct{}{}
	}
}

// RemovedChildStatusTypes returns the removed IDs of the "child_status_types" edge to the StatusType entity.
func (m *StatusTypeMutation) RemovedChildStatusTypesIDs() (ids []int) {
	for id := range m.removedchild_status_types {
		ids = append(ids, id)
	}
	return
}

// ChildStatusTypesIDs returns the "child_status_types" edge IDs in the mutation.
func (m *StatusTypeMutation) ChildStatusTypesIDs() (ids []int) {
	for id := range m.child_status_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildStatusTypes resets all changes to the "child_status_types" edge.
func (m *StatusTypeMutation) ResetChildStatusTypes() {
	m.child_status_types = nil
	m.clearedchild_status_types = false
	m.removedchild_status_types = nil
}

// Op returns the operation name.
func (m *StatusTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StatusType).
func (m *StatusTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, statustype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, statustype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, statustype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, statustype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, statustype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statustype.FieldCreateTime:
		return m.CreateTime()
	case statustype.FieldUpdateTime:
		return m.UpdateTime()
	case statustype.FieldStringRef:
		return m.StringRef()
	case statustype.FieldHasTable:
		return m.HasTable()
	case statustype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statustype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case statustype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case statustype.FieldStringRef:
		return m.OldStringRef(ctx)
	case statustype.FieldHasTable:
		return m.OldHasTable(ctx)
	case statustype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown StatusType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statustype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case statustype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case statustype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case statustype.FieldHasTable:
		v, ok := value.(statustype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case statustype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown StatusType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StatusType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statustype.FieldStringRef) {
		fields = append(fields, statustype.FieldStringRef)
	}
	if m.FieldCleared(statustype.FieldHasTable) {
		fields = append(fields, statustype.FieldHasTable)
	}
	if m.FieldCleared(statustype.FieldDescription) {
		fields = append(fields, statustype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusTypeMutation) ClearField(name string) error {
	switch name {
	case statustype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case statustype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case statustype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown StatusType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusTypeMutation) ResetField(name string) error {
	switch name {
	case statustype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case statustype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case statustype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case statustype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case statustype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown StatusType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, statustype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, statustype.EdgeChildren)
	}
	if m.status_items != nil {
		edges = append(edges, statustype.EdgeStatusItems)
	}
	if m.child_status_types != nil {
		edges = append(edges, statustype.EdgeChildStatusTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statustype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case statustype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case statustype.EdgeStatusItems:
		ids := make([]ent.Value, 0, len(m.status_items))
		for id := range m.status_items {
			ids = append(ids, id)
		}
		return ids
	case statustype.EdgeChildStatusTypes:
		ids := make([]ent.Value, 0, len(m.child_status_types))
		for id := range m.child_status_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, statustype.EdgeChildren)
	}
	if m.removedstatus_items != nil {
		edges = append(edges, statustype.EdgeStatusItems)
	}
	if m.removedchild_status_types != nil {
		edges = append(edges, statustype.EdgeChildStatusTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statustype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case statustype.EdgeStatusItems:
		ids := make([]ent.Value, 0, len(m.removedstatus_items))
		for id := range m.removedstatus_items {
			ids = append(ids, id)
		}
		return ids
	case statustype.EdgeChildStatusTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_status_types))
		for id := range m.removedchild_status_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, statustype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, statustype.EdgeChildren)
	}
	if m.clearedstatus_items {
		edges = append(edges, statustype.EdgeStatusItems)
	}
	if m.clearedchild_status_types {
		edges = append(edges, statustype.EdgeChildStatusTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case statustype.EdgeParent:
		return m.clearedparent
	case statustype.EdgeChildren:
		return m.clearedchildren
	case statustype.EdgeStatusItems:
		return m.clearedstatus_items
	case statustype.EdgeChildStatusTypes:
		return m.clearedchild_status_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusTypeMutation) ClearEdge(name string) error {
	switch name {
	case statustype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown StatusType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusTypeMutation) ResetEdge(name string) error {
	switch name {
	case statustype.EdgeParent:
		m.ResetParent()
		return nil
	case statustype.EdgeChildren:
		m.ResetChildren()
		return nil
	case statustype.EdgeStatusItems:
		m.ResetStatusItems()
		return nil
	case statustype.EdgeChildStatusTypes:
		m.ResetChildStatusTypes()
		return nil
	}
	return fmt.Errorf("unknown StatusType edge %s", name)
}

// StatusValidChangeMutation represents an operation that mutates the StatusValidChange nodes in the graph.
type StatusValidChangeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	string_ref              *string
	condition_expression    *string
	transition_name         *string
	clearedFields           map[string]struct{}
	main_status_item        *int
	clearedmain_status_item bool
	to_status_item          *int
	clearedto_status_item   bool
	done                    bool
	oldValue                func(context.Context) (*StatusValidChange, error)
	predicates              []predicate.StatusValidChange
}

var _ ent.Mutation = (*StatusValidChangeMutation)(nil)

// statusvalidchangeOption allows management of the mutation configuration using functional options.
type statusvalidchangeOption func(*StatusValidChangeMutation)

// newStatusValidChangeMutation creates new mutation for the StatusValidChange entity.
func newStatusValidChangeMutation(c config, op Op, opts ...statusvalidchangeOption) *StatusValidChangeMutation {
	m := &StatusValidChangeMutation{
		config:        c,
		op:            op,
		typ:           TypeStatusValidChange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusValidChangeID sets the ID field of the mutation.
func withStatusValidChangeID(id int) statusvalidchangeOption {
	return func(m *StatusValidChangeMutation) {
		var (
			err   error
			once  sync.Once
			value *StatusValidChange
		)
		m.oldValue = func(ctx context.Context) (*StatusValidChange, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatusValidChange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatusValidChange sets the old StatusValidChange of the mutation.
func withStatusValidChange(node *StatusValidChange) statusvalidchangeOption {
	return func(m *StatusValidChangeMutation) {
		m.oldValue = func(context.Context) (*StatusValidChange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusValidChangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusValidChangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusValidChangeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *StatusValidChangeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StatusValidChangeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the StatusValidChange entity.
// If the StatusValidChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusValidChangeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StatusValidChangeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StatusValidChangeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StatusValidChangeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the StatusValidChange entity.
// If the StatusValidChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusValidChangeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StatusValidChangeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *StatusValidChangeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *StatusValidChangeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the StatusValidChange entity.
// If the StatusValidChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusValidChangeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *StatusValidChangeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[statusvalidchange.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *StatusValidChangeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[statusvalidchange.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *StatusValidChangeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, statusvalidchange.FieldStringRef)
}

// SetConditionExpression sets the "condition_expression" field.
func (m *StatusValidChangeMutation) SetConditionExpression(s string) {
	m.condition_expression = &s
}

// ConditionExpression returns the value of the "condition_expression" field in the mutation.
func (m *StatusValidChangeMutation) ConditionExpression() (r string, exists bool) {
	v := m.condition_expression
	if v == nil {
		return
	}
	return *v, true
}

// OldConditionExpression returns the old "condition_expression" field's value of the StatusValidChange entity.
// If the StatusValidChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusValidChangeMutation) OldConditionExpression(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConditionExpression is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConditionExpression requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditionExpression: %w", err)
	}
	return oldValue.ConditionExpression, nil
}

// ClearConditionExpression clears the value of the "condition_expression" field.
func (m *StatusValidChangeMutation) ClearConditionExpression() {
	m.condition_expression = nil
	m.clearedFields[statusvalidchange.FieldConditionExpression] = struct{}{}
}

// ConditionExpressionCleared returns if the "condition_expression" field was cleared in this mutation.
func (m *StatusValidChangeMutation) ConditionExpressionCleared() bool {
	_, ok := m.clearedFields[statusvalidchange.FieldConditionExpression]
	return ok
}

// ResetConditionExpression resets all changes to the "condition_expression" field.
func (m *StatusValidChangeMutation) ResetConditionExpression() {
	m.condition_expression = nil
	delete(m.clearedFields, statusvalidchange.FieldConditionExpression)
}

// SetTransitionName sets the "transition_name" field.
func (m *StatusValidChangeMutation) SetTransitionName(s string) {
	m.transition_name = &s
}

// TransitionName returns the value of the "transition_name" field in the mutation.
func (m *StatusValidChangeMutation) TransitionName() (r string, exists bool) {
	v := m.transition_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTransitionName returns the old "transition_name" field's value of the StatusValidChange entity.
// If the StatusValidChange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusValidChangeMutation) OldTransitionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransitionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransitionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransitionName: %w", err)
	}
	return oldValue.TransitionName, nil
}

// ClearTransitionName clears the value of the "transition_name" field.
func (m *StatusValidChangeMutation) ClearTransitionName() {
	m.transition_name = nil
	m.clearedFields[statusvalidchange.FieldTransitionName] = struct{}{}
}

// TransitionNameCleared returns if the "transition_name" field was cleared in this mutation.
func (m *StatusValidChangeMutation) TransitionNameCleared() bool {
	_, ok := m.clearedFields[statusvalidchange.FieldTransitionName]
	return ok
}

// ResetTransitionName resets all changes to the "transition_name" field.
func (m *StatusValidChangeMutation) ResetTransitionName() {
	m.transition_name = nil
	delete(m.clearedFields, statusvalidchange.FieldTransitionName)
}

// SetMainStatusItemID sets the "main_status_item" edge to the StatusItem entity by id.
func (m *StatusValidChangeMutation) SetMainStatusItemID(id int) {
	m.main_status_item = &id
}

// ClearMainStatusItem clears the "main_status_item" edge to the StatusItem entity.
func (m *StatusValidChangeMutation) ClearMainStatusItem() {
	m.clearedmain_status_item = true
}

// MainStatusItemCleared reports if the "main_status_item" edge to the StatusItem entity was cleared.
func (m *StatusValidChangeMutation) MainStatusItemCleared() bool {
	return m.clearedmain_status_item
}

// MainStatusItemID returns the "main_status_item" edge ID in the mutation.
func (m *StatusValidChangeMutation) MainStatusItemID() (id int, exists bool) {
	if m.main_status_item != nil {
		return *m.main_status_item, true
	}
	return
}

// MainStatusItemIDs returns the "main_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MainStatusItemID instead. It exists only for internal usage by the builders.
func (m *StatusValidChangeMutation) MainStatusItemIDs() (ids []int) {
	if id := m.main_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMainStatusItem resets all changes to the "main_status_item" edge.
func (m *StatusValidChangeMutation) ResetMainStatusItem() {
	m.main_status_item = nil
	m.clearedmain_status_item = false
}

// SetToStatusItemID sets the "to_status_item" edge to the StatusItem entity by id.
func (m *StatusValidChangeMutation) SetToStatusItemID(id int) {
	m.to_status_item = &id
}

// ClearToStatusItem clears the "to_status_item" edge to the StatusItem entity.
func (m *StatusValidChangeMutation) ClearToStatusItem() {
	m.clearedto_status_item = true
}

// ToStatusItemCleared reports if the "to_status_item" edge to the StatusItem entity was cleared.
func (m *StatusValidChangeMutation) ToStatusItemCleared() bool {
	return m.clearedto_status_item
}

// ToStatusItemID returns the "to_status_item" edge ID in the mutation.
func (m *StatusValidChangeMutation) ToStatusItemID() (id int, exists bool) {
	if m.to_status_item != nil {
		return *m.to_status_item, true
	}
	return
}

// ToStatusItemIDs returns the "to_status_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToStatusItemID instead. It exists only for internal usage by the builders.
func (m *StatusValidChangeMutation) ToStatusItemIDs() (ids []int) {
	if id := m.to_status_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToStatusItem resets all changes to the "to_status_item" edge.
func (m *StatusValidChangeMutation) ResetToStatusItem() {
	m.to_status_item = nil
	m.clearedto_status_item = false
}

// Op returns the operation name.
func (m *StatusValidChangeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StatusValidChange).
func (m *StatusValidChangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusValidChangeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, statusvalidchange.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, statusvalidchange.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, statusvalidchange.FieldStringRef)
	}
	if m.condition_expression != nil {
		fields = append(fields, statusvalidchange.FieldConditionExpression)
	}
	if m.transition_name != nil {
		fields = append(fields, statusvalidchange.FieldTransitionName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusValidChangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statusvalidchange.FieldCreateTime:
		return m.CreateTime()
	case statusvalidchange.FieldUpdateTime:
		return m.UpdateTime()
	case statusvalidchange.FieldStringRef:
		return m.StringRef()
	case statusvalidchange.FieldConditionExpression:
		return m.ConditionExpression()
	case statusvalidchange.FieldTransitionName:
		return m.TransitionName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusValidChangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statusvalidchange.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case statusvalidchange.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case statusvalidchange.FieldStringRef:
		return m.OldStringRef(ctx)
	case statusvalidchange.FieldConditionExpression:
		return m.OldConditionExpression(ctx)
	case statusvalidchange.FieldTransitionName:
		return m.OldTransitionName(ctx)
	}
	return nil, fmt.Errorf("unknown StatusValidChange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusValidChangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statusvalidchange.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case statusvalidchange.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case statusvalidchange.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case statusvalidchange.FieldConditionExpression:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditionExpression(v)
		return nil
	case statusvalidchange.FieldTransitionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransitionName(v)
		return nil
	}
	return fmt.Errorf("unknown StatusValidChange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusValidChangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusValidChangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusValidChangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StatusValidChange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusValidChangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statusvalidchange.FieldStringRef) {
		fields = append(fields, statusvalidchange.FieldStringRef)
	}
	if m.FieldCleared(statusvalidchange.FieldConditionExpression) {
		fields = append(fields, statusvalidchange.FieldConditionExpression)
	}
	if m.FieldCleared(statusvalidchange.FieldTransitionName) {
		fields = append(fields, statusvalidchange.FieldTransitionName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusValidChangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusValidChangeMutation) ClearField(name string) error {
	switch name {
	case statusvalidchange.FieldStringRef:
		m.ClearStringRef()
		return nil
	case statusvalidchange.FieldConditionExpression:
		m.ClearConditionExpression()
		return nil
	case statusvalidchange.FieldTransitionName:
		m.ClearTransitionName()
		return nil
	}
	return fmt.Errorf("unknown StatusValidChange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusValidChangeMutation) ResetField(name string) error {
	switch name {
	case statusvalidchange.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case statusvalidchange.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case statusvalidchange.FieldStringRef:
		m.ResetStringRef()
		return nil
	case statusvalidchange.FieldConditionExpression:
		m.ResetConditionExpression()
		return nil
	case statusvalidchange.FieldTransitionName:
		m.ResetTransitionName()
		return nil
	}
	return fmt.Errorf("unknown StatusValidChange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusValidChangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.main_status_item != nil {
		edges = append(edges, statusvalidchange.EdgeMainStatusItem)
	}
	if m.to_status_item != nil {
		edges = append(edges, statusvalidchange.EdgeToStatusItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusValidChangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statusvalidchange.EdgeMainStatusItem:
		if id := m.main_status_item; id != nil {
			return []ent.Value{*id}
		}
	case statusvalidchange.EdgeToStatusItem:
		if id := m.to_status_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusValidChangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusValidChangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusValidChangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmain_status_item {
		edges = append(edges, statusvalidchange.EdgeMainStatusItem)
	}
	if m.clearedto_status_item {
		edges = append(edges, statusvalidchange.EdgeToStatusItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusValidChangeMutation) EdgeCleared(name string) bool {
	switch name {
	case statusvalidchange.EdgeMainStatusItem:
		return m.clearedmain_status_item
	case statusvalidchange.EdgeToStatusItem:
		return m.clearedto_status_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusValidChangeMutation) ClearEdge(name string) error {
	switch name {
	case statusvalidchange.EdgeMainStatusItem:
		m.ClearMainStatusItem()
		return nil
	case statusvalidchange.EdgeToStatusItem:
		m.ClearToStatusItem()
		return nil
	}
	return fmt.Errorf("unknown StatusValidChange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusValidChangeMutation) ResetEdge(name string) error {
	switch name {
	case statusvalidchange.EdgeMainStatusItem:
		m.ResetMainStatusItem()
		return nil
	case statusvalidchange.EdgeToStatusItem:
		m.ResetToStatusItem()
		return nil
	}
	return fmt.Errorf("unknown StatusValidChange edge %s", name)
}

// SubscriptionTypeMutation represents an operation that mutates the SubscriptionType nodes in the graph.
type SubscriptionTypeMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	create_time                     *time.Time
	update_time                     *time.Time
	string_ref                      *string
	has_table                       *subscriptiontype.HasTable
	description                     *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	children                        map[int]struct{}
	removedchildren                 map[int]struct{}
	clearedchildren                 bool
	child_subscription_types        map[int]struct{}
	removedchild_subscription_types map[int]struct{}
	clearedchild_subscription_types bool
	done                            bool
	oldValue                        func(context.Context) (*SubscriptionType, error)
	predicates                      []predicate.SubscriptionType
}

var _ ent.Mutation = (*SubscriptionTypeMutation)(nil)

// subscriptiontypeOption allows management of the mutation configuration using functional options.
type subscriptiontypeOption func(*SubscriptionTypeMutation)

// newSubscriptionTypeMutation creates new mutation for the SubscriptionType entity.
func newSubscriptionTypeMutation(c config, op Op, opts ...subscriptiontypeOption) *SubscriptionTypeMutation {
	m := &SubscriptionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscriptionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscriptionTypeID sets the ID field of the mutation.
func withSubscriptionTypeID(id int) subscriptiontypeOption {
	return func(m *SubscriptionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscriptionType
		)
		m.oldValue = func(ctx context.Context) (*SubscriptionType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscriptionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscriptionType sets the old SubscriptionType of the mutation.
func withSubscriptionType(node *SubscriptionType) subscriptiontypeOption {
	return func(m *SubscriptionTypeMutation) {
		m.oldValue = func(context.Context) (*SubscriptionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscriptionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscriptionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscriptionTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SubscriptionTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SubscriptionTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SubscriptionType entity.
// If the SubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SubscriptionTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SubscriptionTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SubscriptionTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SubscriptionType entity.
// If the SubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SubscriptionTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *SubscriptionTypeMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *SubscriptionTypeMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the SubscriptionType entity.
// If the SubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTypeMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *SubscriptionTypeMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[subscriptiontype.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *SubscriptionTypeMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[subscriptiontype.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *SubscriptionTypeMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, subscriptiontype.FieldStringRef)
}

// SetHasTable sets the "has_table" field.
func (m *SubscriptionTypeMutation) SetHasTable(st subscriptiontype.HasTable) {
	m.has_table = &st
}

// HasTable returns the value of the "has_table" field in the mutation.
func (m *SubscriptionTypeMutation) HasTable() (r subscriptiontype.HasTable, exists bool) {
	v := m.has_table
	if v == nil {
		return
	}
	return *v, true
}

// OldHasTable returns the old "has_table" field's value of the SubscriptionType entity.
// If the SubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTypeMutation) OldHasTable(ctx context.Context) (v subscriptiontype.HasTable, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasTable: %w", err)
	}
	return oldValue.HasTable, nil
}

// ClearHasTable clears the value of the "has_table" field.
func (m *SubscriptionTypeMutation) ClearHasTable() {
	m.has_table = nil
	m.clearedFields[subscriptiontype.FieldHasTable] = struct{}{}
}

// HasTableCleared returns if the "has_table" field was cleared in this mutation.
func (m *SubscriptionTypeMutation) HasTableCleared() bool {
	_, ok := m.clearedFields[subscriptiontype.FieldHasTable]
	return ok
}

// ResetHasTable resets all changes to the "has_table" field.
func (m *SubscriptionTypeMutation) ResetHasTable() {
	m.has_table = nil
	delete(m.clearedFields, subscriptiontype.FieldHasTable)
}

// SetDescription sets the "description" field.
func (m *SubscriptionTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SubscriptionTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SubscriptionType entity.
// If the SubscriptionType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscriptionTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SubscriptionTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[subscriptiontype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SubscriptionTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[subscriptiontype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SubscriptionTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, subscriptiontype.FieldDescription)
}

// SetParentID sets the "parent" edge to the SubscriptionType entity by id.
func (m *SubscriptionTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the SubscriptionType entity.
func (m *SubscriptionTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the SubscriptionType entity was cleared.
func (m *SubscriptionTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *SubscriptionTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *SubscriptionTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *SubscriptionTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the SubscriptionType entity by ids.
func (m *SubscriptionTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the SubscriptionType entity.
func (m *SubscriptionTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the SubscriptionType entity was cleared.
func (m *SubscriptionTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the SubscriptionType entity by IDs.
func (m *SubscriptionTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the SubscriptionType entity.
func (m *SubscriptionTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *SubscriptionTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *SubscriptionTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddChildSubscriptionTypeIDs adds the "child_subscription_types" edge to the SubscriptionType entity by ids.
func (m *SubscriptionTypeMutation) AddChildSubscriptionTypeIDs(ids ...int) {
	if m.child_subscription_types == nil {
		m.child_subscription_types = make(map[int]struct{})
	}
	for i := range ids {
		m.child_subscription_types[ids[i]] = struct{}{}
	}
}

// ClearChildSubscriptionTypes clears the "child_subscription_types" edge to the SubscriptionType entity.
func (m *SubscriptionTypeMutation) ClearChildSubscriptionTypes() {
	m.clearedchild_subscription_types = true
}

// ChildSubscriptionTypesCleared reports if the "child_subscription_types" edge to the SubscriptionType entity was cleared.
func (m *SubscriptionTypeMutation) ChildSubscriptionTypesCleared() bool {
	return m.clearedchild_subscription_types
}

// RemoveChildSubscriptionTypeIDs removes the "child_subscription_types" edge to the SubscriptionType entity by IDs.
func (m *SubscriptionTypeMutation) RemoveChildSubscriptionTypeIDs(ids ...int) {
	if m.removedchild_subscription_types == nil {
		m.removedchild_subscription_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_subscription_types[ids[i]] = struct{}{}
	}
}

// RemovedChildSubscriptionTypes returns the removed IDs of the "child_subscription_types" edge to the SubscriptionType entity.
func (m *SubscriptionTypeMutation) RemovedChildSubscriptionTypesIDs() (ids []int) {
	for id := range m.removedchild_subscription_types {
		ids = append(ids, id)
	}
	return
}

// ChildSubscriptionTypesIDs returns the "child_subscription_types" edge IDs in the mutation.
func (m *SubscriptionTypeMutation) ChildSubscriptionTypesIDs() (ids []int) {
	for id := range m.child_subscription_types {
		ids = append(ids, id)
	}
	return
}

// ResetChildSubscriptionTypes resets all changes to the "child_subscription_types" edge.
func (m *SubscriptionTypeMutation) ResetChildSubscriptionTypes() {
	m.child_subscription_types = nil
	m.clearedchild_subscription_types = false
	m.removedchild_subscription_types = nil
}

// Op returns the operation name.
func (m *SubscriptionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SubscriptionType).
func (m *SubscriptionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscriptionTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, subscriptiontype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, subscriptiontype.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, subscriptiontype.FieldStringRef)
	}
	if m.has_table != nil {
		fields = append(fields, subscriptiontype.FieldHasTable)
	}
	if m.description != nil {
		fields = append(fields, subscriptiontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscriptionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscriptiontype.FieldCreateTime:
		return m.CreateTime()
	case subscriptiontype.FieldUpdateTime:
		return m.UpdateTime()
	case subscriptiontype.FieldStringRef:
		return m.StringRef()
	case subscriptiontype.FieldHasTable:
		return m.HasTable()
	case subscriptiontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscriptionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscriptiontype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case subscriptiontype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case subscriptiontype.FieldStringRef:
		return m.OldStringRef(ctx)
	case subscriptiontype.FieldHasTable:
		return m.OldHasTable(ctx)
	case subscriptiontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SubscriptionType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscriptiontype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case subscriptiontype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case subscriptiontype.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case subscriptiontype.FieldHasTable:
		v, ok := value.(subscriptiontype.HasTable)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasTable(v)
		return nil
	case subscriptiontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SubscriptionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscriptionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscriptionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscriptionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubscriptionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscriptionTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscriptiontype.FieldStringRef) {
		fields = append(fields, subscriptiontype.FieldStringRef)
	}
	if m.FieldCleared(subscriptiontype.FieldHasTable) {
		fields = append(fields, subscriptiontype.FieldHasTable)
	}
	if m.FieldCleared(subscriptiontype.FieldDescription) {
		fields = append(fields, subscriptiontype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscriptionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscriptionTypeMutation) ClearField(name string) error {
	switch name {
	case subscriptiontype.FieldStringRef:
		m.ClearStringRef()
		return nil
	case subscriptiontype.FieldHasTable:
		m.ClearHasTable()
		return nil
	case subscriptiontype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscriptionTypeMutation) ResetField(name string) error {
	switch name {
	case subscriptiontype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case subscriptiontype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case subscriptiontype.FieldStringRef:
		m.ResetStringRef()
		return nil
	case subscriptiontype.FieldHasTable:
		m.ResetHasTable()
		return nil
	case subscriptiontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscriptionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, subscriptiontype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, subscriptiontype.EdgeChildren)
	}
	if m.child_subscription_types != nil {
		edges = append(edges, subscriptiontype.EdgeChildSubscriptionTypes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscriptionTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscriptiontype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case subscriptiontype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case subscriptiontype.EdgeChildSubscriptionTypes:
		ids := make([]ent.Value, 0, len(m.child_subscription_types))
		for id := range m.child_subscription_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscriptionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, subscriptiontype.EdgeChildren)
	}
	if m.removedchild_subscription_types != nil {
		edges = append(edges, subscriptiontype.EdgeChildSubscriptionTypes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscriptionTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscriptiontype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case subscriptiontype.EdgeChildSubscriptionTypes:
		ids := make([]ent.Value, 0, len(m.removedchild_subscription_types))
		for id := range m.removedchild_subscription_types {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscriptionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, subscriptiontype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, subscriptiontype.EdgeChildren)
	}
	if m.clearedchild_subscription_types {
		edges = append(edges, subscriptiontype.EdgeChildSubscriptionTypes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscriptionTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case subscriptiontype.EdgeParent:
		return m.clearedparent
	case subscriptiontype.EdgeChildren:
		return m.clearedchildren
	case subscriptiontype.EdgeChildSubscriptionTypes:
		return m.clearedchild_subscription_types
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscriptionTypeMutation) ClearEdge(name string) error {
	switch name {
	case subscriptiontype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscriptionTypeMutation) ResetEdge(name string) error {
	switch name {
	case subscriptiontype.EdgeParent:
		m.ResetParent()
		return nil
	case subscriptiontype.EdgeChildren:
		m.ResetChildren()
		return nil
	case subscriptiontype.EdgeChildSubscriptionTypes:
		m.ResetChildSubscriptionTypes()
		return nil
	}
	return fmt.Errorf("unknown SubscriptionType edge %s", name)
}

// SupplierPrefOrderMutation represents an operation that mutates the SupplierPrefOrder nodes in the graph.
type SupplierPrefOrderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SupplierPrefOrder, error)
	predicates    []predicate.SupplierPrefOrder
}

var _ ent.Mutation = (*SupplierPrefOrderMutation)(nil)

// supplierpreforderOption allows management of the mutation configuration using functional options.
type supplierpreforderOption func(*SupplierPrefOrderMutation)

// newSupplierPrefOrderMutation creates new mutation for the SupplierPrefOrder entity.
func newSupplierPrefOrderMutation(c config, op Op, opts ...supplierpreforderOption) *SupplierPrefOrderMutation {
	m := &SupplierPrefOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeSupplierPrefOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSupplierPrefOrderID sets the ID field of the mutation.
func withSupplierPrefOrderID(id int) supplierpreforderOption {
	return func(m *SupplierPrefOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *SupplierPrefOrder
		)
		m.oldValue = func(ctx context.Context) (*SupplierPrefOrder, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SupplierPrefOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSupplierPrefOrder sets the old SupplierPrefOrder of the mutation.
func withSupplierPrefOrder(node *SupplierPrefOrder) supplierpreforderOption {
	return func(m *SupplierPrefOrderMutation) {
		m.oldValue = func(context.Context) (*SupplierPrefOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SupplierPrefOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SupplierPrefOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SupplierPrefOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SupplierPrefOrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SupplierPrefOrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SupplierPrefOrder entity.
// If the SupplierPrefOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierPrefOrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SupplierPrefOrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SupplierPrefOrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SupplierPrefOrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SupplierPrefOrder entity.
// If the SupplierPrefOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierPrefOrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SupplierPrefOrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *SupplierPrefOrderMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *SupplierPrefOrderMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the SupplierPrefOrder entity.
// If the SupplierPrefOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierPrefOrderMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *SupplierPrefOrderMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[supplierpreforder.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *SupplierPrefOrderMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[supplierpreforder.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *SupplierPrefOrderMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, supplierpreforder.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *SupplierPrefOrderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SupplierPrefOrderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SupplierPrefOrder entity.
// If the SupplierPrefOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SupplierPrefOrderMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SupplierPrefOrderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[supplierpreforder.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SupplierPrefOrderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[supplierpreforder.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SupplierPrefOrderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, supplierpreforder.FieldDescription)
}

// Op returns the operation name.
func (m *SupplierPrefOrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SupplierPrefOrder).
func (m *SupplierPrefOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SupplierPrefOrderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, supplierpreforder.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, supplierpreforder.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, supplierpreforder.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, supplierpreforder.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SupplierPrefOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case supplierpreforder.FieldCreateTime:
		return m.CreateTime()
	case supplierpreforder.FieldUpdateTime:
		return m.UpdateTime()
	case supplierpreforder.FieldStringRef:
		return m.StringRef()
	case supplierpreforder.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SupplierPrefOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case supplierpreforder.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case supplierpreforder.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case supplierpreforder.FieldStringRef:
		return m.OldStringRef(ctx)
	case supplierpreforder.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SupplierPrefOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierPrefOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case supplierpreforder.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case supplierpreforder.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case supplierpreforder.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case supplierpreforder.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SupplierPrefOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SupplierPrefOrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SupplierPrefOrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SupplierPrefOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SupplierPrefOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SupplierPrefOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(supplierpreforder.FieldStringRef) {
		fields = append(fields, supplierpreforder.FieldStringRef)
	}
	if m.FieldCleared(supplierpreforder.FieldDescription) {
		fields = append(fields, supplierpreforder.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SupplierPrefOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SupplierPrefOrderMutation) ClearField(name string) error {
	switch name {
	case supplierpreforder.FieldStringRef:
		m.ClearStringRef()
		return nil
	case supplierpreforder.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SupplierPrefOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SupplierPrefOrderMutation) ResetField(name string) error {
	switch name {
	case supplierpreforder.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case supplierpreforder.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case supplierpreforder.FieldStringRef:
		m.ResetStringRef()
		return nil
	case supplierpreforder.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SupplierPrefOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SupplierPrefOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SupplierPrefOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SupplierPrefOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SupplierPrefOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SupplierPrefOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SupplierPrefOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SupplierPrefOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SupplierPrefOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SupplierPrefOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SupplierPrefOrder edge %s", name)
}

// VarianceReasonMutation represents an operation that mutates the VarianceReason nodes in the graph.
type VarianceReasonMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	string_ref    *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VarianceReason, error)
	predicates    []predicate.VarianceReason
}

var _ ent.Mutation = (*VarianceReasonMutation)(nil)

// variancereasonOption allows management of the mutation configuration using functional options.
type variancereasonOption func(*VarianceReasonMutation)

// newVarianceReasonMutation creates new mutation for the VarianceReason entity.
func newVarianceReasonMutation(c config, op Op, opts ...variancereasonOption) *VarianceReasonMutation {
	m := &VarianceReasonMutation{
		config:        c,
		op:            op,
		typ:           TypeVarianceReason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVarianceReasonID sets the ID field of the mutation.
func withVarianceReasonID(id int) variancereasonOption {
	return func(m *VarianceReasonMutation) {
		var (
			err   error
			once  sync.Once
			value *VarianceReason
		)
		m.oldValue = func(ctx context.Context) (*VarianceReason, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VarianceReason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVarianceReason sets the old VarianceReason of the mutation.
func withVarianceReason(node *VarianceReason) variancereasonOption {
	return func(m *VarianceReasonMutation) {
		m.oldValue = func(context.Context) (*VarianceReason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VarianceReasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VarianceReasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VarianceReasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *VarianceReasonMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VarianceReasonMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the VarianceReason entity.
// If the VarianceReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarianceReasonMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VarianceReasonMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *VarianceReasonMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VarianceReasonMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the VarianceReason entity.
// If the VarianceReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarianceReasonMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VarianceReasonMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStringRef sets the "string_ref" field.
func (m *VarianceReasonMutation) SetStringRef(s string) {
	m.string_ref = &s
}

// StringRef returns the value of the "string_ref" field in the mutation.
func (m *VarianceReasonMutation) StringRef() (r string, exists bool) {
	v := m.string_ref
	if v == nil {
		return
	}
	return *v, true
}

// OldStringRef returns the old "string_ref" field's value of the VarianceReason entity.
// If the VarianceReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarianceReasonMutation) OldStringRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringRef: %w", err)
	}
	return oldValue.StringRef, nil
}

// ClearStringRef clears the value of the "string_ref" field.
func (m *VarianceReasonMutation) ClearStringRef() {
	m.string_ref = nil
	m.clearedFields[variancereason.FieldStringRef] = struct{}{}
}

// StringRefCleared returns if the "string_ref" field was cleared in this mutation.
func (m *VarianceReasonMutation) StringRefCleared() bool {
	_, ok := m.clearedFields[variancereason.FieldStringRef]
	return ok
}

// ResetStringRef resets all changes to the "string_ref" field.
func (m *VarianceReasonMutation) ResetStringRef() {
	m.string_ref = nil
	delete(m.clearedFields, variancereason.FieldStringRef)
}

// SetDescription sets the "description" field.
func (m *VarianceReasonMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VarianceReasonMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the VarianceReason entity.
// If the VarianceReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarianceReasonMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VarianceReasonMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[variancereason.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VarianceReasonMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[variancereason.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VarianceReasonMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, variancereason.FieldDescription)
}

// Op returns the operation name.
func (m *VarianceReasonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VarianceReason).
func (m *VarianceReasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VarianceReasonMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, variancereason.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, variancereason.FieldUpdateTime)
	}
	if m.string_ref != nil {
		fields = append(fields, variancereason.FieldStringRef)
	}
	if m.description != nil {
		fields = append(fields, variancereason.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VarianceReasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case variancereason.FieldCreateTime:
		return m.CreateTime()
	case variancereason.FieldUpdateTime:
		return m.UpdateTime()
	case variancereason.FieldStringRef:
		return m.StringRef()
	case variancereason.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VarianceReasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case variancereason.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case variancereason.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case variancereason.FieldStringRef:
		return m.OldStringRef(ctx)
	case variancereason.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown VarianceReason field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarianceReasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case variancereason.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case variancereason.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case variancereason.FieldStringRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringRef(v)
		return nil
	case variancereason.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown VarianceReason field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VarianceReasonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VarianceReasonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarianceReasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VarianceReason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VarianceReasonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(variancereason.FieldStringRef) {
		fields = append(fields, variancereason.FieldStringRef)
	}
	if m.FieldCleared(variancereason.FieldDescription) {
		fields = append(fields, variancereason.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VarianceReasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VarianceReasonMutation) ClearField(name string) error {
	switch name {
	case variancereason.FieldStringRef:
		m.ClearStringRef()
		return nil
	case variancereason.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown VarianceReason nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VarianceReasonMutation) ResetField(name string) error {
	switch name {
	case variancereason.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case variancereason.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case variancereason.FieldStringRef:
		m.ResetStringRef()
		return nil
	case variancereason.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown VarianceReason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VarianceReasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VarianceReasonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VarianceReasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VarianceReasonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VarianceReasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VarianceReasonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VarianceReasonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VarianceReason unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VarianceReasonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VarianceReason edge %s", name)
}
