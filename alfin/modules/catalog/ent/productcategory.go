// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productcategory"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/productcategorytype"
)

// ProductCategory is the model entity for the ProductCategory schema.
type ProductCategory struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// StringRef holds the value of the "string_ref" field.
	StringRef string `json:"string_ref,omitempty"`
	// CategoryName holds the value of the "category_name" field.
	CategoryName string `json:"category_name,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// LongDescription holds the value of the "long_description" field.
	LongDescription string `json:"long_description,omitempty"`
	// CategoryImageURL holds the value of the "category_image_url" field.
	CategoryImageURL string `json:"category_image_url,omitempty"`
	// LinkOneImageURL holds the value of the "link_one_image_url" field.
	LinkOneImageURL string `json:"link_one_image_url,omitempty"`
	// LinkTwoImageURL holds the value of the "link_two_image_url" field.
	LinkTwoImageURL string `json:"link_two_image_url,omitempty"`
	// DetailScreen holds the value of the "detail_screen" field.
	DetailScreen string `json:"detail_screen,omitempty"`
	// ShowInSelect holds the value of the "show_in_select" field.
	ShowInSelect productcategory.ShowInSelect `json:"show_in_select,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ProductCategoryQuery when eager-loading is set.
	Edges                                    ProductCategoryEdges `json:"edges"`
	product_category_children                *int
	product_category_type_product_categories *int
}

// ProductCategoryEdges holds the relations/edges for other nodes in the graph.
type ProductCategoryEdges struct {
	// ProductCategoryType holds the value of the product_category_type edge.
	ProductCategoryType *ProductCategoryType `json:"product_category_type,omitempty"`
	// Parent holds the value of the parent edge.
	Parent *ProductCategory `json:"parent,omitempty"`
	// Children holds the value of the children edge.
	Children []*ProductCategory `json:"children,omitempty"`
	// PrimaryChildProductCategories holds the value of the primary_child_product_categories edge.
	PrimaryChildProductCategories []*ProductCategory `json:"primary_child_product_categories,omitempty"`
	// PrimaryProducts holds the value of the primary_products edge.
	PrimaryProducts []*Product `json:"primary_products,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// ProductCategoryTypeOrErr returns the ProductCategoryType value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ProductCategoryEdges) ProductCategoryTypeOrErr() (*ProductCategoryType, error) {
	if e.loadedTypes[0] {
		if e.ProductCategoryType == nil {
			// The edge product_category_type was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: productcategorytype.Label}
		}
		return e.ProductCategoryType, nil
	}
	return nil, &NotLoadedError{edge: "product_category_type"}
}

// ParentOrErr returns the Parent value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ProductCategoryEdges) ParentOrErr() (*ProductCategory, error) {
	if e.loadedTypes[1] {
		if e.Parent == nil {
			// The edge parent was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: productcategory.Label}
		}
		return e.Parent, nil
	}
	return nil, &NotLoadedError{edge: "parent"}
}

// ChildrenOrErr returns the Children value or an error if the edge
// was not loaded in eager-loading.
func (e ProductCategoryEdges) ChildrenOrErr() ([]*ProductCategory, error) {
	if e.loadedTypes[2] {
		return e.Children, nil
	}
	return nil, &NotLoadedError{edge: "children"}
}

// PrimaryChildProductCategoriesOrErr returns the PrimaryChildProductCategories value or an error if the edge
// was not loaded in eager-loading.
func (e ProductCategoryEdges) PrimaryChildProductCategoriesOrErr() ([]*ProductCategory, error) {
	if e.loadedTypes[3] {
		return e.PrimaryChildProductCategories, nil
	}
	return nil, &NotLoadedError{edge: "primary_child_product_categories"}
}

// PrimaryProductsOrErr returns the PrimaryProducts value or an error if the edge
// was not loaded in eager-loading.
func (e ProductCategoryEdges) PrimaryProductsOrErr() ([]*Product, error) {
	if e.loadedTypes[4] {
		return e.PrimaryProducts, nil
	}
	return nil, &NotLoadedError{edge: "primary_products"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ProductCategory) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case productcategory.FieldID:
			values[i] = new(sql.NullInt64)
		case productcategory.FieldStringRef, productcategory.FieldCategoryName, productcategory.FieldDescription, productcategory.FieldLongDescription, productcategory.FieldCategoryImageURL, productcategory.FieldLinkOneImageURL, productcategory.FieldLinkTwoImageURL, productcategory.FieldDetailScreen, productcategory.FieldShowInSelect:
			values[i] = new(sql.NullString)
		case productcategory.FieldCreateTime, productcategory.FieldUpdateTime:
			values[i] = new(sql.NullTime)
		case productcategory.ForeignKeys[0]: // product_category_children
			values[i] = new(sql.NullInt64)
		case productcategory.ForeignKeys[1]: // product_category_type_product_categories
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ProductCategory", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ProductCategory fields.
func (pc *ProductCategory) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case productcategory.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pc.ID = int(value.Int64)
		case productcategory.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				pc.CreateTime = value.Time
			}
		case productcategory.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				pc.UpdateTime = value.Time
			}
		case productcategory.FieldStringRef:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field string_ref", values[i])
			} else if value.Valid {
				pc.StringRef = value.String
			}
		case productcategory.FieldCategoryName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field category_name", values[i])
			} else if value.Valid {
				pc.CategoryName = value.String
			}
		case productcategory.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				pc.Description = value.String
			}
		case productcategory.FieldLongDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field long_description", values[i])
			} else if value.Valid {
				pc.LongDescription = value.String
			}
		case productcategory.FieldCategoryImageURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field category_image_url", values[i])
			} else if value.Valid {
				pc.CategoryImageURL = value.String
			}
		case productcategory.FieldLinkOneImageURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field link_one_image_url", values[i])
			} else if value.Valid {
				pc.LinkOneImageURL = value.String
			}
		case productcategory.FieldLinkTwoImageURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field link_two_image_url", values[i])
			} else if value.Valid {
				pc.LinkTwoImageURL = value.String
			}
		case productcategory.FieldDetailScreen:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field detail_screen", values[i])
			} else if value.Valid {
				pc.DetailScreen = value.String
			}
		case productcategory.FieldShowInSelect:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field show_in_select", values[i])
			} else if value.Valid {
				pc.ShowInSelect = productcategory.ShowInSelect(value.String)
			}
		case productcategory.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field product_category_children", value)
			} else if value.Valid {
				pc.product_category_children = new(int)
				*pc.product_category_children = int(value.Int64)
			}
		case productcategory.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field product_category_type_product_categories", value)
			} else if value.Valid {
				pc.product_category_type_product_categories = new(int)
				*pc.product_category_type_product_categories = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryProductCategoryType queries the "product_category_type" edge of the ProductCategory entity.
func (pc *ProductCategory) QueryProductCategoryType() *ProductCategoryTypeQuery {
	return (&ProductCategoryClient{config: pc.config}).QueryProductCategoryType(pc)
}

// QueryParent queries the "parent" edge of the ProductCategory entity.
func (pc *ProductCategory) QueryParent() *ProductCategoryQuery {
	return (&ProductCategoryClient{config: pc.config}).QueryParent(pc)
}

// QueryChildren queries the "children" edge of the ProductCategory entity.
func (pc *ProductCategory) QueryChildren() *ProductCategoryQuery {
	return (&ProductCategoryClient{config: pc.config}).QueryChildren(pc)
}

// QueryPrimaryChildProductCategories queries the "primary_child_product_categories" edge of the ProductCategory entity.
func (pc *ProductCategory) QueryPrimaryChildProductCategories() *ProductCategoryQuery {
	return (&ProductCategoryClient{config: pc.config}).QueryPrimaryChildProductCategories(pc)
}

// QueryPrimaryProducts queries the "primary_products" edge of the ProductCategory entity.
func (pc *ProductCategory) QueryPrimaryProducts() *ProductQuery {
	return (&ProductCategoryClient{config: pc.config}).QueryPrimaryProducts(pc)
}

// Update returns a builder for updating this ProductCategory.
// Note that you need to call ProductCategory.Unwrap() before calling this method if this ProductCategory
// was returned from a transaction, and the transaction was committed or rolled back.
func (pc *ProductCategory) Update() *ProductCategoryUpdateOne {
	return (&ProductCategoryClient{config: pc.config}).UpdateOne(pc)
}

// Unwrap unwraps the ProductCategory entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pc *ProductCategory) Unwrap() *ProductCategory {
	tx, ok := pc.config.driver.(*txDriver)
	if !ok {
		panic("ent: ProductCategory is not a transactional entity")
	}
	pc.config.driver = tx.drv
	return pc
}

// String implements the fmt.Stringer.
func (pc *ProductCategory) String() string {
	var builder strings.Builder
	builder.WriteString("ProductCategory(")
	builder.WriteString(fmt.Sprintf("id=%v", pc.ID))
	builder.WriteString(", create_time=")
	builder.WriteString(pc.CreateTime.Format(time.ANSIC))
	builder.WriteString(", update_time=")
	builder.WriteString(pc.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", string_ref=")
	builder.WriteString(pc.StringRef)
	builder.WriteString(", category_name=")
	builder.WriteString(pc.CategoryName)
	builder.WriteString(", description=")
	builder.WriteString(pc.Description)
	builder.WriteString(", long_description=")
	builder.WriteString(pc.LongDescription)
	builder.WriteString(", category_image_url=")
	builder.WriteString(pc.CategoryImageURL)
	builder.WriteString(", link_one_image_url=")
	builder.WriteString(pc.LinkOneImageURL)
	builder.WriteString(", link_two_image_url=")
	builder.WriteString(pc.LinkTwoImageURL)
	builder.WriteString(", detail_screen=")
	builder.WriteString(pc.DetailScreen)
	builder.WriteString(", show_in_select=")
	builder.WriteString(fmt.Sprintf("%v", pc.ShowInSelect))
	builder.WriteByte(')')
	return builder.String()
}

// ProductCategories is a parsable slice of ProductCategory.
type ProductCategories []*ProductCategory

func (pc ProductCategories) config(cfg config) {
	for _i := range pc {
		pc[_i].config = cfg
	}
}
