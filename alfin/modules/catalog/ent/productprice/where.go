// Code generated by entc, DO NOT EDIT.

package productprice

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/samlet/petrel/alfin/modules/catalog/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// StringRef applies equality check predicate on the "string_ref" field. It's identical to StringRefEQ.
func StringRef(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStringRef), v))
	})
}

// CurrencyUomID applies equality check predicate on the "currency_uom_id" field. It's identical to CurrencyUomIDEQ.
func CurrencyUomID(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCurrencyUomID), v))
	})
}

// FromDate applies equality check predicate on the "from_date" field. It's identical to FromDateEQ.
func FromDate(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromDate), v))
	})
}

// ThruDate applies equality check predicate on the "thru_date" field. It's identical to ThruDateEQ.
func ThruDate(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldThruDate), v))
	})
}

// Price applies equality check predicate on the "price" field. It's identical to PriceEQ.
func Price(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPrice), v))
	})
}

// TermUomID applies equality check predicate on the "term_uom_id" field. It's identical to TermUomIDEQ.
func TermUomID(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTermUomID), v))
	})
}

// PriceWithoutTax applies equality check predicate on the "price_without_tax" field. It's identical to PriceWithoutTaxEQ.
func PriceWithoutTax(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithTax applies equality check predicate on the "price_with_tax" field. It's identical to PriceWithTaxEQ.
func PriceWithTax(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPriceWithTax), v))
	})
}

// TaxAmount applies equality check predicate on the "tax_amount" field. It's identical to TaxAmountEQ.
func TaxAmount(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxAmount), v))
	})
}

// TaxPercentage applies equality check predicate on the "tax_percentage" field. It's identical to TaxPercentageEQ.
func TaxPercentage(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxPercentage), v))
	})
}

// TaxAuthPartyID applies equality check predicate on the "tax_auth_party_id" field. It's identical to TaxAuthPartyIDEQ.
func TaxAuthPartyID(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthGeoID applies equality check predicate on the "tax_auth_geo_id" field. It's identical to TaxAuthGeoIDEQ.
func TaxAuthGeoID(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxAuthGeoID), v))
	})
}

// CreatedDate applies equality check predicate on the "created_date" field. It's identical to CreatedDateEQ.
func CreatedDate(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedDate), v))
	})
}

// CreatedByUserLogin applies equality check predicate on the "created_by_user_login" field. It's identical to CreatedByUserLoginEQ.
func CreatedByUserLogin(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedByUserLogin), v))
	})
}

// LastModifiedDate applies equality check predicate on the "last_modified_date" field. It's identical to LastModifiedDateEQ.
func LastModifiedDate(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedByUserLogin applies equality check predicate on the "last_modified_by_user_login" field. It's identical to LastModifiedByUserLoginEQ.
func LastModifiedByUserLogin(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), v))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), v))
	})
}

// StringRefEQ applies the EQ predicate on the "string_ref" field.
func StringRefEQ(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStringRef), v))
	})
}

// StringRefNEQ applies the NEQ predicate on the "string_ref" field.
func StringRefNEQ(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStringRef), v))
	})
}

// StringRefIn applies the In predicate on the "string_ref" field.
func StringRefIn(vs ...string) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStringRef), v...))
	})
}

// StringRefNotIn applies the NotIn predicate on the "string_ref" field.
func StringRefNotIn(vs ...string) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStringRef), v...))
	})
}

// StringRefGT applies the GT predicate on the "string_ref" field.
func StringRefGT(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStringRef), v))
	})
}

// StringRefGTE applies the GTE predicate on the "string_ref" field.
func StringRefGTE(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStringRef), v))
	})
}

// StringRefLT applies the LT predicate on the "string_ref" field.
func StringRefLT(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStringRef), v))
	})
}

// StringRefLTE applies the LTE predicate on the "string_ref" field.
func StringRefLTE(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStringRef), v))
	})
}

// StringRefContains applies the Contains predicate on the "string_ref" field.
func StringRefContains(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldStringRef), v))
	})
}

// StringRefHasPrefix applies the HasPrefix predicate on the "string_ref" field.
func StringRefHasPrefix(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldStringRef), v))
	})
}

// StringRefHasSuffix applies the HasSuffix predicate on the "string_ref" field.
func StringRefHasSuffix(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldStringRef), v))
	})
}

// StringRefIsNil applies the IsNil predicate on the "string_ref" field.
func StringRefIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStringRef)))
	})
}

// StringRefNotNil applies the NotNil predicate on the "string_ref" field.
func StringRefNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStringRef)))
	})
}

// StringRefEqualFold applies the EqualFold predicate on the "string_ref" field.
func StringRefEqualFold(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldStringRef), v))
	})
}

// StringRefContainsFold applies the ContainsFold predicate on the "string_ref" field.
func StringRefContainsFold(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldStringRef), v))
	})
}

// CurrencyUomIDEQ applies the EQ predicate on the "currency_uom_id" field.
func CurrencyUomIDEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDNEQ applies the NEQ predicate on the "currency_uom_id" field.
func CurrencyUomIDNEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDIn applies the In predicate on the "currency_uom_id" field.
func CurrencyUomIDIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCurrencyUomID), v...))
	})
}

// CurrencyUomIDNotIn applies the NotIn predicate on the "currency_uom_id" field.
func CurrencyUomIDNotIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCurrencyUomID), v...))
	})
}

// CurrencyUomIDGT applies the GT predicate on the "currency_uom_id" field.
func CurrencyUomIDGT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDGTE applies the GTE predicate on the "currency_uom_id" field.
func CurrencyUomIDGTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDLT applies the LT predicate on the "currency_uom_id" field.
func CurrencyUomIDLT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDLTE applies the LTE predicate on the "currency_uom_id" field.
func CurrencyUomIDLTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCurrencyUomID), v))
	})
}

// FromDateEQ applies the EQ predicate on the "from_date" field.
func FromDateEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromDate), v))
	})
}

// FromDateNEQ applies the NEQ predicate on the "from_date" field.
func FromDateNEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFromDate), v))
	})
}

// FromDateIn applies the In predicate on the "from_date" field.
func FromDateIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFromDate), v...))
	})
}

// FromDateNotIn applies the NotIn predicate on the "from_date" field.
func FromDateNotIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFromDate), v...))
	})
}

// FromDateGT applies the GT predicate on the "from_date" field.
func FromDateGT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFromDate), v))
	})
}

// FromDateGTE applies the GTE predicate on the "from_date" field.
func FromDateGTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFromDate), v))
	})
}

// FromDateLT applies the LT predicate on the "from_date" field.
func FromDateLT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFromDate), v))
	})
}

// FromDateLTE applies the LTE predicate on the "from_date" field.
func FromDateLTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFromDate), v))
	})
}

// ThruDateEQ applies the EQ predicate on the "thru_date" field.
func ThruDateEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldThruDate), v))
	})
}

// ThruDateNEQ applies the NEQ predicate on the "thru_date" field.
func ThruDateNEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldThruDate), v))
	})
}

// ThruDateIn applies the In predicate on the "thru_date" field.
func ThruDateIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldThruDate), v...))
	})
}

// ThruDateNotIn applies the NotIn predicate on the "thru_date" field.
func ThruDateNotIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldThruDate), v...))
	})
}

// ThruDateGT applies the GT predicate on the "thru_date" field.
func ThruDateGT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldThruDate), v))
	})
}

// ThruDateGTE applies the GTE predicate on the "thru_date" field.
func ThruDateGTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldThruDate), v))
	})
}

// ThruDateLT applies the LT predicate on the "thru_date" field.
func ThruDateLT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldThruDate), v))
	})
}

// ThruDateLTE applies the LTE predicate on the "thru_date" field.
func ThruDateLTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldThruDate), v))
	})
}

// ThruDateIsNil applies the IsNil predicate on the "thru_date" field.
func ThruDateIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldThruDate)))
	})
}

// ThruDateNotNil applies the NotNil predicate on the "thru_date" field.
func ThruDateNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldThruDate)))
	})
}

// PriceEQ applies the EQ predicate on the "price" field.
func PriceEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPrice), v))
	})
}

// PriceNEQ applies the NEQ predicate on the "price" field.
func PriceNEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPrice), v))
	})
}

// PriceIn applies the In predicate on the "price" field.
func PriceIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPrice), v...))
	})
}

// PriceNotIn applies the NotIn predicate on the "price" field.
func PriceNotIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPrice), v...))
	})
}

// PriceGT applies the GT predicate on the "price" field.
func PriceGT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPrice), v))
	})
}

// PriceGTE applies the GTE predicate on the "price" field.
func PriceGTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPrice), v))
	})
}

// PriceLT applies the LT predicate on the "price" field.
func PriceLT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPrice), v))
	})
}

// PriceLTE applies the LTE predicate on the "price" field.
func PriceLTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPrice), v))
	})
}

// PriceIsNil applies the IsNil predicate on the "price" field.
func PriceIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPrice)))
	})
}

// PriceNotNil applies the NotNil predicate on the "price" field.
func PriceNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPrice)))
	})
}

// TermUomIDEQ applies the EQ predicate on the "term_uom_id" field.
func TermUomIDEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTermUomID), v))
	})
}

// TermUomIDNEQ applies the NEQ predicate on the "term_uom_id" field.
func TermUomIDNEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTermUomID), v))
	})
}

// TermUomIDIn applies the In predicate on the "term_uom_id" field.
func TermUomIDIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTermUomID), v...))
	})
}

// TermUomIDNotIn applies the NotIn predicate on the "term_uom_id" field.
func TermUomIDNotIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTermUomID), v...))
	})
}

// TermUomIDGT applies the GT predicate on the "term_uom_id" field.
func TermUomIDGT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTermUomID), v))
	})
}

// TermUomIDGTE applies the GTE predicate on the "term_uom_id" field.
func TermUomIDGTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTermUomID), v))
	})
}

// TermUomIDLT applies the LT predicate on the "term_uom_id" field.
func TermUomIDLT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTermUomID), v))
	})
}

// TermUomIDLTE applies the LTE predicate on the "term_uom_id" field.
func TermUomIDLTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTermUomID), v))
	})
}

// TermUomIDIsNil applies the IsNil predicate on the "term_uom_id" field.
func TermUomIDIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTermUomID)))
	})
}

// TermUomIDNotNil applies the NotNil predicate on the "term_uom_id" field.
func TermUomIDNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTermUomID)))
	})
}

// PriceWithoutTaxEQ applies the EQ predicate on the "price_without_tax" field.
func PriceWithoutTaxEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithoutTaxNEQ applies the NEQ predicate on the "price_without_tax" field.
func PriceWithoutTaxNEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithoutTaxIn applies the In predicate on the "price_without_tax" field.
func PriceWithoutTaxIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPriceWithoutTax), v...))
	})
}

// PriceWithoutTaxNotIn applies the NotIn predicate on the "price_without_tax" field.
func PriceWithoutTaxNotIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPriceWithoutTax), v...))
	})
}

// PriceWithoutTaxGT applies the GT predicate on the "price_without_tax" field.
func PriceWithoutTaxGT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithoutTaxGTE applies the GTE predicate on the "price_without_tax" field.
func PriceWithoutTaxGTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithoutTaxLT applies the LT predicate on the "price_without_tax" field.
func PriceWithoutTaxLT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithoutTaxLTE applies the LTE predicate on the "price_without_tax" field.
func PriceWithoutTaxLTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPriceWithoutTax), v))
	})
}

// PriceWithoutTaxIsNil applies the IsNil predicate on the "price_without_tax" field.
func PriceWithoutTaxIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPriceWithoutTax)))
	})
}

// PriceWithoutTaxNotNil applies the NotNil predicate on the "price_without_tax" field.
func PriceWithoutTaxNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPriceWithoutTax)))
	})
}

// PriceWithTaxEQ applies the EQ predicate on the "price_with_tax" field.
func PriceWithTaxEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPriceWithTax), v))
	})
}

// PriceWithTaxNEQ applies the NEQ predicate on the "price_with_tax" field.
func PriceWithTaxNEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPriceWithTax), v))
	})
}

// PriceWithTaxIn applies the In predicate on the "price_with_tax" field.
func PriceWithTaxIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPriceWithTax), v...))
	})
}

// PriceWithTaxNotIn applies the NotIn predicate on the "price_with_tax" field.
func PriceWithTaxNotIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPriceWithTax), v...))
	})
}

// PriceWithTaxGT applies the GT predicate on the "price_with_tax" field.
func PriceWithTaxGT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPriceWithTax), v))
	})
}

// PriceWithTaxGTE applies the GTE predicate on the "price_with_tax" field.
func PriceWithTaxGTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPriceWithTax), v))
	})
}

// PriceWithTaxLT applies the LT predicate on the "price_with_tax" field.
func PriceWithTaxLT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPriceWithTax), v))
	})
}

// PriceWithTaxLTE applies the LTE predicate on the "price_with_tax" field.
func PriceWithTaxLTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPriceWithTax), v))
	})
}

// PriceWithTaxIsNil applies the IsNil predicate on the "price_with_tax" field.
func PriceWithTaxIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPriceWithTax)))
	})
}

// PriceWithTaxNotNil applies the NotNil predicate on the "price_with_tax" field.
func PriceWithTaxNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPriceWithTax)))
	})
}

// TaxAmountEQ applies the EQ predicate on the "tax_amount" field.
func TaxAmountEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxAmount), v))
	})
}

// TaxAmountNEQ applies the NEQ predicate on the "tax_amount" field.
func TaxAmountNEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTaxAmount), v))
	})
}

// TaxAmountIn applies the In predicate on the "tax_amount" field.
func TaxAmountIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTaxAmount), v...))
	})
}

// TaxAmountNotIn applies the NotIn predicate on the "tax_amount" field.
func TaxAmountNotIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTaxAmount), v...))
	})
}

// TaxAmountGT applies the GT predicate on the "tax_amount" field.
func TaxAmountGT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTaxAmount), v))
	})
}

// TaxAmountGTE applies the GTE predicate on the "tax_amount" field.
func TaxAmountGTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTaxAmount), v))
	})
}

// TaxAmountLT applies the LT predicate on the "tax_amount" field.
func TaxAmountLT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTaxAmount), v))
	})
}

// TaxAmountLTE applies the LTE predicate on the "tax_amount" field.
func TaxAmountLTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTaxAmount), v))
	})
}

// TaxAmountIsNil applies the IsNil predicate on the "tax_amount" field.
func TaxAmountIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTaxAmount)))
	})
}

// TaxAmountNotNil applies the NotNil predicate on the "tax_amount" field.
func TaxAmountNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTaxAmount)))
	})
}

// TaxPercentageEQ applies the EQ predicate on the "tax_percentage" field.
func TaxPercentageEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxPercentage), v))
	})
}

// TaxPercentageNEQ applies the NEQ predicate on the "tax_percentage" field.
func TaxPercentageNEQ(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTaxPercentage), v))
	})
}

// TaxPercentageIn applies the In predicate on the "tax_percentage" field.
func TaxPercentageIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTaxPercentage), v...))
	})
}

// TaxPercentageNotIn applies the NotIn predicate on the "tax_percentage" field.
func TaxPercentageNotIn(vs ...float64) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTaxPercentage), v...))
	})
}

// TaxPercentageGT applies the GT predicate on the "tax_percentage" field.
func TaxPercentageGT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTaxPercentage), v))
	})
}

// TaxPercentageGTE applies the GTE predicate on the "tax_percentage" field.
func TaxPercentageGTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTaxPercentage), v))
	})
}

// TaxPercentageLT applies the LT predicate on the "tax_percentage" field.
func TaxPercentageLT(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTaxPercentage), v))
	})
}

// TaxPercentageLTE applies the LTE predicate on the "tax_percentage" field.
func TaxPercentageLTE(v float64) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTaxPercentage), v))
	})
}

// TaxPercentageIsNil applies the IsNil predicate on the "tax_percentage" field.
func TaxPercentageIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTaxPercentage)))
	})
}

// TaxPercentageNotNil applies the NotNil predicate on the "tax_percentage" field.
func TaxPercentageNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTaxPercentage)))
	})
}

// TaxAuthPartyIDEQ applies the EQ predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthPartyIDNEQ applies the NEQ predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDNEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthPartyIDIn applies the In predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTaxAuthPartyID), v...))
	})
}

// TaxAuthPartyIDNotIn applies the NotIn predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDNotIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTaxAuthPartyID), v...))
	})
}

// TaxAuthPartyIDGT applies the GT predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDGT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthPartyIDGTE applies the GTE predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDGTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthPartyIDLT applies the LT predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDLT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthPartyIDLTE applies the LTE predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDLTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTaxAuthPartyID), v))
	})
}

// TaxAuthPartyIDIsNil applies the IsNil predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTaxAuthPartyID)))
	})
}

// TaxAuthPartyIDNotNil applies the NotNil predicate on the "tax_auth_party_id" field.
func TaxAuthPartyIDNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTaxAuthPartyID)))
	})
}

// TaxAuthGeoIDEQ applies the EQ predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxAuthGeoID), v))
	})
}

// TaxAuthGeoIDNEQ applies the NEQ predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDNEQ(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTaxAuthGeoID), v))
	})
}

// TaxAuthGeoIDIn applies the In predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTaxAuthGeoID), v...))
	})
}

// TaxAuthGeoIDNotIn applies the NotIn predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDNotIn(vs ...int) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTaxAuthGeoID), v...))
	})
}

// TaxAuthGeoIDGT applies the GT predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDGT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTaxAuthGeoID), v))
	})
}

// TaxAuthGeoIDGTE applies the GTE predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDGTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTaxAuthGeoID), v))
	})
}

// TaxAuthGeoIDLT applies the LT predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDLT(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTaxAuthGeoID), v))
	})
}

// TaxAuthGeoIDLTE applies the LTE predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDLTE(v int) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTaxAuthGeoID), v))
	})
}

// TaxAuthGeoIDIsNil applies the IsNil predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTaxAuthGeoID)))
	})
}

// TaxAuthGeoIDNotNil applies the NotNil predicate on the "tax_auth_geo_id" field.
func TaxAuthGeoIDNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTaxAuthGeoID)))
	})
}

// TaxInPriceEQ applies the EQ predicate on the "tax_in_price" field.
func TaxInPriceEQ(v TaxInPrice) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTaxInPrice), v))
	})
}

// TaxInPriceNEQ applies the NEQ predicate on the "tax_in_price" field.
func TaxInPriceNEQ(v TaxInPrice) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTaxInPrice), v))
	})
}

// TaxInPriceIn applies the In predicate on the "tax_in_price" field.
func TaxInPriceIn(vs ...TaxInPrice) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTaxInPrice), v...))
	})
}

// TaxInPriceNotIn applies the NotIn predicate on the "tax_in_price" field.
func TaxInPriceNotIn(vs ...TaxInPrice) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTaxInPrice), v...))
	})
}

// TaxInPriceIsNil applies the IsNil predicate on the "tax_in_price" field.
func TaxInPriceIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTaxInPrice)))
	})
}

// TaxInPriceNotNil applies the NotNil predicate on the "tax_in_price" field.
func TaxInPriceNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTaxInPrice)))
	})
}

// CreatedDateEQ applies the EQ predicate on the "created_date" field.
func CreatedDateEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateNEQ applies the NEQ predicate on the "created_date" field.
func CreatedDateNEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateIn applies the In predicate on the "created_date" field.
func CreatedDateIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedDate), v...))
	})
}

// CreatedDateNotIn applies the NotIn predicate on the "created_date" field.
func CreatedDateNotIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedDate), v...))
	})
}

// CreatedDateGT applies the GT predicate on the "created_date" field.
func CreatedDateGT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateGTE applies the GTE predicate on the "created_date" field.
func CreatedDateGTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateLT applies the LT predicate on the "created_date" field.
func CreatedDateLT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateLTE applies the LTE predicate on the "created_date" field.
func CreatedDateLTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedDate), v))
	})
}

// CreatedDateIsNil applies the IsNil predicate on the "created_date" field.
func CreatedDateIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreatedDate)))
	})
}

// CreatedDateNotNil applies the NotNil predicate on the "created_date" field.
func CreatedDateNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreatedDate)))
	})
}

// CreatedByUserLoginEQ applies the EQ predicate on the "created_by_user_login" field.
func CreatedByUserLoginEQ(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginNEQ applies the NEQ predicate on the "created_by_user_login" field.
func CreatedByUserLoginNEQ(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginIn applies the In predicate on the "created_by_user_login" field.
func CreatedByUserLoginIn(vs ...string) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedByUserLogin), v...))
	})
}

// CreatedByUserLoginNotIn applies the NotIn predicate on the "created_by_user_login" field.
func CreatedByUserLoginNotIn(vs ...string) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedByUserLogin), v...))
	})
}

// CreatedByUserLoginGT applies the GT predicate on the "created_by_user_login" field.
func CreatedByUserLoginGT(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginGTE applies the GTE predicate on the "created_by_user_login" field.
func CreatedByUserLoginGTE(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginLT applies the LT predicate on the "created_by_user_login" field.
func CreatedByUserLoginLT(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginLTE applies the LTE predicate on the "created_by_user_login" field.
func CreatedByUserLoginLTE(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginContains applies the Contains predicate on the "created_by_user_login" field.
func CreatedByUserLoginContains(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginHasPrefix applies the HasPrefix predicate on the "created_by_user_login" field.
func CreatedByUserLoginHasPrefix(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginHasSuffix applies the HasSuffix predicate on the "created_by_user_login" field.
func CreatedByUserLoginHasSuffix(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginIsNil applies the IsNil predicate on the "created_by_user_login" field.
func CreatedByUserLoginIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCreatedByUserLogin)))
	})
}

// CreatedByUserLoginNotNil applies the NotNil predicate on the "created_by_user_login" field.
func CreatedByUserLoginNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCreatedByUserLogin)))
	})
}

// CreatedByUserLoginEqualFold applies the EqualFold predicate on the "created_by_user_login" field.
func CreatedByUserLoginEqualFold(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCreatedByUserLogin), v))
	})
}

// CreatedByUserLoginContainsFold applies the ContainsFold predicate on the "created_by_user_login" field.
func CreatedByUserLoginContainsFold(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCreatedByUserLogin), v))
	})
}

// LastModifiedDateEQ applies the EQ predicate on the "last_modified_date" field.
func LastModifiedDateEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedDateNEQ applies the NEQ predicate on the "last_modified_date" field.
func LastModifiedDateNEQ(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedDateIn applies the In predicate on the "last_modified_date" field.
func LastModifiedDateIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastModifiedDate), v...))
	})
}

// LastModifiedDateNotIn applies the NotIn predicate on the "last_modified_date" field.
func LastModifiedDateNotIn(vs ...time.Time) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastModifiedDate), v...))
	})
}

// LastModifiedDateGT applies the GT predicate on the "last_modified_date" field.
func LastModifiedDateGT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedDateGTE applies the GTE predicate on the "last_modified_date" field.
func LastModifiedDateGTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedDateLT applies the LT predicate on the "last_modified_date" field.
func LastModifiedDateLT(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedDateLTE applies the LTE predicate on the "last_modified_date" field.
func LastModifiedDateLTE(v time.Time) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastModifiedDate), v))
	})
}

// LastModifiedDateIsNil applies the IsNil predicate on the "last_modified_date" field.
func LastModifiedDateIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastModifiedDate)))
	})
}

// LastModifiedDateNotNil applies the NotNil predicate on the "last_modified_date" field.
func LastModifiedDateNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastModifiedDate)))
	})
}

// LastModifiedByUserLoginEQ applies the EQ predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginEQ(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginNEQ applies the NEQ predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginNEQ(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginIn applies the In predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginIn(vs ...string) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastModifiedByUserLogin), v...))
	})
}

// LastModifiedByUserLoginNotIn applies the NotIn predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginNotIn(vs ...string) predicate.ProductPrice {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.ProductPrice(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastModifiedByUserLogin), v...))
	})
}

// LastModifiedByUserLoginGT applies the GT predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginGT(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginGTE applies the GTE predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginGTE(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginLT applies the LT predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginLT(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginLTE applies the LTE predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginLTE(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginContains applies the Contains predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginContains(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginHasPrefix applies the HasPrefix predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginHasPrefix(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginHasSuffix applies the HasSuffix predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginHasSuffix(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginIsNil applies the IsNil predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginIsNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastModifiedByUserLogin)))
	})
}

// LastModifiedByUserLoginNotNil applies the NotNil predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginNotNil() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastModifiedByUserLogin)))
	})
}

// LastModifiedByUserLoginEqualFold applies the EqualFold predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginEqualFold(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// LastModifiedByUserLoginContainsFold applies the ContainsFold predicate on the "last_modified_by_user_login" field.
func LastModifiedByUserLoginContainsFold(v string) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLastModifiedByUserLogin), v))
	})
}

// HasProduct applies the HasEdge predicate on the "product" edge.
func HasProduct() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductTable, ProductColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasProductWith applies the HasEdge predicate on the "product" edge with a given conditions (other predicates).
func HasProductWith(preds ...predicate.Product) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductTable, ProductColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasProductPriceType applies the HasEdge predicate on the "product_price_type" edge.
func HasProductPriceType() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductPriceTypeTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductPriceTypeTable, ProductPriceTypeColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasProductPriceTypeWith applies the HasEdge predicate on the "product_price_type" edge with a given conditions (other predicates).
func HasProductPriceTypeWith(preds ...predicate.ProductPriceType) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductPriceTypeInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductPriceTypeTable, ProductPriceTypeColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasProductPricePurpose applies the HasEdge predicate on the "product_price_purpose" edge.
func HasProductPricePurpose() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductPricePurposeTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductPricePurposeTable, ProductPricePurposeColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasProductPricePurposeWith applies the HasEdge predicate on the "product_price_purpose" edge with a given conditions (other predicates).
func HasProductPricePurposeWith(preds ...predicate.ProductPricePurpose) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductPricePurposeInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductPricePurposeTable, ProductPricePurposeColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasProductStoreGroup applies the HasEdge predicate on the "product_store_group" edge.
func HasProductStoreGroup() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductStoreGroupTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductStoreGroupTable, ProductStoreGroupColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasProductStoreGroupWith applies the HasEdge predicate on the "product_store_group" edge with a given conditions (other predicates).
func HasProductStoreGroupWith(preds ...predicate.ProductStoreGroup) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ProductStoreGroupInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ProductStoreGroupTable, ProductStoreGroupColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCustomMethod applies the HasEdge predicate on the "custom_method" edge.
func HasCustomMethod() predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CustomMethodTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CustomMethodTable, CustomMethodColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCustomMethodWith applies the HasEdge predicate on the "custom_method" edge with a given conditions (other predicates).
func HasCustomMethodWith(preds ...predicate.CustomMethod) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CustomMethodInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CustomMethodTable, CustomMethodColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.ProductPrice) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.ProductPrice) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.ProductPrice) predicate.ProductPrice {
	return predicate.ProductPrice(func(s *sql.Selector) {
		p(s.Not())
	})
}
