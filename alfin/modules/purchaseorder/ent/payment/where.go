// Code generated by entc, DO NOT EDIT.

package payment

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/samlet/petrel/alfin/modules/purchaseorder/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// PaymentTypeID applies equality check predicate on the "payment_type_id" field. It's identical to PaymentTypeIDEQ.
func PaymentTypeID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentMethodTypeID applies equality check predicate on the "payment_method_type_id" field. It's identical to PaymentMethodTypeIDEQ.
func PaymentMethodTypeID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodID applies equality check predicate on the "payment_method_id" field. It's identical to PaymentMethodIDEQ.
func PaymentMethodID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentGatewayResponseID applies equality check predicate on the "payment_gateway_response_id" field. It's identical to PaymentGatewayResponseIDEQ.
func PaymentGatewayResponseID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentPreferenceID applies equality check predicate on the "payment_preference_id" field. It's identical to PaymentPreferenceIDEQ.
func PaymentPreferenceID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentPreferenceID), v))
	})
}

// PartyIDFrom applies equality check predicate on the "party_id_from" field. It's identical to PartyIDFromEQ.
func PartyIDFrom(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDTo applies equality check predicate on the "party_id_to" field. It's identical to PartyIDToEQ.
func PartyIDTo(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPartyIDTo), v))
	})
}

// RoleTypeIDTo applies equality check predicate on the "role_type_id_to" field. It's identical to RoleTypeIDToEQ.
func RoleTypeIDTo(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoleTypeIDTo), v))
	})
}

// StatusID applies equality check predicate on the "status_id" field. It's identical to StatusIDEQ.
func StatusID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusID), v))
	})
}

// EffectiveDate applies equality check predicate on the "effective_date" field. It's identical to EffectiveDateEQ.
func EffectiveDate(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEffectiveDate), v))
	})
}

// PaymentRefNum applies equality check predicate on the "payment_ref_num" field. It's identical to PaymentRefNumEQ.
func PaymentRefNum(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentRefNum), v))
	})
}

// Amount applies equality check predicate on the "amount" field. It's identical to AmountEQ.
func Amount(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmount), v))
	})
}

// CurrencyUomID applies equality check predicate on the "currency_uom_id" field. It's identical to CurrencyUomIDEQ.
func CurrencyUomID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCurrencyUomID), v))
	})
}

// Comments applies equality check predicate on the "comments" field. It's identical to CommentsEQ.
func Comments(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldComments), v))
	})
}

// FinAccountTransID applies equality check predicate on the "fin_account_trans_id" field. It's identical to FinAccountTransIDEQ.
func FinAccountTransID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFinAccountTransID), v))
	})
}

// OverrideGlAccountID applies equality check predicate on the "override_gl_account_id" field. It's identical to OverrideGlAccountIDEQ.
func OverrideGlAccountID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOverrideGlAccountID), v))
	})
}

// ActualCurrencyAmount applies equality check predicate on the "actual_currency_amount" field. It's identical to ActualCurrencyAmountEQ.
func ActualCurrencyAmount(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyUomID applies equality check predicate on the "actual_currency_uom_id" field. It's identical to ActualCurrencyUomIDEQ.
func ActualCurrencyUomID(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActualCurrencyUomID), v))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), v))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...time.Time) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...time.Time) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), v))
	})
}

// PaymentTypeIDEQ applies the EQ predicate on the "payment_type_id" field.
func PaymentTypeIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentTypeIDNEQ applies the NEQ predicate on the "payment_type_id" field.
func PaymentTypeIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentTypeIDIn applies the In predicate on the "payment_type_id" field.
func PaymentTypeIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentTypeID), v...))
	})
}

// PaymentTypeIDNotIn applies the NotIn predicate on the "payment_type_id" field.
func PaymentTypeIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentTypeID), v...))
	})
}

// PaymentTypeIDGT applies the GT predicate on the "payment_type_id" field.
func PaymentTypeIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentTypeIDGTE applies the GTE predicate on the "payment_type_id" field.
func PaymentTypeIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentTypeIDLT applies the LT predicate on the "payment_type_id" field.
func PaymentTypeIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentTypeIDLTE applies the LTE predicate on the "payment_type_id" field.
func PaymentTypeIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentTypeID), v))
	})
}

// PaymentTypeIDIsNil applies the IsNil predicate on the "payment_type_id" field.
func PaymentTypeIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentTypeID)))
	})
}

// PaymentTypeIDNotNil applies the NotNil predicate on the "payment_type_id" field.
func PaymentTypeIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentTypeID)))
	})
}

// PaymentMethodTypeIDEQ applies the EQ predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodTypeIDNEQ applies the NEQ predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodTypeIDIn applies the In predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentMethodTypeID), v...))
	})
}

// PaymentMethodTypeIDNotIn applies the NotIn predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentMethodTypeID), v...))
	})
}

// PaymentMethodTypeIDGT applies the GT predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodTypeIDGTE applies the GTE predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodTypeIDLT applies the LT predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodTypeIDLTE applies the LTE predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentMethodTypeID), v))
	})
}

// PaymentMethodTypeIDIsNil applies the IsNil predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentMethodTypeID)))
	})
}

// PaymentMethodTypeIDNotNil applies the NotNil predicate on the "payment_method_type_id" field.
func PaymentMethodTypeIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentMethodTypeID)))
	})
}

// PaymentMethodIDEQ applies the EQ predicate on the "payment_method_id" field.
func PaymentMethodIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentMethodIDNEQ applies the NEQ predicate on the "payment_method_id" field.
func PaymentMethodIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentMethodIDIn applies the In predicate on the "payment_method_id" field.
func PaymentMethodIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentMethodID), v...))
	})
}

// PaymentMethodIDNotIn applies the NotIn predicate on the "payment_method_id" field.
func PaymentMethodIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentMethodID), v...))
	})
}

// PaymentMethodIDGT applies the GT predicate on the "payment_method_id" field.
func PaymentMethodIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentMethodIDGTE applies the GTE predicate on the "payment_method_id" field.
func PaymentMethodIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentMethodIDLT applies the LT predicate on the "payment_method_id" field.
func PaymentMethodIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentMethodIDLTE applies the LTE predicate on the "payment_method_id" field.
func PaymentMethodIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentMethodID), v))
	})
}

// PaymentMethodIDIsNil applies the IsNil predicate on the "payment_method_id" field.
func PaymentMethodIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentMethodID)))
	})
}

// PaymentMethodIDNotNil applies the NotNil predicate on the "payment_method_id" field.
func PaymentMethodIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentMethodID)))
	})
}

// PaymentGatewayResponseIDEQ applies the EQ predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentGatewayResponseIDNEQ applies the NEQ predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentGatewayResponseIDIn applies the In predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentGatewayResponseID), v...))
	})
}

// PaymentGatewayResponseIDNotIn applies the NotIn predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentGatewayResponseID), v...))
	})
}

// PaymentGatewayResponseIDGT applies the GT predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentGatewayResponseIDGTE applies the GTE predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentGatewayResponseIDLT applies the LT predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentGatewayResponseIDLTE applies the LTE predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentGatewayResponseID), v))
	})
}

// PaymentGatewayResponseIDIsNil applies the IsNil predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentGatewayResponseID)))
	})
}

// PaymentGatewayResponseIDNotNil applies the NotNil predicate on the "payment_gateway_response_id" field.
func PaymentGatewayResponseIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentGatewayResponseID)))
	})
}

// PaymentPreferenceIDEQ applies the EQ predicate on the "payment_preference_id" field.
func PaymentPreferenceIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentPreferenceID), v))
	})
}

// PaymentPreferenceIDNEQ applies the NEQ predicate on the "payment_preference_id" field.
func PaymentPreferenceIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentPreferenceID), v))
	})
}

// PaymentPreferenceIDIn applies the In predicate on the "payment_preference_id" field.
func PaymentPreferenceIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentPreferenceID), v...))
	})
}

// PaymentPreferenceIDNotIn applies the NotIn predicate on the "payment_preference_id" field.
func PaymentPreferenceIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentPreferenceID), v...))
	})
}

// PaymentPreferenceIDGT applies the GT predicate on the "payment_preference_id" field.
func PaymentPreferenceIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentPreferenceID), v))
	})
}

// PaymentPreferenceIDGTE applies the GTE predicate on the "payment_preference_id" field.
func PaymentPreferenceIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentPreferenceID), v))
	})
}

// PaymentPreferenceIDLT applies the LT predicate on the "payment_preference_id" field.
func PaymentPreferenceIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentPreferenceID), v))
	})
}

// PaymentPreferenceIDLTE applies the LTE predicate on the "payment_preference_id" field.
func PaymentPreferenceIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentPreferenceID), v))
	})
}

// PaymentPreferenceIDIsNil applies the IsNil predicate on the "payment_preference_id" field.
func PaymentPreferenceIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentPreferenceID)))
	})
}

// PaymentPreferenceIDNotNil applies the NotNil predicate on the "payment_preference_id" field.
func PaymentPreferenceIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentPreferenceID)))
	})
}

// PartyIDFromEQ applies the EQ predicate on the "party_id_from" field.
func PartyIDFromEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDFromNEQ applies the NEQ predicate on the "party_id_from" field.
func PartyIDFromNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDFromIn applies the In predicate on the "party_id_from" field.
func PartyIDFromIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPartyIDFrom), v...))
	})
}

// PartyIDFromNotIn applies the NotIn predicate on the "party_id_from" field.
func PartyIDFromNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPartyIDFrom), v...))
	})
}

// PartyIDFromGT applies the GT predicate on the "party_id_from" field.
func PartyIDFromGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDFromGTE applies the GTE predicate on the "party_id_from" field.
func PartyIDFromGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDFromLT applies the LT predicate on the "party_id_from" field.
func PartyIDFromLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDFromLTE applies the LTE predicate on the "party_id_from" field.
func PartyIDFromLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPartyIDFrom), v))
	})
}

// PartyIDFromIsNil applies the IsNil predicate on the "party_id_from" field.
func PartyIDFromIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPartyIDFrom)))
	})
}

// PartyIDFromNotNil applies the NotNil predicate on the "party_id_from" field.
func PartyIDFromNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPartyIDFrom)))
	})
}

// PartyIDToEQ applies the EQ predicate on the "party_id_to" field.
func PartyIDToEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPartyIDTo), v))
	})
}

// PartyIDToNEQ applies the NEQ predicate on the "party_id_to" field.
func PartyIDToNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPartyIDTo), v))
	})
}

// PartyIDToIn applies the In predicate on the "party_id_to" field.
func PartyIDToIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPartyIDTo), v...))
	})
}

// PartyIDToNotIn applies the NotIn predicate on the "party_id_to" field.
func PartyIDToNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPartyIDTo), v...))
	})
}

// PartyIDToGT applies the GT predicate on the "party_id_to" field.
func PartyIDToGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPartyIDTo), v))
	})
}

// PartyIDToGTE applies the GTE predicate on the "party_id_to" field.
func PartyIDToGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPartyIDTo), v))
	})
}

// PartyIDToLT applies the LT predicate on the "party_id_to" field.
func PartyIDToLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPartyIDTo), v))
	})
}

// PartyIDToLTE applies the LTE predicate on the "party_id_to" field.
func PartyIDToLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPartyIDTo), v))
	})
}

// PartyIDToIsNil applies the IsNil predicate on the "party_id_to" field.
func PartyIDToIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPartyIDTo)))
	})
}

// PartyIDToNotNil applies the NotNil predicate on the "party_id_to" field.
func PartyIDToNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPartyIDTo)))
	})
}

// RoleTypeIDToEQ applies the EQ predicate on the "role_type_id_to" field.
func RoleTypeIDToEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRoleTypeIDTo), v))
	})
}

// RoleTypeIDToNEQ applies the NEQ predicate on the "role_type_id_to" field.
func RoleTypeIDToNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRoleTypeIDTo), v))
	})
}

// RoleTypeIDToIn applies the In predicate on the "role_type_id_to" field.
func RoleTypeIDToIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRoleTypeIDTo), v...))
	})
}

// RoleTypeIDToNotIn applies the NotIn predicate on the "role_type_id_to" field.
func RoleTypeIDToNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRoleTypeIDTo), v...))
	})
}

// RoleTypeIDToGT applies the GT predicate on the "role_type_id_to" field.
func RoleTypeIDToGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRoleTypeIDTo), v))
	})
}

// RoleTypeIDToGTE applies the GTE predicate on the "role_type_id_to" field.
func RoleTypeIDToGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRoleTypeIDTo), v))
	})
}

// RoleTypeIDToLT applies the LT predicate on the "role_type_id_to" field.
func RoleTypeIDToLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRoleTypeIDTo), v))
	})
}

// RoleTypeIDToLTE applies the LTE predicate on the "role_type_id_to" field.
func RoleTypeIDToLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRoleTypeIDTo), v))
	})
}

// RoleTypeIDToIsNil applies the IsNil predicate on the "role_type_id_to" field.
func RoleTypeIDToIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRoleTypeIDTo)))
	})
}

// RoleTypeIDToNotNil applies the NotNil predicate on the "role_type_id_to" field.
func RoleTypeIDToNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRoleTypeIDTo)))
	})
}

// StatusIDEQ applies the EQ predicate on the "status_id" field.
func StatusIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusID), v))
	})
}

// StatusIDNEQ applies the NEQ predicate on the "status_id" field.
func StatusIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatusID), v))
	})
}

// StatusIDIn applies the In predicate on the "status_id" field.
func StatusIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatusID), v...))
	})
}

// StatusIDNotIn applies the NotIn predicate on the "status_id" field.
func StatusIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatusID), v...))
	})
}

// StatusIDGT applies the GT predicate on the "status_id" field.
func StatusIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStatusID), v))
	})
}

// StatusIDGTE applies the GTE predicate on the "status_id" field.
func StatusIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStatusID), v))
	})
}

// StatusIDLT applies the LT predicate on the "status_id" field.
func StatusIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStatusID), v))
	})
}

// StatusIDLTE applies the LTE predicate on the "status_id" field.
func StatusIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStatusID), v))
	})
}

// StatusIDIsNil applies the IsNil predicate on the "status_id" field.
func StatusIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatusID)))
	})
}

// StatusIDNotNil applies the NotNil predicate on the "status_id" field.
func StatusIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatusID)))
	})
}

// EffectiveDateEQ applies the EQ predicate on the "effective_date" field.
func EffectiveDateEQ(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEffectiveDate), v))
	})
}

// EffectiveDateNEQ applies the NEQ predicate on the "effective_date" field.
func EffectiveDateNEQ(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEffectiveDate), v))
	})
}

// EffectiveDateIn applies the In predicate on the "effective_date" field.
func EffectiveDateIn(vs ...time.Time) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEffectiveDate), v...))
	})
}

// EffectiveDateNotIn applies the NotIn predicate on the "effective_date" field.
func EffectiveDateNotIn(vs ...time.Time) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEffectiveDate), v...))
	})
}

// EffectiveDateGT applies the GT predicate on the "effective_date" field.
func EffectiveDateGT(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEffectiveDate), v))
	})
}

// EffectiveDateGTE applies the GTE predicate on the "effective_date" field.
func EffectiveDateGTE(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEffectiveDate), v))
	})
}

// EffectiveDateLT applies the LT predicate on the "effective_date" field.
func EffectiveDateLT(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEffectiveDate), v))
	})
}

// EffectiveDateLTE applies the LTE predicate on the "effective_date" field.
func EffectiveDateLTE(v time.Time) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEffectiveDate), v))
	})
}

// EffectiveDateIsNil applies the IsNil predicate on the "effective_date" field.
func EffectiveDateIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldEffectiveDate)))
	})
}

// EffectiveDateNotNil applies the NotNil predicate on the "effective_date" field.
func EffectiveDateNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldEffectiveDate)))
	})
}

// PaymentRefNumEQ applies the EQ predicate on the "payment_ref_num" field.
func PaymentRefNumEQ(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumNEQ applies the NEQ predicate on the "payment_ref_num" field.
func PaymentRefNumNEQ(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumIn applies the In predicate on the "payment_ref_num" field.
func PaymentRefNumIn(vs ...string) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentRefNum), v...))
	})
}

// PaymentRefNumNotIn applies the NotIn predicate on the "payment_ref_num" field.
func PaymentRefNumNotIn(vs ...string) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentRefNum), v...))
	})
}

// PaymentRefNumGT applies the GT predicate on the "payment_ref_num" field.
func PaymentRefNumGT(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumGTE applies the GTE predicate on the "payment_ref_num" field.
func PaymentRefNumGTE(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumLT applies the LT predicate on the "payment_ref_num" field.
func PaymentRefNumLT(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumLTE applies the LTE predicate on the "payment_ref_num" field.
func PaymentRefNumLTE(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumContains applies the Contains predicate on the "payment_ref_num" field.
func PaymentRefNumContains(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumHasPrefix applies the HasPrefix predicate on the "payment_ref_num" field.
func PaymentRefNumHasPrefix(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumHasSuffix applies the HasSuffix predicate on the "payment_ref_num" field.
func PaymentRefNumHasSuffix(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumIsNil applies the IsNil predicate on the "payment_ref_num" field.
func PaymentRefNumIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentRefNum)))
	})
}

// PaymentRefNumNotNil applies the NotNil predicate on the "payment_ref_num" field.
func PaymentRefNumNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentRefNum)))
	})
}

// PaymentRefNumEqualFold applies the EqualFold predicate on the "payment_ref_num" field.
func PaymentRefNumEqualFold(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPaymentRefNum), v))
	})
}

// PaymentRefNumContainsFold applies the ContainsFold predicate on the "payment_ref_num" field.
func PaymentRefNumContainsFold(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPaymentRefNum), v))
	})
}

// AmountEQ applies the EQ predicate on the "amount" field.
func AmountEQ(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmount), v))
	})
}

// AmountNEQ applies the NEQ predicate on the "amount" field.
func AmountNEQ(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAmount), v))
	})
}

// AmountIn applies the In predicate on the "amount" field.
func AmountIn(vs ...float64) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAmount), v...))
	})
}

// AmountNotIn applies the NotIn predicate on the "amount" field.
func AmountNotIn(vs ...float64) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAmount), v...))
	})
}

// AmountGT applies the GT predicate on the "amount" field.
func AmountGT(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAmount), v))
	})
}

// AmountGTE applies the GTE predicate on the "amount" field.
func AmountGTE(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAmount), v))
	})
}

// AmountLT applies the LT predicate on the "amount" field.
func AmountLT(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAmount), v))
	})
}

// AmountLTE applies the LTE predicate on the "amount" field.
func AmountLTE(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAmount), v))
	})
}

// AmountIsNil applies the IsNil predicate on the "amount" field.
func AmountIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAmount)))
	})
}

// AmountNotNil applies the NotNil predicate on the "amount" field.
func AmountNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAmount)))
	})
}

// CurrencyUomIDEQ applies the EQ predicate on the "currency_uom_id" field.
func CurrencyUomIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDNEQ applies the NEQ predicate on the "currency_uom_id" field.
func CurrencyUomIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDIn applies the In predicate on the "currency_uom_id" field.
func CurrencyUomIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCurrencyUomID), v...))
	})
}

// CurrencyUomIDNotIn applies the NotIn predicate on the "currency_uom_id" field.
func CurrencyUomIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCurrencyUomID), v...))
	})
}

// CurrencyUomIDGT applies the GT predicate on the "currency_uom_id" field.
func CurrencyUomIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDGTE applies the GTE predicate on the "currency_uom_id" field.
func CurrencyUomIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDLT applies the LT predicate on the "currency_uom_id" field.
func CurrencyUomIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDLTE applies the LTE predicate on the "currency_uom_id" field.
func CurrencyUomIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCurrencyUomID), v))
	})
}

// CurrencyUomIDIsNil applies the IsNil predicate on the "currency_uom_id" field.
func CurrencyUomIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCurrencyUomID)))
	})
}

// CurrencyUomIDNotNil applies the NotNil predicate on the "currency_uom_id" field.
func CurrencyUomIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCurrencyUomID)))
	})
}

// CommentsEQ applies the EQ predicate on the "comments" field.
func CommentsEQ(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldComments), v))
	})
}

// CommentsNEQ applies the NEQ predicate on the "comments" field.
func CommentsNEQ(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldComments), v))
	})
}

// CommentsIn applies the In predicate on the "comments" field.
func CommentsIn(vs ...string) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldComments), v...))
	})
}

// CommentsNotIn applies the NotIn predicate on the "comments" field.
func CommentsNotIn(vs ...string) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldComments), v...))
	})
}

// CommentsGT applies the GT predicate on the "comments" field.
func CommentsGT(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldComments), v))
	})
}

// CommentsGTE applies the GTE predicate on the "comments" field.
func CommentsGTE(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldComments), v))
	})
}

// CommentsLT applies the LT predicate on the "comments" field.
func CommentsLT(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldComments), v))
	})
}

// CommentsLTE applies the LTE predicate on the "comments" field.
func CommentsLTE(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldComments), v))
	})
}

// CommentsContains applies the Contains predicate on the "comments" field.
func CommentsContains(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldComments), v))
	})
}

// CommentsHasPrefix applies the HasPrefix predicate on the "comments" field.
func CommentsHasPrefix(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldComments), v))
	})
}

// CommentsHasSuffix applies the HasSuffix predicate on the "comments" field.
func CommentsHasSuffix(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldComments), v))
	})
}

// CommentsIsNil applies the IsNil predicate on the "comments" field.
func CommentsIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldComments)))
	})
}

// CommentsNotNil applies the NotNil predicate on the "comments" field.
func CommentsNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldComments)))
	})
}

// CommentsEqualFold applies the EqualFold predicate on the "comments" field.
func CommentsEqualFold(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldComments), v))
	})
}

// CommentsContainsFold applies the ContainsFold predicate on the "comments" field.
func CommentsContainsFold(v string) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldComments), v))
	})
}

// FinAccountTransIDEQ applies the EQ predicate on the "fin_account_trans_id" field.
func FinAccountTransIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFinAccountTransID), v))
	})
}

// FinAccountTransIDNEQ applies the NEQ predicate on the "fin_account_trans_id" field.
func FinAccountTransIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFinAccountTransID), v))
	})
}

// FinAccountTransIDIn applies the In predicate on the "fin_account_trans_id" field.
func FinAccountTransIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFinAccountTransID), v...))
	})
}

// FinAccountTransIDNotIn applies the NotIn predicate on the "fin_account_trans_id" field.
func FinAccountTransIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFinAccountTransID), v...))
	})
}

// FinAccountTransIDGT applies the GT predicate on the "fin_account_trans_id" field.
func FinAccountTransIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFinAccountTransID), v))
	})
}

// FinAccountTransIDGTE applies the GTE predicate on the "fin_account_trans_id" field.
func FinAccountTransIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFinAccountTransID), v))
	})
}

// FinAccountTransIDLT applies the LT predicate on the "fin_account_trans_id" field.
func FinAccountTransIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFinAccountTransID), v))
	})
}

// FinAccountTransIDLTE applies the LTE predicate on the "fin_account_trans_id" field.
func FinAccountTransIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFinAccountTransID), v))
	})
}

// FinAccountTransIDIsNil applies the IsNil predicate on the "fin_account_trans_id" field.
func FinAccountTransIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFinAccountTransID)))
	})
}

// FinAccountTransIDNotNil applies the NotNil predicate on the "fin_account_trans_id" field.
func FinAccountTransIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFinAccountTransID)))
	})
}

// OverrideGlAccountIDEQ applies the EQ predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldOverrideGlAccountID), v))
	})
}

// OverrideGlAccountIDNEQ applies the NEQ predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldOverrideGlAccountID), v))
	})
}

// OverrideGlAccountIDIn applies the In predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldOverrideGlAccountID), v...))
	})
}

// OverrideGlAccountIDNotIn applies the NotIn predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldOverrideGlAccountID), v...))
	})
}

// OverrideGlAccountIDGT applies the GT predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldOverrideGlAccountID), v))
	})
}

// OverrideGlAccountIDGTE applies the GTE predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldOverrideGlAccountID), v))
	})
}

// OverrideGlAccountIDLT applies the LT predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldOverrideGlAccountID), v))
	})
}

// OverrideGlAccountIDLTE applies the LTE predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldOverrideGlAccountID), v))
	})
}

// OverrideGlAccountIDIsNil applies the IsNil predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldOverrideGlAccountID)))
	})
}

// OverrideGlAccountIDNotNil applies the NotNil predicate on the "override_gl_account_id" field.
func OverrideGlAccountIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldOverrideGlAccountID)))
	})
}

// ActualCurrencyAmountEQ applies the EQ predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountEQ(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyAmountNEQ applies the NEQ predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountNEQ(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyAmountIn applies the In predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountIn(vs ...float64) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldActualCurrencyAmount), v...))
	})
}

// ActualCurrencyAmountNotIn applies the NotIn predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountNotIn(vs ...float64) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldActualCurrencyAmount), v...))
	})
}

// ActualCurrencyAmountGT applies the GT predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountGT(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyAmountGTE applies the GTE predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountGTE(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyAmountLT applies the LT predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountLT(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyAmountLTE applies the LTE predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountLTE(v float64) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldActualCurrencyAmount), v))
	})
}

// ActualCurrencyAmountIsNil applies the IsNil predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldActualCurrencyAmount)))
	})
}

// ActualCurrencyAmountNotNil applies the NotNil predicate on the "actual_currency_amount" field.
func ActualCurrencyAmountNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldActualCurrencyAmount)))
	})
}

// ActualCurrencyUomIDEQ applies the EQ predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActualCurrencyUomID), v))
	})
}

// ActualCurrencyUomIDNEQ applies the NEQ predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDNEQ(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldActualCurrencyUomID), v))
	})
}

// ActualCurrencyUomIDIn applies the In predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldActualCurrencyUomID), v...))
	})
}

// ActualCurrencyUomIDNotIn applies the NotIn predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDNotIn(vs ...int) predicate.Payment {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Payment(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldActualCurrencyUomID), v...))
	})
}

// ActualCurrencyUomIDGT applies the GT predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDGT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldActualCurrencyUomID), v))
	})
}

// ActualCurrencyUomIDGTE applies the GTE predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDGTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldActualCurrencyUomID), v))
	})
}

// ActualCurrencyUomIDLT applies the LT predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDLT(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldActualCurrencyUomID), v))
	})
}

// ActualCurrencyUomIDLTE applies the LTE predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDLTE(v int) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldActualCurrencyUomID), v))
	})
}

// ActualCurrencyUomIDIsNil applies the IsNil predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDIsNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldActualCurrencyUomID)))
	})
}

// ActualCurrencyUomIDNotNil applies the NotNil predicate on the "actual_currency_uom_id" field.
func ActualCurrencyUomIDNotNil() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldActualCurrencyUomID)))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Payment) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Payment) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Payment) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		p(s.Not())
	})
}
