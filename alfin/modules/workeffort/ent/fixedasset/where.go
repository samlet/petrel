// Code generated by entc, DO NOT EDIT.

package fixedasset

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// UpdateTime applies equality check predicate on the "update_time" field. It's identical to UpdateTimeEQ.
func UpdateTime(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// StringRef applies equality check predicate on the "string_ref" field. It's identical to StringRefEQ.
func StringRef(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStringRef), v))
	})
}

// FixedAssetTypeID applies equality check predicate on the "fixed_asset_type_id" field. It's identical to FixedAssetTypeIDEQ.
func FixedAssetTypeID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFixedAssetTypeID), v))
	})
}

// InstanceOfProductID applies equality check predicate on the "instance_of_product_id" field. It's identical to InstanceOfProductIDEQ.
func InstanceOfProductID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInstanceOfProductID), v))
	})
}

// ClassEnumID applies equality check predicate on the "class_enum_id" field. It's identical to ClassEnumIDEQ.
func ClassEnumID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClassEnumID), v))
	})
}

// FixedAssetName applies equality check predicate on the "fixed_asset_name" field. It's identical to FixedAssetNameEQ.
func FixedAssetName(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFixedAssetName), v))
	})
}

// AcquireOrderID applies equality check predicate on the "acquire_order_id" field. It's identical to AcquireOrderIDEQ.
func AcquireOrderID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderItemSeqID applies equality check predicate on the "acquire_order_item_seq_id" field. It's identical to AcquireOrderItemSeqIDEQ.
func AcquireOrderItemSeqID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// DateAcquired applies equality check predicate on the "date_acquired" field. It's identical to DateAcquiredEQ.
func DateAcquired(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateAcquired), v))
	})
}

// DateLastServiced applies equality check predicate on the "date_last_serviced" field. It's identical to DateLastServicedEQ.
func DateLastServiced(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateLastServiced), v))
	})
}

// DateNextService applies equality check predicate on the "date_next_service" field. It's identical to DateNextServiceEQ.
func DateNextService(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateNextService), v))
	})
}

// ExpectedEndOfLife applies equality check predicate on the "expected_end_of_life" field. It's identical to ExpectedEndOfLifeEQ.
func ExpectedEndOfLife(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExpectedEndOfLife), v))
	})
}

// ActualEndOfLife applies equality check predicate on the "actual_end_of_life" field. It's identical to ActualEndOfLifeEQ.
func ActualEndOfLife(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActualEndOfLife), v))
	})
}

// ProductionCapacity applies equality check predicate on the "production_capacity" field. It's identical to ProductionCapacityEQ.
func ProductionCapacity(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProductionCapacity), v))
	})
}

// UomID applies equality check predicate on the "uom_id" field. It's identical to UomIDEQ.
func UomID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUomID), v))
	})
}

// CalendarID applies equality check predicate on the "calendar_id" field. It's identical to CalendarIDEQ.
func CalendarID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCalendarID), v))
	})
}

// SerialNumber applies equality check predicate on the "serial_number" field. It's identical to SerialNumberEQ.
func SerialNumber(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSerialNumber), v))
	})
}

// LocatedAtFacilityID applies equality check predicate on the "located_at_facility_id" field. It's identical to LocatedAtFacilityIDEQ.
func LocatedAtFacilityID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtLocationSeqID applies equality check predicate on the "located_at_location_seq_id" field. It's identical to LocatedAtLocationSeqIDEQ.
func LocatedAtLocationSeqID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// SalvageValue applies equality check predicate on the "salvage_value" field. It's identical to SalvageValueEQ.
func SalvageValue(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSalvageValue), v))
	})
}

// Depreciation applies equality check predicate on the "depreciation" field. It's identical to DepreciationEQ.
func Depreciation(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDepreciation), v))
	})
}

// PurchaseCost applies equality check predicate on the "purchase_cost" field. It's identical to PurchaseCostEQ.
func PurchaseCost(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostUomID applies equality check predicate on the "purchase_cost_uom_id" field. It's identical to PurchaseCostUomIDEQ.
func PurchaseCostUomID(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPurchaseCostUomID), v))
	})
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreateTime), v))
	})
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreateTime), v...))
	})
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreateTime), v))
	})
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreateTime), v))
	})
}

// UpdateTimeEQ applies the EQ predicate on the "update_time" field.
func UpdateTimeEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeNEQ applies the NEQ predicate on the "update_time" field.
func UpdateTimeNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeIn applies the In predicate on the "update_time" field.
func UpdateTimeIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeNotIn applies the NotIn predicate on the "update_time" field.
func UpdateTimeNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateTime), v...))
	})
}

// UpdateTimeGT applies the GT predicate on the "update_time" field.
func UpdateTimeGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeGTE applies the GTE predicate on the "update_time" field.
func UpdateTimeGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLT applies the LT predicate on the "update_time" field.
func UpdateTimeLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateTime), v))
	})
}

// UpdateTimeLTE applies the LTE predicate on the "update_time" field.
func UpdateTimeLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateTime), v))
	})
}

// StringRefEQ applies the EQ predicate on the "string_ref" field.
func StringRefEQ(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStringRef), v))
	})
}

// StringRefNEQ applies the NEQ predicate on the "string_ref" field.
func StringRefNEQ(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStringRef), v))
	})
}

// StringRefIn applies the In predicate on the "string_ref" field.
func StringRefIn(vs ...string) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStringRef), v...))
	})
}

// StringRefNotIn applies the NotIn predicate on the "string_ref" field.
func StringRefNotIn(vs ...string) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStringRef), v...))
	})
}

// StringRefGT applies the GT predicate on the "string_ref" field.
func StringRefGT(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStringRef), v))
	})
}

// StringRefGTE applies the GTE predicate on the "string_ref" field.
func StringRefGTE(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStringRef), v))
	})
}

// StringRefLT applies the LT predicate on the "string_ref" field.
func StringRefLT(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStringRef), v))
	})
}

// StringRefLTE applies the LTE predicate on the "string_ref" field.
func StringRefLTE(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStringRef), v))
	})
}

// StringRefContains applies the Contains predicate on the "string_ref" field.
func StringRefContains(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldStringRef), v))
	})
}

// StringRefHasPrefix applies the HasPrefix predicate on the "string_ref" field.
func StringRefHasPrefix(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldStringRef), v))
	})
}

// StringRefHasSuffix applies the HasSuffix predicate on the "string_ref" field.
func StringRefHasSuffix(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldStringRef), v))
	})
}

// StringRefIsNil applies the IsNil predicate on the "string_ref" field.
func StringRefIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStringRef)))
	})
}

// StringRefNotNil applies the NotNil predicate on the "string_ref" field.
func StringRefNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStringRef)))
	})
}

// StringRefEqualFold applies the EqualFold predicate on the "string_ref" field.
func StringRefEqualFold(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldStringRef), v))
	})
}

// StringRefContainsFold applies the ContainsFold predicate on the "string_ref" field.
func StringRefContainsFold(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldStringRef), v))
	})
}

// FixedAssetTypeIDEQ applies the EQ predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFixedAssetTypeID), v))
	})
}

// FixedAssetTypeIDNEQ applies the NEQ predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFixedAssetTypeID), v))
	})
}

// FixedAssetTypeIDIn applies the In predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFixedAssetTypeID), v...))
	})
}

// FixedAssetTypeIDNotIn applies the NotIn predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFixedAssetTypeID), v...))
	})
}

// FixedAssetTypeIDGT applies the GT predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFixedAssetTypeID), v))
	})
}

// FixedAssetTypeIDGTE applies the GTE predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFixedAssetTypeID), v))
	})
}

// FixedAssetTypeIDLT applies the LT predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFixedAssetTypeID), v))
	})
}

// FixedAssetTypeIDLTE applies the LTE predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFixedAssetTypeID), v))
	})
}

// FixedAssetTypeIDIsNil applies the IsNil predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFixedAssetTypeID)))
	})
}

// FixedAssetTypeIDNotNil applies the NotNil predicate on the "fixed_asset_type_id" field.
func FixedAssetTypeIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFixedAssetTypeID)))
	})
}

// InstanceOfProductIDEQ applies the EQ predicate on the "instance_of_product_id" field.
func InstanceOfProductIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldInstanceOfProductID), v))
	})
}

// InstanceOfProductIDNEQ applies the NEQ predicate on the "instance_of_product_id" field.
func InstanceOfProductIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldInstanceOfProductID), v))
	})
}

// InstanceOfProductIDIn applies the In predicate on the "instance_of_product_id" field.
func InstanceOfProductIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldInstanceOfProductID), v...))
	})
}

// InstanceOfProductIDNotIn applies the NotIn predicate on the "instance_of_product_id" field.
func InstanceOfProductIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldInstanceOfProductID), v...))
	})
}

// InstanceOfProductIDGT applies the GT predicate on the "instance_of_product_id" field.
func InstanceOfProductIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldInstanceOfProductID), v))
	})
}

// InstanceOfProductIDGTE applies the GTE predicate on the "instance_of_product_id" field.
func InstanceOfProductIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldInstanceOfProductID), v))
	})
}

// InstanceOfProductIDLT applies the LT predicate on the "instance_of_product_id" field.
func InstanceOfProductIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldInstanceOfProductID), v))
	})
}

// InstanceOfProductIDLTE applies the LTE predicate on the "instance_of_product_id" field.
func InstanceOfProductIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldInstanceOfProductID), v))
	})
}

// InstanceOfProductIDIsNil applies the IsNil predicate on the "instance_of_product_id" field.
func InstanceOfProductIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldInstanceOfProductID)))
	})
}

// InstanceOfProductIDNotNil applies the NotNil predicate on the "instance_of_product_id" field.
func InstanceOfProductIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldInstanceOfProductID)))
	})
}

// ClassEnumIDEQ applies the EQ predicate on the "class_enum_id" field.
func ClassEnumIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldClassEnumID), v))
	})
}

// ClassEnumIDNEQ applies the NEQ predicate on the "class_enum_id" field.
func ClassEnumIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldClassEnumID), v))
	})
}

// ClassEnumIDIn applies the In predicate on the "class_enum_id" field.
func ClassEnumIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldClassEnumID), v...))
	})
}

// ClassEnumIDNotIn applies the NotIn predicate on the "class_enum_id" field.
func ClassEnumIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldClassEnumID), v...))
	})
}

// ClassEnumIDGT applies the GT predicate on the "class_enum_id" field.
func ClassEnumIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldClassEnumID), v))
	})
}

// ClassEnumIDGTE applies the GTE predicate on the "class_enum_id" field.
func ClassEnumIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldClassEnumID), v))
	})
}

// ClassEnumIDLT applies the LT predicate on the "class_enum_id" field.
func ClassEnumIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldClassEnumID), v))
	})
}

// ClassEnumIDLTE applies the LTE predicate on the "class_enum_id" field.
func ClassEnumIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldClassEnumID), v))
	})
}

// ClassEnumIDIsNil applies the IsNil predicate on the "class_enum_id" field.
func ClassEnumIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldClassEnumID)))
	})
}

// ClassEnumIDNotNil applies the NotNil predicate on the "class_enum_id" field.
func ClassEnumIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldClassEnumID)))
	})
}

// FixedAssetNameEQ applies the EQ predicate on the "fixed_asset_name" field.
func FixedAssetNameEQ(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameNEQ applies the NEQ predicate on the "fixed_asset_name" field.
func FixedAssetNameNEQ(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameIn applies the In predicate on the "fixed_asset_name" field.
func FixedAssetNameIn(vs ...string) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFixedAssetName), v...))
	})
}

// FixedAssetNameNotIn applies the NotIn predicate on the "fixed_asset_name" field.
func FixedAssetNameNotIn(vs ...string) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFixedAssetName), v...))
	})
}

// FixedAssetNameGT applies the GT predicate on the "fixed_asset_name" field.
func FixedAssetNameGT(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameGTE applies the GTE predicate on the "fixed_asset_name" field.
func FixedAssetNameGTE(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameLT applies the LT predicate on the "fixed_asset_name" field.
func FixedAssetNameLT(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameLTE applies the LTE predicate on the "fixed_asset_name" field.
func FixedAssetNameLTE(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameContains applies the Contains predicate on the "fixed_asset_name" field.
func FixedAssetNameContains(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameHasPrefix applies the HasPrefix predicate on the "fixed_asset_name" field.
func FixedAssetNameHasPrefix(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameHasSuffix applies the HasSuffix predicate on the "fixed_asset_name" field.
func FixedAssetNameHasSuffix(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameIsNil applies the IsNil predicate on the "fixed_asset_name" field.
func FixedAssetNameIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFixedAssetName)))
	})
}

// FixedAssetNameNotNil applies the NotNil predicate on the "fixed_asset_name" field.
func FixedAssetNameNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFixedAssetName)))
	})
}

// FixedAssetNameEqualFold applies the EqualFold predicate on the "fixed_asset_name" field.
func FixedAssetNameEqualFold(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFixedAssetName), v))
	})
}

// FixedAssetNameContainsFold applies the ContainsFold predicate on the "fixed_asset_name" field.
func FixedAssetNameContainsFold(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFixedAssetName), v))
	})
}

// AcquireOrderIDEQ applies the EQ predicate on the "acquire_order_id" field.
func AcquireOrderIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderIDNEQ applies the NEQ predicate on the "acquire_order_id" field.
func AcquireOrderIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderIDIn applies the In predicate on the "acquire_order_id" field.
func AcquireOrderIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAcquireOrderID), v...))
	})
}

// AcquireOrderIDNotIn applies the NotIn predicate on the "acquire_order_id" field.
func AcquireOrderIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAcquireOrderID), v...))
	})
}

// AcquireOrderIDGT applies the GT predicate on the "acquire_order_id" field.
func AcquireOrderIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderIDGTE applies the GTE predicate on the "acquire_order_id" field.
func AcquireOrderIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderIDLT applies the LT predicate on the "acquire_order_id" field.
func AcquireOrderIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderIDLTE applies the LTE predicate on the "acquire_order_id" field.
func AcquireOrderIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAcquireOrderID), v))
	})
}

// AcquireOrderIDIsNil applies the IsNil predicate on the "acquire_order_id" field.
func AcquireOrderIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAcquireOrderID)))
	})
}

// AcquireOrderIDNotNil applies the NotNil predicate on the "acquire_order_id" field.
func AcquireOrderIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAcquireOrderID)))
	})
}

// AcquireOrderItemSeqIDEQ applies the EQ predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// AcquireOrderItemSeqIDNEQ applies the NEQ predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// AcquireOrderItemSeqIDIn applies the In predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAcquireOrderItemSeqID), v...))
	})
}

// AcquireOrderItemSeqIDNotIn applies the NotIn predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAcquireOrderItemSeqID), v...))
	})
}

// AcquireOrderItemSeqIDGT applies the GT predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// AcquireOrderItemSeqIDGTE applies the GTE predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// AcquireOrderItemSeqIDLT applies the LT predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// AcquireOrderItemSeqIDLTE applies the LTE predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAcquireOrderItemSeqID), v))
	})
}

// AcquireOrderItemSeqIDIsNil applies the IsNil predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAcquireOrderItemSeqID)))
	})
}

// AcquireOrderItemSeqIDNotNil applies the NotNil predicate on the "acquire_order_item_seq_id" field.
func AcquireOrderItemSeqIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAcquireOrderItemSeqID)))
	})
}

// DateAcquiredEQ applies the EQ predicate on the "date_acquired" field.
func DateAcquiredEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateAcquired), v))
	})
}

// DateAcquiredNEQ applies the NEQ predicate on the "date_acquired" field.
func DateAcquiredNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateAcquired), v))
	})
}

// DateAcquiredIn applies the In predicate on the "date_acquired" field.
func DateAcquiredIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateAcquired), v...))
	})
}

// DateAcquiredNotIn applies the NotIn predicate on the "date_acquired" field.
func DateAcquiredNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateAcquired), v...))
	})
}

// DateAcquiredGT applies the GT predicate on the "date_acquired" field.
func DateAcquiredGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateAcquired), v))
	})
}

// DateAcquiredGTE applies the GTE predicate on the "date_acquired" field.
func DateAcquiredGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateAcquired), v))
	})
}

// DateAcquiredLT applies the LT predicate on the "date_acquired" field.
func DateAcquiredLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateAcquired), v))
	})
}

// DateAcquiredLTE applies the LTE predicate on the "date_acquired" field.
func DateAcquiredLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateAcquired), v))
	})
}

// DateAcquiredIsNil applies the IsNil predicate on the "date_acquired" field.
func DateAcquiredIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateAcquired)))
	})
}

// DateAcquiredNotNil applies the NotNil predicate on the "date_acquired" field.
func DateAcquiredNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateAcquired)))
	})
}

// DateLastServicedEQ applies the EQ predicate on the "date_last_serviced" field.
func DateLastServicedEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateLastServiced), v))
	})
}

// DateLastServicedNEQ applies the NEQ predicate on the "date_last_serviced" field.
func DateLastServicedNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateLastServiced), v))
	})
}

// DateLastServicedIn applies the In predicate on the "date_last_serviced" field.
func DateLastServicedIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateLastServiced), v...))
	})
}

// DateLastServicedNotIn applies the NotIn predicate on the "date_last_serviced" field.
func DateLastServicedNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateLastServiced), v...))
	})
}

// DateLastServicedGT applies the GT predicate on the "date_last_serviced" field.
func DateLastServicedGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateLastServiced), v))
	})
}

// DateLastServicedGTE applies the GTE predicate on the "date_last_serviced" field.
func DateLastServicedGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateLastServiced), v))
	})
}

// DateLastServicedLT applies the LT predicate on the "date_last_serviced" field.
func DateLastServicedLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateLastServiced), v))
	})
}

// DateLastServicedLTE applies the LTE predicate on the "date_last_serviced" field.
func DateLastServicedLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateLastServiced), v))
	})
}

// DateLastServicedIsNil applies the IsNil predicate on the "date_last_serviced" field.
func DateLastServicedIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateLastServiced)))
	})
}

// DateLastServicedNotNil applies the NotNil predicate on the "date_last_serviced" field.
func DateLastServicedNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateLastServiced)))
	})
}

// DateNextServiceEQ applies the EQ predicate on the "date_next_service" field.
func DateNextServiceEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateNextService), v))
	})
}

// DateNextServiceNEQ applies the NEQ predicate on the "date_next_service" field.
func DateNextServiceNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateNextService), v))
	})
}

// DateNextServiceIn applies the In predicate on the "date_next_service" field.
func DateNextServiceIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateNextService), v...))
	})
}

// DateNextServiceNotIn applies the NotIn predicate on the "date_next_service" field.
func DateNextServiceNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateNextService), v...))
	})
}

// DateNextServiceGT applies the GT predicate on the "date_next_service" field.
func DateNextServiceGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateNextService), v))
	})
}

// DateNextServiceGTE applies the GTE predicate on the "date_next_service" field.
func DateNextServiceGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateNextService), v))
	})
}

// DateNextServiceLT applies the LT predicate on the "date_next_service" field.
func DateNextServiceLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateNextService), v))
	})
}

// DateNextServiceLTE applies the LTE predicate on the "date_next_service" field.
func DateNextServiceLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateNextService), v))
	})
}

// DateNextServiceIsNil applies the IsNil predicate on the "date_next_service" field.
func DateNextServiceIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateNextService)))
	})
}

// DateNextServiceNotNil applies the NotNil predicate on the "date_next_service" field.
func DateNextServiceNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateNextService)))
	})
}

// ExpectedEndOfLifeEQ applies the EQ predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExpectedEndOfLife), v))
	})
}

// ExpectedEndOfLifeNEQ applies the NEQ predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExpectedEndOfLife), v))
	})
}

// ExpectedEndOfLifeIn applies the In predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExpectedEndOfLife), v...))
	})
}

// ExpectedEndOfLifeNotIn applies the NotIn predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExpectedEndOfLife), v...))
	})
}

// ExpectedEndOfLifeGT applies the GT predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExpectedEndOfLife), v))
	})
}

// ExpectedEndOfLifeGTE applies the GTE predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExpectedEndOfLife), v))
	})
}

// ExpectedEndOfLifeLT applies the LT predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExpectedEndOfLife), v))
	})
}

// ExpectedEndOfLifeLTE applies the LTE predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExpectedEndOfLife), v))
	})
}

// ExpectedEndOfLifeIsNil applies the IsNil predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldExpectedEndOfLife)))
	})
}

// ExpectedEndOfLifeNotNil applies the NotNil predicate on the "expected_end_of_life" field.
func ExpectedEndOfLifeNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldExpectedEndOfLife)))
	})
}

// ActualEndOfLifeEQ applies the EQ predicate on the "actual_end_of_life" field.
func ActualEndOfLifeEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldActualEndOfLife), v))
	})
}

// ActualEndOfLifeNEQ applies the NEQ predicate on the "actual_end_of_life" field.
func ActualEndOfLifeNEQ(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldActualEndOfLife), v))
	})
}

// ActualEndOfLifeIn applies the In predicate on the "actual_end_of_life" field.
func ActualEndOfLifeIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldActualEndOfLife), v...))
	})
}

// ActualEndOfLifeNotIn applies the NotIn predicate on the "actual_end_of_life" field.
func ActualEndOfLifeNotIn(vs ...time.Time) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldActualEndOfLife), v...))
	})
}

// ActualEndOfLifeGT applies the GT predicate on the "actual_end_of_life" field.
func ActualEndOfLifeGT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldActualEndOfLife), v))
	})
}

// ActualEndOfLifeGTE applies the GTE predicate on the "actual_end_of_life" field.
func ActualEndOfLifeGTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldActualEndOfLife), v))
	})
}

// ActualEndOfLifeLT applies the LT predicate on the "actual_end_of_life" field.
func ActualEndOfLifeLT(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldActualEndOfLife), v))
	})
}

// ActualEndOfLifeLTE applies the LTE predicate on the "actual_end_of_life" field.
func ActualEndOfLifeLTE(v time.Time) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldActualEndOfLife), v))
	})
}

// ActualEndOfLifeIsNil applies the IsNil predicate on the "actual_end_of_life" field.
func ActualEndOfLifeIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldActualEndOfLife)))
	})
}

// ActualEndOfLifeNotNil applies the NotNil predicate on the "actual_end_of_life" field.
func ActualEndOfLifeNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldActualEndOfLife)))
	})
}

// ProductionCapacityEQ applies the EQ predicate on the "production_capacity" field.
func ProductionCapacityEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldProductionCapacity), v))
	})
}

// ProductionCapacityNEQ applies the NEQ predicate on the "production_capacity" field.
func ProductionCapacityNEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldProductionCapacity), v))
	})
}

// ProductionCapacityIn applies the In predicate on the "production_capacity" field.
func ProductionCapacityIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldProductionCapacity), v...))
	})
}

// ProductionCapacityNotIn applies the NotIn predicate on the "production_capacity" field.
func ProductionCapacityNotIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldProductionCapacity), v...))
	})
}

// ProductionCapacityGT applies the GT predicate on the "production_capacity" field.
func ProductionCapacityGT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldProductionCapacity), v))
	})
}

// ProductionCapacityGTE applies the GTE predicate on the "production_capacity" field.
func ProductionCapacityGTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldProductionCapacity), v))
	})
}

// ProductionCapacityLT applies the LT predicate on the "production_capacity" field.
func ProductionCapacityLT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldProductionCapacity), v))
	})
}

// ProductionCapacityLTE applies the LTE predicate on the "production_capacity" field.
func ProductionCapacityLTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldProductionCapacity), v))
	})
}

// ProductionCapacityIsNil applies the IsNil predicate on the "production_capacity" field.
func ProductionCapacityIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldProductionCapacity)))
	})
}

// ProductionCapacityNotNil applies the NotNil predicate on the "production_capacity" field.
func ProductionCapacityNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldProductionCapacity)))
	})
}

// UomIDEQ applies the EQ predicate on the "uom_id" field.
func UomIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUomID), v))
	})
}

// UomIDNEQ applies the NEQ predicate on the "uom_id" field.
func UomIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUomID), v))
	})
}

// UomIDIn applies the In predicate on the "uom_id" field.
func UomIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUomID), v...))
	})
}

// UomIDNotIn applies the NotIn predicate on the "uom_id" field.
func UomIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUomID), v...))
	})
}

// UomIDGT applies the GT predicate on the "uom_id" field.
func UomIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUomID), v))
	})
}

// UomIDGTE applies the GTE predicate on the "uom_id" field.
func UomIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUomID), v))
	})
}

// UomIDLT applies the LT predicate on the "uom_id" field.
func UomIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUomID), v))
	})
}

// UomIDLTE applies the LTE predicate on the "uom_id" field.
func UomIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUomID), v))
	})
}

// UomIDIsNil applies the IsNil predicate on the "uom_id" field.
func UomIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUomID)))
	})
}

// UomIDNotNil applies the NotNil predicate on the "uom_id" field.
func UomIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUomID)))
	})
}

// CalendarIDEQ applies the EQ predicate on the "calendar_id" field.
func CalendarIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCalendarID), v))
	})
}

// CalendarIDNEQ applies the NEQ predicate on the "calendar_id" field.
func CalendarIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCalendarID), v))
	})
}

// CalendarIDIn applies the In predicate on the "calendar_id" field.
func CalendarIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCalendarID), v...))
	})
}

// CalendarIDNotIn applies the NotIn predicate on the "calendar_id" field.
func CalendarIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCalendarID), v...))
	})
}

// CalendarIDGT applies the GT predicate on the "calendar_id" field.
func CalendarIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCalendarID), v))
	})
}

// CalendarIDGTE applies the GTE predicate on the "calendar_id" field.
func CalendarIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCalendarID), v))
	})
}

// CalendarIDLT applies the LT predicate on the "calendar_id" field.
func CalendarIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCalendarID), v))
	})
}

// CalendarIDLTE applies the LTE predicate on the "calendar_id" field.
func CalendarIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCalendarID), v))
	})
}

// CalendarIDIsNil applies the IsNil predicate on the "calendar_id" field.
func CalendarIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCalendarID)))
	})
}

// CalendarIDNotNil applies the NotNil predicate on the "calendar_id" field.
func CalendarIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCalendarID)))
	})
}

// SerialNumberEQ applies the EQ predicate on the "serial_number" field.
func SerialNumberEQ(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberNEQ applies the NEQ predicate on the "serial_number" field.
func SerialNumberNEQ(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberIn applies the In predicate on the "serial_number" field.
func SerialNumberIn(vs ...string) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSerialNumber), v...))
	})
}

// SerialNumberNotIn applies the NotIn predicate on the "serial_number" field.
func SerialNumberNotIn(vs ...string) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSerialNumber), v...))
	})
}

// SerialNumberGT applies the GT predicate on the "serial_number" field.
func SerialNumberGT(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberGTE applies the GTE predicate on the "serial_number" field.
func SerialNumberGTE(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberLT applies the LT predicate on the "serial_number" field.
func SerialNumberLT(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberLTE applies the LTE predicate on the "serial_number" field.
func SerialNumberLTE(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberContains applies the Contains predicate on the "serial_number" field.
func SerialNumberContains(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberHasPrefix applies the HasPrefix predicate on the "serial_number" field.
func SerialNumberHasPrefix(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberHasSuffix applies the HasSuffix predicate on the "serial_number" field.
func SerialNumberHasSuffix(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberIsNil applies the IsNil predicate on the "serial_number" field.
func SerialNumberIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSerialNumber)))
	})
}

// SerialNumberNotNil applies the NotNil predicate on the "serial_number" field.
func SerialNumberNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSerialNumber)))
	})
}

// SerialNumberEqualFold applies the EqualFold predicate on the "serial_number" field.
func SerialNumberEqualFold(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSerialNumber), v))
	})
}

// SerialNumberContainsFold applies the ContainsFold predicate on the "serial_number" field.
func SerialNumberContainsFold(v string) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSerialNumber), v))
	})
}

// LocatedAtFacilityIDEQ applies the EQ predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtFacilityIDNEQ applies the NEQ predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtFacilityIDIn applies the In predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLocatedAtFacilityID), v...))
	})
}

// LocatedAtFacilityIDNotIn applies the NotIn predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLocatedAtFacilityID), v...))
	})
}

// LocatedAtFacilityIDGT applies the GT predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtFacilityIDGTE applies the GTE predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtFacilityIDLT applies the LT predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtFacilityIDLTE applies the LTE predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLocatedAtFacilityID), v))
	})
}

// LocatedAtFacilityIDIsNil applies the IsNil predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLocatedAtFacilityID)))
	})
}

// LocatedAtFacilityIDNotNil applies the NotNil predicate on the "located_at_facility_id" field.
func LocatedAtFacilityIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLocatedAtFacilityID)))
	})
}

// LocatedAtLocationSeqIDEQ applies the EQ predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// LocatedAtLocationSeqIDNEQ applies the NEQ predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// LocatedAtLocationSeqIDIn applies the In predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLocatedAtLocationSeqID), v...))
	})
}

// LocatedAtLocationSeqIDNotIn applies the NotIn predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLocatedAtLocationSeqID), v...))
	})
}

// LocatedAtLocationSeqIDGT applies the GT predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// LocatedAtLocationSeqIDGTE applies the GTE predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// LocatedAtLocationSeqIDLT applies the LT predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// LocatedAtLocationSeqIDLTE applies the LTE predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLocatedAtLocationSeqID), v))
	})
}

// LocatedAtLocationSeqIDIsNil applies the IsNil predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLocatedAtLocationSeqID)))
	})
}

// LocatedAtLocationSeqIDNotNil applies the NotNil predicate on the "located_at_location_seq_id" field.
func LocatedAtLocationSeqIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLocatedAtLocationSeqID)))
	})
}

// SalvageValueEQ applies the EQ predicate on the "salvage_value" field.
func SalvageValueEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSalvageValue), v))
	})
}

// SalvageValueNEQ applies the NEQ predicate on the "salvage_value" field.
func SalvageValueNEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSalvageValue), v))
	})
}

// SalvageValueIn applies the In predicate on the "salvage_value" field.
func SalvageValueIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSalvageValue), v...))
	})
}

// SalvageValueNotIn applies the NotIn predicate on the "salvage_value" field.
func SalvageValueNotIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSalvageValue), v...))
	})
}

// SalvageValueGT applies the GT predicate on the "salvage_value" field.
func SalvageValueGT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSalvageValue), v))
	})
}

// SalvageValueGTE applies the GTE predicate on the "salvage_value" field.
func SalvageValueGTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSalvageValue), v))
	})
}

// SalvageValueLT applies the LT predicate on the "salvage_value" field.
func SalvageValueLT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSalvageValue), v))
	})
}

// SalvageValueLTE applies the LTE predicate on the "salvage_value" field.
func SalvageValueLTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSalvageValue), v))
	})
}

// SalvageValueIsNil applies the IsNil predicate on the "salvage_value" field.
func SalvageValueIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSalvageValue)))
	})
}

// SalvageValueNotNil applies the NotNil predicate on the "salvage_value" field.
func SalvageValueNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSalvageValue)))
	})
}

// DepreciationEQ applies the EQ predicate on the "depreciation" field.
func DepreciationEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDepreciation), v))
	})
}

// DepreciationNEQ applies the NEQ predicate on the "depreciation" field.
func DepreciationNEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDepreciation), v))
	})
}

// DepreciationIn applies the In predicate on the "depreciation" field.
func DepreciationIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDepreciation), v...))
	})
}

// DepreciationNotIn applies the NotIn predicate on the "depreciation" field.
func DepreciationNotIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDepreciation), v...))
	})
}

// DepreciationGT applies the GT predicate on the "depreciation" field.
func DepreciationGT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDepreciation), v))
	})
}

// DepreciationGTE applies the GTE predicate on the "depreciation" field.
func DepreciationGTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDepreciation), v))
	})
}

// DepreciationLT applies the LT predicate on the "depreciation" field.
func DepreciationLT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDepreciation), v))
	})
}

// DepreciationLTE applies the LTE predicate on the "depreciation" field.
func DepreciationLTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDepreciation), v))
	})
}

// DepreciationIsNil applies the IsNil predicate on the "depreciation" field.
func DepreciationIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDepreciation)))
	})
}

// DepreciationNotNil applies the NotNil predicate on the "depreciation" field.
func DepreciationNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDepreciation)))
	})
}

// PurchaseCostEQ applies the EQ predicate on the "purchase_cost" field.
func PurchaseCostEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostNEQ applies the NEQ predicate on the "purchase_cost" field.
func PurchaseCostNEQ(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostIn applies the In predicate on the "purchase_cost" field.
func PurchaseCostIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPurchaseCost), v...))
	})
}

// PurchaseCostNotIn applies the NotIn predicate on the "purchase_cost" field.
func PurchaseCostNotIn(vs ...float64) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPurchaseCost), v...))
	})
}

// PurchaseCostGT applies the GT predicate on the "purchase_cost" field.
func PurchaseCostGT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostGTE applies the GTE predicate on the "purchase_cost" field.
func PurchaseCostGTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostLT applies the LT predicate on the "purchase_cost" field.
func PurchaseCostLT(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostLTE applies the LTE predicate on the "purchase_cost" field.
func PurchaseCostLTE(v float64) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPurchaseCost), v))
	})
}

// PurchaseCostIsNil applies the IsNil predicate on the "purchase_cost" field.
func PurchaseCostIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPurchaseCost)))
	})
}

// PurchaseCostNotNil applies the NotNil predicate on the "purchase_cost" field.
func PurchaseCostNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPurchaseCost)))
	})
}

// PurchaseCostUomIDEQ applies the EQ predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPurchaseCostUomID), v))
	})
}

// PurchaseCostUomIDNEQ applies the NEQ predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDNEQ(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPurchaseCostUomID), v))
	})
}

// PurchaseCostUomIDIn applies the In predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPurchaseCostUomID), v...))
	})
}

// PurchaseCostUomIDNotIn applies the NotIn predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDNotIn(vs ...int) predicate.FixedAsset {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.FixedAsset(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPurchaseCostUomID), v...))
	})
}

// PurchaseCostUomIDGT applies the GT predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDGT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPurchaseCostUomID), v))
	})
}

// PurchaseCostUomIDGTE applies the GTE predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDGTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPurchaseCostUomID), v))
	})
}

// PurchaseCostUomIDLT applies the LT predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDLT(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPurchaseCostUomID), v))
	})
}

// PurchaseCostUomIDLTE applies the LTE predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDLTE(v int) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPurchaseCostUomID), v))
	})
}

// PurchaseCostUomIDIsNil applies the IsNil predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDIsNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPurchaseCostUomID)))
	})
}

// PurchaseCostUomIDNotNil applies the NotNil predicate on the "purchase_cost_uom_id" field.
func PurchaseCostUomIDNotNil() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPurchaseCostUomID)))
	})
}

// HasParent applies the HasEdge predicate on the "parent" edge.
func HasParent() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ParentTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ParentTable, ParentColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasParentWith applies the HasEdge predicate on the "parent" edge with a given conditions (other predicates).
func HasParentWith(preds ...predicate.FixedAsset) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ParentTable, ParentColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasChildren applies the HasEdge predicate on the "children" edge.
func HasChildren() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChildrenTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ChildrenTable, ChildrenColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasChildrenWith applies the HasEdge predicate on the "children" edge with a given conditions (other predicates).
func HasChildrenWith(preds ...predicate.FixedAsset) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ChildrenTable, ChildrenColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasParty applies the HasEdge predicate on the "party" edge.
func HasParty() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PartyTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PartyTable, PartyColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasPartyWith applies the HasEdge predicate on the "party" edge with a given conditions (other predicates).
func HasPartyWith(preds ...predicate.Party) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PartyInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PartyTable, PartyColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasRoleType applies the HasEdge predicate on the "role_type" edge.
func HasRoleType() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RoleTypeTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, RoleTypeTable, RoleTypeColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasRoleTypeWith applies the HasEdge predicate on the "role_type" edge with a given conditions (other predicates).
func HasRoleTypeWith(preds ...predicate.RoleType) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(RoleTypeInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, RoleTypeTable, RoleTypeColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasPartyRole applies the HasEdge predicate on the "party_role" edge.
func HasPartyRole() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PartyRoleTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PartyRoleTable, PartyRoleColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasPartyRoleWith applies the HasEdge predicate on the "party_role" edge with a given conditions (other predicates).
func HasPartyRoleWith(preds ...predicate.PartyRole) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PartyRoleInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PartyRoleTable, PartyRoleColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasChildFixedAssets applies the HasEdge predicate on the "child_fixed_assets" edge.
func HasChildFixedAssets() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChildFixedAssetsTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, ChildFixedAssetsTable, ChildFixedAssetsPrimaryKey...),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasChildFixedAssetsWith applies the HasEdge predicate on the "child_fixed_assets" edge with a given conditions (other predicates).
func HasChildFixedAssetsWith(preds ...predicate.FixedAsset) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, ChildFixedAssetsTable, ChildFixedAssetsPrimaryKey...),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasWorkEfforts applies the HasEdge predicate on the "work_efforts" edge.
func HasWorkEfforts() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(WorkEffortsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, WorkEffortsTable, WorkEffortsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasWorkEffortsWith applies the HasEdge predicate on the "work_efforts" edge with a given conditions (other predicates).
func HasWorkEffortsWith(preds ...predicate.WorkEffort) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(WorkEffortsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, WorkEffortsTable, WorkEffortsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasWorkEffortFixedAssetAssigns applies the HasEdge predicate on the "work_effort_fixed_asset_assigns" edge.
func HasWorkEffortFixedAssetAssigns() predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(WorkEffortFixedAssetAssignsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, WorkEffortFixedAssetAssignsTable, WorkEffortFixedAssetAssignsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasWorkEffortFixedAssetAssignsWith applies the HasEdge predicate on the "work_effort_fixed_asset_assigns" edge with a given conditions (other predicates).
func HasWorkEffortFixedAssetAssignsWith(preds ...predicate.WorkEffortFixedAssetAssign) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(WorkEffortFixedAssetAssignsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, WorkEffortFixedAssetAssignsTable, WorkEffortFixedAssetAssignsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.FixedAsset) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.FixedAsset) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.FixedAsset) predicate.FixedAsset {
	return predicate.FixedAsset(func(s *sql.Selector) {
		p(s.Not())
	})
}
