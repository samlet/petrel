// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/samlet/petrel/alfin/modules/workeffort/ent/fixedasset"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/party"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/partyrole"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/partystatus"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/person"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/predicate"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/securitygroup"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/securitygrouppermission"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/temporalexpression"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/temporalexpressionassoc"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/userlogin"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/userloginsecuritygroup"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/workeffort"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/workeffortassoc"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/workeffortfixedassetassign"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/workeffortpartyassignment"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFixedAsset                 = "FixedAsset"
	TypeParty                      = "Party"
	TypePartyRole                  = "PartyRole"
	TypePartyStatus                = "PartyStatus"
	TypePerson                     = "Person"
	TypeSecurityGroup              = "SecurityGroup"
	TypeSecurityGroupPermission    = "SecurityGroupPermission"
	TypeTemporalExpression         = "TemporalExpression"
	TypeTemporalExpressionAssoc    = "TemporalExpressionAssoc"
	TypeUserLogin                  = "UserLogin"
	TypeUserLoginSecurityGroup     = "UserLoginSecurityGroup"
	TypeWorkEffort                 = "WorkEffort"
	TypeWorkEffortAssoc            = "WorkEffortAssoc"
	TypeWorkEffortFixedAssetAssign = "WorkEffortFixedAssetAssign"
	TypeWorkEffortPartyAssignment  = "WorkEffortPartyAssignment"
)

// FixedAssetMutation represents an operation that mutates the FixedAsset nodes in the graph.
type FixedAssetMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	fixed_asset_type_id                    *int
	addfixed_asset_type_id                 *int
	instance_of_product_id                 *int
	addinstance_of_product_id              *int
	class_enum_id                          *int
	addclass_enum_id                       *int
	role_type_id                           *int
	addrole_type_id                        *int
	fixed_asset_name                       *string
	acquire_order_id                       *int
	addacquire_order_id                    *int
	acquire_order_item_seq_id              *int
	addacquire_order_item_seq_id           *int
	date_acquired                          *time.Time
	date_last_serviced                     *time.Time
	date_next_service                      *time.Time
	expected_end_of_life                   *time.Time
	actual_end_of_life                     *time.Time
	production_capacity                    *float64
	addproduction_capacity                 *float64
	uom_id                                 *int
	adduom_id                              *int
	calendar_id                            *int
	addcalendar_id                         *int
	serial_number                          *string
	located_at_facility_id                 *int
	addlocated_at_facility_id              *int
	located_at_location_seq_id             *int
	addlocated_at_location_seq_id          *int
	salvage_value                          *float64
	addsalvage_value                       *float64
	depreciation                           *float64
	adddepreciation                        *float64
	purchase_cost                          *float64
	addpurchase_cost                       *float64
	purchase_cost_uom_id                   *int
	addpurchase_cost_uom_id                *int
	clearedFields                          map[string]struct{}
	parent                                 *int
	clearedparent                          bool
	children                               map[int]struct{}
	removedchildren                        map[int]struct{}
	clearedchildren                        bool
	party                                  *int
	clearedparty                           bool
	party_role                             *int
	clearedparty_role                      bool
	child_fixed_assets                     map[int]struct{}
	removedchild_fixed_assets              map[int]struct{}
	clearedchild_fixed_assets              bool
	work_efforts                           map[int]struct{}
	removedwork_efforts                    map[int]struct{}
	clearedwork_efforts                    bool
	work_effort_fixed_asset_assigns        map[int]struct{}
	removedwork_effort_fixed_asset_assigns map[int]struct{}
	clearedwork_effort_fixed_asset_assigns bool
	done                                   bool
	oldValue                               func(context.Context) (*FixedAsset, error)
	predicates                             []predicate.FixedAsset
}

var _ ent.Mutation = (*FixedAssetMutation)(nil)

// fixedassetOption allows management of the mutation configuration using functional options.
type fixedassetOption func(*FixedAssetMutation)

// newFixedAssetMutation creates new mutation for the FixedAsset entity.
func newFixedAssetMutation(c config, op Op, opts ...fixedassetOption) *FixedAssetMutation {
	m := &FixedAssetMutation{
		config:        c,
		op:            op,
		typ:           TypeFixedAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixedAssetID sets the ID field of the mutation.
func withFixedAssetID(id int) fixedassetOption {
	return func(m *FixedAssetMutation) {
		var (
			err   error
			once  sync.Once
			value *FixedAsset
		)
		m.oldValue = func(ctx context.Context) (*FixedAsset, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FixedAsset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixedAsset sets the old FixedAsset of the mutation.
func withFixedAsset(node *FixedAsset) fixedassetOption {
	return func(m *FixedAssetMutation) {
		m.oldValue = func(context.Context) (*FixedAsset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixedAssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixedAssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FixedAssetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFixedAssetTypeID sets the "fixed_asset_type_id" field.
func (m *FixedAssetMutation) SetFixedAssetTypeID(i int) {
	m.fixed_asset_type_id = &i
	m.addfixed_asset_type_id = nil
}

// FixedAssetTypeID returns the value of the "fixed_asset_type_id" field in the mutation.
func (m *FixedAssetMutation) FixedAssetTypeID() (r int, exists bool) {
	v := m.fixed_asset_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedAssetTypeID returns the old "fixed_asset_type_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldFixedAssetTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixedAssetTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixedAssetTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedAssetTypeID: %w", err)
	}
	return oldValue.FixedAssetTypeID, nil
}

// AddFixedAssetTypeID adds i to the "fixed_asset_type_id" field.
func (m *FixedAssetMutation) AddFixedAssetTypeID(i int) {
	if m.addfixed_asset_type_id != nil {
		*m.addfixed_asset_type_id += i
	} else {
		m.addfixed_asset_type_id = &i
	}
}

// AddedFixedAssetTypeID returns the value that was added to the "fixed_asset_type_id" field in this mutation.
func (m *FixedAssetMutation) AddedFixedAssetTypeID() (r int, exists bool) {
	v := m.addfixed_asset_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedAssetTypeID clears the value of the "fixed_asset_type_id" field.
func (m *FixedAssetMutation) ClearFixedAssetTypeID() {
	m.fixed_asset_type_id = nil
	m.addfixed_asset_type_id = nil
	m.clearedFields[fixedasset.FieldFixedAssetTypeID] = struct{}{}
}

// FixedAssetTypeIDCleared returns if the "fixed_asset_type_id" field was cleared in this mutation.
func (m *FixedAssetMutation) FixedAssetTypeIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldFixedAssetTypeID]
	return ok
}

// ResetFixedAssetTypeID resets all changes to the "fixed_asset_type_id" field.
func (m *FixedAssetMutation) ResetFixedAssetTypeID() {
	m.fixed_asset_type_id = nil
	m.addfixed_asset_type_id = nil
	delete(m.clearedFields, fixedasset.FieldFixedAssetTypeID)
}

// SetInstanceOfProductID sets the "instance_of_product_id" field.
func (m *FixedAssetMutation) SetInstanceOfProductID(i int) {
	m.instance_of_product_id = &i
	m.addinstance_of_product_id = nil
}

// InstanceOfProductID returns the value of the "instance_of_product_id" field in the mutation.
func (m *FixedAssetMutation) InstanceOfProductID() (r int, exists bool) {
	v := m.instance_of_product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceOfProductID returns the old "instance_of_product_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldInstanceOfProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstanceOfProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstanceOfProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceOfProductID: %w", err)
	}
	return oldValue.InstanceOfProductID, nil
}

// AddInstanceOfProductID adds i to the "instance_of_product_id" field.
func (m *FixedAssetMutation) AddInstanceOfProductID(i int) {
	if m.addinstance_of_product_id != nil {
		*m.addinstance_of_product_id += i
	} else {
		m.addinstance_of_product_id = &i
	}
}

// AddedInstanceOfProductID returns the value that was added to the "instance_of_product_id" field in this mutation.
func (m *FixedAssetMutation) AddedInstanceOfProductID() (r int, exists bool) {
	v := m.addinstance_of_product_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearInstanceOfProductID clears the value of the "instance_of_product_id" field.
func (m *FixedAssetMutation) ClearInstanceOfProductID() {
	m.instance_of_product_id = nil
	m.addinstance_of_product_id = nil
	m.clearedFields[fixedasset.FieldInstanceOfProductID] = struct{}{}
}

// InstanceOfProductIDCleared returns if the "instance_of_product_id" field was cleared in this mutation.
func (m *FixedAssetMutation) InstanceOfProductIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldInstanceOfProductID]
	return ok
}

// ResetInstanceOfProductID resets all changes to the "instance_of_product_id" field.
func (m *FixedAssetMutation) ResetInstanceOfProductID() {
	m.instance_of_product_id = nil
	m.addinstance_of_product_id = nil
	delete(m.clearedFields, fixedasset.FieldInstanceOfProductID)
}

// SetClassEnumID sets the "class_enum_id" field.
func (m *FixedAssetMutation) SetClassEnumID(i int) {
	m.class_enum_id = &i
	m.addclass_enum_id = nil
}

// ClassEnumID returns the value of the "class_enum_id" field in the mutation.
func (m *FixedAssetMutation) ClassEnumID() (r int, exists bool) {
	v := m.class_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClassEnumID returns the old "class_enum_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldClassEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClassEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClassEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassEnumID: %w", err)
	}
	return oldValue.ClassEnumID, nil
}

// AddClassEnumID adds i to the "class_enum_id" field.
func (m *FixedAssetMutation) AddClassEnumID(i int) {
	if m.addclass_enum_id != nil {
		*m.addclass_enum_id += i
	} else {
		m.addclass_enum_id = &i
	}
}

// AddedClassEnumID returns the value that was added to the "class_enum_id" field in this mutation.
func (m *FixedAssetMutation) AddedClassEnumID() (r int, exists bool) {
	v := m.addclass_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearClassEnumID clears the value of the "class_enum_id" field.
func (m *FixedAssetMutation) ClearClassEnumID() {
	m.class_enum_id = nil
	m.addclass_enum_id = nil
	m.clearedFields[fixedasset.FieldClassEnumID] = struct{}{}
}

// ClassEnumIDCleared returns if the "class_enum_id" field was cleared in this mutation.
func (m *FixedAssetMutation) ClassEnumIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldClassEnumID]
	return ok
}

// ResetClassEnumID resets all changes to the "class_enum_id" field.
func (m *FixedAssetMutation) ResetClassEnumID() {
	m.class_enum_id = nil
	m.addclass_enum_id = nil
	delete(m.clearedFields, fixedasset.FieldClassEnumID)
}

// SetRoleTypeID sets the "role_type_id" field.
func (m *FixedAssetMutation) SetRoleTypeID(i int) {
	m.role_type_id = &i
	m.addrole_type_id = nil
}

// RoleTypeID returns the value of the "role_type_id" field in the mutation.
func (m *FixedAssetMutation) RoleTypeID() (r int, exists bool) {
	v := m.role_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleTypeID returns the old "role_type_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldRoleTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleTypeID: %w", err)
	}
	return oldValue.RoleTypeID, nil
}

// AddRoleTypeID adds i to the "role_type_id" field.
func (m *FixedAssetMutation) AddRoleTypeID(i int) {
	if m.addrole_type_id != nil {
		*m.addrole_type_id += i
	} else {
		m.addrole_type_id = &i
	}
}

// AddedRoleTypeID returns the value that was added to the "role_type_id" field in this mutation.
func (m *FixedAssetMutation) AddedRoleTypeID() (r int, exists bool) {
	v := m.addrole_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRoleTypeID clears the value of the "role_type_id" field.
func (m *FixedAssetMutation) ClearRoleTypeID() {
	m.role_type_id = nil
	m.addrole_type_id = nil
	m.clearedFields[fixedasset.FieldRoleTypeID] = struct{}{}
}

// RoleTypeIDCleared returns if the "role_type_id" field was cleared in this mutation.
func (m *FixedAssetMutation) RoleTypeIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldRoleTypeID]
	return ok
}

// ResetRoleTypeID resets all changes to the "role_type_id" field.
func (m *FixedAssetMutation) ResetRoleTypeID() {
	m.role_type_id = nil
	m.addrole_type_id = nil
	delete(m.clearedFields, fixedasset.FieldRoleTypeID)
}

// SetFixedAssetName sets the "fixed_asset_name" field.
func (m *FixedAssetMutation) SetFixedAssetName(s string) {
	m.fixed_asset_name = &s
}

// FixedAssetName returns the value of the "fixed_asset_name" field in the mutation.
func (m *FixedAssetMutation) FixedAssetName() (r string, exists bool) {
	v := m.fixed_asset_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedAssetName returns the old "fixed_asset_name" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldFixedAssetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixedAssetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixedAssetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedAssetName: %w", err)
	}
	return oldValue.FixedAssetName, nil
}

// ClearFixedAssetName clears the value of the "fixed_asset_name" field.
func (m *FixedAssetMutation) ClearFixedAssetName() {
	m.fixed_asset_name = nil
	m.clearedFields[fixedasset.FieldFixedAssetName] = struct{}{}
}

// FixedAssetNameCleared returns if the "fixed_asset_name" field was cleared in this mutation.
func (m *FixedAssetMutation) FixedAssetNameCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldFixedAssetName]
	return ok
}

// ResetFixedAssetName resets all changes to the "fixed_asset_name" field.
func (m *FixedAssetMutation) ResetFixedAssetName() {
	m.fixed_asset_name = nil
	delete(m.clearedFields, fixedasset.FieldFixedAssetName)
}

// SetAcquireOrderID sets the "acquire_order_id" field.
func (m *FixedAssetMutation) SetAcquireOrderID(i int) {
	m.acquire_order_id = &i
	m.addacquire_order_id = nil
}

// AcquireOrderID returns the value of the "acquire_order_id" field in the mutation.
func (m *FixedAssetMutation) AcquireOrderID() (r int, exists bool) {
	v := m.acquire_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAcquireOrderID returns the old "acquire_order_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldAcquireOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAcquireOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAcquireOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcquireOrderID: %w", err)
	}
	return oldValue.AcquireOrderID, nil
}

// AddAcquireOrderID adds i to the "acquire_order_id" field.
func (m *FixedAssetMutation) AddAcquireOrderID(i int) {
	if m.addacquire_order_id != nil {
		*m.addacquire_order_id += i
	} else {
		m.addacquire_order_id = &i
	}
}

// AddedAcquireOrderID returns the value that was added to the "acquire_order_id" field in this mutation.
func (m *FixedAssetMutation) AddedAcquireOrderID() (r int, exists bool) {
	v := m.addacquire_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAcquireOrderID clears the value of the "acquire_order_id" field.
func (m *FixedAssetMutation) ClearAcquireOrderID() {
	m.acquire_order_id = nil
	m.addacquire_order_id = nil
	m.clearedFields[fixedasset.FieldAcquireOrderID] = struct{}{}
}

// AcquireOrderIDCleared returns if the "acquire_order_id" field was cleared in this mutation.
func (m *FixedAssetMutation) AcquireOrderIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldAcquireOrderID]
	return ok
}

// ResetAcquireOrderID resets all changes to the "acquire_order_id" field.
func (m *FixedAssetMutation) ResetAcquireOrderID() {
	m.acquire_order_id = nil
	m.addacquire_order_id = nil
	delete(m.clearedFields, fixedasset.FieldAcquireOrderID)
}

// SetAcquireOrderItemSeqID sets the "acquire_order_item_seq_id" field.
func (m *FixedAssetMutation) SetAcquireOrderItemSeqID(i int) {
	m.acquire_order_item_seq_id = &i
	m.addacquire_order_item_seq_id = nil
}

// AcquireOrderItemSeqID returns the value of the "acquire_order_item_seq_id" field in the mutation.
func (m *FixedAssetMutation) AcquireOrderItemSeqID() (r int, exists bool) {
	v := m.acquire_order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAcquireOrderItemSeqID returns the old "acquire_order_item_seq_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldAcquireOrderItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAcquireOrderItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAcquireOrderItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcquireOrderItemSeqID: %w", err)
	}
	return oldValue.AcquireOrderItemSeqID, nil
}

// AddAcquireOrderItemSeqID adds i to the "acquire_order_item_seq_id" field.
func (m *FixedAssetMutation) AddAcquireOrderItemSeqID(i int) {
	if m.addacquire_order_item_seq_id != nil {
		*m.addacquire_order_item_seq_id += i
	} else {
		m.addacquire_order_item_seq_id = &i
	}
}

// AddedAcquireOrderItemSeqID returns the value that was added to the "acquire_order_item_seq_id" field in this mutation.
func (m *FixedAssetMutation) AddedAcquireOrderItemSeqID() (r int, exists bool) {
	v := m.addacquire_order_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAcquireOrderItemSeqID clears the value of the "acquire_order_item_seq_id" field.
func (m *FixedAssetMutation) ClearAcquireOrderItemSeqID() {
	m.acquire_order_item_seq_id = nil
	m.addacquire_order_item_seq_id = nil
	m.clearedFields[fixedasset.FieldAcquireOrderItemSeqID] = struct{}{}
}

// AcquireOrderItemSeqIDCleared returns if the "acquire_order_item_seq_id" field was cleared in this mutation.
func (m *FixedAssetMutation) AcquireOrderItemSeqIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldAcquireOrderItemSeqID]
	return ok
}

// ResetAcquireOrderItemSeqID resets all changes to the "acquire_order_item_seq_id" field.
func (m *FixedAssetMutation) ResetAcquireOrderItemSeqID() {
	m.acquire_order_item_seq_id = nil
	m.addacquire_order_item_seq_id = nil
	delete(m.clearedFields, fixedasset.FieldAcquireOrderItemSeqID)
}

// SetDateAcquired sets the "date_acquired" field.
func (m *FixedAssetMutation) SetDateAcquired(t time.Time) {
	m.date_acquired = &t
}

// DateAcquired returns the value of the "date_acquired" field in the mutation.
func (m *FixedAssetMutation) DateAcquired() (r time.Time, exists bool) {
	v := m.date_acquired
	if v == nil {
		return
	}
	return *v, true
}

// OldDateAcquired returns the old "date_acquired" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldDateAcquired(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateAcquired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateAcquired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateAcquired: %w", err)
	}
	return oldValue.DateAcquired, nil
}

// ClearDateAcquired clears the value of the "date_acquired" field.
func (m *FixedAssetMutation) ClearDateAcquired() {
	m.date_acquired = nil
	m.clearedFields[fixedasset.FieldDateAcquired] = struct{}{}
}

// DateAcquiredCleared returns if the "date_acquired" field was cleared in this mutation.
func (m *FixedAssetMutation) DateAcquiredCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldDateAcquired]
	return ok
}

// ResetDateAcquired resets all changes to the "date_acquired" field.
func (m *FixedAssetMutation) ResetDateAcquired() {
	m.date_acquired = nil
	delete(m.clearedFields, fixedasset.FieldDateAcquired)
}

// SetDateLastServiced sets the "date_last_serviced" field.
func (m *FixedAssetMutation) SetDateLastServiced(t time.Time) {
	m.date_last_serviced = &t
}

// DateLastServiced returns the value of the "date_last_serviced" field in the mutation.
func (m *FixedAssetMutation) DateLastServiced() (r time.Time, exists bool) {
	v := m.date_last_serviced
	if v == nil {
		return
	}
	return *v, true
}

// OldDateLastServiced returns the old "date_last_serviced" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldDateLastServiced(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateLastServiced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateLastServiced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateLastServiced: %w", err)
	}
	return oldValue.DateLastServiced, nil
}

// ClearDateLastServiced clears the value of the "date_last_serviced" field.
func (m *FixedAssetMutation) ClearDateLastServiced() {
	m.date_last_serviced = nil
	m.clearedFields[fixedasset.FieldDateLastServiced] = struct{}{}
}

// DateLastServicedCleared returns if the "date_last_serviced" field was cleared in this mutation.
func (m *FixedAssetMutation) DateLastServicedCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldDateLastServiced]
	return ok
}

// ResetDateLastServiced resets all changes to the "date_last_serviced" field.
func (m *FixedAssetMutation) ResetDateLastServiced() {
	m.date_last_serviced = nil
	delete(m.clearedFields, fixedasset.FieldDateLastServiced)
}

// SetDateNextService sets the "date_next_service" field.
func (m *FixedAssetMutation) SetDateNextService(t time.Time) {
	m.date_next_service = &t
}

// DateNextService returns the value of the "date_next_service" field in the mutation.
func (m *FixedAssetMutation) DateNextService() (r time.Time, exists bool) {
	v := m.date_next_service
	if v == nil {
		return
	}
	return *v, true
}

// OldDateNextService returns the old "date_next_service" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldDateNextService(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateNextService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateNextService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateNextService: %w", err)
	}
	return oldValue.DateNextService, nil
}

// ClearDateNextService clears the value of the "date_next_service" field.
func (m *FixedAssetMutation) ClearDateNextService() {
	m.date_next_service = nil
	m.clearedFields[fixedasset.FieldDateNextService] = struct{}{}
}

// DateNextServiceCleared returns if the "date_next_service" field was cleared in this mutation.
func (m *FixedAssetMutation) DateNextServiceCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldDateNextService]
	return ok
}

// ResetDateNextService resets all changes to the "date_next_service" field.
func (m *FixedAssetMutation) ResetDateNextService() {
	m.date_next_service = nil
	delete(m.clearedFields, fixedasset.FieldDateNextService)
}

// SetExpectedEndOfLife sets the "expected_end_of_life" field.
func (m *FixedAssetMutation) SetExpectedEndOfLife(t time.Time) {
	m.expected_end_of_life = &t
}

// ExpectedEndOfLife returns the value of the "expected_end_of_life" field in the mutation.
func (m *FixedAssetMutation) ExpectedEndOfLife() (r time.Time, exists bool) {
	v := m.expected_end_of_life
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedEndOfLife returns the old "expected_end_of_life" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldExpectedEndOfLife(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpectedEndOfLife is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpectedEndOfLife requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedEndOfLife: %w", err)
	}
	return oldValue.ExpectedEndOfLife, nil
}

// ClearExpectedEndOfLife clears the value of the "expected_end_of_life" field.
func (m *FixedAssetMutation) ClearExpectedEndOfLife() {
	m.expected_end_of_life = nil
	m.clearedFields[fixedasset.FieldExpectedEndOfLife] = struct{}{}
}

// ExpectedEndOfLifeCleared returns if the "expected_end_of_life" field was cleared in this mutation.
func (m *FixedAssetMutation) ExpectedEndOfLifeCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldExpectedEndOfLife]
	return ok
}

// ResetExpectedEndOfLife resets all changes to the "expected_end_of_life" field.
func (m *FixedAssetMutation) ResetExpectedEndOfLife() {
	m.expected_end_of_life = nil
	delete(m.clearedFields, fixedasset.FieldExpectedEndOfLife)
}

// SetActualEndOfLife sets the "actual_end_of_life" field.
func (m *FixedAssetMutation) SetActualEndOfLife(t time.Time) {
	m.actual_end_of_life = &t
}

// ActualEndOfLife returns the value of the "actual_end_of_life" field in the mutation.
func (m *FixedAssetMutation) ActualEndOfLife() (r time.Time, exists bool) {
	v := m.actual_end_of_life
	if v == nil {
		return
	}
	return *v, true
}

// OldActualEndOfLife returns the old "actual_end_of_life" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldActualEndOfLife(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActualEndOfLife is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActualEndOfLife requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualEndOfLife: %w", err)
	}
	return oldValue.ActualEndOfLife, nil
}

// ClearActualEndOfLife clears the value of the "actual_end_of_life" field.
func (m *FixedAssetMutation) ClearActualEndOfLife() {
	m.actual_end_of_life = nil
	m.clearedFields[fixedasset.FieldActualEndOfLife] = struct{}{}
}

// ActualEndOfLifeCleared returns if the "actual_end_of_life" field was cleared in this mutation.
func (m *FixedAssetMutation) ActualEndOfLifeCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldActualEndOfLife]
	return ok
}

// ResetActualEndOfLife resets all changes to the "actual_end_of_life" field.
func (m *FixedAssetMutation) ResetActualEndOfLife() {
	m.actual_end_of_life = nil
	delete(m.clearedFields, fixedasset.FieldActualEndOfLife)
}

// SetProductionCapacity sets the "production_capacity" field.
func (m *FixedAssetMutation) SetProductionCapacity(f float64) {
	m.production_capacity = &f
	m.addproduction_capacity = nil
}

// ProductionCapacity returns the value of the "production_capacity" field in the mutation.
func (m *FixedAssetMutation) ProductionCapacity() (r float64, exists bool) {
	v := m.production_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldProductionCapacity returns the old "production_capacity" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldProductionCapacity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductionCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductionCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductionCapacity: %w", err)
	}
	return oldValue.ProductionCapacity, nil
}

// AddProductionCapacity adds f to the "production_capacity" field.
func (m *FixedAssetMutation) AddProductionCapacity(f float64) {
	if m.addproduction_capacity != nil {
		*m.addproduction_capacity += f
	} else {
		m.addproduction_capacity = &f
	}
}

// AddedProductionCapacity returns the value that was added to the "production_capacity" field in this mutation.
func (m *FixedAssetMutation) AddedProductionCapacity() (r float64, exists bool) {
	v := m.addproduction_capacity
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductionCapacity clears the value of the "production_capacity" field.
func (m *FixedAssetMutation) ClearProductionCapacity() {
	m.production_capacity = nil
	m.addproduction_capacity = nil
	m.clearedFields[fixedasset.FieldProductionCapacity] = struct{}{}
}

// ProductionCapacityCleared returns if the "production_capacity" field was cleared in this mutation.
func (m *FixedAssetMutation) ProductionCapacityCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldProductionCapacity]
	return ok
}

// ResetProductionCapacity resets all changes to the "production_capacity" field.
func (m *FixedAssetMutation) ResetProductionCapacity() {
	m.production_capacity = nil
	m.addproduction_capacity = nil
	delete(m.clearedFields, fixedasset.FieldProductionCapacity)
}

// SetUomID sets the "uom_id" field.
func (m *FixedAssetMutation) SetUomID(i int) {
	m.uom_id = &i
	m.adduom_id = nil
}

// UomID returns the value of the "uom_id" field in the mutation.
func (m *FixedAssetMutation) UomID() (r int, exists bool) {
	v := m.uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUomID returns the old "uom_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUomID: %w", err)
	}
	return oldValue.UomID, nil
}

// AddUomID adds i to the "uom_id" field.
func (m *FixedAssetMutation) AddUomID(i int) {
	if m.adduom_id != nil {
		*m.adduom_id += i
	} else {
		m.adduom_id = &i
	}
}

// AddedUomID returns the value that was added to the "uom_id" field in this mutation.
func (m *FixedAssetMutation) AddedUomID() (r int, exists bool) {
	v := m.adduom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUomID clears the value of the "uom_id" field.
func (m *FixedAssetMutation) ClearUomID() {
	m.uom_id = nil
	m.adduom_id = nil
	m.clearedFields[fixedasset.FieldUomID] = struct{}{}
}

// UomIDCleared returns if the "uom_id" field was cleared in this mutation.
func (m *FixedAssetMutation) UomIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldUomID]
	return ok
}

// ResetUomID resets all changes to the "uom_id" field.
func (m *FixedAssetMutation) ResetUomID() {
	m.uom_id = nil
	m.adduom_id = nil
	delete(m.clearedFields, fixedasset.FieldUomID)
}

// SetCalendarID sets the "calendar_id" field.
func (m *FixedAssetMutation) SetCalendarID(i int) {
	m.calendar_id = &i
	m.addcalendar_id = nil
}

// CalendarID returns the value of the "calendar_id" field in the mutation.
func (m *FixedAssetMutation) CalendarID() (r int, exists bool) {
	v := m.calendar_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCalendarID returns the old "calendar_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldCalendarID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalendarID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalendarID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalendarID: %w", err)
	}
	return oldValue.CalendarID, nil
}

// AddCalendarID adds i to the "calendar_id" field.
func (m *FixedAssetMutation) AddCalendarID(i int) {
	if m.addcalendar_id != nil {
		*m.addcalendar_id += i
	} else {
		m.addcalendar_id = &i
	}
}

// AddedCalendarID returns the value that was added to the "calendar_id" field in this mutation.
func (m *FixedAssetMutation) AddedCalendarID() (r int, exists bool) {
	v := m.addcalendar_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCalendarID clears the value of the "calendar_id" field.
func (m *FixedAssetMutation) ClearCalendarID() {
	m.calendar_id = nil
	m.addcalendar_id = nil
	m.clearedFields[fixedasset.FieldCalendarID] = struct{}{}
}

// CalendarIDCleared returns if the "calendar_id" field was cleared in this mutation.
func (m *FixedAssetMutation) CalendarIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldCalendarID]
	return ok
}

// ResetCalendarID resets all changes to the "calendar_id" field.
func (m *FixedAssetMutation) ResetCalendarID() {
	m.calendar_id = nil
	m.addcalendar_id = nil
	delete(m.clearedFields, fixedasset.FieldCalendarID)
}

// SetSerialNumber sets the "serial_number" field.
func (m *FixedAssetMutation) SetSerialNumber(s string) {
	m.serial_number = &s
}

// SerialNumber returns the value of the "serial_number" field in the mutation.
func (m *FixedAssetMutation) SerialNumber() (r string, exists bool) {
	v := m.serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSerialNumber returns the old "serial_number" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerialNumber: %w", err)
	}
	return oldValue.SerialNumber, nil
}

// ClearSerialNumber clears the value of the "serial_number" field.
func (m *FixedAssetMutation) ClearSerialNumber() {
	m.serial_number = nil
	m.clearedFields[fixedasset.FieldSerialNumber] = struct{}{}
}

// SerialNumberCleared returns if the "serial_number" field was cleared in this mutation.
func (m *FixedAssetMutation) SerialNumberCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldSerialNumber]
	return ok
}

// ResetSerialNumber resets all changes to the "serial_number" field.
func (m *FixedAssetMutation) ResetSerialNumber() {
	m.serial_number = nil
	delete(m.clearedFields, fixedasset.FieldSerialNumber)
}

// SetLocatedAtFacilityID sets the "located_at_facility_id" field.
func (m *FixedAssetMutation) SetLocatedAtFacilityID(i int) {
	m.located_at_facility_id = &i
	m.addlocated_at_facility_id = nil
}

// LocatedAtFacilityID returns the value of the "located_at_facility_id" field in the mutation.
func (m *FixedAssetMutation) LocatedAtFacilityID() (r int, exists bool) {
	v := m.located_at_facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocatedAtFacilityID returns the old "located_at_facility_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldLocatedAtFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocatedAtFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocatedAtFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocatedAtFacilityID: %w", err)
	}
	return oldValue.LocatedAtFacilityID, nil
}

// AddLocatedAtFacilityID adds i to the "located_at_facility_id" field.
func (m *FixedAssetMutation) AddLocatedAtFacilityID(i int) {
	if m.addlocated_at_facility_id != nil {
		*m.addlocated_at_facility_id += i
	} else {
		m.addlocated_at_facility_id = &i
	}
}

// AddedLocatedAtFacilityID returns the value that was added to the "located_at_facility_id" field in this mutation.
func (m *FixedAssetMutation) AddedLocatedAtFacilityID() (r int, exists bool) {
	v := m.addlocated_at_facility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocatedAtFacilityID clears the value of the "located_at_facility_id" field.
func (m *FixedAssetMutation) ClearLocatedAtFacilityID() {
	m.located_at_facility_id = nil
	m.addlocated_at_facility_id = nil
	m.clearedFields[fixedasset.FieldLocatedAtFacilityID] = struct{}{}
}

// LocatedAtFacilityIDCleared returns if the "located_at_facility_id" field was cleared in this mutation.
func (m *FixedAssetMutation) LocatedAtFacilityIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldLocatedAtFacilityID]
	return ok
}

// ResetLocatedAtFacilityID resets all changes to the "located_at_facility_id" field.
func (m *FixedAssetMutation) ResetLocatedAtFacilityID() {
	m.located_at_facility_id = nil
	m.addlocated_at_facility_id = nil
	delete(m.clearedFields, fixedasset.FieldLocatedAtFacilityID)
}

// SetLocatedAtLocationSeqID sets the "located_at_location_seq_id" field.
func (m *FixedAssetMutation) SetLocatedAtLocationSeqID(i int) {
	m.located_at_location_seq_id = &i
	m.addlocated_at_location_seq_id = nil
}

// LocatedAtLocationSeqID returns the value of the "located_at_location_seq_id" field in the mutation.
func (m *FixedAssetMutation) LocatedAtLocationSeqID() (r int, exists bool) {
	v := m.located_at_location_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocatedAtLocationSeqID returns the old "located_at_location_seq_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldLocatedAtLocationSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocatedAtLocationSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocatedAtLocationSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocatedAtLocationSeqID: %w", err)
	}
	return oldValue.LocatedAtLocationSeqID, nil
}

// AddLocatedAtLocationSeqID adds i to the "located_at_location_seq_id" field.
func (m *FixedAssetMutation) AddLocatedAtLocationSeqID(i int) {
	if m.addlocated_at_location_seq_id != nil {
		*m.addlocated_at_location_seq_id += i
	} else {
		m.addlocated_at_location_seq_id = &i
	}
}

// AddedLocatedAtLocationSeqID returns the value that was added to the "located_at_location_seq_id" field in this mutation.
func (m *FixedAssetMutation) AddedLocatedAtLocationSeqID() (r int, exists bool) {
	v := m.addlocated_at_location_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocatedAtLocationSeqID clears the value of the "located_at_location_seq_id" field.
func (m *FixedAssetMutation) ClearLocatedAtLocationSeqID() {
	m.located_at_location_seq_id = nil
	m.addlocated_at_location_seq_id = nil
	m.clearedFields[fixedasset.FieldLocatedAtLocationSeqID] = struct{}{}
}

// LocatedAtLocationSeqIDCleared returns if the "located_at_location_seq_id" field was cleared in this mutation.
func (m *FixedAssetMutation) LocatedAtLocationSeqIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldLocatedAtLocationSeqID]
	return ok
}

// ResetLocatedAtLocationSeqID resets all changes to the "located_at_location_seq_id" field.
func (m *FixedAssetMutation) ResetLocatedAtLocationSeqID() {
	m.located_at_location_seq_id = nil
	m.addlocated_at_location_seq_id = nil
	delete(m.clearedFields, fixedasset.FieldLocatedAtLocationSeqID)
}

// SetSalvageValue sets the "salvage_value" field.
func (m *FixedAssetMutation) SetSalvageValue(f float64) {
	m.salvage_value = &f
	m.addsalvage_value = nil
}

// SalvageValue returns the value of the "salvage_value" field in the mutation.
func (m *FixedAssetMutation) SalvageValue() (r float64, exists bool) {
	v := m.salvage_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSalvageValue returns the old "salvage_value" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldSalvageValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalvageValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalvageValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalvageValue: %w", err)
	}
	return oldValue.SalvageValue, nil
}

// AddSalvageValue adds f to the "salvage_value" field.
func (m *FixedAssetMutation) AddSalvageValue(f float64) {
	if m.addsalvage_value != nil {
		*m.addsalvage_value += f
	} else {
		m.addsalvage_value = &f
	}
}

// AddedSalvageValue returns the value that was added to the "salvage_value" field in this mutation.
func (m *FixedAssetMutation) AddedSalvageValue() (r float64, exists bool) {
	v := m.addsalvage_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalvageValue clears the value of the "salvage_value" field.
func (m *FixedAssetMutation) ClearSalvageValue() {
	m.salvage_value = nil
	m.addsalvage_value = nil
	m.clearedFields[fixedasset.FieldSalvageValue] = struct{}{}
}

// SalvageValueCleared returns if the "salvage_value" field was cleared in this mutation.
func (m *FixedAssetMutation) SalvageValueCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldSalvageValue]
	return ok
}

// ResetSalvageValue resets all changes to the "salvage_value" field.
func (m *FixedAssetMutation) ResetSalvageValue() {
	m.salvage_value = nil
	m.addsalvage_value = nil
	delete(m.clearedFields, fixedasset.FieldSalvageValue)
}

// SetDepreciation sets the "depreciation" field.
func (m *FixedAssetMutation) SetDepreciation(f float64) {
	m.depreciation = &f
	m.adddepreciation = nil
}

// Depreciation returns the value of the "depreciation" field in the mutation.
func (m *FixedAssetMutation) Depreciation() (r float64, exists bool) {
	v := m.depreciation
	if v == nil {
		return
	}
	return *v, true
}

// OldDepreciation returns the old "depreciation" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldDepreciation(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepreciation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepreciation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepreciation: %w", err)
	}
	return oldValue.Depreciation, nil
}

// AddDepreciation adds f to the "depreciation" field.
func (m *FixedAssetMutation) AddDepreciation(f float64) {
	if m.adddepreciation != nil {
		*m.adddepreciation += f
	} else {
		m.adddepreciation = &f
	}
}

// AddedDepreciation returns the value that was added to the "depreciation" field in this mutation.
func (m *FixedAssetMutation) AddedDepreciation() (r float64, exists bool) {
	v := m.adddepreciation
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepreciation clears the value of the "depreciation" field.
func (m *FixedAssetMutation) ClearDepreciation() {
	m.depreciation = nil
	m.adddepreciation = nil
	m.clearedFields[fixedasset.FieldDepreciation] = struct{}{}
}

// DepreciationCleared returns if the "depreciation" field was cleared in this mutation.
func (m *FixedAssetMutation) DepreciationCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldDepreciation]
	return ok
}

// ResetDepreciation resets all changes to the "depreciation" field.
func (m *FixedAssetMutation) ResetDepreciation() {
	m.depreciation = nil
	m.adddepreciation = nil
	delete(m.clearedFields, fixedasset.FieldDepreciation)
}

// SetPurchaseCost sets the "purchase_cost" field.
func (m *FixedAssetMutation) SetPurchaseCost(f float64) {
	m.purchase_cost = &f
	m.addpurchase_cost = nil
}

// PurchaseCost returns the value of the "purchase_cost" field in the mutation.
func (m *FixedAssetMutation) PurchaseCost() (r float64, exists bool) {
	v := m.purchase_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseCost returns the old "purchase_cost" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldPurchaseCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPurchaseCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPurchaseCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseCost: %w", err)
	}
	return oldValue.PurchaseCost, nil
}

// AddPurchaseCost adds f to the "purchase_cost" field.
func (m *FixedAssetMutation) AddPurchaseCost(f float64) {
	if m.addpurchase_cost != nil {
		*m.addpurchase_cost += f
	} else {
		m.addpurchase_cost = &f
	}
}

// AddedPurchaseCost returns the value that was added to the "purchase_cost" field in this mutation.
func (m *FixedAssetMutation) AddedPurchaseCost() (r float64, exists bool) {
	v := m.addpurchase_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearPurchaseCost clears the value of the "purchase_cost" field.
func (m *FixedAssetMutation) ClearPurchaseCost() {
	m.purchase_cost = nil
	m.addpurchase_cost = nil
	m.clearedFields[fixedasset.FieldPurchaseCost] = struct{}{}
}

// PurchaseCostCleared returns if the "purchase_cost" field was cleared in this mutation.
func (m *FixedAssetMutation) PurchaseCostCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldPurchaseCost]
	return ok
}

// ResetPurchaseCost resets all changes to the "purchase_cost" field.
func (m *FixedAssetMutation) ResetPurchaseCost() {
	m.purchase_cost = nil
	m.addpurchase_cost = nil
	delete(m.clearedFields, fixedasset.FieldPurchaseCost)
}

// SetPurchaseCostUomID sets the "purchase_cost_uom_id" field.
func (m *FixedAssetMutation) SetPurchaseCostUomID(i int) {
	m.purchase_cost_uom_id = &i
	m.addpurchase_cost_uom_id = nil
}

// PurchaseCostUomID returns the value of the "purchase_cost_uom_id" field in the mutation.
func (m *FixedAssetMutation) PurchaseCostUomID() (r int, exists bool) {
	v := m.purchase_cost_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseCostUomID returns the old "purchase_cost_uom_id" field's value of the FixedAsset entity.
// If the FixedAsset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixedAssetMutation) OldPurchaseCostUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPurchaseCostUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPurchaseCostUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseCostUomID: %w", err)
	}
	return oldValue.PurchaseCostUomID, nil
}

// AddPurchaseCostUomID adds i to the "purchase_cost_uom_id" field.
func (m *FixedAssetMutation) AddPurchaseCostUomID(i int) {
	if m.addpurchase_cost_uom_id != nil {
		*m.addpurchase_cost_uom_id += i
	} else {
		m.addpurchase_cost_uom_id = &i
	}
}

// AddedPurchaseCostUomID returns the value that was added to the "purchase_cost_uom_id" field in this mutation.
func (m *FixedAssetMutation) AddedPurchaseCostUomID() (r int, exists bool) {
	v := m.addpurchase_cost_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPurchaseCostUomID clears the value of the "purchase_cost_uom_id" field.
func (m *FixedAssetMutation) ClearPurchaseCostUomID() {
	m.purchase_cost_uom_id = nil
	m.addpurchase_cost_uom_id = nil
	m.clearedFields[fixedasset.FieldPurchaseCostUomID] = struct{}{}
}

// PurchaseCostUomIDCleared returns if the "purchase_cost_uom_id" field was cleared in this mutation.
func (m *FixedAssetMutation) PurchaseCostUomIDCleared() bool {
	_, ok := m.clearedFields[fixedasset.FieldPurchaseCostUomID]
	return ok
}

// ResetPurchaseCostUomID resets all changes to the "purchase_cost_uom_id" field.
func (m *FixedAssetMutation) ResetPurchaseCostUomID() {
	m.purchase_cost_uom_id = nil
	m.addpurchase_cost_uom_id = nil
	delete(m.clearedFields, fixedasset.FieldPurchaseCostUomID)
}

// SetParentID sets the "parent" edge to the FixedAsset entity by id.
func (m *FixedAssetMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FixedAsset entity.
func (m *FixedAssetMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FixedAsset entity was cleared.
func (m *FixedAssetMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FixedAssetMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FixedAssetMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FixedAssetMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the FixedAsset entity by ids.
func (m *FixedAssetMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the FixedAsset entity.
func (m *FixedAssetMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the FixedAsset entity was cleared.
func (m *FixedAssetMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the FixedAsset entity by IDs.
func (m *FixedAssetMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the FixedAsset entity.
func (m *FixedAssetMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FixedAssetMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FixedAssetMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *FixedAssetMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *FixedAssetMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *FixedAssetMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *FixedAssetMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *FixedAssetMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *FixedAssetMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// SetPartyRoleID sets the "party_role" edge to the PartyRole entity by id.
func (m *FixedAssetMutation) SetPartyRoleID(id int) {
	m.party_role = &id
}

// ClearPartyRole clears the "party_role" edge to the PartyRole entity.
func (m *FixedAssetMutation) ClearPartyRole() {
	m.clearedparty_role = true
}

// PartyRoleCleared reports if the "party_role" edge to the PartyRole entity was cleared.
func (m *FixedAssetMutation) PartyRoleCleared() bool {
	return m.clearedparty_role
}

// PartyRoleID returns the "party_role" edge ID in the mutation.
func (m *FixedAssetMutation) PartyRoleID() (id int, exists bool) {
	if m.party_role != nil {
		return *m.party_role, true
	}
	return
}

// PartyRoleIDs returns the "party_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyRoleID instead. It exists only for internal usage by the builders.
func (m *FixedAssetMutation) PartyRoleIDs() (ids []int) {
	if id := m.party_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartyRole resets all changes to the "party_role" edge.
func (m *FixedAssetMutation) ResetPartyRole() {
	m.party_role = nil
	m.clearedparty_role = false
}

// AddChildFixedAssetIDs adds the "child_fixed_assets" edge to the FixedAsset entity by ids.
func (m *FixedAssetMutation) AddChildFixedAssetIDs(ids ...int) {
	if m.child_fixed_assets == nil {
		m.child_fixed_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.child_fixed_assets[ids[i]] = struct{}{}
	}
}

// ClearChildFixedAssets clears the "child_fixed_assets" edge to the FixedAsset entity.
func (m *FixedAssetMutation) ClearChildFixedAssets() {
	m.clearedchild_fixed_assets = true
}

// ChildFixedAssetsCleared reports if the "child_fixed_assets" edge to the FixedAsset entity was cleared.
func (m *FixedAssetMutation) ChildFixedAssetsCleared() bool {
	return m.clearedchild_fixed_assets
}

// RemoveChildFixedAssetIDs removes the "child_fixed_assets" edge to the FixedAsset entity by IDs.
func (m *FixedAssetMutation) RemoveChildFixedAssetIDs(ids ...int) {
	if m.removedchild_fixed_assets == nil {
		m.removedchild_fixed_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_fixed_assets[ids[i]] = struct{}{}
	}
}

// RemovedChildFixedAssets returns the removed IDs of the "child_fixed_assets" edge to the FixedAsset entity.
func (m *FixedAssetMutation) RemovedChildFixedAssetsIDs() (ids []int) {
	for id := range m.removedchild_fixed_assets {
		ids = append(ids, id)
	}
	return
}

// ChildFixedAssetsIDs returns the "child_fixed_assets" edge IDs in the mutation.
func (m *FixedAssetMutation) ChildFixedAssetsIDs() (ids []int) {
	for id := range m.child_fixed_assets {
		ids = append(ids, id)
	}
	return
}

// ResetChildFixedAssets resets all changes to the "child_fixed_assets" edge.
func (m *FixedAssetMutation) ResetChildFixedAssets() {
	m.child_fixed_assets = nil
	m.clearedchild_fixed_assets = false
	m.removedchild_fixed_assets = nil
}

// AddWorkEffortIDs adds the "work_efforts" edge to the WorkEffort entity by ids.
func (m *FixedAssetMutation) AddWorkEffortIDs(ids ...int) {
	if m.work_efforts == nil {
		m.work_efforts = make(map[int]struct{})
	}
	for i := range ids {
		m.work_efforts[ids[i]] = struct{}{}
	}
}

// ClearWorkEfforts clears the "work_efforts" edge to the WorkEffort entity.
func (m *FixedAssetMutation) ClearWorkEfforts() {
	m.clearedwork_efforts = true
}

// WorkEffortsCleared reports if the "work_efforts" edge to the WorkEffort entity was cleared.
func (m *FixedAssetMutation) WorkEffortsCleared() bool {
	return m.clearedwork_efforts
}

// RemoveWorkEffortIDs removes the "work_efforts" edge to the WorkEffort entity by IDs.
func (m *FixedAssetMutation) RemoveWorkEffortIDs(ids ...int) {
	if m.removedwork_efforts == nil {
		m.removedwork_efforts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_efforts[ids[i]] = struct{}{}
	}
}

// RemovedWorkEfforts returns the removed IDs of the "work_efforts" edge to the WorkEffort entity.
func (m *FixedAssetMutation) RemovedWorkEffortsIDs() (ids []int) {
	for id := range m.removedwork_efforts {
		ids = append(ids, id)
	}
	return
}

// WorkEffortsIDs returns the "work_efforts" edge IDs in the mutation.
func (m *FixedAssetMutation) WorkEffortsIDs() (ids []int) {
	for id := range m.work_efforts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEfforts resets all changes to the "work_efforts" edge.
func (m *FixedAssetMutation) ResetWorkEfforts() {
	m.work_efforts = nil
	m.clearedwork_efforts = false
	m.removedwork_efforts = nil
}

// AddWorkEffortFixedAssetAssignIDs adds the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity by ids.
func (m *FixedAssetMutation) AddWorkEffortFixedAssetAssignIDs(ids ...int) {
	if m.work_effort_fixed_asset_assigns == nil {
		m.work_effort_fixed_asset_assigns = make(map[int]struct{})
	}
	for i := range ids {
		m.work_effort_fixed_asset_assigns[ids[i]] = struct{}{}
	}
}

// ClearWorkEffortFixedAssetAssigns clears the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity.
func (m *FixedAssetMutation) ClearWorkEffortFixedAssetAssigns() {
	m.clearedwork_effort_fixed_asset_assigns = true
}

// WorkEffortFixedAssetAssignsCleared reports if the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity was cleared.
func (m *FixedAssetMutation) WorkEffortFixedAssetAssignsCleared() bool {
	return m.clearedwork_effort_fixed_asset_assigns
}

// RemoveWorkEffortFixedAssetAssignIDs removes the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity by IDs.
func (m *FixedAssetMutation) RemoveWorkEffortFixedAssetAssignIDs(ids ...int) {
	if m.removedwork_effort_fixed_asset_assigns == nil {
		m.removedwork_effort_fixed_asset_assigns = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_effort_fixed_asset_assigns[ids[i]] = struct{}{}
	}
}

// RemovedWorkEffortFixedAssetAssigns returns the removed IDs of the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity.
func (m *FixedAssetMutation) RemovedWorkEffortFixedAssetAssignsIDs() (ids []int) {
	for id := range m.removedwork_effort_fixed_asset_assigns {
		ids = append(ids, id)
	}
	return
}

// WorkEffortFixedAssetAssignsIDs returns the "work_effort_fixed_asset_assigns" edge IDs in the mutation.
func (m *FixedAssetMutation) WorkEffortFixedAssetAssignsIDs() (ids []int) {
	for id := range m.work_effort_fixed_asset_assigns {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEffortFixedAssetAssigns resets all changes to the "work_effort_fixed_asset_assigns" edge.
func (m *FixedAssetMutation) ResetWorkEffortFixedAssetAssigns() {
	m.work_effort_fixed_asset_assigns = nil
	m.clearedwork_effort_fixed_asset_assigns = false
	m.removedwork_effort_fixed_asset_assigns = nil
}

// Op returns the operation name.
func (m *FixedAssetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FixedAsset).
func (m *FixedAssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FixedAssetMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.fixed_asset_type_id != nil {
		fields = append(fields, fixedasset.FieldFixedAssetTypeID)
	}
	if m.instance_of_product_id != nil {
		fields = append(fields, fixedasset.FieldInstanceOfProductID)
	}
	if m.class_enum_id != nil {
		fields = append(fields, fixedasset.FieldClassEnumID)
	}
	if m.role_type_id != nil {
		fields = append(fields, fixedasset.FieldRoleTypeID)
	}
	if m.fixed_asset_name != nil {
		fields = append(fields, fixedasset.FieldFixedAssetName)
	}
	if m.acquire_order_id != nil {
		fields = append(fields, fixedasset.FieldAcquireOrderID)
	}
	if m.acquire_order_item_seq_id != nil {
		fields = append(fields, fixedasset.FieldAcquireOrderItemSeqID)
	}
	if m.date_acquired != nil {
		fields = append(fields, fixedasset.FieldDateAcquired)
	}
	if m.date_last_serviced != nil {
		fields = append(fields, fixedasset.FieldDateLastServiced)
	}
	if m.date_next_service != nil {
		fields = append(fields, fixedasset.FieldDateNextService)
	}
	if m.expected_end_of_life != nil {
		fields = append(fields, fixedasset.FieldExpectedEndOfLife)
	}
	if m.actual_end_of_life != nil {
		fields = append(fields, fixedasset.FieldActualEndOfLife)
	}
	if m.production_capacity != nil {
		fields = append(fields, fixedasset.FieldProductionCapacity)
	}
	if m.uom_id != nil {
		fields = append(fields, fixedasset.FieldUomID)
	}
	if m.calendar_id != nil {
		fields = append(fields, fixedasset.FieldCalendarID)
	}
	if m.serial_number != nil {
		fields = append(fields, fixedasset.FieldSerialNumber)
	}
	if m.located_at_facility_id != nil {
		fields = append(fields, fixedasset.FieldLocatedAtFacilityID)
	}
	if m.located_at_location_seq_id != nil {
		fields = append(fields, fixedasset.FieldLocatedAtLocationSeqID)
	}
	if m.salvage_value != nil {
		fields = append(fields, fixedasset.FieldSalvageValue)
	}
	if m.depreciation != nil {
		fields = append(fields, fixedasset.FieldDepreciation)
	}
	if m.purchase_cost != nil {
		fields = append(fields, fixedasset.FieldPurchaseCost)
	}
	if m.purchase_cost_uom_id != nil {
		fields = append(fields, fixedasset.FieldPurchaseCostUomID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FixedAssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		return m.FixedAssetTypeID()
	case fixedasset.FieldInstanceOfProductID:
		return m.InstanceOfProductID()
	case fixedasset.FieldClassEnumID:
		return m.ClassEnumID()
	case fixedasset.FieldRoleTypeID:
		return m.RoleTypeID()
	case fixedasset.FieldFixedAssetName:
		return m.FixedAssetName()
	case fixedasset.FieldAcquireOrderID:
		return m.AcquireOrderID()
	case fixedasset.FieldAcquireOrderItemSeqID:
		return m.AcquireOrderItemSeqID()
	case fixedasset.FieldDateAcquired:
		return m.DateAcquired()
	case fixedasset.FieldDateLastServiced:
		return m.DateLastServiced()
	case fixedasset.FieldDateNextService:
		return m.DateNextService()
	case fixedasset.FieldExpectedEndOfLife:
		return m.ExpectedEndOfLife()
	case fixedasset.FieldActualEndOfLife:
		return m.ActualEndOfLife()
	case fixedasset.FieldProductionCapacity:
		return m.ProductionCapacity()
	case fixedasset.FieldUomID:
		return m.UomID()
	case fixedasset.FieldCalendarID:
		return m.CalendarID()
	case fixedasset.FieldSerialNumber:
		return m.SerialNumber()
	case fixedasset.FieldLocatedAtFacilityID:
		return m.LocatedAtFacilityID()
	case fixedasset.FieldLocatedAtLocationSeqID:
		return m.LocatedAtLocationSeqID()
	case fixedasset.FieldSalvageValue:
		return m.SalvageValue()
	case fixedasset.FieldDepreciation:
		return m.Depreciation()
	case fixedasset.FieldPurchaseCost:
		return m.PurchaseCost()
	case fixedasset.FieldPurchaseCostUomID:
		return m.PurchaseCostUomID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FixedAssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		return m.OldFixedAssetTypeID(ctx)
	case fixedasset.FieldInstanceOfProductID:
		return m.OldInstanceOfProductID(ctx)
	case fixedasset.FieldClassEnumID:
		return m.OldClassEnumID(ctx)
	case fixedasset.FieldRoleTypeID:
		return m.OldRoleTypeID(ctx)
	case fixedasset.FieldFixedAssetName:
		return m.OldFixedAssetName(ctx)
	case fixedasset.FieldAcquireOrderID:
		return m.OldAcquireOrderID(ctx)
	case fixedasset.FieldAcquireOrderItemSeqID:
		return m.OldAcquireOrderItemSeqID(ctx)
	case fixedasset.FieldDateAcquired:
		return m.OldDateAcquired(ctx)
	case fixedasset.FieldDateLastServiced:
		return m.OldDateLastServiced(ctx)
	case fixedasset.FieldDateNextService:
		return m.OldDateNextService(ctx)
	case fixedasset.FieldExpectedEndOfLife:
		return m.OldExpectedEndOfLife(ctx)
	case fixedasset.FieldActualEndOfLife:
		return m.OldActualEndOfLife(ctx)
	case fixedasset.FieldProductionCapacity:
		return m.OldProductionCapacity(ctx)
	case fixedasset.FieldUomID:
		return m.OldUomID(ctx)
	case fixedasset.FieldCalendarID:
		return m.OldCalendarID(ctx)
	case fixedasset.FieldSerialNumber:
		return m.OldSerialNumber(ctx)
	case fixedasset.FieldLocatedAtFacilityID:
		return m.OldLocatedAtFacilityID(ctx)
	case fixedasset.FieldLocatedAtLocationSeqID:
		return m.OldLocatedAtLocationSeqID(ctx)
	case fixedasset.FieldSalvageValue:
		return m.OldSalvageValue(ctx)
	case fixedasset.FieldDepreciation:
		return m.OldDepreciation(ctx)
	case fixedasset.FieldPurchaseCost:
		return m.OldPurchaseCost(ctx)
	case fixedasset.FieldPurchaseCostUomID:
		return m.OldPurchaseCostUomID(ctx)
	}
	return nil, fmt.Errorf("unknown FixedAsset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixedAssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedAssetTypeID(v)
		return nil
	case fixedasset.FieldInstanceOfProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceOfProductID(v)
		return nil
	case fixedasset.FieldClassEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassEnumID(v)
		return nil
	case fixedasset.FieldRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleTypeID(v)
		return nil
	case fixedasset.FieldFixedAssetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedAssetName(v)
		return nil
	case fixedasset.FieldAcquireOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcquireOrderID(v)
		return nil
	case fixedasset.FieldAcquireOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcquireOrderItemSeqID(v)
		return nil
	case fixedasset.FieldDateAcquired:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateAcquired(v)
		return nil
	case fixedasset.FieldDateLastServiced:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateLastServiced(v)
		return nil
	case fixedasset.FieldDateNextService:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateNextService(v)
		return nil
	case fixedasset.FieldExpectedEndOfLife:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedEndOfLife(v)
		return nil
	case fixedasset.FieldActualEndOfLife:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualEndOfLife(v)
		return nil
	case fixedasset.FieldProductionCapacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductionCapacity(v)
		return nil
	case fixedasset.FieldUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUomID(v)
		return nil
	case fixedasset.FieldCalendarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalendarID(v)
		return nil
	case fixedasset.FieldSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerialNumber(v)
		return nil
	case fixedasset.FieldLocatedAtFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocatedAtFacilityID(v)
		return nil
	case fixedasset.FieldLocatedAtLocationSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocatedAtLocationSeqID(v)
		return nil
	case fixedasset.FieldSalvageValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalvageValue(v)
		return nil
	case fixedasset.FieldDepreciation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepreciation(v)
		return nil
	case fixedasset.FieldPurchaseCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseCost(v)
		return nil
	case fixedasset.FieldPurchaseCostUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseCostUomID(v)
		return nil
	}
	return fmt.Errorf("unknown FixedAsset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FixedAssetMutation) AddedFields() []string {
	var fields []string
	if m.addfixed_asset_type_id != nil {
		fields = append(fields, fixedasset.FieldFixedAssetTypeID)
	}
	if m.addinstance_of_product_id != nil {
		fields = append(fields, fixedasset.FieldInstanceOfProductID)
	}
	if m.addclass_enum_id != nil {
		fields = append(fields, fixedasset.FieldClassEnumID)
	}
	if m.addrole_type_id != nil {
		fields = append(fields, fixedasset.FieldRoleTypeID)
	}
	if m.addacquire_order_id != nil {
		fields = append(fields, fixedasset.FieldAcquireOrderID)
	}
	if m.addacquire_order_item_seq_id != nil {
		fields = append(fields, fixedasset.FieldAcquireOrderItemSeqID)
	}
	if m.addproduction_capacity != nil {
		fields = append(fields, fixedasset.FieldProductionCapacity)
	}
	if m.adduom_id != nil {
		fields = append(fields, fixedasset.FieldUomID)
	}
	if m.addcalendar_id != nil {
		fields = append(fields, fixedasset.FieldCalendarID)
	}
	if m.addlocated_at_facility_id != nil {
		fields = append(fields, fixedasset.FieldLocatedAtFacilityID)
	}
	if m.addlocated_at_location_seq_id != nil {
		fields = append(fields, fixedasset.FieldLocatedAtLocationSeqID)
	}
	if m.addsalvage_value != nil {
		fields = append(fields, fixedasset.FieldSalvageValue)
	}
	if m.adddepreciation != nil {
		fields = append(fields, fixedasset.FieldDepreciation)
	}
	if m.addpurchase_cost != nil {
		fields = append(fields, fixedasset.FieldPurchaseCost)
	}
	if m.addpurchase_cost_uom_id != nil {
		fields = append(fields, fixedasset.FieldPurchaseCostUomID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FixedAssetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		return m.AddedFixedAssetTypeID()
	case fixedasset.FieldInstanceOfProductID:
		return m.AddedInstanceOfProductID()
	case fixedasset.FieldClassEnumID:
		return m.AddedClassEnumID()
	case fixedasset.FieldRoleTypeID:
		return m.AddedRoleTypeID()
	case fixedasset.FieldAcquireOrderID:
		return m.AddedAcquireOrderID()
	case fixedasset.FieldAcquireOrderItemSeqID:
		return m.AddedAcquireOrderItemSeqID()
	case fixedasset.FieldProductionCapacity:
		return m.AddedProductionCapacity()
	case fixedasset.FieldUomID:
		return m.AddedUomID()
	case fixedasset.FieldCalendarID:
		return m.AddedCalendarID()
	case fixedasset.FieldLocatedAtFacilityID:
		return m.AddedLocatedAtFacilityID()
	case fixedasset.FieldLocatedAtLocationSeqID:
		return m.AddedLocatedAtLocationSeqID()
	case fixedasset.FieldSalvageValue:
		return m.AddedSalvageValue()
	case fixedasset.FieldDepreciation:
		return m.AddedDepreciation()
	case fixedasset.FieldPurchaseCost:
		return m.AddedPurchaseCost()
	case fixedasset.FieldPurchaseCostUomID:
		return m.AddedPurchaseCostUomID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixedAssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedAssetTypeID(v)
		return nil
	case fixedasset.FieldInstanceOfProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInstanceOfProductID(v)
		return nil
	case fixedasset.FieldClassEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClassEnumID(v)
		return nil
	case fixedasset.FieldRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleTypeID(v)
		return nil
	case fixedasset.FieldAcquireOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcquireOrderID(v)
		return nil
	case fixedasset.FieldAcquireOrderItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAcquireOrderItemSeqID(v)
		return nil
	case fixedasset.FieldProductionCapacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductionCapacity(v)
		return nil
	case fixedasset.FieldUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUomID(v)
		return nil
	case fixedasset.FieldCalendarID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalendarID(v)
		return nil
	case fixedasset.FieldLocatedAtFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocatedAtFacilityID(v)
		return nil
	case fixedasset.FieldLocatedAtLocationSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocatedAtLocationSeqID(v)
		return nil
	case fixedasset.FieldSalvageValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalvageValue(v)
		return nil
	case fixedasset.FieldDepreciation:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepreciation(v)
		return nil
	case fixedasset.FieldPurchaseCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseCost(v)
		return nil
	case fixedasset.FieldPurchaseCostUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseCostUomID(v)
		return nil
	}
	return fmt.Errorf("unknown FixedAsset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FixedAssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fixedasset.FieldFixedAssetTypeID) {
		fields = append(fields, fixedasset.FieldFixedAssetTypeID)
	}
	if m.FieldCleared(fixedasset.FieldInstanceOfProductID) {
		fields = append(fields, fixedasset.FieldInstanceOfProductID)
	}
	if m.FieldCleared(fixedasset.FieldClassEnumID) {
		fields = append(fields, fixedasset.FieldClassEnumID)
	}
	if m.FieldCleared(fixedasset.FieldRoleTypeID) {
		fields = append(fields, fixedasset.FieldRoleTypeID)
	}
	if m.FieldCleared(fixedasset.FieldFixedAssetName) {
		fields = append(fields, fixedasset.FieldFixedAssetName)
	}
	if m.FieldCleared(fixedasset.FieldAcquireOrderID) {
		fields = append(fields, fixedasset.FieldAcquireOrderID)
	}
	if m.FieldCleared(fixedasset.FieldAcquireOrderItemSeqID) {
		fields = append(fields, fixedasset.FieldAcquireOrderItemSeqID)
	}
	if m.FieldCleared(fixedasset.FieldDateAcquired) {
		fields = append(fields, fixedasset.FieldDateAcquired)
	}
	if m.FieldCleared(fixedasset.FieldDateLastServiced) {
		fields = append(fields, fixedasset.FieldDateLastServiced)
	}
	if m.FieldCleared(fixedasset.FieldDateNextService) {
		fields = append(fields, fixedasset.FieldDateNextService)
	}
	if m.FieldCleared(fixedasset.FieldExpectedEndOfLife) {
		fields = append(fields, fixedasset.FieldExpectedEndOfLife)
	}
	if m.FieldCleared(fixedasset.FieldActualEndOfLife) {
		fields = append(fields, fixedasset.FieldActualEndOfLife)
	}
	if m.FieldCleared(fixedasset.FieldProductionCapacity) {
		fields = append(fields, fixedasset.FieldProductionCapacity)
	}
	if m.FieldCleared(fixedasset.FieldUomID) {
		fields = append(fields, fixedasset.FieldUomID)
	}
	if m.FieldCleared(fixedasset.FieldCalendarID) {
		fields = append(fields, fixedasset.FieldCalendarID)
	}
	if m.FieldCleared(fixedasset.FieldSerialNumber) {
		fields = append(fields, fixedasset.FieldSerialNumber)
	}
	if m.FieldCleared(fixedasset.FieldLocatedAtFacilityID) {
		fields = append(fields, fixedasset.FieldLocatedAtFacilityID)
	}
	if m.FieldCleared(fixedasset.FieldLocatedAtLocationSeqID) {
		fields = append(fields, fixedasset.FieldLocatedAtLocationSeqID)
	}
	if m.FieldCleared(fixedasset.FieldSalvageValue) {
		fields = append(fields, fixedasset.FieldSalvageValue)
	}
	if m.FieldCleared(fixedasset.FieldDepreciation) {
		fields = append(fields, fixedasset.FieldDepreciation)
	}
	if m.FieldCleared(fixedasset.FieldPurchaseCost) {
		fields = append(fields, fixedasset.FieldPurchaseCost)
	}
	if m.FieldCleared(fixedasset.FieldPurchaseCostUomID) {
		fields = append(fields, fixedasset.FieldPurchaseCostUomID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FixedAssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixedAssetMutation) ClearField(name string) error {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		m.ClearFixedAssetTypeID()
		return nil
	case fixedasset.FieldInstanceOfProductID:
		m.ClearInstanceOfProductID()
		return nil
	case fixedasset.FieldClassEnumID:
		m.ClearClassEnumID()
		return nil
	case fixedasset.FieldRoleTypeID:
		m.ClearRoleTypeID()
		return nil
	case fixedasset.FieldFixedAssetName:
		m.ClearFixedAssetName()
		return nil
	case fixedasset.FieldAcquireOrderID:
		m.ClearAcquireOrderID()
		return nil
	case fixedasset.FieldAcquireOrderItemSeqID:
		m.ClearAcquireOrderItemSeqID()
		return nil
	case fixedasset.FieldDateAcquired:
		m.ClearDateAcquired()
		return nil
	case fixedasset.FieldDateLastServiced:
		m.ClearDateLastServiced()
		return nil
	case fixedasset.FieldDateNextService:
		m.ClearDateNextService()
		return nil
	case fixedasset.FieldExpectedEndOfLife:
		m.ClearExpectedEndOfLife()
		return nil
	case fixedasset.FieldActualEndOfLife:
		m.ClearActualEndOfLife()
		return nil
	case fixedasset.FieldProductionCapacity:
		m.ClearProductionCapacity()
		return nil
	case fixedasset.FieldUomID:
		m.ClearUomID()
		return nil
	case fixedasset.FieldCalendarID:
		m.ClearCalendarID()
		return nil
	case fixedasset.FieldSerialNumber:
		m.ClearSerialNumber()
		return nil
	case fixedasset.FieldLocatedAtFacilityID:
		m.ClearLocatedAtFacilityID()
		return nil
	case fixedasset.FieldLocatedAtLocationSeqID:
		m.ClearLocatedAtLocationSeqID()
		return nil
	case fixedasset.FieldSalvageValue:
		m.ClearSalvageValue()
		return nil
	case fixedasset.FieldDepreciation:
		m.ClearDepreciation()
		return nil
	case fixedasset.FieldPurchaseCost:
		m.ClearPurchaseCost()
		return nil
	case fixedasset.FieldPurchaseCostUomID:
		m.ClearPurchaseCostUomID()
		return nil
	}
	return fmt.Errorf("unknown FixedAsset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FixedAssetMutation) ResetField(name string) error {
	switch name {
	case fixedasset.FieldFixedAssetTypeID:
		m.ResetFixedAssetTypeID()
		return nil
	case fixedasset.FieldInstanceOfProductID:
		m.ResetInstanceOfProductID()
		return nil
	case fixedasset.FieldClassEnumID:
		m.ResetClassEnumID()
		return nil
	case fixedasset.FieldRoleTypeID:
		m.ResetRoleTypeID()
		return nil
	case fixedasset.FieldFixedAssetName:
		m.ResetFixedAssetName()
		return nil
	case fixedasset.FieldAcquireOrderID:
		m.ResetAcquireOrderID()
		return nil
	case fixedasset.FieldAcquireOrderItemSeqID:
		m.ResetAcquireOrderItemSeqID()
		return nil
	case fixedasset.FieldDateAcquired:
		m.ResetDateAcquired()
		return nil
	case fixedasset.FieldDateLastServiced:
		m.ResetDateLastServiced()
		return nil
	case fixedasset.FieldDateNextService:
		m.ResetDateNextService()
		return nil
	case fixedasset.FieldExpectedEndOfLife:
		m.ResetExpectedEndOfLife()
		return nil
	case fixedasset.FieldActualEndOfLife:
		m.ResetActualEndOfLife()
		return nil
	case fixedasset.FieldProductionCapacity:
		m.ResetProductionCapacity()
		return nil
	case fixedasset.FieldUomID:
		m.ResetUomID()
		return nil
	case fixedasset.FieldCalendarID:
		m.ResetCalendarID()
		return nil
	case fixedasset.FieldSerialNumber:
		m.ResetSerialNumber()
		return nil
	case fixedasset.FieldLocatedAtFacilityID:
		m.ResetLocatedAtFacilityID()
		return nil
	case fixedasset.FieldLocatedAtLocationSeqID:
		m.ResetLocatedAtLocationSeqID()
		return nil
	case fixedasset.FieldSalvageValue:
		m.ResetSalvageValue()
		return nil
	case fixedasset.FieldDepreciation:
		m.ResetDepreciation()
		return nil
	case fixedasset.FieldPurchaseCost:
		m.ResetPurchaseCost()
		return nil
	case fixedasset.FieldPurchaseCostUomID:
		m.ResetPurchaseCostUomID()
		return nil
	}
	return fmt.Errorf("unknown FixedAsset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FixedAssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.parent != nil {
		edges = append(edges, fixedasset.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, fixedasset.EdgeChildren)
	}
	if m.party != nil {
		edges = append(edges, fixedasset.EdgeParty)
	}
	if m.party_role != nil {
		edges = append(edges, fixedasset.EdgePartyRole)
	}
	if m.child_fixed_assets != nil {
		edges = append(edges, fixedasset.EdgeChildFixedAssets)
	}
	if m.work_efforts != nil {
		edges = append(edges, fixedasset.EdgeWorkEfforts)
	}
	if m.work_effort_fixed_asset_assigns != nil {
		edges = append(edges, fixedasset.EdgeWorkEffortFixedAssetAssigns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FixedAssetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixedasset.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case fixedasset.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case fixedasset.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	case fixedasset.EdgePartyRole:
		if id := m.party_role; id != nil {
			return []ent.Value{*id}
		}
	case fixedasset.EdgeChildFixedAssets:
		ids := make([]ent.Value, 0, len(m.child_fixed_assets))
		for id := range m.child_fixed_assets {
			ids = append(ids, id)
		}
		return ids
	case fixedasset.EdgeWorkEfforts:
		ids := make([]ent.Value, 0, len(m.work_efforts))
		for id := range m.work_efforts {
			ids = append(ids, id)
		}
		return ids
	case fixedasset.EdgeWorkEffortFixedAssetAssigns:
		ids := make([]ent.Value, 0, len(m.work_effort_fixed_asset_assigns))
		for id := range m.work_effort_fixed_asset_assigns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FixedAssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, fixedasset.EdgeChildren)
	}
	if m.removedchild_fixed_assets != nil {
		edges = append(edges, fixedasset.EdgeChildFixedAssets)
	}
	if m.removedwork_efforts != nil {
		edges = append(edges, fixedasset.EdgeWorkEfforts)
	}
	if m.removedwork_effort_fixed_asset_assigns != nil {
		edges = append(edges, fixedasset.EdgeWorkEffortFixedAssetAssigns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FixedAssetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fixedasset.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case fixedasset.EdgeChildFixedAssets:
		ids := make([]ent.Value, 0, len(m.removedchild_fixed_assets))
		for id := range m.removedchild_fixed_assets {
			ids = append(ids, id)
		}
		return ids
	case fixedasset.EdgeWorkEfforts:
		ids := make([]ent.Value, 0, len(m.removedwork_efforts))
		for id := range m.removedwork_efforts {
			ids = append(ids, id)
		}
		return ids
	case fixedasset.EdgeWorkEffortFixedAssetAssigns:
		ids := make([]ent.Value, 0, len(m.removedwork_effort_fixed_asset_assigns))
		for id := range m.removedwork_effort_fixed_asset_assigns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FixedAssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedparent {
		edges = append(edges, fixedasset.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, fixedasset.EdgeChildren)
	}
	if m.clearedparty {
		edges = append(edges, fixedasset.EdgeParty)
	}
	if m.clearedparty_role {
		edges = append(edges, fixedasset.EdgePartyRole)
	}
	if m.clearedchild_fixed_assets {
		edges = append(edges, fixedasset.EdgeChildFixedAssets)
	}
	if m.clearedwork_efforts {
		edges = append(edges, fixedasset.EdgeWorkEfforts)
	}
	if m.clearedwork_effort_fixed_asset_assigns {
		edges = append(edges, fixedasset.EdgeWorkEffortFixedAssetAssigns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FixedAssetMutation) EdgeCleared(name string) bool {
	switch name {
	case fixedasset.EdgeParent:
		return m.clearedparent
	case fixedasset.EdgeChildren:
		return m.clearedchildren
	case fixedasset.EdgeParty:
		return m.clearedparty
	case fixedasset.EdgePartyRole:
		return m.clearedparty_role
	case fixedasset.EdgeChildFixedAssets:
		return m.clearedchild_fixed_assets
	case fixedasset.EdgeWorkEfforts:
		return m.clearedwork_efforts
	case fixedasset.EdgeWorkEffortFixedAssetAssigns:
		return m.clearedwork_effort_fixed_asset_assigns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FixedAssetMutation) ClearEdge(name string) error {
	switch name {
	case fixedasset.EdgeParent:
		m.ClearParent()
		return nil
	case fixedasset.EdgeParty:
		m.ClearParty()
		return nil
	case fixedasset.EdgePartyRole:
		m.ClearPartyRole()
		return nil
	}
	return fmt.Errorf("unknown FixedAsset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FixedAssetMutation) ResetEdge(name string) error {
	switch name {
	case fixedasset.EdgeParent:
		m.ResetParent()
		return nil
	case fixedasset.EdgeChildren:
		m.ResetChildren()
		return nil
	case fixedasset.EdgeParty:
		m.ResetParty()
		return nil
	case fixedasset.EdgePartyRole:
		m.ResetPartyRole()
		return nil
	case fixedasset.EdgeChildFixedAssets:
		m.ResetChildFixedAssets()
		return nil
	case fixedasset.EdgeWorkEfforts:
		m.ResetWorkEfforts()
		return nil
	case fixedasset.EdgeWorkEffortFixedAssetAssigns:
		m.ResetWorkEffortFixedAssetAssigns()
		return nil
	}
	return fmt.Errorf("unknown FixedAsset edge %s", name)
}

// PartyMutation represents an operation that mutates the Party nodes in the graph.
type PartyMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	party_type_id                        *int
	addparty_type_id                     *int
	external_id                          *int
	addexternal_id                       *int
	preferred_currency_uom_id            *int
	addpreferred_currency_uom_id         *int
	description                          *string
	status_id                            *int
	addstatus_id                         *int
	created_date                         *time.Time
	last_modified_date                   *time.Time
	data_source_id                       *int
	adddata_source_id                    *int
	is_unread                            *party.IsUnread
	clearedFields                        map[string]struct{}
	created_by_user_login                *int
	clearedcreated_by_user_login         bool
	last_modified_by_user_login          *int
	clearedlast_modified_by_user_login   bool
	fixed_assets                         map[int]struct{}
	removedfixed_assets                  map[int]struct{}
	clearedfixed_assets                  bool
	party_roles                          map[int]struct{}
	removedparty_roles                   map[int]struct{}
	clearedparty_roles                   bool
	party_statuses                       map[int]struct{}
	removedparty_statuses                map[int]struct{}
	clearedparty_statuses                bool
	person                               *int
	clearedperson                        bool
	user_logins                          map[int]struct{}
	removeduser_logins                   map[int]struct{}
	cleareduser_logins                   bool
	work_effort_party_assignments        map[int]struct{}
	removedwork_effort_party_assignments map[int]struct{}
	clearedwork_effort_party_assignments bool
	done                                 bool
	oldValue                             func(context.Context) (*Party, error)
	predicates                           []predicate.Party
}

var _ ent.Mutation = (*PartyMutation)(nil)

// partyOption allows management of the mutation configuration using functional options.
type partyOption func(*PartyMutation)

// newPartyMutation creates new mutation for the Party entity.
func newPartyMutation(c config, op Op, opts ...partyOption) *PartyMutation {
	m := &PartyMutation{
		config:        c,
		op:            op,
		typ:           TypeParty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartyID sets the ID field of the mutation.
func withPartyID(id int) partyOption {
	return func(m *PartyMutation) {
		var (
			err   error
			once  sync.Once
			value *Party
		)
		m.oldValue = func(ctx context.Context) (*Party, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Party.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParty sets the old Party of the mutation.
func withParty(node *Party) partyOption {
	return func(m *PartyMutation) {
		m.oldValue = func(context.Context) (*Party, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PartyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPartyTypeID sets the "party_type_id" field.
func (m *PartyMutation) SetPartyTypeID(i int) {
	m.party_type_id = &i
	m.addparty_type_id = nil
}

// PartyTypeID returns the value of the "party_type_id" field in the mutation.
func (m *PartyMutation) PartyTypeID() (r int, exists bool) {
	v := m.party_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPartyTypeID returns the old "party_type_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldPartyTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPartyTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPartyTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartyTypeID: %w", err)
	}
	return oldValue.PartyTypeID, nil
}

// AddPartyTypeID adds i to the "party_type_id" field.
func (m *PartyMutation) AddPartyTypeID(i int) {
	if m.addparty_type_id != nil {
		*m.addparty_type_id += i
	} else {
		m.addparty_type_id = &i
	}
}

// AddedPartyTypeID returns the value that was added to the "party_type_id" field in this mutation.
func (m *PartyMutation) AddedPartyTypeID() (r int, exists bool) {
	v := m.addparty_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPartyTypeID clears the value of the "party_type_id" field.
func (m *PartyMutation) ClearPartyTypeID() {
	m.party_type_id = nil
	m.addparty_type_id = nil
	m.clearedFields[party.FieldPartyTypeID] = struct{}{}
}

// PartyTypeIDCleared returns if the "party_type_id" field was cleared in this mutation.
func (m *PartyMutation) PartyTypeIDCleared() bool {
	_, ok := m.clearedFields[party.FieldPartyTypeID]
	return ok
}

// ResetPartyTypeID resets all changes to the "party_type_id" field.
func (m *PartyMutation) ResetPartyTypeID() {
	m.party_type_id = nil
	m.addparty_type_id = nil
	delete(m.clearedFields, party.FieldPartyTypeID)
}

// SetExternalID sets the "external_id" field.
func (m *PartyMutation) SetExternalID(i int) {
	m.external_id = &i
	m.addexternal_id = nil
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *PartyMutation) ExternalID() (r int, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldExternalID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// AddExternalID adds i to the "external_id" field.
func (m *PartyMutation) AddExternalID(i int) {
	if m.addexternal_id != nil {
		*m.addexternal_id += i
	} else {
		m.addexternal_id = &i
	}
}

// AddedExternalID returns the value that was added to the "external_id" field in this mutation.
func (m *PartyMutation) AddedExternalID() (r int, exists bool) {
	v := m.addexternal_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExternalID clears the value of the "external_id" field.
func (m *PartyMutation) ClearExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	m.clearedFields[party.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *PartyMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[party.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *PartyMutation) ResetExternalID() {
	m.external_id = nil
	m.addexternal_id = nil
	delete(m.clearedFields, party.FieldExternalID)
}

// SetPreferredCurrencyUomID sets the "preferred_currency_uom_id" field.
func (m *PartyMutation) SetPreferredCurrencyUomID(i int) {
	m.preferred_currency_uom_id = &i
	m.addpreferred_currency_uom_id = nil
}

// PreferredCurrencyUomID returns the value of the "preferred_currency_uom_id" field in the mutation.
func (m *PartyMutation) PreferredCurrencyUomID() (r int, exists bool) {
	v := m.preferred_currency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferredCurrencyUomID returns the old "preferred_currency_uom_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldPreferredCurrencyUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPreferredCurrencyUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPreferredCurrencyUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferredCurrencyUomID: %w", err)
	}
	return oldValue.PreferredCurrencyUomID, nil
}

// AddPreferredCurrencyUomID adds i to the "preferred_currency_uom_id" field.
func (m *PartyMutation) AddPreferredCurrencyUomID(i int) {
	if m.addpreferred_currency_uom_id != nil {
		*m.addpreferred_currency_uom_id += i
	} else {
		m.addpreferred_currency_uom_id = &i
	}
}

// AddedPreferredCurrencyUomID returns the value that was added to the "preferred_currency_uom_id" field in this mutation.
func (m *PartyMutation) AddedPreferredCurrencyUomID() (r int, exists bool) {
	v := m.addpreferred_currency_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPreferredCurrencyUomID clears the value of the "preferred_currency_uom_id" field.
func (m *PartyMutation) ClearPreferredCurrencyUomID() {
	m.preferred_currency_uom_id = nil
	m.addpreferred_currency_uom_id = nil
	m.clearedFields[party.FieldPreferredCurrencyUomID] = struct{}{}
}

// PreferredCurrencyUomIDCleared returns if the "preferred_currency_uom_id" field was cleared in this mutation.
func (m *PartyMutation) PreferredCurrencyUomIDCleared() bool {
	_, ok := m.clearedFields[party.FieldPreferredCurrencyUomID]
	return ok
}

// ResetPreferredCurrencyUomID resets all changes to the "preferred_currency_uom_id" field.
func (m *PartyMutation) ResetPreferredCurrencyUomID() {
	m.preferred_currency_uom_id = nil
	m.addpreferred_currency_uom_id = nil
	delete(m.clearedFields, party.FieldPreferredCurrencyUomID)
}

// SetDescription sets the "description" field.
func (m *PartyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PartyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PartyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[party.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PartyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[party.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PartyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, party.FieldDescription)
}

// SetStatusID sets the "status_id" field.
func (m *PartyMutation) SetStatusID(i int) {
	m.status_id = &i
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *PartyMutation) StatusID() (r int, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds i to the "status_id" field.
func (m *PartyMutation) AddStatusID(i int) {
	if m.addstatus_id != nil {
		*m.addstatus_id += i
	} else {
		m.addstatus_id = &i
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *PartyMutation) AddedStatusID() (r int, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusID clears the value of the "status_id" field.
func (m *PartyMutation) ClearStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	m.clearedFields[party.FieldStatusID] = struct{}{}
}

// StatusIDCleared returns if the "status_id" field was cleared in this mutation.
func (m *PartyMutation) StatusIDCleared() bool {
	_, ok := m.clearedFields[party.FieldStatusID]
	return ok
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *PartyMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	delete(m.clearedFields, party.FieldStatusID)
}

// SetCreatedDate sets the "created_date" field.
func (m *PartyMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *PartyMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *PartyMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[party.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *PartyMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[party.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *PartyMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, party.FieldCreatedDate)
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *PartyMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *PartyMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ClearLastModifiedDate clears the value of the "last_modified_date" field.
func (m *PartyMutation) ClearLastModifiedDate() {
	m.last_modified_date = nil
	m.clearedFields[party.FieldLastModifiedDate] = struct{}{}
}

// LastModifiedDateCleared returns if the "last_modified_date" field was cleared in this mutation.
func (m *PartyMutation) LastModifiedDateCleared() bool {
	_, ok := m.clearedFields[party.FieldLastModifiedDate]
	return ok
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *PartyMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
	delete(m.clearedFields, party.FieldLastModifiedDate)
}

// SetDataSourceID sets the "data_source_id" field.
func (m *PartyMutation) SetDataSourceID(i int) {
	m.data_source_id = &i
	m.adddata_source_id = nil
}

// DataSourceID returns the value of the "data_source_id" field in the mutation.
func (m *PartyMutation) DataSourceID() (r int, exists bool) {
	v := m.data_source_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDataSourceID returns the old "data_source_id" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldDataSourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDataSourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDataSourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataSourceID: %w", err)
	}
	return oldValue.DataSourceID, nil
}

// AddDataSourceID adds i to the "data_source_id" field.
func (m *PartyMutation) AddDataSourceID(i int) {
	if m.adddata_source_id != nil {
		*m.adddata_source_id += i
	} else {
		m.adddata_source_id = &i
	}
}

// AddedDataSourceID returns the value that was added to the "data_source_id" field in this mutation.
func (m *PartyMutation) AddedDataSourceID() (r int, exists bool) {
	v := m.adddata_source_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDataSourceID clears the value of the "data_source_id" field.
func (m *PartyMutation) ClearDataSourceID() {
	m.data_source_id = nil
	m.adddata_source_id = nil
	m.clearedFields[party.FieldDataSourceID] = struct{}{}
}

// DataSourceIDCleared returns if the "data_source_id" field was cleared in this mutation.
func (m *PartyMutation) DataSourceIDCleared() bool {
	_, ok := m.clearedFields[party.FieldDataSourceID]
	return ok
}

// ResetDataSourceID resets all changes to the "data_source_id" field.
func (m *PartyMutation) ResetDataSourceID() {
	m.data_source_id = nil
	m.adddata_source_id = nil
	delete(m.clearedFields, party.FieldDataSourceID)
}

// SetIsUnread sets the "is_unread" field.
func (m *PartyMutation) SetIsUnread(pu party.IsUnread) {
	m.is_unread = &pu
}

// IsUnread returns the value of the "is_unread" field in the mutation.
func (m *PartyMutation) IsUnread() (r party.IsUnread, exists bool) {
	v := m.is_unread
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUnread returns the old "is_unread" field's value of the Party entity.
// If the Party object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyMutation) OldIsUnread(ctx context.Context) (v party.IsUnread, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsUnread is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsUnread requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUnread: %w", err)
	}
	return oldValue.IsUnread, nil
}

// ClearIsUnread clears the value of the "is_unread" field.
func (m *PartyMutation) ClearIsUnread() {
	m.is_unread = nil
	m.clearedFields[party.FieldIsUnread] = struct{}{}
}

// IsUnreadCleared returns if the "is_unread" field was cleared in this mutation.
func (m *PartyMutation) IsUnreadCleared() bool {
	_, ok := m.clearedFields[party.FieldIsUnread]
	return ok
}

// ResetIsUnread resets all changes to the "is_unread" field.
func (m *PartyMutation) ResetIsUnread() {
	m.is_unread = nil
	delete(m.clearedFields, party.FieldIsUnread)
}

// SetCreatedByUserLoginID sets the "created_by_user_login" edge to the UserLogin entity by id.
func (m *PartyMutation) SetCreatedByUserLoginID(id int) {
	m.created_by_user_login = &id
}

// ClearCreatedByUserLogin clears the "created_by_user_login" edge to the UserLogin entity.
func (m *PartyMutation) ClearCreatedByUserLogin() {
	m.clearedcreated_by_user_login = true
}

// CreatedByUserLoginCleared reports if the "created_by_user_login" edge to the UserLogin entity was cleared.
func (m *PartyMutation) CreatedByUserLoginCleared() bool {
	return m.clearedcreated_by_user_login
}

// CreatedByUserLoginID returns the "created_by_user_login" edge ID in the mutation.
func (m *PartyMutation) CreatedByUserLoginID() (id int, exists bool) {
	if m.created_by_user_login != nil {
		return *m.created_by_user_login, true
	}
	return
}

// CreatedByUserLoginIDs returns the "created_by_user_login" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByUserLoginID instead. It exists only for internal usage by the builders.
func (m *PartyMutation) CreatedByUserLoginIDs() (ids []int) {
	if id := m.created_by_user_login; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByUserLogin resets all changes to the "created_by_user_login" edge.
func (m *PartyMutation) ResetCreatedByUserLogin() {
	m.created_by_user_login = nil
	m.clearedcreated_by_user_login = false
}

// SetLastModifiedByUserLoginID sets the "last_modified_by_user_login" edge to the UserLogin entity by id.
func (m *PartyMutation) SetLastModifiedByUserLoginID(id int) {
	m.last_modified_by_user_login = &id
}

// ClearLastModifiedByUserLogin clears the "last_modified_by_user_login" edge to the UserLogin entity.
func (m *PartyMutation) ClearLastModifiedByUserLogin() {
	m.clearedlast_modified_by_user_login = true
}

// LastModifiedByUserLoginCleared reports if the "last_modified_by_user_login" edge to the UserLogin entity was cleared.
func (m *PartyMutation) LastModifiedByUserLoginCleared() bool {
	return m.clearedlast_modified_by_user_login
}

// LastModifiedByUserLoginID returns the "last_modified_by_user_login" edge ID in the mutation.
func (m *PartyMutation) LastModifiedByUserLoginID() (id int, exists bool) {
	if m.last_modified_by_user_login != nil {
		return *m.last_modified_by_user_login, true
	}
	return
}

// LastModifiedByUserLoginIDs returns the "last_modified_by_user_login" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LastModifiedByUserLoginID instead. It exists only for internal usage by the builders.
func (m *PartyMutation) LastModifiedByUserLoginIDs() (ids []int) {
	if id := m.last_modified_by_user_login; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLastModifiedByUserLogin resets all changes to the "last_modified_by_user_login" edge.
func (m *PartyMutation) ResetLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	m.clearedlast_modified_by_user_login = false
}

// AddFixedAssetIDs adds the "fixed_assets" edge to the FixedAsset entity by ids.
func (m *PartyMutation) AddFixedAssetIDs(ids ...int) {
	if m.fixed_assets == nil {
		m.fixed_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.fixed_assets[ids[i]] = struct{}{}
	}
}

// ClearFixedAssets clears the "fixed_assets" edge to the FixedAsset entity.
func (m *PartyMutation) ClearFixedAssets() {
	m.clearedfixed_assets = true
}

// FixedAssetsCleared reports if the "fixed_assets" edge to the FixedAsset entity was cleared.
func (m *PartyMutation) FixedAssetsCleared() bool {
	return m.clearedfixed_assets
}

// RemoveFixedAssetIDs removes the "fixed_assets" edge to the FixedAsset entity by IDs.
func (m *PartyMutation) RemoveFixedAssetIDs(ids ...int) {
	if m.removedfixed_assets == nil {
		m.removedfixed_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfixed_assets[ids[i]] = struct{}{}
	}
}

// RemovedFixedAssets returns the removed IDs of the "fixed_assets" edge to the FixedAsset entity.
func (m *PartyMutation) RemovedFixedAssetsIDs() (ids []int) {
	for id := range m.removedfixed_assets {
		ids = append(ids, id)
	}
	return
}

// FixedAssetsIDs returns the "fixed_assets" edge IDs in the mutation.
func (m *PartyMutation) FixedAssetsIDs() (ids []int) {
	for id := range m.fixed_assets {
		ids = append(ids, id)
	}
	return
}

// ResetFixedAssets resets all changes to the "fixed_assets" edge.
func (m *PartyMutation) ResetFixedAssets() {
	m.fixed_assets = nil
	m.clearedfixed_assets = false
	m.removedfixed_assets = nil
}

// AddPartyRoleIDs adds the "party_roles" edge to the PartyRole entity by ids.
func (m *PartyMutation) AddPartyRoleIDs(ids ...int) {
	if m.party_roles == nil {
		m.party_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.party_roles[ids[i]] = struct{}{}
	}
}

// ClearPartyRoles clears the "party_roles" edge to the PartyRole entity.
func (m *PartyMutation) ClearPartyRoles() {
	m.clearedparty_roles = true
}

// PartyRolesCleared reports if the "party_roles" edge to the PartyRole entity was cleared.
func (m *PartyMutation) PartyRolesCleared() bool {
	return m.clearedparty_roles
}

// RemovePartyRoleIDs removes the "party_roles" edge to the PartyRole entity by IDs.
func (m *PartyMutation) RemovePartyRoleIDs(ids ...int) {
	if m.removedparty_roles == nil {
		m.removedparty_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedparty_roles[ids[i]] = struct{}{}
	}
}

// RemovedPartyRoles returns the removed IDs of the "party_roles" edge to the PartyRole entity.
func (m *PartyMutation) RemovedPartyRolesIDs() (ids []int) {
	for id := range m.removedparty_roles {
		ids = append(ids, id)
	}
	return
}

// PartyRolesIDs returns the "party_roles" edge IDs in the mutation.
func (m *PartyMutation) PartyRolesIDs() (ids []int) {
	for id := range m.party_roles {
		ids = append(ids, id)
	}
	return
}

// ResetPartyRoles resets all changes to the "party_roles" edge.
func (m *PartyMutation) ResetPartyRoles() {
	m.party_roles = nil
	m.clearedparty_roles = false
	m.removedparty_roles = nil
}

// AddPartyStatusIDs adds the "party_statuses" edge to the PartyStatus entity by ids.
func (m *PartyMutation) AddPartyStatusIDs(ids ...int) {
	if m.party_statuses == nil {
		m.party_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.party_statuses[ids[i]] = struct{}{}
	}
}

// ClearPartyStatuses clears the "party_statuses" edge to the PartyStatus entity.
func (m *PartyMutation) ClearPartyStatuses() {
	m.clearedparty_statuses = true
}

// PartyStatusesCleared reports if the "party_statuses" edge to the PartyStatus entity was cleared.
func (m *PartyMutation) PartyStatusesCleared() bool {
	return m.clearedparty_statuses
}

// RemovePartyStatusIDs removes the "party_statuses" edge to the PartyStatus entity by IDs.
func (m *PartyMutation) RemovePartyStatusIDs(ids ...int) {
	if m.removedparty_statuses == nil {
		m.removedparty_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedparty_statuses[ids[i]] = struct{}{}
	}
}

// RemovedPartyStatuses returns the removed IDs of the "party_statuses" edge to the PartyStatus entity.
func (m *PartyMutation) RemovedPartyStatusesIDs() (ids []int) {
	for id := range m.removedparty_statuses {
		ids = append(ids, id)
	}
	return
}

// PartyStatusesIDs returns the "party_statuses" edge IDs in the mutation.
func (m *PartyMutation) PartyStatusesIDs() (ids []int) {
	for id := range m.party_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetPartyStatuses resets all changes to the "party_statuses" edge.
func (m *PartyMutation) ResetPartyStatuses() {
	m.party_statuses = nil
	m.clearedparty_statuses = false
	m.removedparty_statuses = nil
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *PartyMutation) SetPersonID(id int) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *PartyMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *PartyMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *PartyMutation) PersonID() (id int, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *PartyMutation) PersonIDs() (ids []int) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *PartyMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// AddUserLoginIDs adds the "user_logins" edge to the UserLogin entity by ids.
func (m *PartyMutation) AddUserLoginIDs(ids ...int) {
	if m.user_logins == nil {
		m.user_logins = make(map[int]struct{})
	}
	for i := range ids {
		m.user_logins[ids[i]] = struct{}{}
	}
}

// ClearUserLogins clears the "user_logins" edge to the UserLogin entity.
func (m *PartyMutation) ClearUserLogins() {
	m.cleareduser_logins = true
}

// UserLoginsCleared reports if the "user_logins" edge to the UserLogin entity was cleared.
func (m *PartyMutation) UserLoginsCleared() bool {
	return m.cleareduser_logins
}

// RemoveUserLoginIDs removes the "user_logins" edge to the UserLogin entity by IDs.
func (m *PartyMutation) RemoveUserLoginIDs(ids ...int) {
	if m.removeduser_logins == nil {
		m.removeduser_logins = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_logins[ids[i]] = struct{}{}
	}
}

// RemovedUserLogins returns the removed IDs of the "user_logins" edge to the UserLogin entity.
func (m *PartyMutation) RemovedUserLoginsIDs() (ids []int) {
	for id := range m.removeduser_logins {
		ids = append(ids, id)
	}
	return
}

// UserLoginsIDs returns the "user_logins" edge IDs in the mutation.
func (m *PartyMutation) UserLoginsIDs() (ids []int) {
	for id := range m.user_logins {
		ids = append(ids, id)
	}
	return
}

// ResetUserLogins resets all changes to the "user_logins" edge.
func (m *PartyMutation) ResetUserLogins() {
	m.user_logins = nil
	m.cleareduser_logins = false
	m.removeduser_logins = nil
}

// AddWorkEffortPartyAssignmentIDs adds the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by ids.
func (m *PartyMutation) AddWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.work_effort_party_assignments == nil {
		m.work_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.work_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// ClearWorkEffortPartyAssignments clears the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *PartyMutation) ClearWorkEffortPartyAssignments() {
	m.clearedwork_effort_party_assignments = true
}

// WorkEffortPartyAssignmentsCleared reports if the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity was cleared.
func (m *PartyMutation) WorkEffortPartyAssignmentsCleared() bool {
	return m.clearedwork_effort_party_assignments
}

// RemoveWorkEffortPartyAssignmentIDs removes the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by IDs.
func (m *PartyMutation) RemoveWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.removedwork_effort_party_assignments == nil {
		m.removedwork_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// RemovedWorkEffortPartyAssignments returns the removed IDs of the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *PartyMutation) RemovedWorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.removedwork_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// WorkEffortPartyAssignmentsIDs returns the "work_effort_party_assignments" edge IDs in the mutation.
func (m *PartyMutation) WorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.work_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEffortPartyAssignments resets all changes to the "work_effort_party_assignments" edge.
func (m *PartyMutation) ResetWorkEffortPartyAssignments() {
	m.work_effort_party_assignments = nil
	m.clearedwork_effort_party_assignments = false
	m.removedwork_effort_party_assignments = nil
}

// Op returns the operation name.
func (m *PartyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Party).
func (m *PartyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartyMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.party_type_id != nil {
		fields = append(fields, party.FieldPartyTypeID)
	}
	if m.external_id != nil {
		fields = append(fields, party.FieldExternalID)
	}
	if m.preferred_currency_uom_id != nil {
		fields = append(fields, party.FieldPreferredCurrencyUomID)
	}
	if m.description != nil {
		fields = append(fields, party.FieldDescription)
	}
	if m.status_id != nil {
		fields = append(fields, party.FieldStatusID)
	}
	if m.created_date != nil {
		fields = append(fields, party.FieldCreatedDate)
	}
	if m.last_modified_date != nil {
		fields = append(fields, party.FieldLastModifiedDate)
	}
	if m.data_source_id != nil {
		fields = append(fields, party.FieldDataSourceID)
	}
	if m.is_unread != nil {
		fields = append(fields, party.FieldIsUnread)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case party.FieldPartyTypeID:
		return m.PartyTypeID()
	case party.FieldExternalID:
		return m.ExternalID()
	case party.FieldPreferredCurrencyUomID:
		return m.PreferredCurrencyUomID()
	case party.FieldDescription:
		return m.Description()
	case party.FieldStatusID:
		return m.StatusID()
	case party.FieldCreatedDate:
		return m.CreatedDate()
	case party.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case party.FieldDataSourceID:
		return m.DataSourceID()
	case party.FieldIsUnread:
		return m.IsUnread()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case party.FieldPartyTypeID:
		return m.OldPartyTypeID(ctx)
	case party.FieldExternalID:
		return m.OldExternalID(ctx)
	case party.FieldPreferredCurrencyUomID:
		return m.OldPreferredCurrencyUomID(ctx)
	case party.FieldDescription:
		return m.OldDescription(ctx)
	case party.FieldStatusID:
		return m.OldStatusID(ctx)
	case party.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case party.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case party.FieldDataSourceID:
		return m.OldDataSourceID(ctx)
	case party.FieldIsUnread:
		return m.OldIsUnread(ctx)
	}
	return nil, fmt.Errorf("unknown Party field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case party.FieldPartyTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartyTypeID(v)
		return nil
	case party.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case party.FieldPreferredCurrencyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferredCurrencyUomID(v)
		return nil
	case party.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case party.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	case party.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case party.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case party.FieldDataSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataSourceID(v)
		return nil
	case party.FieldIsUnread:
		v, ok := value.(party.IsUnread)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUnread(v)
		return nil
	}
	return fmt.Errorf("unknown Party field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartyMutation) AddedFields() []string {
	var fields []string
	if m.addparty_type_id != nil {
		fields = append(fields, party.FieldPartyTypeID)
	}
	if m.addexternal_id != nil {
		fields = append(fields, party.FieldExternalID)
	}
	if m.addpreferred_currency_uom_id != nil {
		fields = append(fields, party.FieldPreferredCurrencyUomID)
	}
	if m.addstatus_id != nil {
		fields = append(fields, party.FieldStatusID)
	}
	if m.adddata_source_id != nil {
		fields = append(fields, party.FieldDataSourceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case party.FieldPartyTypeID:
		return m.AddedPartyTypeID()
	case party.FieldExternalID:
		return m.AddedExternalID()
	case party.FieldPreferredCurrencyUomID:
		return m.AddedPreferredCurrencyUomID()
	case party.FieldStatusID:
		return m.AddedStatusID()
	case party.FieldDataSourceID:
		return m.AddedDataSourceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case party.FieldPartyTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPartyTypeID(v)
		return nil
	case party.FieldExternalID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExternalID(v)
		return nil
	case party.FieldPreferredCurrencyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreferredCurrencyUomID(v)
		return nil
	case party.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	case party.FieldDataSourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDataSourceID(v)
		return nil
	}
	return fmt.Errorf("unknown Party numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(party.FieldPartyTypeID) {
		fields = append(fields, party.FieldPartyTypeID)
	}
	if m.FieldCleared(party.FieldExternalID) {
		fields = append(fields, party.FieldExternalID)
	}
	if m.FieldCleared(party.FieldPreferredCurrencyUomID) {
		fields = append(fields, party.FieldPreferredCurrencyUomID)
	}
	if m.FieldCleared(party.FieldDescription) {
		fields = append(fields, party.FieldDescription)
	}
	if m.FieldCleared(party.FieldStatusID) {
		fields = append(fields, party.FieldStatusID)
	}
	if m.FieldCleared(party.FieldCreatedDate) {
		fields = append(fields, party.FieldCreatedDate)
	}
	if m.FieldCleared(party.FieldLastModifiedDate) {
		fields = append(fields, party.FieldLastModifiedDate)
	}
	if m.FieldCleared(party.FieldDataSourceID) {
		fields = append(fields, party.FieldDataSourceID)
	}
	if m.FieldCleared(party.FieldIsUnread) {
		fields = append(fields, party.FieldIsUnread)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartyMutation) ClearField(name string) error {
	switch name {
	case party.FieldPartyTypeID:
		m.ClearPartyTypeID()
		return nil
	case party.FieldExternalID:
		m.ClearExternalID()
		return nil
	case party.FieldPreferredCurrencyUomID:
		m.ClearPreferredCurrencyUomID()
		return nil
	case party.FieldDescription:
		m.ClearDescription()
		return nil
	case party.FieldStatusID:
		m.ClearStatusID()
		return nil
	case party.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case party.FieldLastModifiedDate:
		m.ClearLastModifiedDate()
		return nil
	case party.FieldDataSourceID:
		m.ClearDataSourceID()
		return nil
	case party.FieldIsUnread:
		m.ClearIsUnread()
		return nil
	}
	return fmt.Errorf("unknown Party nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartyMutation) ResetField(name string) error {
	switch name {
	case party.FieldPartyTypeID:
		m.ResetPartyTypeID()
		return nil
	case party.FieldExternalID:
		m.ResetExternalID()
		return nil
	case party.FieldPreferredCurrencyUomID:
		m.ResetPreferredCurrencyUomID()
		return nil
	case party.FieldDescription:
		m.ResetDescription()
		return nil
	case party.FieldStatusID:
		m.ResetStatusID()
		return nil
	case party.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case party.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case party.FieldDataSourceID:
		m.ResetDataSourceID()
		return nil
	case party.FieldIsUnread:
		m.ResetIsUnread()
		return nil
	}
	return fmt.Errorf("unknown Party field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartyMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.created_by_user_login != nil {
		edges = append(edges, party.EdgeCreatedByUserLogin)
	}
	if m.last_modified_by_user_login != nil {
		edges = append(edges, party.EdgeLastModifiedByUserLogin)
	}
	if m.fixed_assets != nil {
		edges = append(edges, party.EdgeFixedAssets)
	}
	if m.party_roles != nil {
		edges = append(edges, party.EdgePartyRoles)
	}
	if m.party_statuses != nil {
		edges = append(edges, party.EdgePartyStatuses)
	}
	if m.person != nil {
		edges = append(edges, party.EdgePerson)
	}
	if m.user_logins != nil {
		edges = append(edges, party.EdgeUserLogins)
	}
	if m.work_effort_party_assignments != nil {
		edges = append(edges, party.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case party.EdgeCreatedByUserLogin:
		if id := m.created_by_user_login; id != nil {
			return []ent.Value{*id}
		}
	case party.EdgeLastModifiedByUserLogin:
		if id := m.last_modified_by_user_login; id != nil {
			return []ent.Value{*id}
		}
	case party.EdgeFixedAssets:
		ids := make([]ent.Value, 0, len(m.fixed_assets))
		for id := range m.fixed_assets {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePartyRoles:
		ids := make([]ent.Value, 0, len(m.party_roles))
		for id := range m.party_roles {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePartyStatuses:
		ids := make([]ent.Value, 0, len(m.party_statuses))
		for id := range m.party_statuses {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case party.EdgeUserLogins:
		ids := make([]ent.Value, 0, len(m.user_logins))
		for id := range m.user_logins {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.work_effort_party_assignments))
		for id := range m.work_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedfixed_assets != nil {
		edges = append(edges, party.EdgeFixedAssets)
	}
	if m.removedparty_roles != nil {
		edges = append(edges, party.EdgePartyRoles)
	}
	if m.removedparty_statuses != nil {
		edges = append(edges, party.EdgePartyStatuses)
	}
	if m.removeduser_logins != nil {
		edges = append(edges, party.EdgeUserLogins)
	}
	if m.removedwork_effort_party_assignments != nil {
		edges = append(edges, party.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case party.EdgeFixedAssets:
		ids := make([]ent.Value, 0, len(m.removedfixed_assets))
		for id := range m.removedfixed_assets {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePartyRoles:
		ids := make([]ent.Value, 0, len(m.removedparty_roles))
		for id := range m.removedparty_roles {
			ids = append(ids, id)
		}
		return ids
	case party.EdgePartyStatuses:
		ids := make([]ent.Value, 0, len(m.removedparty_statuses))
		for id := range m.removedparty_statuses {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeUserLogins:
		ids := make([]ent.Value, 0, len(m.removeduser_logins))
		for id := range m.removeduser_logins {
			ids = append(ids, id)
		}
		return ids
	case party.EdgeWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.removedwork_effort_party_assignments))
		for id := range m.removedwork_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcreated_by_user_login {
		edges = append(edges, party.EdgeCreatedByUserLogin)
	}
	if m.clearedlast_modified_by_user_login {
		edges = append(edges, party.EdgeLastModifiedByUserLogin)
	}
	if m.clearedfixed_assets {
		edges = append(edges, party.EdgeFixedAssets)
	}
	if m.clearedparty_roles {
		edges = append(edges, party.EdgePartyRoles)
	}
	if m.clearedparty_statuses {
		edges = append(edges, party.EdgePartyStatuses)
	}
	if m.clearedperson {
		edges = append(edges, party.EdgePerson)
	}
	if m.cleareduser_logins {
		edges = append(edges, party.EdgeUserLogins)
	}
	if m.clearedwork_effort_party_assignments {
		edges = append(edges, party.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartyMutation) EdgeCleared(name string) bool {
	switch name {
	case party.EdgeCreatedByUserLogin:
		return m.clearedcreated_by_user_login
	case party.EdgeLastModifiedByUserLogin:
		return m.clearedlast_modified_by_user_login
	case party.EdgeFixedAssets:
		return m.clearedfixed_assets
	case party.EdgePartyRoles:
		return m.clearedparty_roles
	case party.EdgePartyStatuses:
		return m.clearedparty_statuses
	case party.EdgePerson:
		return m.clearedperson
	case party.EdgeUserLogins:
		return m.cleareduser_logins
	case party.EdgeWorkEffortPartyAssignments:
		return m.clearedwork_effort_party_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartyMutation) ClearEdge(name string) error {
	switch name {
	case party.EdgeCreatedByUserLogin:
		m.ClearCreatedByUserLogin()
		return nil
	case party.EdgeLastModifiedByUserLogin:
		m.ClearLastModifiedByUserLogin()
		return nil
	case party.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown Party unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartyMutation) ResetEdge(name string) error {
	switch name {
	case party.EdgeCreatedByUserLogin:
		m.ResetCreatedByUserLogin()
		return nil
	case party.EdgeLastModifiedByUserLogin:
		m.ResetLastModifiedByUserLogin()
		return nil
	case party.EdgeFixedAssets:
		m.ResetFixedAssets()
		return nil
	case party.EdgePartyRoles:
		m.ResetPartyRoles()
		return nil
	case party.EdgePartyStatuses:
		m.ResetPartyStatuses()
		return nil
	case party.EdgePerson:
		m.ResetPerson()
		return nil
	case party.EdgeUserLogins:
		m.ResetUserLogins()
		return nil
	case party.EdgeWorkEffortPartyAssignments:
		m.ResetWorkEffortPartyAssignments()
		return nil
	}
	return fmt.Errorf("unknown Party edge %s", name)
}

// PartyRoleMutation represents an operation that mutates the PartyRole nodes in the graph.
type PartyRoleMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	role_type_id                         *int
	addrole_type_id                      *int
	clearedFields                        map[string]struct{}
	party                                *int
	clearedparty                         bool
	fixed_assets                         map[int]struct{}
	removedfixed_assets                  map[int]struct{}
	clearedfixed_assets                  bool
	work_effort_party_assignments        map[int]struct{}
	removedwork_effort_party_assignments map[int]struct{}
	clearedwork_effort_party_assignments bool
	done                                 bool
	oldValue                             func(context.Context) (*PartyRole, error)
	predicates                           []predicate.PartyRole
}

var _ ent.Mutation = (*PartyRoleMutation)(nil)

// partyroleOption allows management of the mutation configuration using functional options.
type partyroleOption func(*PartyRoleMutation)

// newPartyRoleMutation creates new mutation for the PartyRole entity.
func newPartyRoleMutation(c config, op Op, opts ...partyroleOption) *PartyRoleMutation {
	m := &PartyRoleMutation{
		config:        c,
		op:            op,
		typ:           TypePartyRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartyRoleID sets the ID field of the mutation.
func withPartyRoleID(id int) partyroleOption {
	return func(m *PartyRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *PartyRole
		)
		m.oldValue = func(ctx context.Context) (*PartyRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartyRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartyRole sets the old PartyRole of the mutation.
func withPartyRole(node *PartyRole) partyroleOption {
	return func(m *PartyRoleMutation) {
		m.oldValue = func(context.Context) (*PartyRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartyRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartyRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PartyRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoleTypeID sets the "role_type_id" field.
func (m *PartyRoleMutation) SetRoleTypeID(i int) {
	m.role_type_id = &i
	m.addrole_type_id = nil
}

// RoleTypeID returns the value of the "role_type_id" field in the mutation.
func (m *PartyRoleMutation) RoleTypeID() (r int, exists bool) {
	v := m.role_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleTypeID returns the old "role_type_id" field's value of the PartyRole entity.
// If the PartyRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyRoleMutation) OldRoleTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleTypeID: %w", err)
	}
	return oldValue.RoleTypeID, nil
}

// AddRoleTypeID adds i to the "role_type_id" field.
func (m *PartyRoleMutation) AddRoleTypeID(i int) {
	if m.addrole_type_id != nil {
		*m.addrole_type_id += i
	} else {
		m.addrole_type_id = &i
	}
}

// AddedRoleTypeID returns the value that was added to the "role_type_id" field in this mutation.
func (m *PartyRoleMutation) AddedRoleTypeID() (r int, exists bool) {
	v := m.addrole_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleTypeID resets all changes to the "role_type_id" field.
func (m *PartyRoleMutation) ResetRoleTypeID() {
	m.role_type_id = nil
	m.addrole_type_id = nil
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *PartyRoleMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *PartyRoleMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *PartyRoleMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *PartyRoleMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *PartyRoleMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *PartyRoleMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// AddFixedAssetIDs adds the "fixed_assets" edge to the FixedAsset entity by ids.
func (m *PartyRoleMutation) AddFixedAssetIDs(ids ...int) {
	if m.fixed_assets == nil {
		m.fixed_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.fixed_assets[ids[i]] = struct{}{}
	}
}

// ClearFixedAssets clears the "fixed_assets" edge to the FixedAsset entity.
func (m *PartyRoleMutation) ClearFixedAssets() {
	m.clearedfixed_assets = true
}

// FixedAssetsCleared reports if the "fixed_assets" edge to the FixedAsset entity was cleared.
func (m *PartyRoleMutation) FixedAssetsCleared() bool {
	return m.clearedfixed_assets
}

// RemoveFixedAssetIDs removes the "fixed_assets" edge to the FixedAsset entity by IDs.
func (m *PartyRoleMutation) RemoveFixedAssetIDs(ids ...int) {
	if m.removedfixed_assets == nil {
		m.removedfixed_assets = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfixed_assets[ids[i]] = struct{}{}
	}
}

// RemovedFixedAssets returns the removed IDs of the "fixed_assets" edge to the FixedAsset entity.
func (m *PartyRoleMutation) RemovedFixedAssetsIDs() (ids []int) {
	for id := range m.removedfixed_assets {
		ids = append(ids, id)
	}
	return
}

// FixedAssetsIDs returns the "fixed_assets" edge IDs in the mutation.
func (m *PartyRoleMutation) FixedAssetsIDs() (ids []int) {
	for id := range m.fixed_assets {
		ids = append(ids, id)
	}
	return
}

// ResetFixedAssets resets all changes to the "fixed_assets" edge.
func (m *PartyRoleMutation) ResetFixedAssets() {
	m.fixed_assets = nil
	m.clearedfixed_assets = false
	m.removedfixed_assets = nil
}

// AddWorkEffortPartyAssignmentIDs adds the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by ids.
func (m *PartyRoleMutation) AddWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.work_effort_party_assignments == nil {
		m.work_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.work_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// ClearWorkEffortPartyAssignments clears the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *PartyRoleMutation) ClearWorkEffortPartyAssignments() {
	m.clearedwork_effort_party_assignments = true
}

// WorkEffortPartyAssignmentsCleared reports if the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity was cleared.
func (m *PartyRoleMutation) WorkEffortPartyAssignmentsCleared() bool {
	return m.clearedwork_effort_party_assignments
}

// RemoveWorkEffortPartyAssignmentIDs removes the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by IDs.
func (m *PartyRoleMutation) RemoveWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.removedwork_effort_party_assignments == nil {
		m.removedwork_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// RemovedWorkEffortPartyAssignments returns the removed IDs of the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *PartyRoleMutation) RemovedWorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.removedwork_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// WorkEffortPartyAssignmentsIDs returns the "work_effort_party_assignments" edge IDs in the mutation.
func (m *PartyRoleMutation) WorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.work_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEffortPartyAssignments resets all changes to the "work_effort_party_assignments" edge.
func (m *PartyRoleMutation) ResetWorkEffortPartyAssignments() {
	m.work_effort_party_assignments = nil
	m.clearedwork_effort_party_assignments = false
	m.removedwork_effort_party_assignments = nil
}

// Op returns the operation name.
func (m *PartyRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PartyRole).
func (m *PartyRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartyRoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.role_type_id != nil {
		fields = append(fields, partyrole.FieldRoleTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartyRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partyrole.FieldRoleTypeID:
		return m.RoleTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartyRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partyrole.FieldRoleTypeID:
		return m.OldRoleTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown PartyRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partyrole.FieldRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown PartyRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartyRoleMutation) AddedFields() []string {
	var fields []string
	if m.addrole_type_id != nil {
		fields = append(fields, partyrole.FieldRoleTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartyRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partyrole.FieldRoleTypeID:
		return m.AddedRoleTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partyrole.FieldRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown PartyRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartyRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartyRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartyRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PartyRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartyRoleMutation) ResetField(name string) error {
	switch name {
	case partyrole.FieldRoleTypeID:
		m.ResetRoleTypeID()
		return nil
	}
	return fmt.Errorf("unknown PartyRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartyRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.party != nil {
		edges = append(edges, partyrole.EdgeParty)
	}
	if m.fixed_assets != nil {
		edges = append(edges, partyrole.EdgeFixedAssets)
	}
	if m.work_effort_party_assignments != nil {
		edges = append(edges, partyrole.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartyRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partyrole.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	case partyrole.EdgeFixedAssets:
		ids := make([]ent.Value, 0, len(m.fixed_assets))
		for id := range m.fixed_assets {
			ids = append(ids, id)
		}
		return ids
	case partyrole.EdgeWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.work_effort_party_assignments))
		for id := range m.work_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartyRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfixed_assets != nil {
		edges = append(edges, partyrole.EdgeFixedAssets)
	}
	if m.removedwork_effort_party_assignments != nil {
		edges = append(edges, partyrole.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartyRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case partyrole.EdgeFixedAssets:
		ids := make([]ent.Value, 0, len(m.removedfixed_assets))
		for id := range m.removedfixed_assets {
			ids = append(ids, id)
		}
		return ids
	case partyrole.EdgeWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.removedwork_effort_party_assignments))
		for id := range m.removedwork_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartyRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparty {
		edges = append(edges, partyrole.EdgeParty)
	}
	if m.clearedfixed_assets {
		edges = append(edges, partyrole.EdgeFixedAssets)
	}
	if m.clearedwork_effort_party_assignments {
		edges = append(edges, partyrole.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartyRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case partyrole.EdgeParty:
		return m.clearedparty
	case partyrole.EdgeFixedAssets:
		return m.clearedfixed_assets
	case partyrole.EdgeWorkEffortPartyAssignments:
		return m.clearedwork_effort_party_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartyRoleMutation) ClearEdge(name string) error {
	switch name {
	case partyrole.EdgeParty:
		m.ClearParty()
		return nil
	}
	return fmt.Errorf("unknown PartyRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartyRoleMutation) ResetEdge(name string) error {
	switch name {
	case partyrole.EdgeParty:
		m.ResetParty()
		return nil
	case partyrole.EdgeFixedAssets:
		m.ResetFixedAssets()
		return nil
	case partyrole.EdgeWorkEffortPartyAssignments:
		m.ResetWorkEffortPartyAssignments()
		return nil
	}
	return fmt.Errorf("unknown PartyRole edge %s", name)
}

// PartyStatusMutation represents an operation that mutates the PartyStatus nodes in the graph.
type PartyStatusMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	status_id                   *int
	addstatus_id                *int
	status_date                 *time.Time
	clearedFields               map[string]struct{}
	party                       *int
	clearedparty                bool
	change_by_user_login        *int
	clearedchange_by_user_login bool
	done                        bool
	oldValue                    func(context.Context) (*PartyStatus, error)
	predicates                  []predicate.PartyStatus
}

var _ ent.Mutation = (*PartyStatusMutation)(nil)

// partystatusOption allows management of the mutation configuration using functional options.
type partystatusOption func(*PartyStatusMutation)

// newPartyStatusMutation creates new mutation for the PartyStatus entity.
func newPartyStatusMutation(c config, op Op, opts ...partystatusOption) *PartyStatusMutation {
	m := &PartyStatusMutation{
		config:        c,
		op:            op,
		typ:           TypePartyStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartyStatusID sets the ID field of the mutation.
func withPartyStatusID(id int) partystatusOption {
	return func(m *PartyStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *PartyStatus
		)
		m.oldValue = func(ctx context.Context) (*PartyStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartyStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartyStatus sets the old PartyStatus of the mutation.
func withPartyStatus(node *PartyStatus) partystatusOption {
	return func(m *PartyStatusMutation) {
		m.oldValue = func(context.Context) (*PartyStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartyStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartyStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PartyStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusID sets the "status_id" field.
func (m *PartyStatusMutation) SetStatusID(i int) {
	m.status_id = &i
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *PartyStatusMutation) StatusID() (r int, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the PartyStatus entity.
// If the PartyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyStatusMutation) OldStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds i to the "status_id" field.
func (m *PartyStatusMutation) AddStatusID(i int) {
	if m.addstatus_id != nil {
		*m.addstatus_id += i
	} else {
		m.addstatus_id = &i
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *PartyStatusMutation) AddedStatusID() (r int, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *PartyStatusMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
}

// SetStatusDate sets the "status_date" field.
func (m *PartyStatusMutation) SetStatusDate(t time.Time) {
	m.status_date = &t
}

// StatusDate returns the value of the "status_date" field in the mutation.
func (m *PartyStatusMutation) StatusDate() (r time.Time, exists bool) {
	v := m.status_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDate returns the old "status_date" field's value of the PartyStatus entity.
// If the PartyStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartyStatusMutation) OldStatusDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDate: %w", err)
	}
	return oldValue.StatusDate, nil
}

// ResetStatusDate resets all changes to the "status_date" field.
func (m *PartyStatusMutation) ResetStatusDate() {
	m.status_date = nil
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *PartyStatusMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *PartyStatusMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *PartyStatusMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *PartyStatusMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *PartyStatusMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *PartyStatusMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// SetChangeByUserLoginID sets the "change_by_user_login" edge to the UserLogin entity by id.
func (m *PartyStatusMutation) SetChangeByUserLoginID(id int) {
	m.change_by_user_login = &id
}

// ClearChangeByUserLogin clears the "change_by_user_login" edge to the UserLogin entity.
func (m *PartyStatusMutation) ClearChangeByUserLogin() {
	m.clearedchange_by_user_login = true
}

// ChangeByUserLoginCleared reports if the "change_by_user_login" edge to the UserLogin entity was cleared.
func (m *PartyStatusMutation) ChangeByUserLoginCleared() bool {
	return m.clearedchange_by_user_login
}

// ChangeByUserLoginID returns the "change_by_user_login" edge ID in the mutation.
func (m *PartyStatusMutation) ChangeByUserLoginID() (id int, exists bool) {
	if m.change_by_user_login != nil {
		return *m.change_by_user_login, true
	}
	return
}

// ChangeByUserLoginIDs returns the "change_by_user_login" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangeByUserLoginID instead. It exists only for internal usage by the builders.
func (m *PartyStatusMutation) ChangeByUserLoginIDs() (ids []int) {
	if id := m.change_by_user_login; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangeByUserLogin resets all changes to the "change_by_user_login" edge.
func (m *PartyStatusMutation) ResetChangeByUserLogin() {
	m.change_by_user_login = nil
	m.clearedchange_by_user_login = false
}

// Op returns the operation name.
func (m *PartyStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PartyStatus).
func (m *PartyStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartyStatusMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status_id != nil {
		fields = append(fields, partystatus.FieldStatusID)
	}
	if m.status_date != nil {
		fields = append(fields, partystatus.FieldStatusDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartyStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partystatus.FieldStatusID:
		return m.StatusID()
	case partystatus.FieldStatusDate:
		return m.StatusDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartyStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partystatus.FieldStatusID:
		return m.OldStatusID(ctx)
	case partystatus.FieldStatusDate:
		return m.OldStatusDate(ctx)
	}
	return nil, fmt.Errorf("unknown PartyStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partystatus.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	case partystatus.FieldStatusDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDate(v)
		return nil
	}
	return fmt.Errorf("unknown PartyStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartyStatusMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_id != nil {
		fields = append(fields, partystatus.FieldStatusID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartyStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partystatus.FieldStatusID:
		return m.AddedStatusID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartyStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partystatus.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown PartyStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartyStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartyStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartyStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PartyStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartyStatusMutation) ResetField(name string) error {
	switch name {
	case partystatus.FieldStatusID:
		m.ResetStatusID()
		return nil
	case partystatus.FieldStatusDate:
		m.ResetStatusDate()
		return nil
	}
	return fmt.Errorf("unknown PartyStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartyStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.party != nil {
		edges = append(edges, partystatus.EdgeParty)
	}
	if m.change_by_user_login != nil {
		edges = append(edges, partystatus.EdgeChangeByUserLogin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartyStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partystatus.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	case partystatus.EdgeChangeByUserLogin:
		if id := m.change_by_user_login; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartyStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartyStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartyStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparty {
		edges = append(edges, partystatus.EdgeParty)
	}
	if m.clearedchange_by_user_login {
		edges = append(edges, partystatus.EdgeChangeByUserLogin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartyStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case partystatus.EdgeParty:
		return m.clearedparty
	case partystatus.EdgeChangeByUserLogin:
		return m.clearedchange_by_user_login
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartyStatusMutation) ClearEdge(name string) error {
	switch name {
	case partystatus.EdgeParty:
		m.ClearParty()
		return nil
	case partystatus.EdgeChangeByUserLogin:
		m.ClearChangeByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown PartyStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartyStatusMutation) ResetEdge(name string) error {
	switch name {
	case partystatus.EdgeParty:
		m.ResetParty()
		return nil
	case partystatus.EdgeChangeByUserLogin:
		m.ResetChangeByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown PartyStatus edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	salutation                     *string
	first_name                     *string
	middle_name                    *string
	last_name                      *string
	personal_title                 *string
	suffix                         *string
	nickname                       *string
	first_name_local               *string
	middle_name_local              *string
	last_name_local                *string
	other_local                    *string
	member_id                      *int
	addmember_id                   *int
	gender                         *person.Gender
	birth_date                     *time.Time
	deceased_date                  *time.Time
	height                         *float64
	addheight                      *float64
	weight                         *float64
	addweight                      *float64
	mothers_maiden_name            *string
	old_marital_status             *person.OldMaritalStatus
	marital_status_enum_id         *int
	addmarital_status_enum_id      *int
	social_security_number         *string
	passport_number                *string
	passport_expire_date           *time.Time
	total_years_work_experience    *float64
	addtotal_years_work_experience *float64
	comments                       *string
	employment_status_enum_id      *int
	addemployment_status_enum_id   *int
	residence_status_enum_id       *int
	addresidence_status_enum_id    *int
	occupation                     *string
	years_with_employer            *int
	addyears_with_employer         *int
	months_with_employer           *int
	addmonths_with_employer        *int
	existing_customer              *person.ExistingCustomer
	card_id                        *string
	clearedFields                  map[string]struct{}
	party                          *int
	clearedparty                   bool
	user_logins                    map[int]struct{}
	removeduser_logins             map[int]struct{}
	cleareduser_logins             bool
	done                           bool
	oldValue                       func(context.Context) (*Person, error)
	predicates                     []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id int) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSalutation sets the "salutation" field.
func (m *PersonMutation) SetSalutation(s string) {
	m.salutation = &s
}

// Salutation returns the value of the "salutation" field in the mutation.
func (m *PersonMutation) Salutation() (r string, exists bool) {
	v := m.salutation
	if v == nil {
		return
	}
	return *v, true
}

// OldSalutation returns the old "salutation" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSalutation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalutation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalutation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalutation: %w", err)
	}
	return oldValue.Salutation, nil
}

// ClearSalutation clears the value of the "salutation" field.
func (m *PersonMutation) ClearSalutation() {
	m.salutation = nil
	m.clearedFields[person.FieldSalutation] = struct{}{}
}

// SalutationCleared returns if the "salutation" field was cleared in this mutation.
func (m *PersonMutation) SalutationCleared() bool {
	_, ok := m.clearedFields[person.FieldSalutation]
	return ok
}

// ResetSalutation resets all changes to the "salutation" field.
func (m *PersonMutation) ResetSalutation() {
	m.salutation = nil
	delete(m.clearedFields, person.FieldSalutation)
}

// SetFirstName sets the "first_name" field.
func (m *PersonMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *PersonMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *PersonMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[person.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *PersonMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[person.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *PersonMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, person.FieldFirstName)
}

// SetMiddleName sets the "middle_name" field.
func (m *PersonMutation) SetMiddleName(s string) {
	m.middle_name = &s
}

// MiddleName returns the value of the "middle_name" field in the mutation.
func (m *PersonMutation) MiddleName() (r string, exists bool) {
	v := m.middle_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleName returns the old "middle_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMiddleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMiddleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMiddleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleName: %w", err)
	}
	return oldValue.MiddleName, nil
}

// ClearMiddleName clears the value of the "middle_name" field.
func (m *PersonMutation) ClearMiddleName() {
	m.middle_name = nil
	m.clearedFields[person.FieldMiddleName] = struct{}{}
}

// MiddleNameCleared returns if the "middle_name" field was cleared in this mutation.
func (m *PersonMutation) MiddleNameCleared() bool {
	_, ok := m.clearedFields[person.FieldMiddleName]
	return ok
}

// ResetMiddleName resets all changes to the "middle_name" field.
func (m *PersonMutation) ResetMiddleName() {
	m.middle_name = nil
	delete(m.clearedFields, person.FieldMiddleName)
}

// SetLastName sets the "last_name" field.
func (m *PersonMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *PersonMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *PersonMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[person.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *PersonMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[person.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *PersonMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, person.FieldLastName)
}

// SetPersonalTitle sets the "personal_title" field.
func (m *PersonMutation) SetPersonalTitle(s string) {
	m.personal_title = &s
}

// PersonalTitle returns the value of the "personal_title" field in the mutation.
func (m *PersonMutation) PersonalTitle() (r string, exists bool) {
	v := m.personal_title
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalTitle returns the old "personal_title" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPersonalTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPersonalTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPersonalTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalTitle: %w", err)
	}
	return oldValue.PersonalTitle, nil
}

// ClearPersonalTitle clears the value of the "personal_title" field.
func (m *PersonMutation) ClearPersonalTitle() {
	m.personal_title = nil
	m.clearedFields[person.FieldPersonalTitle] = struct{}{}
}

// PersonalTitleCleared returns if the "personal_title" field was cleared in this mutation.
func (m *PersonMutation) PersonalTitleCleared() bool {
	_, ok := m.clearedFields[person.FieldPersonalTitle]
	return ok
}

// ResetPersonalTitle resets all changes to the "personal_title" field.
func (m *PersonMutation) ResetPersonalTitle() {
	m.personal_title = nil
	delete(m.clearedFields, person.FieldPersonalTitle)
}

// SetSuffix sets the "suffix" field.
func (m *PersonMutation) SetSuffix(s string) {
	m.suffix = &s
}

// Suffix returns the value of the "suffix" field in the mutation.
func (m *PersonMutation) Suffix() (r string, exists bool) {
	v := m.suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldSuffix returns the old "suffix" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuffix: %w", err)
	}
	return oldValue.Suffix, nil
}

// ClearSuffix clears the value of the "suffix" field.
func (m *PersonMutation) ClearSuffix() {
	m.suffix = nil
	m.clearedFields[person.FieldSuffix] = struct{}{}
}

// SuffixCleared returns if the "suffix" field was cleared in this mutation.
func (m *PersonMutation) SuffixCleared() bool {
	_, ok := m.clearedFields[person.FieldSuffix]
	return ok
}

// ResetSuffix resets all changes to the "suffix" field.
func (m *PersonMutation) ResetSuffix() {
	m.suffix = nil
	delete(m.clearedFields, person.FieldSuffix)
}

// SetNickname sets the "nickname" field.
func (m *PersonMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *PersonMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *PersonMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[person.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *PersonMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[person.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *PersonMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, person.FieldNickname)
}

// SetFirstNameLocal sets the "first_name_local" field.
func (m *PersonMutation) SetFirstNameLocal(s string) {
	m.first_name_local = &s
}

// FirstNameLocal returns the value of the "first_name_local" field in the mutation.
func (m *PersonMutation) FirstNameLocal() (r string, exists bool) {
	v := m.first_name_local
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstNameLocal returns the old "first_name_local" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFirstNameLocal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstNameLocal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstNameLocal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstNameLocal: %w", err)
	}
	return oldValue.FirstNameLocal, nil
}

// ClearFirstNameLocal clears the value of the "first_name_local" field.
func (m *PersonMutation) ClearFirstNameLocal() {
	m.first_name_local = nil
	m.clearedFields[person.FieldFirstNameLocal] = struct{}{}
}

// FirstNameLocalCleared returns if the "first_name_local" field was cleared in this mutation.
func (m *PersonMutation) FirstNameLocalCleared() bool {
	_, ok := m.clearedFields[person.FieldFirstNameLocal]
	return ok
}

// ResetFirstNameLocal resets all changes to the "first_name_local" field.
func (m *PersonMutation) ResetFirstNameLocal() {
	m.first_name_local = nil
	delete(m.clearedFields, person.FieldFirstNameLocal)
}

// SetMiddleNameLocal sets the "middle_name_local" field.
func (m *PersonMutation) SetMiddleNameLocal(s string) {
	m.middle_name_local = &s
}

// MiddleNameLocal returns the value of the "middle_name_local" field in the mutation.
func (m *PersonMutation) MiddleNameLocal() (r string, exists bool) {
	v := m.middle_name_local
	if v == nil {
		return
	}
	return *v, true
}

// OldMiddleNameLocal returns the old "middle_name_local" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMiddleNameLocal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMiddleNameLocal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMiddleNameLocal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiddleNameLocal: %w", err)
	}
	return oldValue.MiddleNameLocal, nil
}

// ClearMiddleNameLocal clears the value of the "middle_name_local" field.
func (m *PersonMutation) ClearMiddleNameLocal() {
	m.middle_name_local = nil
	m.clearedFields[person.FieldMiddleNameLocal] = struct{}{}
}

// MiddleNameLocalCleared returns if the "middle_name_local" field was cleared in this mutation.
func (m *PersonMutation) MiddleNameLocalCleared() bool {
	_, ok := m.clearedFields[person.FieldMiddleNameLocal]
	return ok
}

// ResetMiddleNameLocal resets all changes to the "middle_name_local" field.
func (m *PersonMutation) ResetMiddleNameLocal() {
	m.middle_name_local = nil
	delete(m.clearedFields, person.FieldMiddleNameLocal)
}

// SetLastNameLocal sets the "last_name_local" field.
func (m *PersonMutation) SetLastNameLocal(s string) {
	m.last_name_local = &s
}

// LastNameLocal returns the value of the "last_name_local" field in the mutation.
func (m *PersonMutation) LastNameLocal() (r string, exists bool) {
	v := m.last_name_local
	if v == nil {
		return
	}
	return *v, true
}

// OldLastNameLocal returns the old "last_name_local" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastNameLocal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastNameLocal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastNameLocal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastNameLocal: %w", err)
	}
	return oldValue.LastNameLocal, nil
}

// ClearLastNameLocal clears the value of the "last_name_local" field.
func (m *PersonMutation) ClearLastNameLocal() {
	m.last_name_local = nil
	m.clearedFields[person.FieldLastNameLocal] = struct{}{}
}

// LastNameLocalCleared returns if the "last_name_local" field was cleared in this mutation.
func (m *PersonMutation) LastNameLocalCleared() bool {
	_, ok := m.clearedFields[person.FieldLastNameLocal]
	return ok
}

// ResetLastNameLocal resets all changes to the "last_name_local" field.
func (m *PersonMutation) ResetLastNameLocal() {
	m.last_name_local = nil
	delete(m.clearedFields, person.FieldLastNameLocal)
}

// SetOtherLocal sets the "other_local" field.
func (m *PersonMutation) SetOtherLocal(s string) {
	m.other_local = &s
}

// OtherLocal returns the value of the "other_local" field in the mutation.
func (m *PersonMutation) OtherLocal() (r string, exists bool) {
	v := m.other_local
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherLocal returns the old "other_local" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldOtherLocal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOtherLocal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOtherLocal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherLocal: %w", err)
	}
	return oldValue.OtherLocal, nil
}

// ClearOtherLocal clears the value of the "other_local" field.
func (m *PersonMutation) ClearOtherLocal() {
	m.other_local = nil
	m.clearedFields[person.FieldOtherLocal] = struct{}{}
}

// OtherLocalCleared returns if the "other_local" field was cleared in this mutation.
func (m *PersonMutation) OtherLocalCleared() bool {
	_, ok := m.clearedFields[person.FieldOtherLocal]
	return ok
}

// ResetOtherLocal resets all changes to the "other_local" field.
func (m *PersonMutation) ResetOtherLocal() {
	m.other_local = nil
	delete(m.clearedFields, person.FieldOtherLocal)
}

// SetMemberID sets the "member_id" field.
func (m *PersonMutation) SetMemberID(i int) {
	m.member_id = &i
	m.addmember_id = nil
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PersonMutation) MemberID() (r int, exists bool) {
	v := m.member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMemberID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// AddMemberID adds i to the "member_id" field.
func (m *PersonMutation) AddMemberID(i int) {
	if m.addmember_id != nil {
		*m.addmember_id += i
	} else {
		m.addmember_id = &i
	}
}

// AddedMemberID returns the value that was added to the "member_id" field in this mutation.
func (m *PersonMutation) AddedMemberID() (r int, exists bool) {
	v := m.addmember_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMemberID clears the value of the "member_id" field.
func (m *PersonMutation) ClearMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	m.clearedFields[person.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *PersonMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[person.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PersonMutation) ResetMemberID() {
	m.member_id = nil
	m.addmember_id = nil
	delete(m.clearedFields, person.FieldMemberID)
}

// SetGender sets the "gender" field.
func (m *PersonMutation) SetGender(pe person.Gender) {
	m.gender = &pe
}

// Gender returns the value of the "gender" field in the mutation.
func (m *PersonMutation) Gender() (r person.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldGender(ctx context.Context) (v person.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *PersonMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[person.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *PersonMutation) GenderCleared() bool {
	_, ok := m.clearedFields[person.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *PersonMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, person.FieldGender)
}

// SetBirthDate sets the "birth_date" field.
func (m *PersonMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *PersonMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ClearBirthDate clears the value of the "birth_date" field.
func (m *PersonMutation) ClearBirthDate() {
	m.birth_date = nil
	m.clearedFields[person.FieldBirthDate] = struct{}{}
}

// BirthDateCleared returns if the "birth_date" field was cleared in this mutation.
func (m *PersonMutation) BirthDateCleared() bool {
	_, ok := m.clearedFields[person.FieldBirthDate]
	return ok
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *PersonMutation) ResetBirthDate() {
	m.birth_date = nil
	delete(m.clearedFields, person.FieldBirthDate)
}

// SetDeceasedDate sets the "deceased_date" field.
func (m *PersonMutation) SetDeceasedDate(t time.Time) {
	m.deceased_date = &t
}

// DeceasedDate returns the value of the "deceased_date" field in the mutation.
func (m *PersonMutation) DeceasedDate() (r time.Time, exists bool) {
	v := m.deceased_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDeceasedDate returns the old "deceased_date" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDeceasedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeceasedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeceasedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeceasedDate: %w", err)
	}
	return oldValue.DeceasedDate, nil
}

// ClearDeceasedDate clears the value of the "deceased_date" field.
func (m *PersonMutation) ClearDeceasedDate() {
	m.deceased_date = nil
	m.clearedFields[person.FieldDeceasedDate] = struct{}{}
}

// DeceasedDateCleared returns if the "deceased_date" field was cleared in this mutation.
func (m *PersonMutation) DeceasedDateCleared() bool {
	_, ok := m.clearedFields[person.FieldDeceasedDate]
	return ok
}

// ResetDeceasedDate resets all changes to the "deceased_date" field.
func (m *PersonMutation) ResetDeceasedDate() {
	m.deceased_date = nil
	delete(m.clearedFields, person.FieldDeceasedDate)
}

// SetHeight sets the "height" field.
func (m *PersonMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PersonMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *PersonMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PersonMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *PersonMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[person.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *PersonMutation) HeightCleared() bool {
	_, ok := m.clearedFields[person.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *PersonMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, person.FieldHeight)
}

// SetWeight sets the "weight" field.
func (m *PersonMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PersonMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *PersonMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *PersonMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *PersonMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[person.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *PersonMutation) WeightCleared() bool {
	_, ok := m.clearedFields[person.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *PersonMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, person.FieldWeight)
}

// SetMothersMaidenName sets the "mothers_maiden_name" field.
func (m *PersonMutation) SetMothersMaidenName(s string) {
	m.mothers_maiden_name = &s
}

// MothersMaidenName returns the value of the "mothers_maiden_name" field in the mutation.
func (m *PersonMutation) MothersMaidenName() (r string, exists bool) {
	v := m.mothers_maiden_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMothersMaidenName returns the old "mothers_maiden_name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMothersMaidenName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMothersMaidenName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMothersMaidenName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMothersMaidenName: %w", err)
	}
	return oldValue.MothersMaidenName, nil
}

// ClearMothersMaidenName clears the value of the "mothers_maiden_name" field.
func (m *PersonMutation) ClearMothersMaidenName() {
	m.mothers_maiden_name = nil
	m.clearedFields[person.FieldMothersMaidenName] = struct{}{}
}

// MothersMaidenNameCleared returns if the "mothers_maiden_name" field was cleared in this mutation.
func (m *PersonMutation) MothersMaidenNameCleared() bool {
	_, ok := m.clearedFields[person.FieldMothersMaidenName]
	return ok
}

// ResetMothersMaidenName resets all changes to the "mothers_maiden_name" field.
func (m *PersonMutation) ResetMothersMaidenName() {
	m.mothers_maiden_name = nil
	delete(m.clearedFields, person.FieldMothersMaidenName)
}

// SetOldMaritalStatus sets the "old_marital_status" field.
func (m *PersonMutation) SetOldMaritalStatus(pms person.OldMaritalStatus) {
	m.old_marital_status = &pms
}

// OldMaritalStatus returns the value of the "old_marital_status" field in the mutation.
func (m *PersonMutation) OldMaritalStatus() (r person.OldMaritalStatus, exists bool) {
	v := m.old_marital_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOldMaritalStatus returns the old "old_marital_status" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldOldMaritalStatus(ctx context.Context) (v person.OldMaritalStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOldMaritalStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOldMaritalStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOldMaritalStatus: %w", err)
	}
	return oldValue.OldMaritalStatus, nil
}

// ClearOldMaritalStatus clears the value of the "old_marital_status" field.
func (m *PersonMutation) ClearOldMaritalStatus() {
	m.old_marital_status = nil
	m.clearedFields[person.FieldOldMaritalStatus] = struct{}{}
}

// OldMaritalStatusCleared returns if the "old_marital_status" field was cleared in this mutation.
func (m *PersonMutation) OldMaritalStatusCleared() bool {
	_, ok := m.clearedFields[person.FieldOldMaritalStatus]
	return ok
}

// ResetOldMaritalStatus resets all changes to the "old_marital_status" field.
func (m *PersonMutation) ResetOldMaritalStatus() {
	m.old_marital_status = nil
	delete(m.clearedFields, person.FieldOldMaritalStatus)
}

// SetMaritalStatusEnumID sets the "marital_status_enum_id" field.
func (m *PersonMutation) SetMaritalStatusEnumID(i int) {
	m.marital_status_enum_id = &i
	m.addmarital_status_enum_id = nil
}

// MaritalStatusEnumID returns the value of the "marital_status_enum_id" field in the mutation.
func (m *PersonMutation) MaritalStatusEnumID() (r int, exists bool) {
	v := m.marital_status_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMaritalStatusEnumID returns the old "marital_status_enum_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMaritalStatusEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaritalStatusEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaritalStatusEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaritalStatusEnumID: %w", err)
	}
	return oldValue.MaritalStatusEnumID, nil
}

// AddMaritalStatusEnumID adds i to the "marital_status_enum_id" field.
func (m *PersonMutation) AddMaritalStatusEnumID(i int) {
	if m.addmarital_status_enum_id != nil {
		*m.addmarital_status_enum_id += i
	} else {
		m.addmarital_status_enum_id = &i
	}
}

// AddedMaritalStatusEnumID returns the value that was added to the "marital_status_enum_id" field in this mutation.
func (m *PersonMutation) AddedMaritalStatusEnumID() (r int, exists bool) {
	v := m.addmarital_status_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaritalStatusEnumID clears the value of the "marital_status_enum_id" field.
func (m *PersonMutation) ClearMaritalStatusEnumID() {
	m.marital_status_enum_id = nil
	m.addmarital_status_enum_id = nil
	m.clearedFields[person.FieldMaritalStatusEnumID] = struct{}{}
}

// MaritalStatusEnumIDCleared returns if the "marital_status_enum_id" field was cleared in this mutation.
func (m *PersonMutation) MaritalStatusEnumIDCleared() bool {
	_, ok := m.clearedFields[person.FieldMaritalStatusEnumID]
	return ok
}

// ResetMaritalStatusEnumID resets all changes to the "marital_status_enum_id" field.
func (m *PersonMutation) ResetMaritalStatusEnumID() {
	m.marital_status_enum_id = nil
	m.addmarital_status_enum_id = nil
	delete(m.clearedFields, person.FieldMaritalStatusEnumID)
}

// SetSocialSecurityNumber sets the "social_security_number" field.
func (m *PersonMutation) SetSocialSecurityNumber(s string) {
	m.social_security_number = &s
}

// SocialSecurityNumber returns the value of the "social_security_number" field in the mutation.
func (m *PersonMutation) SocialSecurityNumber() (r string, exists bool) {
	v := m.social_security_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialSecurityNumber returns the old "social_security_number" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldSocialSecurityNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSocialSecurityNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSocialSecurityNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialSecurityNumber: %w", err)
	}
	return oldValue.SocialSecurityNumber, nil
}

// ClearSocialSecurityNumber clears the value of the "social_security_number" field.
func (m *PersonMutation) ClearSocialSecurityNumber() {
	m.social_security_number = nil
	m.clearedFields[person.FieldSocialSecurityNumber] = struct{}{}
}

// SocialSecurityNumberCleared returns if the "social_security_number" field was cleared in this mutation.
func (m *PersonMutation) SocialSecurityNumberCleared() bool {
	_, ok := m.clearedFields[person.FieldSocialSecurityNumber]
	return ok
}

// ResetSocialSecurityNumber resets all changes to the "social_security_number" field.
func (m *PersonMutation) ResetSocialSecurityNumber() {
	m.social_security_number = nil
	delete(m.clearedFields, person.FieldSocialSecurityNumber)
}

// SetPassportNumber sets the "passport_number" field.
func (m *PersonMutation) SetPassportNumber(s string) {
	m.passport_number = &s
}

// PassportNumber returns the value of the "passport_number" field in the mutation.
func (m *PersonMutation) PassportNumber() (r string, exists bool) {
	v := m.passport_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPassportNumber returns the old "passport_number" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPassportNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassportNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassportNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassportNumber: %w", err)
	}
	return oldValue.PassportNumber, nil
}

// ClearPassportNumber clears the value of the "passport_number" field.
func (m *PersonMutation) ClearPassportNumber() {
	m.passport_number = nil
	m.clearedFields[person.FieldPassportNumber] = struct{}{}
}

// PassportNumberCleared returns if the "passport_number" field was cleared in this mutation.
func (m *PersonMutation) PassportNumberCleared() bool {
	_, ok := m.clearedFields[person.FieldPassportNumber]
	return ok
}

// ResetPassportNumber resets all changes to the "passport_number" field.
func (m *PersonMutation) ResetPassportNumber() {
	m.passport_number = nil
	delete(m.clearedFields, person.FieldPassportNumber)
}

// SetPassportExpireDate sets the "passport_expire_date" field.
func (m *PersonMutation) SetPassportExpireDate(t time.Time) {
	m.passport_expire_date = &t
}

// PassportExpireDate returns the value of the "passport_expire_date" field in the mutation.
func (m *PersonMutation) PassportExpireDate() (r time.Time, exists bool) {
	v := m.passport_expire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPassportExpireDate returns the old "passport_expire_date" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldPassportExpireDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassportExpireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassportExpireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassportExpireDate: %w", err)
	}
	return oldValue.PassportExpireDate, nil
}

// ClearPassportExpireDate clears the value of the "passport_expire_date" field.
func (m *PersonMutation) ClearPassportExpireDate() {
	m.passport_expire_date = nil
	m.clearedFields[person.FieldPassportExpireDate] = struct{}{}
}

// PassportExpireDateCleared returns if the "passport_expire_date" field was cleared in this mutation.
func (m *PersonMutation) PassportExpireDateCleared() bool {
	_, ok := m.clearedFields[person.FieldPassportExpireDate]
	return ok
}

// ResetPassportExpireDate resets all changes to the "passport_expire_date" field.
func (m *PersonMutation) ResetPassportExpireDate() {
	m.passport_expire_date = nil
	delete(m.clearedFields, person.FieldPassportExpireDate)
}

// SetTotalYearsWorkExperience sets the "total_years_work_experience" field.
func (m *PersonMutation) SetTotalYearsWorkExperience(f float64) {
	m.total_years_work_experience = &f
	m.addtotal_years_work_experience = nil
}

// TotalYearsWorkExperience returns the value of the "total_years_work_experience" field in the mutation.
func (m *PersonMutation) TotalYearsWorkExperience() (r float64, exists bool) {
	v := m.total_years_work_experience
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalYearsWorkExperience returns the old "total_years_work_experience" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldTotalYearsWorkExperience(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalYearsWorkExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalYearsWorkExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalYearsWorkExperience: %w", err)
	}
	return oldValue.TotalYearsWorkExperience, nil
}

// AddTotalYearsWorkExperience adds f to the "total_years_work_experience" field.
func (m *PersonMutation) AddTotalYearsWorkExperience(f float64) {
	if m.addtotal_years_work_experience != nil {
		*m.addtotal_years_work_experience += f
	} else {
		m.addtotal_years_work_experience = &f
	}
}

// AddedTotalYearsWorkExperience returns the value that was added to the "total_years_work_experience" field in this mutation.
func (m *PersonMutation) AddedTotalYearsWorkExperience() (r float64, exists bool) {
	v := m.addtotal_years_work_experience
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalYearsWorkExperience clears the value of the "total_years_work_experience" field.
func (m *PersonMutation) ClearTotalYearsWorkExperience() {
	m.total_years_work_experience = nil
	m.addtotal_years_work_experience = nil
	m.clearedFields[person.FieldTotalYearsWorkExperience] = struct{}{}
}

// TotalYearsWorkExperienceCleared returns if the "total_years_work_experience" field was cleared in this mutation.
func (m *PersonMutation) TotalYearsWorkExperienceCleared() bool {
	_, ok := m.clearedFields[person.FieldTotalYearsWorkExperience]
	return ok
}

// ResetTotalYearsWorkExperience resets all changes to the "total_years_work_experience" field.
func (m *PersonMutation) ResetTotalYearsWorkExperience() {
	m.total_years_work_experience = nil
	m.addtotal_years_work_experience = nil
	delete(m.clearedFields, person.FieldTotalYearsWorkExperience)
}

// SetComments sets the "comments" field.
func (m *PersonMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *PersonMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *PersonMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[person.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *PersonMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[person.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *PersonMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, person.FieldComments)
}

// SetEmploymentStatusEnumID sets the "employment_status_enum_id" field.
func (m *PersonMutation) SetEmploymentStatusEnumID(i int) {
	m.employment_status_enum_id = &i
	m.addemployment_status_enum_id = nil
}

// EmploymentStatusEnumID returns the value of the "employment_status_enum_id" field in the mutation.
func (m *PersonMutation) EmploymentStatusEnumID() (r int, exists bool) {
	v := m.employment_status_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmploymentStatusEnumID returns the old "employment_status_enum_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEmploymentStatusEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmploymentStatusEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmploymentStatusEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmploymentStatusEnumID: %w", err)
	}
	return oldValue.EmploymentStatusEnumID, nil
}

// AddEmploymentStatusEnumID adds i to the "employment_status_enum_id" field.
func (m *PersonMutation) AddEmploymentStatusEnumID(i int) {
	if m.addemployment_status_enum_id != nil {
		*m.addemployment_status_enum_id += i
	} else {
		m.addemployment_status_enum_id = &i
	}
}

// AddedEmploymentStatusEnumID returns the value that was added to the "employment_status_enum_id" field in this mutation.
func (m *PersonMutation) AddedEmploymentStatusEnumID() (r int, exists bool) {
	v := m.addemployment_status_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmploymentStatusEnumID clears the value of the "employment_status_enum_id" field.
func (m *PersonMutation) ClearEmploymentStatusEnumID() {
	m.employment_status_enum_id = nil
	m.addemployment_status_enum_id = nil
	m.clearedFields[person.FieldEmploymentStatusEnumID] = struct{}{}
}

// EmploymentStatusEnumIDCleared returns if the "employment_status_enum_id" field was cleared in this mutation.
func (m *PersonMutation) EmploymentStatusEnumIDCleared() bool {
	_, ok := m.clearedFields[person.FieldEmploymentStatusEnumID]
	return ok
}

// ResetEmploymentStatusEnumID resets all changes to the "employment_status_enum_id" field.
func (m *PersonMutation) ResetEmploymentStatusEnumID() {
	m.employment_status_enum_id = nil
	m.addemployment_status_enum_id = nil
	delete(m.clearedFields, person.FieldEmploymentStatusEnumID)
}

// SetResidenceStatusEnumID sets the "residence_status_enum_id" field.
func (m *PersonMutation) SetResidenceStatusEnumID(i int) {
	m.residence_status_enum_id = &i
	m.addresidence_status_enum_id = nil
}

// ResidenceStatusEnumID returns the value of the "residence_status_enum_id" field in the mutation.
func (m *PersonMutation) ResidenceStatusEnumID() (r int, exists bool) {
	v := m.residence_status_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResidenceStatusEnumID returns the old "residence_status_enum_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldResidenceStatusEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResidenceStatusEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResidenceStatusEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResidenceStatusEnumID: %w", err)
	}
	return oldValue.ResidenceStatusEnumID, nil
}

// AddResidenceStatusEnumID adds i to the "residence_status_enum_id" field.
func (m *PersonMutation) AddResidenceStatusEnumID(i int) {
	if m.addresidence_status_enum_id != nil {
		*m.addresidence_status_enum_id += i
	} else {
		m.addresidence_status_enum_id = &i
	}
}

// AddedResidenceStatusEnumID returns the value that was added to the "residence_status_enum_id" field in this mutation.
func (m *PersonMutation) AddedResidenceStatusEnumID() (r int, exists bool) {
	v := m.addresidence_status_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearResidenceStatusEnumID clears the value of the "residence_status_enum_id" field.
func (m *PersonMutation) ClearResidenceStatusEnumID() {
	m.residence_status_enum_id = nil
	m.addresidence_status_enum_id = nil
	m.clearedFields[person.FieldResidenceStatusEnumID] = struct{}{}
}

// ResidenceStatusEnumIDCleared returns if the "residence_status_enum_id" field was cleared in this mutation.
func (m *PersonMutation) ResidenceStatusEnumIDCleared() bool {
	_, ok := m.clearedFields[person.FieldResidenceStatusEnumID]
	return ok
}

// ResetResidenceStatusEnumID resets all changes to the "residence_status_enum_id" field.
func (m *PersonMutation) ResetResidenceStatusEnumID() {
	m.residence_status_enum_id = nil
	m.addresidence_status_enum_id = nil
	delete(m.clearedFields, person.FieldResidenceStatusEnumID)
}

// SetOccupation sets the "occupation" field.
func (m *PersonMutation) SetOccupation(s string) {
	m.occupation = &s
}

// Occupation returns the value of the "occupation" field in the mutation.
func (m *PersonMutation) Occupation() (r string, exists bool) {
	v := m.occupation
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupation returns the old "occupation" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldOccupation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOccupation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOccupation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupation: %w", err)
	}
	return oldValue.Occupation, nil
}

// ClearOccupation clears the value of the "occupation" field.
func (m *PersonMutation) ClearOccupation() {
	m.occupation = nil
	m.clearedFields[person.FieldOccupation] = struct{}{}
}

// OccupationCleared returns if the "occupation" field was cleared in this mutation.
func (m *PersonMutation) OccupationCleared() bool {
	_, ok := m.clearedFields[person.FieldOccupation]
	return ok
}

// ResetOccupation resets all changes to the "occupation" field.
func (m *PersonMutation) ResetOccupation() {
	m.occupation = nil
	delete(m.clearedFields, person.FieldOccupation)
}

// SetYearsWithEmployer sets the "years_with_employer" field.
func (m *PersonMutation) SetYearsWithEmployer(i int) {
	m.years_with_employer = &i
	m.addyears_with_employer = nil
}

// YearsWithEmployer returns the value of the "years_with_employer" field in the mutation.
func (m *PersonMutation) YearsWithEmployer() (r int, exists bool) {
	v := m.years_with_employer
	if v == nil {
		return
	}
	return *v, true
}

// OldYearsWithEmployer returns the old "years_with_employer" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldYearsWithEmployer(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldYearsWithEmployer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldYearsWithEmployer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearsWithEmployer: %w", err)
	}
	return oldValue.YearsWithEmployer, nil
}

// AddYearsWithEmployer adds i to the "years_with_employer" field.
func (m *PersonMutation) AddYearsWithEmployer(i int) {
	if m.addyears_with_employer != nil {
		*m.addyears_with_employer += i
	} else {
		m.addyears_with_employer = &i
	}
}

// AddedYearsWithEmployer returns the value that was added to the "years_with_employer" field in this mutation.
func (m *PersonMutation) AddedYearsWithEmployer() (r int, exists bool) {
	v := m.addyears_with_employer
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearsWithEmployer clears the value of the "years_with_employer" field.
func (m *PersonMutation) ClearYearsWithEmployer() {
	m.years_with_employer = nil
	m.addyears_with_employer = nil
	m.clearedFields[person.FieldYearsWithEmployer] = struct{}{}
}

// YearsWithEmployerCleared returns if the "years_with_employer" field was cleared in this mutation.
func (m *PersonMutation) YearsWithEmployerCleared() bool {
	_, ok := m.clearedFields[person.FieldYearsWithEmployer]
	return ok
}

// ResetYearsWithEmployer resets all changes to the "years_with_employer" field.
func (m *PersonMutation) ResetYearsWithEmployer() {
	m.years_with_employer = nil
	m.addyears_with_employer = nil
	delete(m.clearedFields, person.FieldYearsWithEmployer)
}

// SetMonthsWithEmployer sets the "months_with_employer" field.
func (m *PersonMutation) SetMonthsWithEmployer(i int) {
	m.months_with_employer = &i
	m.addmonths_with_employer = nil
}

// MonthsWithEmployer returns the value of the "months_with_employer" field in the mutation.
func (m *PersonMutation) MonthsWithEmployer() (r int, exists bool) {
	v := m.months_with_employer
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthsWithEmployer returns the old "months_with_employer" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldMonthsWithEmployer(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMonthsWithEmployer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMonthsWithEmployer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthsWithEmployer: %w", err)
	}
	return oldValue.MonthsWithEmployer, nil
}

// AddMonthsWithEmployer adds i to the "months_with_employer" field.
func (m *PersonMutation) AddMonthsWithEmployer(i int) {
	if m.addmonths_with_employer != nil {
		*m.addmonths_with_employer += i
	} else {
		m.addmonths_with_employer = &i
	}
}

// AddedMonthsWithEmployer returns the value that was added to the "months_with_employer" field in this mutation.
func (m *PersonMutation) AddedMonthsWithEmployer() (r int, exists bool) {
	v := m.addmonths_with_employer
	if v == nil {
		return
	}
	return *v, true
}

// ClearMonthsWithEmployer clears the value of the "months_with_employer" field.
func (m *PersonMutation) ClearMonthsWithEmployer() {
	m.months_with_employer = nil
	m.addmonths_with_employer = nil
	m.clearedFields[person.FieldMonthsWithEmployer] = struct{}{}
}

// MonthsWithEmployerCleared returns if the "months_with_employer" field was cleared in this mutation.
func (m *PersonMutation) MonthsWithEmployerCleared() bool {
	_, ok := m.clearedFields[person.FieldMonthsWithEmployer]
	return ok
}

// ResetMonthsWithEmployer resets all changes to the "months_with_employer" field.
func (m *PersonMutation) ResetMonthsWithEmployer() {
	m.months_with_employer = nil
	m.addmonths_with_employer = nil
	delete(m.clearedFields, person.FieldMonthsWithEmployer)
}

// SetExistingCustomer sets the "existing_customer" field.
func (m *PersonMutation) SetExistingCustomer(pc person.ExistingCustomer) {
	m.existing_customer = &pc
}

// ExistingCustomer returns the value of the "existing_customer" field in the mutation.
func (m *PersonMutation) ExistingCustomer() (r person.ExistingCustomer, exists bool) {
	v := m.existing_customer
	if v == nil {
		return
	}
	return *v, true
}

// OldExistingCustomer returns the old "existing_customer" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldExistingCustomer(ctx context.Context) (v person.ExistingCustomer, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExistingCustomer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExistingCustomer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExistingCustomer: %w", err)
	}
	return oldValue.ExistingCustomer, nil
}

// ClearExistingCustomer clears the value of the "existing_customer" field.
func (m *PersonMutation) ClearExistingCustomer() {
	m.existing_customer = nil
	m.clearedFields[person.FieldExistingCustomer] = struct{}{}
}

// ExistingCustomerCleared returns if the "existing_customer" field was cleared in this mutation.
func (m *PersonMutation) ExistingCustomerCleared() bool {
	_, ok := m.clearedFields[person.FieldExistingCustomer]
	return ok
}

// ResetExistingCustomer resets all changes to the "existing_customer" field.
func (m *PersonMutation) ResetExistingCustomer() {
	m.existing_customer = nil
	delete(m.clearedFields, person.FieldExistingCustomer)
}

// SetCardID sets the "card_id" field.
func (m *PersonMutation) SetCardID(s string) {
	m.card_id = &s
}

// CardID returns the value of the "card_id" field in the mutation.
func (m *PersonMutation) CardID() (r string, exists bool) {
	v := m.card_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCardID returns the old "card_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardID: %w", err)
	}
	return oldValue.CardID, nil
}

// ClearCardID clears the value of the "card_id" field.
func (m *PersonMutation) ClearCardID() {
	m.card_id = nil
	m.clearedFields[person.FieldCardID] = struct{}{}
}

// CardIDCleared returns if the "card_id" field was cleared in this mutation.
func (m *PersonMutation) CardIDCleared() bool {
	_, ok := m.clearedFields[person.FieldCardID]
	return ok
}

// ResetCardID resets all changes to the "card_id" field.
func (m *PersonMutation) ResetCardID() {
	m.card_id = nil
	delete(m.clearedFields, person.FieldCardID)
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *PersonMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *PersonMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *PersonMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *PersonMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *PersonMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *PersonMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// AddUserLoginIDs adds the "user_logins" edge to the UserLogin entity by ids.
func (m *PersonMutation) AddUserLoginIDs(ids ...int) {
	if m.user_logins == nil {
		m.user_logins = make(map[int]struct{})
	}
	for i := range ids {
		m.user_logins[ids[i]] = struct{}{}
	}
}

// ClearUserLogins clears the "user_logins" edge to the UserLogin entity.
func (m *PersonMutation) ClearUserLogins() {
	m.cleareduser_logins = true
}

// UserLoginsCleared reports if the "user_logins" edge to the UserLogin entity was cleared.
func (m *PersonMutation) UserLoginsCleared() bool {
	return m.cleareduser_logins
}

// RemoveUserLoginIDs removes the "user_logins" edge to the UserLogin entity by IDs.
func (m *PersonMutation) RemoveUserLoginIDs(ids ...int) {
	if m.removeduser_logins == nil {
		m.removeduser_logins = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_logins[ids[i]] = struct{}{}
	}
}

// RemovedUserLogins returns the removed IDs of the "user_logins" edge to the UserLogin entity.
func (m *PersonMutation) RemovedUserLoginsIDs() (ids []int) {
	for id := range m.removeduser_logins {
		ids = append(ids, id)
	}
	return
}

// UserLoginsIDs returns the "user_logins" edge IDs in the mutation.
func (m *PersonMutation) UserLoginsIDs() (ids []int) {
	for id := range m.user_logins {
		ids = append(ids, id)
	}
	return
}

// ResetUserLogins resets all changes to the "user_logins" edge.
func (m *PersonMutation) ResetUserLogins() {
	m.user_logins = nil
	m.cleareduser_logins = false
	m.removeduser_logins = nil
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.salutation != nil {
		fields = append(fields, person.FieldSalutation)
	}
	if m.first_name != nil {
		fields = append(fields, person.FieldFirstName)
	}
	if m.middle_name != nil {
		fields = append(fields, person.FieldMiddleName)
	}
	if m.last_name != nil {
		fields = append(fields, person.FieldLastName)
	}
	if m.personal_title != nil {
		fields = append(fields, person.FieldPersonalTitle)
	}
	if m.suffix != nil {
		fields = append(fields, person.FieldSuffix)
	}
	if m.nickname != nil {
		fields = append(fields, person.FieldNickname)
	}
	if m.first_name_local != nil {
		fields = append(fields, person.FieldFirstNameLocal)
	}
	if m.middle_name_local != nil {
		fields = append(fields, person.FieldMiddleNameLocal)
	}
	if m.last_name_local != nil {
		fields = append(fields, person.FieldLastNameLocal)
	}
	if m.other_local != nil {
		fields = append(fields, person.FieldOtherLocal)
	}
	if m.member_id != nil {
		fields = append(fields, person.FieldMemberID)
	}
	if m.gender != nil {
		fields = append(fields, person.FieldGender)
	}
	if m.birth_date != nil {
		fields = append(fields, person.FieldBirthDate)
	}
	if m.deceased_date != nil {
		fields = append(fields, person.FieldDeceasedDate)
	}
	if m.height != nil {
		fields = append(fields, person.FieldHeight)
	}
	if m.weight != nil {
		fields = append(fields, person.FieldWeight)
	}
	if m.mothers_maiden_name != nil {
		fields = append(fields, person.FieldMothersMaidenName)
	}
	if m.old_marital_status != nil {
		fields = append(fields, person.FieldOldMaritalStatus)
	}
	if m.marital_status_enum_id != nil {
		fields = append(fields, person.FieldMaritalStatusEnumID)
	}
	if m.social_security_number != nil {
		fields = append(fields, person.FieldSocialSecurityNumber)
	}
	if m.passport_number != nil {
		fields = append(fields, person.FieldPassportNumber)
	}
	if m.passport_expire_date != nil {
		fields = append(fields, person.FieldPassportExpireDate)
	}
	if m.total_years_work_experience != nil {
		fields = append(fields, person.FieldTotalYearsWorkExperience)
	}
	if m.comments != nil {
		fields = append(fields, person.FieldComments)
	}
	if m.employment_status_enum_id != nil {
		fields = append(fields, person.FieldEmploymentStatusEnumID)
	}
	if m.residence_status_enum_id != nil {
		fields = append(fields, person.FieldResidenceStatusEnumID)
	}
	if m.occupation != nil {
		fields = append(fields, person.FieldOccupation)
	}
	if m.years_with_employer != nil {
		fields = append(fields, person.FieldYearsWithEmployer)
	}
	if m.months_with_employer != nil {
		fields = append(fields, person.FieldMonthsWithEmployer)
	}
	if m.existing_customer != nil {
		fields = append(fields, person.FieldExistingCustomer)
	}
	if m.card_id != nil {
		fields = append(fields, person.FieldCardID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldSalutation:
		return m.Salutation()
	case person.FieldFirstName:
		return m.FirstName()
	case person.FieldMiddleName:
		return m.MiddleName()
	case person.FieldLastName:
		return m.LastName()
	case person.FieldPersonalTitle:
		return m.PersonalTitle()
	case person.FieldSuffix:
		return m.Suffix()
	case person.FieldNickname:
		return m.Nickname()
	case person.FieldFirstNameLocal:
		return m.FirstNameLocal()
	case person.FieldMiddleNameLocal:
		return m.MiddleNameLocal()
	case person.FieldLastNameLocal:
		return m.LastNameLocal()
	case person.FieldOtherLocal:
		return m.OtherLocal()
	case person.FieldMemberID:
		return m.MemberID()
	case person.FieldGender:
		return m.Gender()
	case person.FieldBirthDate:
		return m.BirthDate()
	case person.FieldDeceasedDate:
		return m.DeceasedDate()
	case person.FieldHeight:
		return m.Height()
	case person.FieldWeight:
		return m.Weight()
	case person.FieldMothersMaidenName:
		return m.MothersMaidenName()
	case person.FieldOldMaritalStatus:
		return m.OldMaritalStatus()
	case person.FieldMaritalStatusEnumID:
		return m.MaritalStatusEnumID()
	case person.FieldSocialSecurityNumber:
		return m.SocialSecurityNumber()
	case person.FieldPassportNumber:
		return m.PassportNumber()
	case person.FieldPassportExpireDate:
		return m.PassportExpireDate()
	case person.FieldTotalYearsWorkExperience:
		return m.TotalYearsWorkExperience()
	case person.FieldComments:
		return m.Comments()
	case person.FieldEmploymentStatusEnumID:
		return m.EmploymentStatusEnumID()
	case person.FieldResidenceStatusEnumID:
		return m.ResidenceStatusEnumID()
	case person.FieldOccupation:
		return m.Occupation()
	case person.FieldYearsWithEmployer:
		return m.YearsWithEmployer()
	case person.FieldMonthsWithEmployer:
		return m.MonthsWithEmployer()
	case person.FieldExistingCustomer:
		return m.ExistingCustomer()
	case person.FieldCardID:
		return m.CardID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldSalutation:
		return m.OldSalutation(ctx)
	case person.FieldFirstName:
		return m.OldFirstName(ctx)
	case person.FieldMiddleName:
		return m.OldMiddleName(ctx)
	case person.FieldLastName:
		return m.OldLastName(ctx)
	case person.FieldPersonalTitle:
		return m.OldPersonalTitle(ctx)
	case person.FieldSuffix:
		return m.OldSuffix(ctx)
	case person.FieldNickname:
		return m.OldNickname(ctx)
	case person.FieldFirstNameLocal:
		return m.OldFirstNameLocal(ctx)
	case person.FieldMiddleNameLocal:
		return m.OldMiddleNameLocal(ctx)
	case person.FieldLastNameLocal:
		return m.OldLastNameLocal(ctx)
	case person.FieldOtherLocal:
		return m.OldOtherLocal(ctx)
	case person.FieldMemberID:
		return m.OldMemberID(ctx)
	case person.FieldGender:
		return m.OldGender(ctx)
	case person.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case person.FieldDeceasedDate:
		return m.OldDeceasedDate(ctx)
	case person.FieldHeight:
		return m.OldHeight(ctx)
	case person.FieldWeight:
		return m.OldWeight(ctx)
	case person.FieldMothersMaidenName:
		return m.OldMothersMaidenName(ctx)
	case person.FieldOldMaritalStatus:
		return m.OldOldMaritalStatus(ctx)
	case person.FieldMaritalStatusEnumID:
		return m.OldMaritalStatusEnumID(ctx)
	case person.FieldSocialSecurityNumber:
		return m.OldSocialSecurityNumber(ctx)
	case person.FieldPassportNumber:
		return m.OldPassportNumber(ctx)
	case person.FieldPassportExpireDate:
		return m.OldPassportExpireDate(ctx)
	case person.FieldTotalYearsWorkExperience:
		return m.OldTotalYearsWorkExperience(ctx)
	case person.FieldComments:
		return m.OldComments(ctx)
	case person.FieldEmploymentStatusEnumID:
		return m.OldEmploymentStatusEnumID(ctx)
	case person.FieldResidenceStatusEnumID:
		return m.OldResidenceStatusEnumID(ctx)
	case person.FieldOccupation:
		return m.OldOccupation(ctx)
	case person.FieldYearsWithEmployer:
		return m.OldYearsWithEmployer(ctx)
	case person.FieldMonthsWithEmployer:
		return m.OldMonthsWithEmployer(ctx)
	case person.FieldExistingCustomer:
		return m.OldExistingCustomer(ctx)
	case person.FieldCardID:
		return m.OldCardID(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldSalutation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalutation(v)
		return nil
	case person.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case person.FieldMiddleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleName(v)
		return nil
	case person.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case person.FieldPersonalTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalTitle(v)
		return nil
	case person.FieldSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuffix(v)
		return nil
	case person.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case person.FieldFirstNameLocal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstNameLocal(v)
		return nil
	case person.FieldMiddleNameLocal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiddleNameLocal(v)
		return nil
	case person.FieldLastNameLocal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastNameLocal(v)
		return nil
	case person.FieldOtherLocal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherLocal(v)
		return nil
	case person.FieldMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case person.FieldGender:
		v, ok := value.(person.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case person.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case person.FieldDeceasedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeceasedDate(v)
		return nil
	case person.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case person.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case person.FieldMothersMaidenName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMothersMaidenName(v)
		return nil
	case person.FieldOldMaritalStatus:
		v, ok := value.(person.OldMaritalStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOldMaritalStatus(v)
		return nil
	case person.FieldMaritalStatusEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaritalStatusEnumID(v)
		return nil
	case person.FieldSocialSecurityNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialSecurityNumber(v)
		return nil
	case person.FieldPassportNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassportNumber(v)
		return nil
	case person.FieldPassportExpireDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassportExpireDate(v)
		return nil
	case person.FieldTotalYearsWorkExperience:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalYearsWorkExperience(v)
		return nil
	case person.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case person.FieldEmploymentStatusEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmploymentStatusEnumID(v)
		return nil
	case person.FieldResidenceStatusEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResidenceStatusEnumID(v)
		return nil
	case person.FieldOccupation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupation(v)
		return nil
	case person.FieldYearsWithEmployer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearsWithEmployer(v)
		return nil
	case person.FieldMonthsWithEmployer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthsWithEmployer(v)
		return nil
	case person.FieldExistingCustomer:
		v, ok := value.(person.ExistingCustomer)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExistingCustomer(v)
		return nil
	case person.FieldCardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardID(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addmember_id != nil {
		fields = append(fields, person.FieldMemberID)
	}
	if m.addheight != nil {
		fields = append(fields, person.FieldHeight)
	}
	if m.addweight != nil {
		fields = append(fields, person.FieldWeight)
	}
	if m.addmarital_status_enum_id != nil {
		fields = append(fields, person.FieldMaritalStatusEnumID)
	}
	if m.addtotal_years_work_experience != nil {
		fields = append(fields, person.FieldTotalYearsWorkExperience)
	}
	if m.addemployment_status_enum_id != nil {
		fields = append(fields, person.FieldEmploymentStatusEnumID)
	}
	if m.addresidence_status_enum_id != nil {
		fields = append(fields, person.FieldResidenceStatusEnumID)
	}
	if m.addyears_with_employer != nil {
		fields = append(fields, person.FieldYearsWithEmployer)
	}
	if m.addmonths_with_employer != nil {
		fields = append(fields, person.FieldMonthsWithEmployer)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldMemberID:
		return m.AddedMemberID()
	case person.FieldHeight:
		return m.AddedHeight()
	case person.FieldWeight:
		return m.AddedWeight()
	case person.FieldMaritalStatusEnumID:
		return m.AddedMaritalStatusEnumID()
	case person.FieldTotalYearsWorkExperience:
		return m.AddedTotalYearsWorkExperience()
	case person.FieldEmploymentStatusEnumID:
		return m.AddedEmploymentStatusEnumID()
	case person.FieldResidenceStatusEnumID:
		return m.AddedResidenceStatusEnumID()
	case person.FieldYearsWithEmployer:
		return m.AddedYearsWithEmployer()
	case person.FieldMonthsWithEmployer:
		return m.AddedMonthsWithEmployer()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberID(v)
		return nil
	case person.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case person.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case person.FieldMaritalStatusEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaritalStatusEnumID(v)
		return nil
	case person.FieldTotalYearsWorkExperience:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalYearsWorkExperience(v)
		return nil
	case person.FieldEmploymentStatusEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmploymentStatusEnumID(v)
		return nil
	case person.FieldResidenceStatusEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResidenceStatusEnumID(v)
		return nil
	case person.FieldYearsWithEmployer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearsWithEmployer(v)
		return nil
	case person.FieldMonthsWithEmployer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthsWithEmployer(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldSalutation) {
		fields = append(fields, person.FieldSalutation)
	}
	if m.FieldCleared(person.FieldFirstName) {
		fields = append(fields, person.FieldFirstName)
	}
	if m.FieldCleared(person.FieldMiddleName) {
		fields = append(fields, person.FieldMiddleName)
	}
	if m.FieldCleared(person.FieldLastName) {
		fields = append(fields, person.FieldLastName)
	}
	if m.FieldCleared(person.FieldPersonalTitle) {
		fields = append(fields, person.FieldPersonalTitle)
	}
	if m.FieldCleared(person.FieldSuffix) {
		fields = append(fields, person.FieldSuffix)
	}
	if m.FieldCleared(person.FieldNickname) {
		fields = append(fields, person.FieldNickname)
	}
	if m.FieldCleared(person.FieldFirstNameLocal) {
		fields = append(fields, person.FieldFirstNameLocal)
	}
	if m.FieldCleared(person.FieldMiddleNameLocal) {
		fields = append(fields, person.FieldMiddleNameLocal)
	}
	if m.FieldCleared(person.FieldLastNameLocal) {
		fields = append(fields, person.FieldLastNameLocal)
	}
	if m.FieldCleared(person.FieldOtherLocal) {
		fields = append(fields, person.FieldOtherLocal)
	}
	if m.FieldCleared(person.FieldMemberID) {
		fields = append(fields, person.FieldMemberID)
	}
	if m.FieldCleared(person.FieldGender) {
		fields = append(fields, person.FieldGender)
	}
	if m.FieldCleared(person.FieldBirthDate) {
		fields = append(fields, person.FieldBirthDate)
	}
	if m.FieldCleared(person.FieldDeceasedDate) {
		fields = append(fields, person.FieldDeceasedDate)
	}
	if m.FieldCleared(person.FieldHeight) {
		fields = append(fields, person.FieldHeight)
	}
	if m.FieldCleared(person.FieldWeight) {
		fields = append(fields, person.FieldWeight)
	}
	if m.FieldCleared(person.FieldMothersMaidenName) {
		fields = append(fields, person.FieldMothersMaidenName)
	}
	if m.FieldCleared(person.FieldOldMaritalStatus) {
		fields = append(fields, person.FieldOldMaritalStatus)
	}
	if m.FieldCleared(person.FieldMaritalStatusEnumID) {
		fields = append(fields, person.FieldMaritalStatusEnumID)
	}
	if m.FieldCleared(person.FieldSocialSecurityNumber) {
		fields = append(fields, person.FieldSocialSecurityNumber)
	}
	if m.FieldCleared(person.FieldPassportNumber) {
		fields = append(fields, person.FieldPassportNumber)
	}
	if m.FieldCleared(person.FieldPassportExpireDate) {
		fields = append(fields, person.FieldPassportExpireDate)
	}
	if m.FieldCleared(person.FieldTotalYearsWorkExperience) {
		fields = append(fields, person.FieldTotalYearsWorkExperience)
	}
	if m.FieldCleared(person.FieldComments) {
		fields = append(fields, person.FieldComments)
	}
	if m.FieldCleared(person.FieldEmploymentStatusEnumID) {
		fields = append(fields, person.FieldEmploymentStatusEnumID)
	}
	if m.FieldCleared(person.FieldResidenceStatusEnumID) {
		fields = append(fields, person.FieldResidenceStatusEnumID)
	}
	if m.FieldCleared(person.FieldOccupation) {
		fields = append(fields, person.FieldOccupation)
	}
	if m.FieldCleared(person.FieldYearsWithEmployer) {
		fields = append(fields, person.FieldYearsWithEmployer)
	}
	if m.FieldCleared(person.FieldMonthsWithEmployer) {
		fields = append(fields, person.FieldMonthsWithEmployer)
	}
	if m.FieldCleared(person.FieldExistingCustomer) {
		fields = append(fields, person.FieldExistingCustomer)
	}
	if m.FieldCleared(person.FieldCardID) {
		fields = append(fields, person.FieldCardID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldSalutation:
		m.ClearSalutation()
		return nil
	case person.FieldFirstName:
		m.ClearFirstName()
		return nil
	case person.FieldMiddleName:
		m.ClearMiddleName()
		return nil
	case person.FieldLastName:
		m.ClearLastName()
		return nil
	case person.FieldPersonalTitle:
		m.ClearPersonalTitle()
		return nil
	case person.FieldSuffix:
		m.ClearSuffix()
		return nil
	case person.FieldNickname:
		m.ClearNickname()
		return nil
	case person.FieldFirstNameLocal:
		m.ClearFirstNameLocal()
		return nil
	case person.FieldMiddleNameLocal:
		m.ClearMiddleNameLocal()
		return nil
	case person.FieldLastNameLocal:
		m.ClearLastNameLocal()
		return nil
	case person.FieldOtherLocal:
		m.ClearOtherLocal()
		return nil
	case person.FieldMemberID:
		m.ClearMemberID()
		return nil
	case person.FieldGender:
		m.ClearGender()
		return nil
	case person.FieldBirthDate:
		m.ClearBirthDate()
		return nil
	case person.FieldDeceasedDate:
		m.ClearDeceasedDate()
		return nil
	case person.FieldHeight:
		m.ClearHeight()
		return nil
	case person.FieldWeight:
		m.ClearWeight()
		return nil
	case person.FieldMothersMaidenName:
		m.ClearMothersMaidenName()
		return nil
	case person.FieldOldMaritalStatus:
		m.ClearOldMaritalStatus()
		return nil
	case person.FieldMaritalStatusEnumID:
		m.ClearMaritalStatusEnumID()
		return nil
	case person.FieldSocialSecurityNumber:
		m.ClearSocialSecurityNumber()
		return nil
	case person.FieldPassportNumber:
		m.ClearPassportNumber()
		return nil
	case person.FieldPassportExpireDate:
		m.ClearPassportExpireDate()
		return nil
	case person.FieldTotalYearsWorkExperience:
		m.ClearTotalYearsWorkExperience()
		return nil
	case person.FieldComments:
		m.ClearComments()
		return nil
	case person.FieldEmploymentStatusEnumID:
		m.ClearEmploymentStatusEnumID()
		return nil
	case person.FieldResidenceStatusEnumID:
		m.ClearResidenceStatusEnumID()
		return nil
	case person.FieldOccupation:
		m.ClearOccupation()
		return nil
	case person.FieldYearsWithEmployer:
		m.ClearYearsWithEmployer()
		return nil
	case person.FieldMonthsWithEmployer:
		m.ClearMonthsWithEmployer()
		return nil
	case person.FieldExistingCustomer:
		m.ClearExistingCustomer()
		return nil
	case person.FieldCardID:
		m.ClearCardID()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldSalutation:
		m.ResetSalutation()
		return nil
	case person.FieldFirstName:
		m.ResetFirstName()
		return nil
	case person.FieldMiddleName:
		m.ResetMiddleName()
		return nil
	case person.FieldLastName:
		m.ResetLastName()
		return nil
	case person.FieldPersonalTitle:
		m.ResetPersonalTitle()
		return nil
	case person.FieldSuffix:
		m.ResetSuffix()
		return nil
	case person.FieldNickname:
		m.ResetNickname()
		return nil
	case person.FieldFirstNameLocal:
		m.ResetFirstNameLocal()
		return nil
	case person.FieldMiddleNameLocal:
		m.ResetMiddleNameLocal()
		return nil
	case person.FieldLastNameLocal:
		m.ResetLastNameLocal()
		return nil
	case person.FieldOtherLocal:
		m.ResetOtherLocal()
		return nil
	case person.FieldMemberID:
		m.ResetMemberID()
		return nil
	case person.FieldGender:
		m.ResetGender()
		return nil
	case person.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case person.FieldDeceasedDate:
		m.ResetDeceasedDate()
		return nil
	case person.FieldHeight:
		m.ResetHeight()
		return nil
	case person.FieldWeight:
		m.ResetWeight()
		return nil
	case person.FieldMothersMaidenName:
		m.ResetMothersMaidenName()
		return nil
	case person.FieldOldMaritalStatus:
		m.ResetOldMaritalStatus()
		return nil
	case person.FieldMaritalStatusEnumID:
		m.ResetMaritalStatusEnumID()
		return nil
	case person.FieldSocialSecurityNumber:
		m.ResetSocialSecurityNumber()
		return nil
	case person.FieldPassportNumber:
		m.ResetPassportNumber()
		return nil
	case person.FieldPassportExpireDate:
		m.ResetPassportExpireDate()
		return nil
	case person.FieldTotalYearsWorkExperience:
		m.ResetTotalYearsWorkExperience()
		return nil
	case person.FieldComments:
		m.ResetComments()
		return nil
	case person.FieldEmploymentStatusEnumID:
		m.ResetEmploymentStatusEnumID()
		return nil
	case person.FieldResidenceStatusEnumID:
		m.ResetResidenceStatusEnumID()
		return nil
	case person.FieldOccupation:
		m.ResetOccupation()
		return nil
	case person.FieldYearsWithEmployer:
		m.ResetYearsWithEmployer()
		return nil
	case person.FieldMonthsWithEmployer:
		m.ResetMonthsWithEmployer()
		return nil
	case person.FieldExistingCustomer:
		m.ResetExistingCustomer()
		return nil
	case person.FieldCardID:
		m.ResetCardID()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.party != nil {
		edges = append(edges, person.EdgeParty)
	}
	if m.user_logins != nil {
		edges = append(edges, person.EdgeUserLogins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	case person.EdgeUserLogins:
		ids := make([]ent.Value, 0, len(m.user_logins))
		for id := range m.user_logins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_logins != nil {
		edges = append(edges, person.EdgeUserLogins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeUserLogins:
		ids := make([]ent.Value, 0, len(m.removeduser_logins))
		for id := range m.removeduser_logins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparty {
		edges = append(edges, person.EdgeParty)
	}
	if m.cleareduser_logins {
		edges = append(edges, person.EdgeUserLogins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeParty:
		return m.clearedparty
	case person.EdgeUserLogins:
		return m.cleareduser_logins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	case person.EdgeParty:
		m.ClearParty()
		return nil
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeParty:
		m.ResetParty()
		return nil
	case person.EdgeUserLogins:
		m.ResetUserLogins()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// SecurityGroupMutation represents an operation that mutates the SecurityGroup nodes in the graph.
type SecurityGroupMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	group_name                        *string
	description                       *string
	clearedFields                     map[string]struct{}
	security_group_permissions        map[int]struct{}
	removedsecurity_group_permissions map[int]struct{}
	clearedsecurity_group_permissions bool
	user_login_security_groups        map[int]struct{}
	removeduser_login_security_groups map[int]struct{}
	cleareduser_login_security_groups bool
	done                              bool
	oldValue                          func(context.Context) (*SecurityGroup, error)
	predicates                        []predicate.SecurityGroup
}

var _ ent.Mutation = (*SecurityGroupMutation)(nil)

// securitygroupOption allows management of the mutation configuration using functional options.
type securitygroupOption func(*SecurityGroupMutation)

// newSecurityGroupMutation creates new mutation for the SecurityGroup entity.
func newSecurityGroupMutation(c config, op Op, opts ...securitygroupOption) *SecurityGroupMutation {
	m := &SecurityGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityGroupID sets the ID field of the mutation.
func withSecurityGroupID(id int) securitygroupOption {
	return func(m *SecurityGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityGroup
		)
		m.oldValue = func(ctx context.Context) (*SecurityGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityGroup sets the old SecurityGroup of the mutation.
func withSecurityGroup(node *SecurityGroup) securitygroupOption {
	return func(m *SecurityGroupMutation) {
		m.oldValue = func(context.Context) (*SecurityGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *SecurityGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGroupName sets the "group_name" field.
func (m *SecurityGroupMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *SecurityGroupMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the SecurityGroup entity.
// If the SecurityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityGroupMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ClearGroupName clears the value of the "group_name" field.
func (m *SecurityGroupMutation) ClearGroupName() {
	m.group_name = nil
	m.clearedFields[securitygroup.FieldGroupName] = struct{}{}
}

// GroupNameCleared returns if the "group_name" field was cleared in this mutation.
func (m *SecurityGroupMutation) GroupNameCleared() bool {
	_, ok := m.clearedFields[securitygroup.FieldGroupName]
	return ok
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *SecurityGroupMutation) ResetGroupName() {
	m.group_name = nil
	delete(m.clearedFields, securitygroup.FieldGroupName)
}

// SetDescription sets the "description" field.
func (m *SecurityGroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SecurityGroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SecurityGroup entity.
// If the SecurityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityGroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SecurityGroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[securitygroup.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SecurityGroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[securitygroup.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SecurityGroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, securitygroup.FieldDescription)
}

// AddSecurityGroupPermissionIDs adds the "security_group_permissions" edge to the SecurityGroupPermission entity by ids.
func (m *SecurityGroupMutation) AddSecurityGroupPermissionIDs(ids ...int) {
	if m.security_group_permissions == nil {
		m.security_group_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.security_group_permissions[ids[i]] = struct{}{}
	}
}

// ClearSecurityGroupPermissions clears the "security_group_permissions" edge to the SecurityGroupPermission entity.
func (m *SecurityGroupMutation) ClearSecurityGroupPermissions() {
	m.clearedsecurity_group_permissions = true
}

// SecurityGroupPermissionsCleared reports if the "security_group_permissions" edge to the SecurityGroupPermission entity was cleared.
func (m *SecurityGroupMutation) SecurityGroupPermissionsCleared() bool {
	return m.clearedsecurity_group_permissions
}

// RemoveSecurityGroupPermissionIDs removes the "security_group_permissions" edge to the SecurityGroupPermission entity by IDs.
func (m *SecurityGroupMutation) RemoveSecurityGroupPermissionIDs(ids ...int) {
	if m.removedsecurity_group_permissions == nil {
		m.removedsecurity_group_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsecurity_group_permissions[ids[i]] = struct{}{}
	}
}

// RemovedSecurityGroupPermissions returns the removed IDs of the "security_group_permissions" edge to the SecurityGroupPermission entity.
func (m *SecurityGroupMutation) RemovedSecurityGroupPermissionsIDs() (ids []int) {
	for id := range m.removedsecurity_group_permissions {
		ids = append(ids, id)
	}
	return
}

// SecurityGroupPermissionsIDs returns the "security_group_permissions" edge IDs in the mutation.
func (m *SecurityGroupMutation) SecurityGroupPermissionsIDs() (ids []int) {
	for id := range m.security_group_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetSecurityGroupPermissions resets all changes to the "security_group_permissions" edge.
func (m *SecurityGroupMutation) ResetSecurityGroupPermissions() {
	m.security_group_permissions = nil
	m.clearedsecurity_group_permissions = false
	m.removedsecurity_group_permissions = nil
}

// AddUserLoginSecurityGroupIDs adds the "user_login_security_groups" edge to the UserLoginSecurityGroup entity by ids.
func (m *SecurityGroupMutation) AddUserLoginSecurityGroupIDs(ids ...int) {
	if m.user_login_security_groups == nil {
		m.user_login_security_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.user_login_security_groups[ids[i]] = struct{}{}
	}
}

// ClearUserLoginSecurityGroups clears the "user_login_security_groups" edge to the UserLoginSecurityGroup entity.
func (m *SecurityGroupMutation) ClearUserLoginSecurityGroups() {
	m.cleareduser_login_security_groups = true
}

// UserLoginSecurityGroupsCleared reports if the "user_login_security_groups" edge to the UserLoginSecurityGroup entity was cleared.
func (m *SecurityGroupMutation) UserLoginSecurityGroupsCleared() bool {
	return m.cleareduser_login_security_groups
}

// RemoveUserLoginSecurityGroupIDs removes the "user_login_security_groups" edge to the UserLoginSecurityGroup entity by IDs.
func (m *SecurityGroupMutation) RemoveUserLoginSecurityGroupIDs(ids ...int) {
	if m.removeduser_login_security_groups == nil {
		m.removeduser_login_security_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_login_security_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserLoginSecurityGroups returns the removed IDs of the "user_login_security_groups" edge to the UserLoginSecurityGroup entity.
func (m *SecurityGroupMutation) RemovedUserLoginSecurityGroupsIDs() (ids []int) {
	for id := range m.removeduser_login_security_groups {
		ids = append(ids, id)
	}
	return
}

// UserLoginSecurityGroupsIDs returns the "user_login_security_groups" edge IDs in the mutation.
func (m *SecurityGroupMutation) UserLoginSecurityGroupsIDs() (ids []int) {
	for id := range m.user_login_security_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserLoginSecurityGroups resets all changes to the "user_login_security_groups" edge.
func (m *SecurityGroupMutation) ResetUserLoginSecurityGroups() {
	m.user_login_security_groups = nil
	m.cleareduser_login_security_groups = false
	m.removeduser_login_security_groups = nil
}

// Op returns the operation name.
func (m *SecurityGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SecurityGroup).
func (m *SecurityGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityGroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.group_name != nil {
		fields = append(fields, securitygroup.FieldGroupName)
	}
	if m.description != nil {
		fields = append(fields, securitygroup.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securitygroup.FieldGroupName:
		return m.GroupName()
	case securitygroup.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securitygroup.FieldGroupName:
		return m.OldGroupName(ctx)
	case securitygroup.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securitygroup.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	case securitygroup.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SecurityGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securitygroup.FieldGroupName) {
		fields = append(fields, securitygroup.FieldGroupName)
	}
	if m.FieldCleared(securitygroup.FieldDescription) {
		fields = append(fields, securitygroup.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityGroupMutation) ClearField(name string) error {
	switch name {
	case securitygroup.FieldGroupName:
		m.ClearGroupName()
		return nil
	case securitygroup.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityGroupMutation) ResetField(name string) error {
	switch name {
	case securitygroup.FieldGroupName:
		m.ResetGroupName()
		return nil
	case securitygroup.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.security_group_permissions != nil {
		edges = append(edges, securitygroup.EdgeSecurityGroupPermissions)
	}
	if m.user_login_security_groups != nil {
		edges = append(edges, securitygroup.EdgeUserLoginSecurityGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case securitygroup.EdgeSecurityGroupPermissions:
		ids := make([]ent.Value, 0, len(m.security_group_permissions))
		for id := range m.security_group_permissions {
			ids = append(ids, id)
		}
		return ids
	case securitygroup.EdgeUserLoginSecurityGroups:
		ids := make([]ent.Value, 0, len(m.user_login_security_groups))
		for id := range m.user_login_security_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsecurity_group_permissions != nil {
		edges = append(edges, securitygroup.EdgeSecurityGroupPermissions)
	}
	if m.removeduser_login_security_groups != nil {
		edges = append(edges, securitygroup.EdgeUserLoginSecurityGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case securitygroup.EdgeSecurityGroupPermissions:
		ids := make([]ent.Value, 0, len(m.removedsecurity_group_permissions))
		for id := range m.removedsecurity_group_permissions {
			ids = append(ids, id)
		}
		return ids
	case securitygroup.EdgeUserLoginSecurityGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_login_security_groups))
		for id := range m.removeduser_login_security_groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsecurity_group_permissions {
		edges = append(edges, securitygroup.EdgeSecurityGroupPermissions)
	}
	if m.cleareduser_login_security_groups {
		edges = append(edges, securitygroup.EdgeUserLoginSecurityGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case securitygroup.EdgeSecurityGroupPermissions:
		return m.clearedsecurity_group_permissions
	case securitygroup.EdgeUserLoginSecurityGroups:
		return m.cleareduser_login_security_groups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SecurityGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityGroupMutation) ResetEdge(name string) error {
	switch name {
	case securitygroup.EdgeSecurityGroupPermissions:
		m.ResetSecurityGroupPermissions()
		return nil
	case securitygroup.EdgeUserLoginSecurityGroups:
		m.ResetUserLoginSecurityGroups()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroup edge %s", name)
}

// SecurityGroupPermissionMutation represents an operation that mutates the SecurityGroupPermission nodes in the graph.
type SecurityGroupPermissionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	permission_id         *string
	from_date             *time.Time
	thru_date             *time.Time
	clearedFields         map[string]struct{}
	security_group        *int
	clearedsecurity_group bool
	done                  bool
	oldValue              func(context.Context) (*SecurityGroupPermission, error)
	predicates            []predicate.SecurityGroupPermission
}

var _ ent.Mutation = (*SecurityGroupPermissionMutation)(nil)

// securitygrouppermissionOption allows management of the mutation configuration using functional options.
type securitygrouppermissionOption func(*SecurityGroupPermissionMutation)

// newSecurityGroupPermissionMutation creates new mutation for the SecurityGroupPermission entity.
func newSecurityGroupPermissionMutation(c config, op Op, opts ...securitygrouppermissionOption) *SecurityGroupPermissionMutation {
	m := &SecurityGroupPermissionMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityGroupPermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityGroupPermissionID sets the ID field of the mutation.
func withSecurityGroupPermissionID(id int) securitygrouppermissionOption {
	return func(m *SecurityGroupPermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityGroupPermission
		)
		m.oldValue = func(ctx context.Context) (*SecurityGroupPermission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityGroupPermission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityGroupPermission sets the old SecurityGroupPermission of the mutation.
func withSecurityGroupPermission(node *SecurityGroupPermission) securitygrouppermissionOption {
	return func(m *SecurityGroupPermissionMutation) {
		m.oldValue = func(context.Context) (*SecurityGroupPermission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityGroupPermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityGroupPermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *SecurityGroupPermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPermissionID sets the "permission_id" field.
func (m *SecurityGroupPermissionMutation) SetPermissionID(s string) {
	m.permission_id = &s
}

// PermissionID returns the value of the "permission_id" field in the mutation.
func (m *SecurityGroupPermissionMutation) PermissionID() (r string, exists bool) {
	v := m.permission_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissionID returns the old "permission_id" field's value of the SecurityGroupPermission entity.
// If the SecurityGroupPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityGroupPermissionMutation) OldPermissionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPermissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPermissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissionID: %w", err)
	}
	return oldValue.PermissionID, nil
}

// ResetPermissionID resets all changes to the "permission_id" field.
func (m *SecurityGroupPermissionMutation) ResetPermissionID() {
	m.permission_id = nil
}

// SetFromDate sets the "from_date" field.
func (m *SecurityGroupPermissionMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *SecurityGroupPermissionMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the SecurityGroupPermission entity.
// If the SecurityGroupPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityGroupPermissionMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *SecurityGroupPermissionMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *SecurityGroupPermissionMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *SecurityGroupPermissionMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the SecurityGroupPermission entity.
// If the SecurityGroupPermission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityGroupPermissionMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *SecurityGroupPermissionMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[securitygrouppermission.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *SecurityGroupPermissionMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[securitygrouppermission.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *SecurityGroupPermissionMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, securitygrouppermission.FieldThruDate)
}

// SetSecurityGroupID sets the "security_group" edge to the SecurityGroup entity by id.
func (m *SecurityGroupPermissionMutation) SetSecurityGroupID(id int) {
	m.security_group = &id
}

// ClearSecurityGroup clears the "security_group" edge to the SecurityGroup entity.
func (m *SecurityGroupPermissionMutation) ClearSecurityGroup() {
	m.clearedsecurity_group = true
}

// SecurityGroupCleared reports if the "security_group" edge to the SecurityGroup entity was cleared.
func (m *SecurityGroupPermissionMutation) SecurityGroupCleared() bool {
	return m.clearedsecurity_group
}

// SecurityGroupID returns the "security_group" edge ID in the mutation.
func (m *SecurityGroupPermissionMutation) SecurityGroupID() (id int, exists bool) {
	if m.security_group != nil {
		return *m.security_group, true
	}
	return
}

// SecurityGroupIDs returns the "security_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecurityGroupID instead. It exists only for internal usage by the builders.
func (m *SecurityGroupPermissionMutation) SecurityGroupIDs() (ids []int) {
	if id := m.security_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecurityGroup resets all changes to the "security_group" edge.
func (m *SecurityGroupPermissionMutation) ResetSecurityGroup() {
	m.security_group = nil
	m.clearedsecurity_group = false
}

// Op returns the operation name.
func (m *SecurityGroupPermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SecurityGroupPermission).
func (m *SecurityGroupPermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityGroupPermissionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.permission_id != nil {
		fields = append(fields, securitygrouppermission.FieldPermissionID)
	}
	if m.from_date != nil {
		fields = append(fields, securitygrouppermission.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, securitygrouppermission.FieldThruDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityGroupPermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securitygrouppermission.FieldPermissionID:
		return m.PermissionID()
	case securitygrouppermission.FieldFromDate:
		return m.FromDate()
	case securitygrouppermission.FieldThruDate:
		return m.ThruDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityGroupPermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securitygrouppermission.FieldPermissionID:
		return m.OldPermissionID(ctx)
	case securitygrouppermission.FieldFromDate:
		return m.OldFromDate(ctx)
	case securitygrouppermission.FieldThruDate:
		return m.OldThruDate(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityGroupPermission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityGroupPermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securitygrouppermission.FieldPermissionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissionID(v)
		return nil
	case securitygrouppermission.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case securitygrouppermission.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityGroupPermission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityGroupPermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityGroupPermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityGroupPermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SecurityGroupPermission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityGroupPermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securitygrouppermission.FieldThruDate) {
		fields = append(fields, securitygrouppermission.FieldThruDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityGroupPermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityGroupPermissionMutation) ClearField(name string) error {
	switch name {
	case securitygrouppermission.FieldThruDate:
		m.ClearThruDate()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroupPermission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityGroupPermissionMutation) ResetField(name string) error {
	switch name {
	case securitygrouppermission.FieldPermissionID:
		m.ResetPermissionID()
		return nil
	case securitygrouppermission.FieldFromDate:
		m.ResetFromDate()
		return nil
	case securitygrouppermission.FieldThruDate:
		m.ResetThruDate()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroupPermission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityGroupPermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.security_group != nil {
		edges = append(edges, securitygrouppermission.EdgeSecurityGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityGroupPermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case securitygrouppermission.EdgeSecurityGroup:
		if id := m.security_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityGroupPermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityGroupPermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityGroupPermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsecurity_group {
		edges = append(edges, securitygrouppermission.EdgeSecurityGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityGroupPermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case securitygrouppermission.EdgeSecurityGroup:
		return m.clearedsecurity_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityGroupPermissionMutation) ClearEdge(name string) error {
	switch name {
	case securitygrouppermission.EdgeSecurityGroup:
		m.ClearSecurityGroup()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroupPermission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityGroupPermissionMutation) ResetEdge(name string) error {
	switch name {
	case securitygrouppermission.EdgeSecurityGroup:
		m.ResetSecurityGroup()
		return nil
	}
	return fmt.Errorf("unknown SecurityGroupPermission edge %s", name)
}

// TemporalExpressionMutation represents an operation that mutates the TemporalExpression nodes in the graph.
type TemporalExpressionMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	temp_expr_type_id                      *int
	addtemp_expr_type_id                   *int
	description                            *string
	date_1                                 *time.Time
	date_2                                 *time.Time
	integer_1                              *int
	addinteger_1                           *int
	integer_2                              *int
	addinteger_2                           *int
	string_1                               *int
	addstring_1                            *int
	string_2                               *int
	addstring_2                            *int
	clearedFields                          map[string]struct{}
	from_temporal_expression_assocs        map[int]struct{}
	removedfrom_temporal_expression_assocs map[int]struct{}
	clearedfrom_temporal_expression_assocs bool
	to_temporal_expression_assocs          map[int]struct{}
	removedto_temporal_expression_assocs   map[int]struct{}
	clearedto_temporal_expression_assocs   bool
	work_efforts                           map[int]struct{}
	removedwork_efforts                    map[int]struct{}
	clearedwork_efforts                    bool
	done                                   bool
	oldValue                               func(context.Context) (*TemporalExpression, error)
	predicates                             []predicate.TemporalExpression
}

var _ ent.Mutation = (*TemporalExpressionMutation)(nil)

// temporalexpressionOption allows management of the mutation configuration using functional options.
type temporalexpressionOption func(*TemporalExpressionMutation)

// newTemporalExpressionMutation creates new mutation for the TemporalExpression entity.
func newTemporalExpressionMutation(c config, op Op, opts ...temporalexpressionOption) *TemporalExpressionMutation {
	m := &TemporalExpressionMutation{
		config:        c,
		op:            op,
		typ:           TypeTemporalExpression,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemporalExpressionID sets the ID field of the mutation.
func withTemporalExpressionID(id int) temporalexpressionOption {
	return func(m *TemporalExpressionMutation) {
		var (
			err   error
			once  sync.Once
			value *TemporalExpression
		)
		m.oldValue = func(ctx context.Context) (*TemporalExpression, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemporalExpression.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemporalExpression sets the old TemporalExpression of the mutation.
func withTemporalExpression(node *TemporalExpression) temporalexpressionOption {
	return func(m *TemporalExpressionMutation) {
		m.oldValue = func(context.Context) (*TemporalExpression, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemporalExpressionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemporalExpressionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TemporalExpressionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTempExprTypeID sets the "temp_expr_type_id" field.
func (m *TemporalExpressionMutation) SetTempExprTypeID(i int) {
	m.temp_expr_type_id = &i
	m.addtemp_expr_type_id = nil
}

// TempExprTypeID returns the value of the "temp_expr_type_id" field in the mutation.
func (m *TemporalExpressionMutation) TempExprTypeID() (r int, exists bool) {
	v := m.temp_expr_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTempExprTypeID returns the old "temp_expr_type_id" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldTempExprTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTempExprTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTempExprTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTempExprTypeID: %w", err)
	}
	return oldValue.TempExprTypeID, nil
}

// AddTempExprTypeID adds i to the "temp_expr_type_id" field.
func (m *TemporalExpressionMutation) AddTempExprTypeID(i int) {
	if m.addtemp_expr_type_id != nil {
		*m.addtemp_expr_type_id += i
	} else {
		m.addtemp_expr_type_id = &i
	}
}

// AddedTempExprTypeID returns the value that was added to the "temp_expr_type_id" field in this mutation.
func (m *TemporalExpressionMutation) AddedTempExprTypeID() (r int, exists bool) {
	v := m.addtemp_expr_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTempExprTypeID clears the value of the "temp_expr_type_id" field.
func (m *TemporalExpressionMutation) ClearTempExprTypeID() {
	m.temp_expr_type_id = nil
	m.addtemp_expr_type_id = nil
	m.clearedFields[temporalexpression.FieldTempExprTypeID] = struct{}{}
}

// TempExprTypeIDCleared returns if the "temp_expr_type_id" field was cleared in this mutation.
func (m *TemporalExpressionMutation) TempExprTypeIDCleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldTempExprTypeID]
	return ok
}

// ResetTempExprTypeID resets all changes to the "temp_expr_type_id" field.
func (m *TemporalExpressionMutation) ResetTempExprTypeID() {
	m.temp_expr_type_id = nil
	m.addtemp_expr_type_id = nil
	delete(m.clearedFields, temporalexpression.FieldTempExprTypeID)
}

// SetDescription sets the "description" field.
func (m *TemporalExpressionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TemporalExpressionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TemporalExpressionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[temporalexpression.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TemporalExpressionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TemporalExpressionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, temporalexpression.FieldDescription)
}

// SetDate1 sets the "date_1" field.
func (m *TemporalExpressionMutation) SetDate1(t time.Time) {
	m.date_1 = &t
}

// Date1 returns the value of the "date_1" field in the mutation.
func (m *TemporalExpressionMutation) Date1() (r time.Time, exists bool) {
	v := m.date_1
	if v == nil {
		return
	}
	return *v, true
}

// OldDate1 returns the old "date_1" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldDate1(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate1: %w", err)
	}
	return oldValue.Date1, nil
}

// ClearDate1 clears the value of the "date_1" field.
func (m *TemporalExpressionMutation) ClearDate1() {
	m.date_1 = nil
	m.clearedFields[temporalexpression.FieldDate1] = struct{}{}
}

// Date1Cleared returns if the "date_1" field was cleared in this mutation.
func (m *TemporalExpressionMutation) Date1Cleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldDate1]
	return ok
}

// ResetDate1 resets all changes to the "date_1" field.
func (m *TemporalExpressionMutation) ResetDate1() {
	m.date_1 = nil
	delete(m.clearedFields, temporalexpression.FieldDate1)
}

// SetDate2 sets the "date_2" field.
func (m *TemporalExpressionMutation) SetDate2(t time.Time) {
	m.date_2 = &t
}

// Date2 returns the value of the "date_2" field in the mutation.
func (m *TemporalExpressionMutation) Date2() (r time.Time, exists bool) {
	v := m.date_2
	if v == nil {
		return
	}
	return *v, true
}

// OldDate2 returns the old "date_2" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldDate2(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate2: %w", err)
	}
	return oldValue.Date2, nil
}

// ClearDate2 clears the value of the "date_2" field.
func (m *TemporalExpressionMutation) ClearDate2() {
	m.date_2 = nil
	m.clearedFields[temporalexpression.FieldDate2] = struct{}{}
}

// Date2Cleared returns if the "date_2" field was cleared in this mutation.
func (m *TemporalExpressionMutation) Date2Cleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldDate2]
	return ok
}

// ResetDate2 resets all changes to the "date_2" field.
func (m *TemporalExpressionMutation) ResetDate2() {
	m.date_2 = nil
	delete(m.clearedFields, temporalexpression.FieldDate2)
}

// SetInteger1 sets the "integer_1" field.
func (m *TemporalExpressionMutation) SetInteger1(i int) {
	m.integer_1 = &i
	m.addinteger_1 = nil
}

// Integer1 returns the value of the "integer_1" field in the mutation.
func (m *TemporalExpressionMutation) Integer1() (r int, exists bool) {
	v := m.integer_1
	if v == nil {
		return
	}
	return *v, true
}

// OldInteger1 returns the old "integer_1" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldInteger1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInteger1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInteger1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteger1: %w", err)
	}
	return oldValue.Integer1, nil
}

// AddInteger1 adds i to the "integer_1" field.
func (m *TemporalExpressionMutation) AddInteger1(i int) {
	if m.addinteger_1 != nil {
		*m.addinteger_1 += i
	} else {
		m.addinteger_1 = &i
	}
}

// AddedInteger1 returns the value that was added to the "integer_1" field in this mutation.
func (m *TemporalExpressionMutation) AddedInteger1() (r int, exists bool) {
	v := m.addinteger_1
	if v == nil {
		return
	}
	return *v, true
}

// ClearInteger1 clears the value of the "integer_1" field.
func (m *TemporalExpressionMutation) ClearInteger1() {
	m.integer_1 = nil
	m.addinteger_1 = nil
	m.clearedFields[temporalexpression.FieldInteger1] = struct{}{}
}

// Integer1Cleared returns if the "integer_1" field was cleared in this mutation.
func (m *TemporalExpressionMutation) Integer1Cleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldInteger1]
	return ok
}

// ResetInteger1 resets all changes to the "integer_1" field.
func (m *TemporalExpressionMutation) ResetInteger1() {
	m.integer_1 = nil
	m.addinteger_1 = nil
	delete(m.clearedFields, temporalexpression.FieldInteger1)
}

// SetInteger2 sets the "integer_2" field.
func (m *TemporalExpressionMutation) SetInteger2(i int) {
	m.integer_2 = &i
	m.addinteger_2 = nil
}

// Integer2 returns the value of the "integer_2" field in the mutation.
func (m *TemporalExpressionMutation) Integer2() (r int, exists bool) {
	v := m.integer_2
	if v == nil {
		return
	}
	return *v, true
}

// OldInteger2 returns the old "integer_2" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldInteger2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInteger2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInteger2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteger2: %w", err)
	}
	return oldValue.Integer2, nil
}

// AddInteger2 adds i to the "integer_2" field.
func (m *TemporalExpressionMutation) AddInteger2(i int) {
	if m.addinteger_2 != nil {
		*m.addinteger_2 += i
	} else {
		m.addinteger_2 = &i
	}
}

// AddedInteger2 returns the value that was added to the "integer_2" field in this mutation.
func (m *TemporalExpressionMutation) AddedInteger2() (r int, exists bool) {
	v := m.addinteger_2
	if v == nil {
		return
	}
	return *v, true
}

// ClearInteger2 clears the value of the "integer_2" field.
func (m *TemporalExpressionMutation) ClearInteger2() {
	m.integer_2 = nil
	m.addinteger_2 = nil
	m.clearedFields[temporalexpression.FieldInteger2] = struct{}{}
}

// Integer2Cleared returns if the "integer_2" field was cleared in this mutation.
func (m *TemporalExpressionMutation) Integer2Cleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldInteger2]
	return ok
}

// ResetInteger2 resets all changes to the "integer_2" field.
func (m *TemporalExpressionMutation) ResetInteger2() {
	m.integer_2 = nil
	m.addinteger_2 = nil
	delete(m.clearedFields, temporalexpression.FieldInteger2)
}

// SetString1 sets the "string_1" field.
func (m *TemporalExpressionMutation) SetString1(i int) {
	m.string_1 = &i
	m.addstring_1 = nil
}

// String1 returns the value of the "string_1" field in the mutation.
func (m *TemporalExpressionMutation) String1() (r int, exists bool) {
	v := m.string_1
	if v == nil {
		return
	}
	return *v, true
}

// OldString1 returns the old "string_1" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldString1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString1: %w", err)
	}
	return oldValue.String1, nil
}

// AddString1 adds i to the "string_1" field.
func (m *TemporalExpressionMutation) AddString1(i int) {
	if m.addstring_1 != nil {
		*m.addstring_1 += i
	} else {
		m.addstring_1 = &i
	}
}

// AddedString1 returns the value that was added to the "string_1" field in this mutation.
func (m *TemporalExpressionMutation) AddedString1() (r int, exists bool) {
	v := m.addstring_1
	if v == nil {
		return
	}
	return *v, true
}

// ClearString1 clears the value of the "string_1" field.
func (m *TemporalExpressionMutation) ClearString1() {
	m.string_1 = nil
	m.addstring_1 = nil
	m.clearedFields[temporalexpression.FieldString1] = struct{}{}
}

// String1Cleared returns if the "string_1" field was cleared in this mutation.
func (m *TemporalExpressionMutation) String1Cleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldString1]
	return ok
}

// ResetString1 resets all changes to the "string_1" field.
func (m *TemporalExpressionMutation) ResetString1() {
	m.string_1 = nil
	m.addstring_1 = nil
	delete(m.clearedFields, temporalexpression.FieldString1)
}

// SetString2 sets the "string_2" field.
func (m *TemporalExpressionMutation) SetString2(i int) {
	m.string_2 = &i
	m.addstring_2 = nil
}

// String2 returns the value of the "string_2" field in the mutation.
func (m *TemporalExpressionMutation) String2() (r int, exists bool) {
	v := m.string_2
	if v == nil {
		return
	}
	return *v, true
}

// OldString2 returns the old "string_2" field's value of the TemporalExpression entity.
// If the TemporalExpression object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionMutation) OldString2(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldString2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldString2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldString2: %w", err)
	}
	return oldValue.String2, nil
}

// AddString2 adds i to the "string_2" field.
func (m *TemporalExpressionMutation) AddString2(i int) {
	if m.addstring_2 != nil {
		*m.addstring_2 += i
	} else {
		m.addstring_2 = &i
	}
}

// AddedString2 returns the value that was added to the "string_2" field in this mutation.
func (m *TemporalExpressionMutation) AddedString2() (r int, exists bool) {
	v := m.addstring_2
	if v == nil {
		return
	}
	return *v, true
}

// ClearString2 clears the value of the "string_2" field.
func (m *TemporalExpressionMutation) ClearString2() {
	m.string_2 = nil
	m.addstring_2 = nil
	m.clearedFields[temporalexpression.FieldString2] = struct{}{}
}

// String2Cleared returns if the "string_2" field was cleared in this mutation.
func (m *TemporalExpressionMutation) String2Cleared() bool {
	_, ok := m.clearedFields[temporalexpression.FieldString2]
	return ok
}

// ResetString2 resets all changes to the "string_2" field.
func (m *TemporalExpressionMutation) ResetString2() {
	m.string_2 = nil
	m.addstring_2 = nil
	delete(m.clearedFields, temporalexpression.FieldString2)
}

// AddFromTemporalExpressionAssocIDs adds the "from_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity by ids.
func (m *TemporalExpressionMutation) AddFromTemporalExpressionAssocIDs(ids ...int) {
	if m.from_temporal_expression_assocs == nil {
		m.from_temporal_expression_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.from_temporal_expression_assocs[ids[i]] = struct{}{}
	}
}

// ClearFromTemporalExpressionAssocs clears the "from_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity.
func (m *TemporalExpressionMutation) ClearFromTemporalExpressionAssocs() {
	m.clearedfrom_temporal_expression_assocs = true
}

// FromTemporalExpressionAssocsCleared reports if the "from_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity was cleared.
func (m *TemporalExpressionMutation) FromTemporalExpressionAssocsCleared() bool {
	return m.clearedfrom_temporal_expression_assocs
}

// RemoveFromTemporalExpressionAssocIDs removes the "from_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity by IDs.
func (m *TemporalExpressionMutation) RemoveFromTemporalExpressionAssocIDs(ids ...int) {
	if m.removedfrom_temporal_expression_assocs == nil {
		m.removedfrom_temporal_expression_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfrom_temporal_expression_assocs[ids[i]] = struct{}{}
	}
}

// RemovedFromTemporalExpressionAssocs returns the removed IDs of the "from_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity.
func (m *TemporalExpressionMutation) RemovedFromTemporalExpressionAssocsIDs() (ids []int) {
	for id := range m.removedfrom_temporal_expression_assocs {
		ids = append(ids, id)
	}
	return
}

// FromTemporalExpressionAssocsIDs returns the "from_temporal_expression_assocs" edge IDs in the mutation.
func (m *TemporalExpressionMutation) FromTemporalExpressionAssocsIDs() (ids []int) {
	for id := range m.from_temporal_expression_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetFromTemporalExpressionAssocs resets all changes to the "from_temporal_expression_assocs" edge.
func (m *TemporalExpressionMutation) ResetFromTemporalExpressionAssocs() {
	m.from_temporal_expression_assocs = nil
	m.clearedfrom_temporal_expression_assocs = false
	m.removedfrom_temporal_expression_assocs = nil
}

// AddToTemporalExpressionAssocIDs adds the "to_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity by ids.
func (m *TemporalExpressionMutation) AddToTemporalExpressionAssocIDs(ids ...int) {
	if m.to_temporal_expression_assocs == nil {
		m.to_temporal_expression_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.to_temporal_expression_assocs[ids[i]] = struct{}{}
	}
}

// ClearToTemporalExpressionAssocs clears the "to_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity.
func (m *TemporalExpressionMutation) ClearToTemporalExpressionAssocs() {
	m.clearedto_temporal_expression_assocs = true
}

// ToTemporalExpressionAssocsCleared reports if the "to_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity was cleared.
func (m *TemporalExpressionMutation) ToTemporalExpressionAssocsCleared() bool {
	return m.clearedto_temporal_expression_assocs
}

// RemoveToTemporalExpressionAssocIDs removes the "to_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity by IDs.
func (m *TemporalExpressionMutation) RemoveToTemporalExpressionAssocIDs(ids ...int) {
	if m.removedto_temporal_expression_assocs == nil {
		m.removedto_temporal_expression_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedto_temporal_expression_assocs[ids[i]] = struct{}{}
	}
}

// RemovedToTemporalExpressionAssocs returns the removed IDs of the "to_temporal_expression_assocs" edge to the TemporalExpressionAssoc entity.
func (m *TemporalExpressionMutation) RemovedToTemporalExpressionAssocsIDs() (ids []int) {
	for id := range m.removedto_temporal_expression_assocs {
		ids = append(ids, id)
	}
	return
}

// ToTemporalExpressionAssocsIDs returns the "to_temporal_expression_assocs" edge IDs in the mutation.
func (m *TemporalExpressionMutation) ToTemporalExpressionAssocsIDs() (ids []int) {
	for id := range m.to_temporal_expression_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetToTemporalExpressionAssocs resets all changes to the "to_temporal_expression_assocs" edge.
func (m *TemporalExpressionMutation) ResetToTemporalExpressionAssocs() {
	m.to_temporal_expression_assocs = nil
	m.clearedto_temporal_expression_assocs = false
	m.removedto_temporal_expression_assocs = nil
}

// AddWorkEffortIDs adds the "work_efforts" edge to the WorkEffort entity by ids.
func (m *TemporalExpressionMutation) AddWorkEffortIDs(ids ...int) {
	if m.work_efforts == nil {
		m.work_efforts = make(map[int]struct{})
	}
	for i := range ids {
		m.work_efforts[ids[i]] = struct{}{}
	}
}

// ClearWorkEfforts clears the "work_efforts" edge to the WorkEffort entity.
func (m *TemporalExpressionMutation) ClearWorkEfforts() {
	m.clearedwork_efforts = true
}

// WorkEffortsCleared reports if the "work_efforts" edge to the WorkEffort entity was cleared.
func (m *TemporalExpressionMutation) WorkEffortsCleared() bool {
	return m.clearedwork_efforts
}

// RemoveWorkEffortIDs removes the "work_efforts" edge to the WorkEffort entity by IDs.
func (m *TemporalExpressionMutation) RemoveWorkEffortIDs(ids ...int) {
	if m.removedwork_efforts == nil {
		m.removedwork_efforts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_efforts[ids[i]] = struct{}{}
	}
}

// RemovedWorkEfforts returns the removed IDs of the "work_efforts" edge to the WorkEffort entity.
func (m *TemporalExpressionMutation) RemovedWorkEffortsIDs() (ids []int) {
	for id := range m.removedwork_efforts {
		ids = append(ids, id)
	}
	return
}

// WorkEffortsIDs returns the "work_efforts" edge IDs in the mutation.
func (m *TemporalExpressionMutation) WorkEffortsIDs() (ids []int) {
	for id := range m.work_efforts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEfforts resets all changes to the "work_efforts" edge.
func (m *TemporalExpressionMutation) ResetWorkEfforts() {
	m.work_efforts = nil
	m.clearedwork_efforts = false
	m.removedwork_efforts = nil
}

// Op returns the operation name.
func (m *TemporalExpressionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TemporalExpression).
func (m *TemporalExpressionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemporalExpressionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.temp_expr_type_id != nil {
		fields = append(fields, temporalexpression.FieldTempExprTypeID)
	}
	if m.description != nil {
		fields = append(fields, temporalexpression.FieldDescription)
	}
	if m.date_1 != nil {
		fields = append(fields, temporalexpression.FieldDate1)
	}
	if m.date_2 != nil {
		fields = append(fields, temporalexpression.FieldDate2)
	}
	if m.integer_1 != nil {
		fields = append(fields, temporalexpression.FieldInteger1)
	}
	if m.integer_2 != nil {
		fields = append(fields, temporalexpression.FieldInteger2)
	}
	if m.string_1 != nil {
		fields = append(fields, temporalexpression.FieldString1)
	}
	if m.string_2 != nil {
		fields = append(fields, temporalexpression.FieldString2)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemporalExpressionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		return m.TempExprTypeID()
	case temporalexpression.FieldDescription:
		return m.Description()
	case temporalexpression.FieldDate1:
		return m.Date1()
	case temporalexpression.FieldDate2:
		return m.Date2()
	case temporalexpression.FieldInteger1:
		return m.Integer1()
	case temporalexpression.FieldInteger2:
		return m.Integer2()
	case temporalexpression.FieldString1:
		return m.String1()
	case temporalexpression.FieldString2:
		return m.String2()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemporalExpressionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		return m.OldTempExprTypeID(ctx)
	case temporalexpression.FieldDescription:
		return m.OldDescription(ctx)
	case temporalexpression.FieldDate1:
		return m.OldDate1(ctx)
	case temporalexpression.FieldDate2:
		return m.OldDate2(ctx)
	case temporalexpression.FieldInteger1:
		return m.OldInteger1(ctx)
	case temporalexpression.FieldInteger2:
		return m.OldInteger2(ctx)
	case temporalexpression.FieldString1:
		return m.OldString1(ctx)
	case temporalexpression.FieldString2:
		return m.OldString2(ctx)
	}
	return nil, fmt.Errorf("unknown TemporalExpression field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporalExpressionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTempExprTypeID(v)
		return nil
	case temporalexpression.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case temporalexpression.FieldDate1:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate1(v)
		return nil
	case temporalexpression.FieldDate2:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate2(v)
		return nil
	case temporalexpression.FieldInteger1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteger1(v)
		return nil
	case temporalexpression.FieldInteger2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteger2(v)
		return nil
	case temporalexpression.FieldString1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString1(v)
		return nil
	case temporalexpression.FieldString2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetString2(v)
		return nil
	}
	return fmt.Errorf("unknown TemporalExpression field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemporalExpressionMutation) AddedFields() []string {
	var fields []string
	if m.addtemp_expr_type_id != nil {
		fields = append(fields, temporalexpression.FieldTempExprTypeID)
	}
	if m.addinteger_1 != nil {
		fields = append(fields, temporalexpression.FieldInteger1)
	}
	if m.addinteger_2 != nil {
		fields = append(fields, temporalexpression.FieldInteger2)
	}
	if m.addstring_1 != nil {
		fields = append(fields, temporalexpression.FieldString1)
	}
	if m.addstring_2 != nil {
		fields = append(fields, temporalexpression.FieldString2)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemporalExpressionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		return m.AddedTempExprTypeID()
	case temporalexpression.FieldInteger1:
		return m.AddedInteger1()
	case temporalexpression.FieldInteger2:
		return m.AddedInteger2()
	case temporalexpression.FieldString1:
		return m.AddedString1()
	case temporalexpression.FieldString2:
		return m.AddedString2()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporalExpressionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTempExprTypeID(v)
		return nil
	case temporalexpression.FieldInteger1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInteger1(v)
		return nil
	case temporalexpression.FieldInteger2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInteger2(v)
		return nil
	case temporalexpression.FieldString1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddString1(v)
		return nil
	case temporalexpression.FieldString2:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddString2(v)
		return nil
	}
	return fmt.Errorf("unknown TemporalExpression numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemporalExpressionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(temporalexpression.FieldTempExprTypeID) {
		fields = append(fields, temporalexpression.FieldTempExprTypeID)
	}
	if m.FieldCleared(temporalexpression.FieldDescription) {
		fields = append(fields, temporalexpression.FieldDescription)
	}
	if m.FieldCleared(temporalexpression.FieldDate1) {
		fields = append(fields, temporalexpression.FieldDate1)
	}
	if m.FieldCleared(temporalexpression.FieldDate2) {
		fields = append(fields, temporalexpression.FieldDate2)
	}
	if m.FieldCleared(temporalexpression.FieldInteger1) {
		fields = append(fields, temporalexpression.FieldInteger1)
	}
	if m.FieldCleared(temporalexpression.FieldInteger2) {
		fields = append(fields, temporalexpression.FieldInteger2)
	}
	if m.FieldCleared(temporalexpression.FieldString1) {
		fields = append(fields, temporalexpression.FieldString1)
	}
	if m.FieldCleared(temporalexpression.FieldString2) {
		fields = append(fields, temporalexpression.FieldString2)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemporalExpressionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemporalExpressionMutation) ClearField(name string) error {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		m.ClearTempExprTypeID()
		return nil
	case temporalexpression.FieldDescription:
		m.ClearDescription()
		return nil
	case temporalexpression.FieldDate1:
		m.ClearDate1()
		return nil
	case temporalexpression.FieldDate2:
		m.ClearDate2()
		return nil
	case temporalexpression.FieldInteger1:
		m.ClearInteger1()
		return nil
	case temporalexpression.FieldInteger2:
		m.ClearInteger2()
		return nil
	case temporalexpression.FieldString1:
		m.ClearString1()
		return nil
	case temporalexpression.FieldString2:
		m.ClearString2()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpression nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemporalExpressionMutation) ResetField(name string) error {
	switch name {
	case temporalexpression.FieldTempExprTypeID:
		m.ResetTempExprTypeID()
		return nil
	case temporalexpression.FieldDescription:
		m.ResetDescription()
		return nil
	case temporalexpression.FieldDate1:
		m.ResetDate1()
		return nil
	case temporalexpression.FieldDate2:
		m.ResetDate2()
		return nil
	case temporalexpression.FieldInteger1:
		m.ResetInteger1()
		return nil
	case temporalexpression.FieldInteger2:
		m.ResetInteger2()
		return nil
	case temporalexpression.FieldString1:
		m.ResetString1()
		return nil
	case temporalexpression.FieldString2:
		m.ResetString2()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpression field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemporalExpressionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.from_temporal_expression_assocs != nil {
		edges = append(edges, temporalexpression.EdgeFromTemporalExpressionAssocs)
	}
	if m.to_temporal_expression_assocs != nil {
		edges = append(edges, temporalexpression.EdgeToTemporalExpressionAssocs)
	}
	if m.work_efforts != nil {
		edges = append(edges, temporalexpression.EdgeWorkEfforts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemporalExpressionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case temporalexpression.EdgeFromTemporalExpressionAssocs:
		ids := make([]ent.Value, 0, len(m.from_temporal_expression_assocs))
		for id := range m.from_temporal_expression_assocs {
			ids = append(ids, id)
		}
		return ids
	case temporalexpression.EdgeToTemporalExpressionAssocs:
		ids := make([]ent.Value, 0, len(m.to_temporal_expression_assocs))
		for id := range m.to_temporal_expression_assocs {
			ids = append(ids, id)
		}
		return ids
	case temporalexpression.EdgeWorkEfforts:
		ids := make([]ent.Value, 0, len(m.work_efforts))
		for id := range m.work_efforts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemporalExpressionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfrom_temporal_expression_assocs != nil {
		edges = append(edges, temporalexpression.EdgeFromTemporalExpressionAssocs)
	}
	if m.removedto_temporal_expression_assocs != nil {
		edges = append(edges, temporalexpression.EdgeToTemporalExpressionAssocs)
	}
	if m.removedwork_efforts != nil {
		edges = append(edges, temporalexpression.EdgeWorkEfforts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemporalExpressionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case temporalexpression.EdgeFromTemporalExpressionAssocs:
		ids := make([]ent.Value, 0, len(m.removedfrom_temporal_expression_assocs))
		for id := range m.removedfrom_temporal_expression_assocs {
			ids = append(ids, id)
		}
		return ids
	case temporalexpression.EdgeToTemporalExpressionAssocs:
		ids := make([]ent.Value, 0, len(m.removedto_temporal_expression_assocs))
		for id := range m.removedto_temporal_expression_assocs {
			ids = append(ids, id)
		}
		return ids
	case temporalexpression.EdgeWorkEfforts:
		ids := make([]ent.Value, 0, len(m.removedwork_efforts))
		for id := range m.removedwork_efforts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemporalExpressionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfrom_temporal_expression_assocs {
		edges = append(edges, temporalexpression.EdgeFromTemporalExpressionAssocs)
	}
	if m.clearedto_temporal_expression_assocs {
		edges = append(edges, temporalexpression.EdgeToTemporalExpressionAssocs)
	}
	if m.clearedwork_efforts {
		edges = append(edges, temporalexpression.EdgeWorkEfforts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemporalExpressionMutation) EdgeCleared(name string) bool {
	switch name {
	case temporalexpression.EdgeFromTemporalExpressionAssocs:
		return m.clearedfrom_temporal_expression_assocs
	case temporalexpression.EdgeToTemporalExpressionAssocs:
		return m.clearedto_temporal_expression_assocs
	case temporalexpression.EdgeWorkEfforts:
		return m.clearedwork_efforts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemporalExpressionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TemporalExpression unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemporalExpressionMutation) ResetEdge(name string) error {
	switch name {
	case temporalexpression.EdgeFromTemporalExpressionAssocs:
		m.ResetFromTemporalExpressionAssocs()
		return nil
	case temporalexpression.EdgeToTemporalExpressionAssocs:
		m.ResetToTemporalExpressionAssocs()
		return nil
	case temporalexpression.EdgeWorkEfforts:
		m.ResetWorkEfforts()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpression edge %s", name)
}

// TemporalExpressionAssocMutation represents an operation that mutates the TemporalExpressionAssoc nodes in the graph.
type TemporalExpressionAssocMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	expr_assoc_type                 *int
	addexpr_assoc_type              *int
	clearedFields                   map[string]struct{}
	from_temporal_expression        *int
	clearedfrom_temporal_expression bool
	to_temporal_expression          *int
	clearedto_temporal_expression   bool
	done                            bool
	oldValue                        func(context.Context) (*TemporalExpressionAssoc, error)
	predicates                      []predicate.TemporalExpressionAssoc
}

var _ ent.Mutation = (*TemporalExpressionAssocMutation)(nil)

// temporalexpressionassocOption allows management of the mutation configuration using functional options.
type temporalexpressionassocOption func(*TemporalExpressionAssocMutation)

// newTemporalExpressionAssocMutation creates new mutation for the TemporalExpressionAssoc entity.
func newTemporalExpressionAssocMutation(c config, op Op, opts ...temporalexpressionassocOption) *TemporalExpressionAssocMutation {
	m := &TemporalExpressionAssocMutation{
		config:        c,
		op:            op,
		typ:           TypeTemporalExpressionAssoc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemporalExpressionAssocID sets the ID field of the mutation.
func withTemporalExpressionAssocID(id int) temporalexpressionassocOption {
	return func(m *TemporalExpressionAssocMutation) {
		var (
			err   error
			once  sync.Once
			value *TemporalExpressionAssoc
		)
		m.oldValue = func(ctx context.Context) (*TemporalExpressionAssoc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemporalExpressionAssoc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemporalExpressionAssoc sets the old TemporalExpressionAssoc of the mutation.
func withTemporalExpressionAssoc(node *TemporalExpressionAssoc) temporalexpressionassocOption {
	return func(m *TemporalExpressionAssocMutation) {
		m.oldValue = func(context.Context) (*TemporalExpressionAssoc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemporalExpressionAssocMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemporalExpressionAssocMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TemporalExpressionAssocMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExprAssocType sets the "expr_assoc_type" field.
func (m *TemporalExpressionAssocMutation) SetExprAssocType(i int) {
	m.expr_assoc_type = &i
	m.addexpr_assoc_type = nil
}

// ExprAssocType returns the value of the "expr_assoc_type" field in the mutation.
func (m *TemporalExpressionAssocMutation) ExprAssocType() (r int, exists bool) {
	v := m.expr_assoc_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExprAssocType returns the old "expr_assoc_type" field's value of the TemporalExpressionAssoc entity.
// If the TemporalExpressionAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporalExpressionAssocMutation) OldExprAssocType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExprAssocType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExprAssocType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExprAssocType: %w", err)
	}
	return oldValue.ExprAssocType, nil
}

// AddExprAssocType adds i to the "expr_assoc_type" field.
func (m *TemporalExpressionAssocMutation) AddExprAssocType(i int) {
	if m.addexpr_assoc_type != nil {
		*m.addexpr_assoc_type += i
	} else {
		m.addexpr_assoc_type = &i
	}
}

// AddedExprAssocType returns the value that was added to the "expr_assoc_type" field in this mutation.
func (m *TemporalExpressionAssocMutation) AddedExprAssocType() (r int, exists bool) {
	v := m.addexpr_assoc_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearExprAssocType clears the value of the "expr_assoc_type" field.
func (m *TemporalExpressionAssocMutation) ClearExprAssocType() {
	m.expr_assoc_type = nil
	m.addexpr_assoc_type = nil
	m.clearedFields[temporalexpressionassoc.FieldExprAssocType] = struct{}{}
}

// ExprAssocTypeCleared returns if the "expr_assoc_type" field was cleared in this mutation.
func (m *TemporalExpressionAssocMutation) ExprAssocTypeCleared() bool {
	_, ok := m.clearedFields[temporalexpressionassoc.FieldExprAssocType]
	return ok
}

// ResetExprAssocType resets all changes to the "expr_assoc_type" field.
func (m *TemporalExpressionAssocMutation) ResetExprAssocType() {
	m.expr_assoc_type = nil
	m.addexpr_assoc_type = nil
	delete(m.clearedFields, temporalexpressionassoc.FieldExprAssocType)
}

// SetFromTemporalExpressionID sets the "from_temporal_expression" edge to the TemporalExpression entity by id.
func (m *TemporalExpressionAssocMutation) SetFromTemporalExpressionID(id int) {
	m.from_temporal_expression = &id
}

// ClearFromTemporalExpression clears the "from_temporal_expression" edge to the TemporalExpression entity.
func (m *TemporalExpressionAssocMutation) ClearFromTemporalExpression() {
	m.clearedfrom_temporal_expression = true
}

// FromTemporalExpressionCleared reports if the "from_temporal_expression" edge to the TemporalExpression entity was cleared.
func (m *TemporalExpressionAssocMutation) FromTemporalExpressionCleared() bool {
	return m.clearedfrom_temporal_expression
}

// FromTemporalExpressionID returns the "from_temporal_expression" edge ID in the mutation.
func (m *TemporalExpressionAssocMutation) FromTemporalExpressionID() (id int, exists bool) {
	if m.from_temporal_expression != nil {
		return *m.from_temporal_expression, true
	}
	return
}

// FromTemporalExpressionIDs returns the "from_temporal_expression" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromTemporalExpressionID instead. It exists only for internal usage by the builders.
func (m *TemporalExpressionAssocMutation) FromTemporalExpressionIDs() (ids []int) {
	if id := m.from_temporal_expression; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromTemporalExpression resets all changes to the "from_temporal_expression" edge.
func (m *TemporalExpressionAssocMutation) ResetFromTemporalExpression() {
	m.from_temporal_expression = nil
	m.clearedfrom_temporal_expression = false
}

// SetToTemporalExpressionID sets the "to_temporal_expression" edge to the TemporalExpression entity by id.
func (m *TemporalExpressionAssocMutation) SetToTemporalExpressionID(id int) {
	m.to_temporal_expression = &id
}

// ClearToTemporalExpression clears the "to_temporal_expression" edge to the TemporalExpression entity.
func (m *TemporalExpressionAssocMutation) ClearToTemporalExpression() {
	m.clearedto_temporal_expression = true
}

// ToTemporalExpressionCleared reports if the "to_temporal_expression" edge to the TemporalExpression entity was cleared.
func (m *TemporalExpressionAssocMutation) ToTemporalExpressionCleared() bool {
	return m.clearedto_temporal_expression
}

// ToTemporalExpressionID returns the "to_temporal_expression" edge ID in the mutation.
func (m *TemporalExpressionAssocMutation) ToTemporalExpressionID() (id int, exists bool) {
	if m.to_temporal_expression != nil {
		return *m.to_temporal_expression, true
	}
	return
}

// ToTemporalExpressionIDs returns the "to_temporal_expression" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToTemporalExpressionID instead. It exists only for internal usage by the builders.
func (m *TemporalExpressionAssocMutation) ToTemporalExpressionIDs() (ids []int) {
	if id := m.to_temporal_expression; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToTemporalExpression resets all changes to the "to_temporal_expression" edge.
func (m *TemporalExpressionAssocMutation) ResetToTemporalExpression() {
	m.to_temporal_expression = nil
	m.clearedto_temporal_expression = false
}

// Op returns the operation name.
func (m *TemporalExpressionAssocMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TemporalExpressionAssoc).
func (m *TemporalExpressionAssocMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemporalExpressionAssocMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.expr_assoc_type != nil {
		fields = append(fields, temporalexpressionassoc.FieldExprAssocType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemporalExpressionAssocMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		return m.ExprAssocType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemporalExpressionAssocMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		return m.OldExprAssocType(ctx)
	}
	return nil, fmt.Errorf("unknown TemporalExpressionAssoc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporalExpressionAssocMutation) SetField(name string, value ent.Value) error {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExprAssocType(v)
		return nil
	}
	return fmt.Errorf("unknown TemporalExpressionAssoc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemporalExpressionAssocMutation) AddedFields() []string {
	var fields []string
	if m.addexpr_assoc_type != nil {
		fields = append(fields, temporalexpressionassoc.FieldExprAssocType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemporalExpressionAssocMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		return m.AddedExprAssocType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporalExpressionAssocMutation) AddField(name string, value ent.Value) error {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExprAssocType(v)
		return nil
	}
	return fmt.Errorf("unknown TemporalExpressionAssoc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemporalExpressionAssocMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(temporalexpressionassoc.FieldExprAssocType) {
		fields = append(fields, temporalexpressionassoc.FieldExprAssocType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemporalExpressionAssocMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemporalExpressionAssocMutation) ClearField(name string) error {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		m.ClearExprAssocType()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpressionAssoc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemporalExpressionAssocMutation) ResetField(name string) error {
	switch name {
	case temporalexpressionassoc.FieldExprAssocType:
		m.ResetExprAssocType()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpressionAssoc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemporalExpressionAssocMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_temporal_expression != nil {
		edges = append(edges, temporalexpressionassoc.EdgeFromTemporalExpression)
	}
	if m.to_temporal_expression != nil {
		edges = append(edges, temporalexpressionassoc.EdgeToTemporalExpression)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemporalExpressionAssocMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case temporalexpressionassoc.EdgeFromTemporalExpression:
		if id := m.from_temporal_expression; id != nil {
			return []ent.Value{*id}
		}
	case temporalexpressionassoc.EdgeToTemporalExpression:
		if id := m.to_temporal_expression; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemporalExpressionAssocMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemporalExpressionAssocMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemporalExpressionAssocMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_temporal_expression {
		edges = append(edges, temporalexpressionassoc.EdgeFromTemporalExpression)
	}
	if m.clearedto_temporal_expression {
		edges = append(edges, temporalexpressionassoc.EdgeToTemporalExpression)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemporalExpressionAssocMutation) EdgeCleared(name string) bool {
	switch name {
	case temporalexpressionassoc.EdgeFromTemporalExpression:
		return m.clearedfrom_temporal_expression
	case temporalexpressionassoc.EdgeToTemporalExpression:
		return m.clearedto_temporal_expression
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemporalExpressionAssocMutation) ClearEdge(name string) error {
	switch name {
	case temporalexpressionassoc.EdgeFromTemporalExpression:
		m.ClearFromTemporalExpression()
		return nil
	case temporalexpressionassoc.EdgeToTemporalExpression:
		m.ClearToTemporalExpression()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpressionAssoc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemporalExpressionAssocMutation) ResetEdge(name string) error {
	switch name {
	case temporalexpressionassoc.EdgeFromTemporalExpression:
		m.ResetFromTemporalExpression()
		return nil
	case temporalexpressionassoc.EdgeToTemporalExpression:
		m.ResetToTemporalExpression()
		return nil
	}
	return fmt.Errorf("unknown TemporalExpressionAssoc edge %s", name)
}

// UserLoginMutation represents an operation that mutates the UserLogin nodes in the graph.
type UserLoginMutation struct {
	config
	op                                               Op
	typ                                              string
	id                                               *int
	current_password                                 *string
	password_hint                                    *string
	is_system                                        *userlogin.IsSystem
	enabled                                          *userlogin.Enabled
	has_logged_out                                   *userlogin.HasLoggedOut
	require_password_change                          *userlogin.RequirePasswordChange
	last_currency_uom                                *int
	addlast_currency_uom                             *int
	last_locale                                      *string
	last_time_zone                                   *string
	disabled_date_time                               *time.Time
	successive_failed_logins                         *int
	addsuccessive_failed_logins                      *int
	external_auth_id                                 *string
	user_ldap_dn                                     *string
	disabled_by                                      *string
	clearedFields                                    map[string]struct{}
	party                                            *int
	clearedparty                                     bool
	person                                           *int
	clearedperson                                    bool
	created_by_parties                               map[int]struct{}
	removedcreated_by_parties                        map[int]struct{}
	clearedcreated_by_parties                        bool
	last_modified_by_parties                         map[int]struct{}
	removedlast_modified_by_parties                  map[int]struct{}
	clearedlast_modified_by_parties                  bool
	change_by_party_statuses                         map[int]struct{}
	removedchange_by_party_statuses                  map[int]struct{}
	clearedchange_by_party_statuses                  bool
	user_login_security_groups                       map[int]struct{}
	removeduser_login_security_groups                map[int]struct{}
	cleareduser_login_security_groups                bool
	assigned_by_work_effort_party_assignments        map[int]struct{}
	removedassigned_by_work_effort_party_assignments map[int]struct{}
	clearedassigned_by_work_effort_party_assignments bool
	done                                             bool
	oldValue                                         func(context.Context) (*UserLogin, error)
	predicates                                       []predicate.UserLogin
}

var _ ent.Mutation = (*UserLoginMutation)(nil)

// userloginOption allows management of the mutation configuration using functional options.
type userloginOption func(*UserLoginMutation)

// newUserLoginMutation creates new mutation for the UserLogin entity.
func newUserLoginMutation(c config, op Op, opts ...userloginOption) *UserLoginMutation {
	m := &UserLoginMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLogin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginID sets the ID field of the mutation.
func withUserLoginID(id int) userloginOption {
	return func(m *UserLoginMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLogin
		)
		m.oldValue = func(ctx context.Context) (*UserLogin, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLogin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLogin sets the old UserLogin of the mutation.
func withUserLogin(node *UserLogin) userloginOption {
	return func(m *UserLoginMutation) {
		m.oldValue = func(context.Context) (*UserLogin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserLoginMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCurrentPassword sets the "current_password" field.
func (m *UserLoginMutation) SetCurrentPassword(s string) {
	m.current_password = &s
}

// CurrentPassword returns the value of the "current_password" field in the mutation.
func (m *UserLoginMutation) CurrentPassword() (r string, exists bool) {
	v := m.current_password
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPassword returns the old "current_password" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldCurrentPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrentPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrentPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPassword: %w", err)
	}
	return oldValue.CurrentPassword, nil
}

// ClearCurrentPassword clears the value of the "current_password" field.
func (m *UserLoginMutation) ClearCurrentPassword() {
	m.current_password = nil
	m.clearedFields[userlogin.FieldCurrentPassword] = struct{}{}
}

// CurrentPasswordCleared returns if the "current_password" field was cleared in this mutation.
func (m *UserLoginMutation) CurrentPasswordCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldCurrentPassword]
	return ok
}

// ResetCurrentPassword resets all changes to the "current_password" field.
func (m *UserLoginMutation) ResetCurrentPassword() {
	m.current_password = nil
	delete(m.clearedFields, userlogin.FieldCurrentPassword)
}

// SetPasswordHint sets the "password_hint" field.
func (m *UserLoginMutation) SetPasswordHint(s string) {
	m.password_hint = &s
}

// PasswordHint returns the value of the "password_hint" field in the mutation.
func (m *UserLoginMutation) PasswordHint() (r string, exists bool) {
	v := m.password_hint
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHint returns the old "password_hint" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldPasswordHint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordHint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordHint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHint: %w", err)
	}
	return oldValue.PasswordHint, nil
}

// ClearPasswordHint clears the value of the "password_hint" field.
func (m *UserLoginMutation) ClearPasswordHint() {
	m.password_hint = nil
	m.clearedFields[userlogin.FieldPasswordHint] = struct{}{}
}

// PasswordHintCleared returns if the "password_hint" field was cleared in this mutation.
func (m *UserLoginMutation) PasswordHintCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldPasswordHint]
	return ok
}

// ResetPasswordHint resets all changes to the "password_hint" field.
func (m *UserLoginMutation) ResetPasswordHint() {
	m.password_hint = nil
	delete(m.clearedFields, userlogin.FieldPasswordHint)
}

// SetIsSystem sets the "is_system" field.
func (m *UserLoginMutation) SetIsSystem(us userlogin.IsSystem) {
	m.is_system = &us
}

// IsSystem returns the value of the "is_system" field in the mutation.
func (m *UserLoginMutation) IsSystem() (r userlogin.IsSystem, exists bool) {
	v := m.is_system
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSystem returns the old "is_system" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldIsSystem(ctx context.Context) (v userlogin.IsSystem, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSystem: %w", err)
	}
	return oldValue.IsSystem, nil
}

// ClearIsSystem clears the value of the "is_system" field.
func (m *UserLoginMutation) ClearIsSystem() {
	m.is_system = nil
	m.clearedFields[userlogin.FieldIsSystem] = struct{}{}
}

// IsSystemCleared returns if the "is_system" field was cleared in this mutation.
func (m *UserLoginMutation) IsSystemCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldIsSystem]
	return ok
}

// ResetIsSystem resets all changes to the "is_system" field.
func (m *UserLoginMutation) ResetIsSystem() {
	m.is_system = nil
	delete(m.clearedFields, userlogin.FieldIsSystem)
}

// SetEnabled sets the "enabled" field.
func (m *UserLoginMutation) SetEnabled(u userlogin.Enabled) {
	m.enabled = &u
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *UserLoginMutation) Enabled() (r userlogin.Enabled, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldEnabled(ctx context.Context) (v userlogin.Enabled, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ClearEnabled clears the value of the "enabled" field.
func (m *UserLoginMutation) ClearEnabled() {
	m.enabled = nil
	m.clearedFields[userlogin.FieldEnabled] = struct{}{}
}

// EnabledCleared returns if the "enabled" field was cleared in this mutation.
func (m *UserLoginMutation) EnabledCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldEnabled]
	return ok
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *UserLoginMutation) ResetEnabled() {
	m.enabled = nil
	delete(m.clearedFields, userlogin.FieldEnabled)
}

// SetHasLoggedOut sets the "has_logged_out" field.
func (m *UserLoginMutation) SetHasLoggedOut(ulo userlogin.HasLoggedOut) {
	m.has_logged_out = &ulo
}

// HasLoggedOut returns the value of the "has_logged_out" field in the mutation.
func (m *UserLoginMutation) HasLoggedOut() (r userlogin.HasLoggedOut, exists bool) {
	v := m.has_logged_out
	if v == nil {
		return
	}
	return *v, true
}

// OldHasLoggedOut returns the old "has_logged_out" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldHasLoggedOut(ctx context.Context) (v userlogin.HasLoggedOut, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasLoggedOut is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasLoggedOut requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasLoggedOut: %w", err)
	}
	return oldValue.HasLoggedOut, nil
}

// ClearHasLoggedOut clears the value of the "has_logged_out" field.
func (m *UserLoginMutation) ClearHasLoggedOut() {
	m.has_logged_out = nil
	m.clearedFields[userlogin.FieldHasLoggedOut] = struct{}{}
}

// HasLoggedOutCleared returns if the "has_logged_out" field was cleared in this mutation.
func (m *UserLoginMutation) HasLoggedOutCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldHasLoggedOut]
	return ok
}

// ResetHasLoggedOut resets all changes to the "has_logged_out" field.
func (m *UserLoginMutation) ResetHasLoggedOut() {
	m.has_logged_out = nil
	delete(m.clearedFields, userlogin.FieldHasLoggedOut)
}

// SetRequirePasswordChange sets the "require_password_change" field.
func (m *UserLoginMutation) SetRequirePasswordChange(upc userlogin.RequirePasswordChange) {
	m.require_password_change = &upc
}

// RequirePasswordChange returns the value of the "require_password_change" field in the mutation.
func (m *UserLoginMutation) RequirePasswordChange() (r userlogin.RequirePasswordChange, exists bool) {
	v := m.require_password_change
	if v == nil {
		return
	}
	return *v, true
}

// OldRequirePasswordChange returns the old "require_password_change" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldRequirePasswordChange(ctx context.Context) (v userlogin.RequirePasswordChange, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequirePasswordChange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequirePasswordChange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequirePasswordChange: %w", err)
	}
	return oldValue.RequirePasswordChange, nil
}

// ClearRequirePasswordChange clears the value of the "require_password_change" field.
func (m *UserLoginMutation) ClearRequirePasswordChange() {
	m.require_password_change = nil
	m.clearedFields[userlogin.FieldRequirePasswordChange] = struct{}{}
}

// RequirePasswordChangeCleared returns if the "require_password_change" field was cleared in this mutation.
func (m *UserLoginMutation) RequirePasswordChangeCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldRequirePasswordChange]
	return ok
}

// ResetRequirePasswordChange resets all changes to the "require_password_change" field.
func (m *UserLoginMutation) ResetRequirePasswordChange() {
	m.require_password_change = nil
	delete(m.clearedFields, userlogin.FieldRequirePasswordChange)
}

// SetLastCurrencyUom sets the "last_currency_uom" field.
func (m *UserLoginMutation) SetLastCurrencyUom(i int) {
	m.last_currency_uom = &i
	m.addlast_currency_uom = nil
}

// LastCurrencyUom returns the value of the "last_currency_uom" field in the mutation.
func (m *UserLoginMutation) LastCurrencyUom() (r int, exists bool) {
	v := m.last_currency_uom
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCurrencyUom returns the old "last_currency_uom" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldLastCurrencyUom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastCurrencyUom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastCurrencyUom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCurrencyUom: %w", err)
	}
	return oldValue.LastCurrencyUom, nil
}

// AddLastCurrencyUom adds i to the "last_currency_uom" field.
func (m *UserLoginMutation) AddLastCurrencyUom(i int) {
	if m.addlast_currency_uom != nil {
		*m.addlast_currency_uom += i
	} else {
		m.addlast_currency_uom = &i
	}
}

// AddedLastCurrencyUom returns the value that was added to the "last_currency_uom" field in this mutation.
func (m *UserLoginMutation) AddedLastCurrencyUom() (r int, exists bool) {
	v := m.addlast_currency_uom
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastCurrencyUom clears the value of the "last_currency_uom" field.
func (m *UserLoginMutation) ClearLastCurrencyUom() {
	m.last_currency_uom = nil
	m.addlast_currency_uom = nil
	m.clearedFields[userlogin.FieldLastCurrencyUom] = struct{}{}
}

// LastCurrencyUomCleared returns if the "last_currency_uom" field was cleared in this mutation.
func (m *UserLoginMutation) LastCurrencyUomCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldLastCurrencyUom]
	return ok
}

// ResetLastCurrencyUom resets all changes to the "last_currency_uom" field.
func (m *UserLoginMutation) ResetLastCurrencyUom() {
	m.last_currency_uom = nil
	m.addlast_currency_uom = nil
	delete(m.clearedFields, userlogin.FieldLastCurrencyUom)
}

// SetLastLocale sets the "last_locale" field.
func (m *UserLoginMutation) SetLastLocale(s string) {
	m.last_locale = &s
}

// LastLocale returns the value of the "last_locale" field in the mutation.
func (m *UserLoginMutation) LastLocale() (r string, exists bool) {
	v := m.last_locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLocale returns the old "last_locale" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldLastLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLocale: %w", err)
	}
	return oldValue.LastLocale, nil
}

// ClearLastLocale clears the value of the "last_locale" field.
func (m *UserLoginMutation) ClearLastLocale() {
	m.last_locale = nil
	m.clearedFields[userlogin.FieldLastLocale] = struct{}{}
}

// LastLocaleCleared returns if the "last_locale" field was cleared in this mutation.
func (m *UserLoginMutation) LastLocaleCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldLastLocale]
	return ok
}

// ResetLastLocale resets all changes to the "last_locale" field.
func (m *UserLoginMutation) ResetLastLocale() {
	m.last_locale = nil
	delete(m.clearedFields, userlogin.FieldLastLocale)
}

// SetLastTimeZone sets the "last_time_zone" field.
func (m *UserLoginMutation) SetLastTimeZone(s string) {
	m.last_time_zone = &s
}

// LastTimeZone returns the value of the "last_time_zone" field in the mutation.
func (m *UserLoginMutation) LastTimeZone() (r string, exists bool) {
	v := m.last_time_zone
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTimeZone returns the old "last_time_zone" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldLastTimeZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastTimeZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastTimeZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTimeZone: %w", err)
	}
	return oldValue.LastTimeZone, nil
}

// ClearLastTimeZone clears the value of the "last_time_zone" field.
func (m *UserLoginMutation) ClearLastTimeZone() {
	m.last_time_zone = nil
	m.clearedFields[userlogin.FieldLastTimeZone] = struct{}{}
}

// LastTimeZoneCleared returns if the "last_time_zone" field was cleared in this mutation.
func (m *UserLoginMutation) LastTimeZoneCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldLastTimeZone]
	return ok
}

// ResetLastTimeZone resets all changes to the "last_time_zone" field.
func (m *UserLoginMutation) ResetLastTimeZone() {
	m.last_time_zone = nil
	delete(m.clearedFields, userlogin.FieldLastTimeZone)
}

// SetDisabledDateTime sets the "disabled_date_time" field.
func (m *UserLoginMutation) SetDisabledDateTime(t time.Time) {
	m.disabled_date_time = &t
}

// DisabledDateTime returns the value of the "disabled_date_time" field in the mutation.
func (m *UserLoginMutation) DisabledDateTime() (r time.Time, exists bool) {
	v := m.disabled_date_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabledDateTime returns the old "disabled_date_time" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldDisabledDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabledDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabledDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabledDateTime: %w", err)
	}
	return oldValue.DisabledDateTime, nil
}

// ClearDisabledDateTime clears the value of the "disabled_date_time" field.
func (m *UserLoginMutation) ClearDisabledDateTime() {
	m.disabled_date_time = nil
	m.clearedFields[userlogin.FieldDisabledDateTime] = struct{}{}
}

// DisabledDateTimeCleared returns if the "disabled_date_time" field was cleared in this mutation.
func (m *UserLoginMutation) DisabledDateTimeCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldDisabledDateTime]
	return ok
}

// ResetDisabledDateTime resets all changes to the "disabled_date_time" field.
func (m *UserLoginMutation) ResetDisabledDateTime() {
	m.disabled_date_time = nil
	delete(m.clearedFields, userlogin.FieldDisabledDateTime)
}

// SetSuccessiveFailedLogins sets the "successive_failed_logins" field.
func (m *UserLoginMutation) SetSuccessiveFailedLogins(i int) {
	m.successive_failed_logins = &i
	m.addsuccessive_failed_logins = nil
}

// SuccessiveFailedLogins returns the value of the "successive_failed_logins" field in the mutation.
func (m *UserLoginMutation) SuccessiveFailedLogins() (r int, exists bool) {
	v := m.successive_failed_logins
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessiveFailedLogins returns the old "successive_failed_logins" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldSuccessiveFailedLogins(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuccessiveFailedLogins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuccessiveFailedLogins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessiveFailedLogins: %w", err)
	}
	return oldValue.SuccessiveFailedLogins, nil
}

// AddSuccessiveFailedLogins adds i to the "successive_failed_logins" field.
func (m *UserLoginMutation) AddSuccessiveFailedLogins(i int) {
	if m.addsuccessive_failed_logins != nil {
		*m.addsuccessive_failed_logins += i
	} else {
		m.addsuccessive_failed_logins = &i
	}
}

// AddedSuccessiveFailedLogins returns the value that was added to the "successive_failed_logins" field in this mutation.
func (m *UserLoginMutation) AddedSuccessiveFailedLogins() (r int, exists bool) {
	v := m.addsuccessive_failed_logins
	if v == nil {
		return
	}
	return *v, true
}

// ClearSuccessiveFailedLogins clears the value of the "successive_failed_logins" field.
func (m *UserLoginMutation) ClearSuccessiveFailedLogins() {
	m.successive_failed_logins = nil
	m.addsuccessive_failed_logins = nil
	m.clearedFields[userlogin.FieldSuccessiveFailedLogins] = struct{}{}
}

// SuccessiveFailedLoginsCleared returns if the "successive_failed_logins" field was cleared in this mutation.
func (m *UserLoginMutation) SuccessiveFailedLoginsCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldSuccessiveFailedLogins]
	return ok
}

// ResetSuccessiveFailedLogins resets all changes to the "successive_failed_logins" field.
func (m *UserLoginMutation) ResetSuccessiveFailedLogins() {
	m.successive_failed_logins = nil
	m.addsuccessive_failed_logins = nil
	delete(m.clearedFields, userlogin.FieldSuccessiveFailedLogins)
}

// SetExternalAuthID sets the "external_auth_id" field.
func (m *UserLoginMutation) SetExternalAuthID(s string) {
	m.external_auth_id = &s
}

// ExternalAuthID returns the value of the "external_auth_id" field in the mutation.
func (m *UserLoginMutation) ExternalAuthID() (r string, exists bool) {
	v := m.external_auth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalAuthID returns the old "external_auth_id" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldExternalAuthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalAuthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalAuthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalAuthID: %w", err)
	}
	return oldValue.ExternalAuthID, nil
}

// ClearExternalAuthID clears the value of the "external_auth_id" field.
func (m *UserLoginMutation) ClearExternalAuthID() {
	m.external_auth_id = nil
	m.clearedFields[userlogin.FieldExternalAuthID] = struct{}{}
}

// ExternalAuthIDCleared returns if the "external_auth_id" field was cleared in this mutation.
func (m *UserLoginMutation) ExternalAuthIDCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldExternalAuthID]
	return ok
}

// ResetExternalAuthID resets all changes to the "external_auth_id" field.
func (m *UserLoginMutation) ResetExternalAuthID() {
	m.external_auth_id = nil
	delete(m.clearedFields, userlogin.FieldExternalAuthID)
}

// SetUserLdapDn sets the "user_ldap_dn" field.
func (m *UserLoginMutation) SetUserLdapDn(s string) {
	m.user_ldap_dn = &s
}

// UserLdapDn returns the value of the "user_ldap_dn" field in the mutation.
func (m *UserLoginMutation) UserLdapDn() (r string, exists bool) {
	v := m.user_ldap_dn
	if v == nil {
		return
	}
	return *v, true
}

// OldUserLdapDn returns the old "user_ldap_dn" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldUserLdapDn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserLdapDn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserLdapDn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserLdapDn: %w", err)
	}
	return oldValue.UserLdapDn, nil
}

// ClearUserLdapDn clears the value of the "user_ldap_dn" field.
func (m *UserLoginMutation) ClearUserLdapDn() {
	m.user_ldap_dn = nil
	m.clearedFields[userlogin.FieldUserLdapDn] = struct{}{}
}

// UserLdapDnCleared returns if the "user_ldap_dn" field was cleared in this mutation.
func (m *UserLoginMutation) UserLdapDnCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldUserLdapDn]
	return ok
}

// ResetUserLdapDn resets all changes to the "user_ldap_dn" field.
func (m *UserLoginMutation) ResetUserLdapDn() {
	m.user_ldap_dn = nil
	delete(m.clearedFields, userlogin.FieldUserLdapDn)
}

// SetDisabledBy sets the "disabled_by" field.
func (m *UserLoginMutation) SetDisabledBy(s string) {
	m.disabled_by = &s
}

// DisabledBy returns the value of the "disabled_by" field in the mutation.
func (m *UserLoginMutation) DisabledBy() (r string, exists bool) {
	v := m.disabled_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabledBy returns the old "disabled_by" field's value of the UserLogin entity.
// If the UserLogin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginMutation) OldDisabledBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabledBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabledBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabledBy: %w", err)
	}
	return oldValue.DisabledBy, nil
}

// ClearDisabledBy clears the value of the "disabled_by" field.
func (m *UserLoginMutation) ClearDisabledBy() {
	m.disabled_by = nil
	m.clearedFields[userlogin.FieldDisabledBy] = struct{}{}
}

// DisabledByCleared returns if the "disabled_by" field was cleared in this mutation.
func (m *UserLoginMutation) DisabledByCleared() bool {
	_, ok := m.clearedFields[userlogin.FieldDisabledBy]
	return ok
}

// ResetDisabledBy resets all changes to the "disabled_by" field.
func (m *UserLoginMutation) ResetDisabledBy() {
	m.disabled_by = nil
	delete(m.clearedFields, userlogin.FieldDisabledBy)
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *UserLoginMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *UserLoginMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *UserLoginMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *UserLoginMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *UserLoginMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *UserLoginMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// SetPersonID sets the "person" edge to the Person entity by id.
func (m *UserLoginMutation) SetPersonID(id int) {
	m.person = &id
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *UserLoginMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *UserLoginMutation) PersonCleared() bool {
	return m.clearedperson
}

// PersonID returns the "person" edge ID in the mutation.
func (m *UserLoginMutation) PersonID() (id int, exists bool) {
	if m.person != nil {
		return *m.person, true
	}
	return
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *UserLoginMutation) PersonIDs() (ids []int) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *UserLoginMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// AddCreatedByPartyIDs adds the "created_by_parties" edge to the Party entity by ids.
func (m *UserLoginMutation) AddCreatedByPartyIDs(ids ...int) {
	if m.created_by_parties == nil {
		m.created_by_parties = make(map[int]struct{})
	}
	for i := range ids {
		m.created_by_parties[ids[i]] = struct{}{}
	}
}

// ClearCreatedByParties clears the "created_by_parties" edge to the Party entity.
func (m *UserLoginMutation) ClearCreatedByParties() {
	m.clearedcreated_by_parties = true
}

// CreatedByPartiesCleared reports if the "created_by_parties" edge to the Party entity was cleared.
func (m *UserLoginMutation) CreatedByPartiesCleared() bool {
	return m.clearedcreated_by_parties
}

// RemoveCreatedByPartyIDs removes the "created_by_parties" edge to the Party entity by IDs.
func (m *UserLoginMutation) RemoveCreatedByPartyIDs(ids ...int) {
	if m.removedcreated_by_parties == nil {
		m.removedcreated_by_parties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcreated_by_parties[ids[i]] = struct{}{}
	}
}

// RemovedCreatedByParties returns the removed IDs of the "created_by_parties" edge to the Party entity.
func (m *UserLoginMutation) RemovedCreatedByPartiesIDs() (ids []int) {
	for id := range m.removedcreated_by_parties {
		ids = append(ids, id)
	}
	return
}

// CreatedByPartiesIDs returns the "created_by_parties" edge IDs in the mutation.
func (m *UserLoginMutation) CreatedByPartiesIDs() (ids []int) {
	for id := range m.created_by_parties {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedByParties resets all changes to the "created_by_parties" edge.
func (m *UserLoginMutation) ResetCreatedByParties() {
	m.created_by_parties = nil
	m.clearedcreated_by_parties = false
	m.removedcreated_by_parties = nil
}

// AddLastModifiedByPartyIDs adds the "last_modified_by_parties" edge to the Party entity by ids.
func (m *UserLoginMutation) AddLastModifiedByPartyIDs(ids ...int) {
	if m.last_modified_by_parties == nil {
		m.last_modified_by_parties = make(map[int]struct{})
	}
	for i := range ids {
		m.last_modified_by_parties[ids[i]] = struct{}{}
	}
}

// ClearLastModifiedByParties clears the "last_modified_by_parties" edge to the Party entity.
func (m *UserLoginMutation) ClearLastModifiedByParties() {
	m.clearedlast_modified_by_parties = true
}

// LastModifiedByPartiesCleared reports if the "last_modified_by_parties" edge to the Party entity was cleared.
func (m *UserLoginMutation) LastModifiedByPartiesCleared() bool {
	return m.clearedlast_modified_by_parties
}

// RemoveLastModifiedByPartyIDs removes the "last_modified_by_parties" edge to the Party entity by IDs.
func (m *UserLoginMutation) RemoveLastModifiedByPartyIDs(ids ...int) {
	if m.removedlast_modified_by_parties == nil {
		m.removedlast_modified_by_parties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlast_modified_by_parties[ids[i]] = struct{}{}
	}
}

// RemovedLastModifiedByParties returns the removed IDs of the "last_modified_by_parties" edge to the Party entity.
func (m *UserLoginMutation) RemovedLastModifiedByPartiesIDs() (ids []int) {
	for id := range m.removedlast_modified_by_parties {
		ids = append(ids, id)
	}
	return
}

// LastModifiedByPartiesIDs returns the "last_modified_by_parties" edge IDs in the mutation.
func (m *UserLoginMutation) LastModifiedByPartiesIDs() (ids []int) {
	for id := range m.last_modified_by_parties {
		ids = append(ids, id)
	}
	return
}

// ResetLastModifiedByParties resets all changes to the "last_modified_by_parties" edge.
func (m *UserLoginMutation) ResetLastModifiedByParties() {
	m.last_modified_by_parties = nil
	m.clearedlast_modified_by_parties = false
	m.removedlast_modified_by_parties = nil
}

// AddChangeByPartyStatusIDs adds the "change_by_party_statuses" edge to the PartyStatus entity by ids.
func (m *UserLoginMutation) AddChangeByPartyStatusIDs(ids ...int) {
	if m.change_by_party_statuses == nil {
		m.change_by_party_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.change_by_party_statuses[ids[i]] = struct{}{}
	}
}

// ClearChangeByPartyStatuses clears the "change_by_party_statuses" edge to the PartyStatus entity.
func (m *UserLoginMutation) ClearChangeByPartyStatuses() {
	m.clearedchange_by_party_statuses = true
}

// ChangeByPartyStatusesCleared reports if the "change_by_party_statuses" edge to the PartyStatus entity was cleared.
func (m *UserLoginMutation) ChangeByPartyStatusesCleared() bool {
	return m.clearedchange_by_party_statuses
}

// RemoveChangeByPartyStatusIDs removes the "change_by_party_statuses" edge to the PartyStatus entity by IDs.
func (m *UserLoginMutation) RemoveChangeByPartyStatusIDs(ids ...int) {
	if m.removedchange_by_party_statuses == nil {
		m.removedchange_by_party_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchange_by_party_statuses[ids[i]] = struct{}{}
	}
}

// RemovedChangeByPartyStatuses returns the removed IDs of the "change_by_party_statuses" edge to the PartyStatus entity.
func (m *UserLoginMutation) RemovedChangeByPartyStatusesIDs() (ids []int) {
	for id := range m.removedchange_by_party_statuses {
		ids = append(ids, id)
	}
	return
}

// ChangeByPartyStatusesIDs returns the "change_by_party_statuses" edge IDs in the mutation.
func (m *UserLoginMutation) ChangeByPartyStatusesIDs() (ids []int) {
	for id := range m.change_by_party_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetChangeByPartyStatuses resets all changes to the "change_by_party_statuses" edge.
func (m *UserLoginMutation) ResetChangeByPartyStatuses() {
	m.change_by_party_statuses = nil
	m.clearedchange_by_party_statuses = false
	m.removedchange_by_party_statuses = nil
}

// AddUserLoginSecurityGroupIDs adds the "user_login_security_groups" edge to the UserLoginSecurityGroup entity by ids.
func (m *UserLoginMutation) AddUserLoginSecurityGroupIDs(ids ...int) {
	if m.user_login_security_groups == nil {
		m.user_login_security_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.user_login_security_groups[ids[i]] = struct{}{}
	}
}

// ClearUserLoginSecurityGroups clears the "user_login_security_groups" edge to the UserLoginSecurityGroup entity.
func (m *UserLoginMutation) ClearUserLoginSecurityGroups() {
	m.cleareduser_login_security_groups = true
}

// UserLoginSecurityGroupsCleared reports if the "user_login_security_groups" edge to the UserLoginSecurityGroup entity was cleared.
func (m *UserLoginMutation) UserLoginSecurityGroupsCleared() bool {
	return m.cleareduser_login_security_groups
}

// RemoveUserLoginSecurityGroupIDs removes the "user_login_security_groups" edge to the UserLoginSecurityGroup entity by IDs.
func (m *UserLoginMutation) RemoveUserLoginSecurityGroupIDs(ids ...int) {
	if m.removeduser_login_security_groups == nil {
		m.removeduser_login_security_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_login_security_groups[ids[i]] = struct{}{}
	}
}

// RemovedUserLoginSecurityGroups returns the removed IDs of the "user_login_security_groups" edge to the UserLoginSecurityGroup entity.
func (m *UserLoginMutation) RemovedUserLoginSecurityGroupsIDs() (ids []int) {
	for id := range m.removeduser_login_security_groups {
		ids = append(ids, id)
	}
	return
}

// UserLoginSecurityGroupsIDs returns the "user_login_security_groups" edge IDs in the mutation.
func (m *UserLoginMutation) UserLoginSecurityGroupsIDs() (ids []int) {
	for id := range m.user_login_security_groups {
		ids = append(ids, id)
	}
	return
}

// ResetUserLoginSecurityGroups resets all changes to the "user_login_security_groups" edge.
func (m *UserLoginMutation) ResetUserLoginSecurityGroups() {
	m.user_login_security_groups = nil
	m.cleareduser_login_security_groups = false
	m.removeduser_login_security_groups = nil
}

// AddAssignedByWorkEffortPartyAssignmentIDs adds the "assigned_by_work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by ids.
func (m *UserLoginMutation) AddAssignedByWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.assigned_by_work_effort_party_assignments == nil {
		m.assigned_by_work_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_by_work_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignedByWorkEffortPartyAssignments clears the "assigned_by_work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *UserLoginMutation) ClearAssignedByWorkEffortPartyAssignments() {
	m.clearedassigned_by_work_effort_party_assignments = true
}

// AssignedByWorkEffortPartyAssignmentsCleared reports if the "assigned_by_work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity was cleared.
func (m *UserLoginMutation) AssignedByWorkEffortPartyAssignmentsCleared() bool {
	return m.clearedassigned_by_work_effort_party_assignments
}

// RemoveAssignedByWorkEffortPartyAssignmentIDs removes the "assigned_by_work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by IDs.
func (m *UserLoginMutation) RemoveAssignedByWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.removedassigned_by_work_effort_party_assignments == nil {
		m.removedassigned_by_work_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedassigned_by_work_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignedByWorkEffortPartyAssignments returns the removed IDs of the "assigned_by_work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *UserLoginMutation) RemovedAssignedByWorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.removedassigned_by_work_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// AssignedByWorkEffortPartyAssignmentsIDs returns the "assigned_by_work_effort_party_assignments" edge IDs in the mutation.
func (m *UserLoginMutation) AssignedByWorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.assigned_by_work_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedByWorkEffortPartyAssignments resets all changes to the "assigned_by_work_effort_party_assignments" edge.
func (m *UserLoginMutation) ResetAssignedByWorkEffortPartyAssignments() {
	m.assigned_by_work_effort_party_assignments = nil
	m.clearedassigned_by_work_effort_party_assignments = false
	m.removedassigned_by_work_effort_party_assignments = nil
}

// Op returns the operation name.
func (m *UserLoginMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLogin).
func (m *UserLoginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.current_password != nil {
		fields = append(fields, userlogin.FieldCurrentPassword)
	}
	if m.password_hint != nil {
		fields = append(fields, userlogin.FieldPasswordHint)
	}
	if m.is_system != nil {
		fields = append(fields, userlogin.FieldIsSystem)
	}
	if m.enabled != nil {
		fields = append(fields, userlogin.FieldEnabled)
	}
	if m.has_logged_out != nil {
		fields = append(fields, userlogin.FieldHasLoggedOut)
	}
	if m.require_password_change != nil {
		fields = append(fields, userlogin.FieldRequirePasswordChange)
	}
	if m.last_currency_uom != nil {
		fields = append(fields, userlogin.FieldLastCurrencyUom)
	}
	if m.last_locale != nil {
		fields = append(fields, userlogin.FieldLastLocale)
	}
	if m.last_time_zone != nil {
		fields = append(fields, userlogin.FieldLastTimeZone)
	}
	if m.disabled_date_time != nil {
		fields = append(fields, userlogin.FieldDisabledDateTime)
	}
	if m.successive_failed_logins != nil {
		fields = append(fields, userlogin.FieldSuccessiveFailedLogins)
	}
	if m.external_auth_id != nil {
		fields = append(fields, userlogin.FieldExternalAuthID)
	}
	if m.user_ldap_dn != nil {
		fields = append(fields, userlogin.FieldUserLdapDn)
	}
	if m.disabled_by != nil {
		fields = append(fields, userlogin.FieldDisabledBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlogin.FieldCurrentPassword:
		return m.CurrentPassword()
	case userlogin.FieldPasswordHint:
		return m.PasswordHint()
	case userlogin.FieldIsSystem:
		return m.IsSystem()
	case userlogin.FieldEnabled:
		return m.Enabled()
	case userlogin.FieldHasLoggedOut:
		return m.HasLoggedOut()
	case userlogin.FieldRequirePasswordChange:
		return m.RequirePasswordChange()
	case userlogin.FieldLastCurrencyUom:
		return m.LastCurrencyUom()
	case userlogin.FieldLastLocale:
		return m.LastLocale()
	case userlogin.FieldLastTimeZone:
		return m.LastTimeZone()
	case userlogin.FieldDisabledDateTime:
		return m.DisabledDateTime()
	case userlogin.FieldSuccessiveFailedLogins:
		return m.SuccessiveFailedLogins()
	case userlogin.FieldExternalAuthID:
		return m.ExternalAuthID()
	case userlogin.FieldUserLdapDn:
		return m.UserLdapDn()
	case userlogin.FieldDisabledBy:
		return m.DisabledBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlogin.FieldCurrentPassword:
		return m.OldCurrentPassword(ctx)
	case userlogin.FieldPasswordHint:
		return m.OldPasswordHint(ctx)
	case userlogin.FieldIsSystem:
		return m.OldIsSystem(ctx)
	case userlogin.FieldEnabled:
		return m.OldEnabled(ctx)
	case userlogin.FieldHasLoggedOut:
		return m.OldHasLoggedOut(ctx)
	case userlogin.FieldRequirePasswordChange:
		return m.OldRequirePasswordChange(ctx)
	case userlogin.FieldLastCurrencyUom:
		return m.OldLastCurrencyUom(ctx)
	case userlogin.FieldLastLocale:
		return m.OldLastLocale(ctx)
	case userlogin.FieldLastTimeZone:
		return m.OldLastTimeZone(ctx)
	case userlogin.FieldDisabledDateTime:
		return m.OldDisabledDateTime(ctx)
	case userlogin.FieldSuccessiveFailedLogins:
		return m.OldSuccessiveFailedLogins(ctx)
	case userlogin.FieldExternalAuthID:
		return m.OldExternalAuthID(ctx)
	case userlogin.FieldUserLdapDn:
		return m.OldUserLdapDn(ctx)
	case userlogin.FieldDisabledBy:
		return m.OldDisabledBy(ctx)
	}
	return nil, fmt.Errorf("unknown UserLogin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlogin.FieldCurrentPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPassword(v)
		return nil
	case userlogin.FieldPasswordHint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHint(v)
		return nil
	case userlogin.FieldIsSystem:
		v, ok := value.(userlogin.IsSystem)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSystem(v)
		return nil
	case userlogin.FieldEnabled:
		v, ok := value.(userlogin.Enabled)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case userlogin.FieldHasLoggedOut:
		v, ok := value.(userlogin.HasLoggedOut)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasLoggedOut(v)
		return nil
	case userlogin.FieldRequirePasswordChange:
		v, ok := value.(userlogin.RequirePasswordChange)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequirePasswordChange(v)
		return nil
	case userlogin.FieldLastCurrencyUom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCurrencyUom(v)
		return nil
	case userlogin.FieldLastLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLocale(v)
		return nil
	case userlogin.FieldLastTimeZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTimeZone(v)
		return nil
	case userlogin.FieldDisabledDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabledDateTime(v)
		return nil
	case userlogin.FieldSuccessiveFailedLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessiveFailedLogins(v)
		return nil
	case userlogin.FieldExternalAuthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalAuthID(v)
		return nil
	case userlogin.FieldUserLdapDn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserLdapDn(v)
		return nil
	case userlogin.FieldDisabledBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabledBy(v)
		return nil
	}
	return fmt.Errorf("unknown UserLogin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginMutation) AddedFields() []string {
	var fields []string
	if m.addlast_currency_uom != nil {
		fields = append(fields, userlogin.FieldLastCurrencyUom)
	}
	if m.addsuccessive_failed_logins != nil {
		fields = append(fields, userlogin.FieldSuccessiveFailedLogins)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userlogin.FieldLastCurrencyUom:
		return m.AddedLastCurrencyUom()
	case userlogin.FieldSuccessiveFailedLogins:
		return m.AddedSuccessiveFailedLogins()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userlogin.FieldLastCurrencyUom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastCurrencyUom(v)
		return nil
	case userlogin.FieldSuccessiveFailedLogins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessiveFailedLogins(v)
		return nil
	}
	return fmt.Errorf("unknown UserLogin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userlogin.FieldCurrentPassword) {
		fields = append(fields, userlogin.FieldCurrentPassword)
	}
	if m.FieldCleared(userlogin.FieldPasswordHint) {
		fields = append(fields, userlogin.FieldPasswordHint)
	}
	if m.FieldCleared(userlogin.FieldIsSystem) {
		fields = append(fields, userlogin.FieldIsSystem)
	}
	if m.FieldCleared(userlogin.FieldEnabled) {
		fields = append(fields, userlogin.FieldEnabled)
	}
	if m.FieldCleared(userlogin.FieldHasLoggedOut) {
		fields = append(fields, userlogin.FieldHasLoggedOut)
	}
	if m.FieldCleared(userlogin.FieldRequirePasswordChange) {
		fields = append(fields, userlogin.FieldRequirePasswordChange)
	}
	if m.FieldCleared(userlogin.FieldLastCurrencyUom) {
		fields = append(fields, userlogin.FieldLastCurrencyUom)
	}
	if m.FieldCleared(userlogin.FieldLastLocale) {
		fields = append(fields, userlogin.FieldLastLocale)
	}
	if m.FieldCleared(userlogin.FieldLastTimeZone) {
		fields = append(fields, userlogin.FieldLastTimeZone)
	}
	if m.FieldCleared(userlogin.FieldDisabledDateTime) {
		fields = append(fields, userlogin.FieldDisabledDateTime)
	}
	if m.FieldCleared(userlogin.FieldSuccessiveFailedLogins) {
		fields = append(fields, userlogin.FieldSuccessiveFailedLogins)
	}
	if m.FieldCleared(userlogin.FieldExternalAuthID) {
		fields = append(fields, userlogin.FieldExternalAuthID)
	}
	if m.FieldCleared(userlogin.FieldUserLdapDn) {
		fields = append(fields, userlogin.FieldUserLdapDn)
	}
	if m.FieldCleared(userlogin.FieldDisabledBy) {
		fields = append(fields, userlogin.FieldDisabledBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginMutation) ClearField(name string) error {
	switch name {
	case userlogin.FieldCurrentPassword:
		m.ClearCurrentPassword()
		return nil
	case userlogin.FieldPasswordHint:
		m.ClearPasswordHint()
		return nil
	case userlogin.FieldIsSystem:
		m.ClearIsSystem()
		return nil
	case userlogin.FieldEnabled:
		m.ClearEnabled()
		return nil
	case userlogin.FieldHasLoggedOut:
		m.ClearHasLoggedOut()
		return nil
	case userlogin.FieldRequirePasswordChange:
		m.ClearRequirePasswordChange()
		return nil
	case userlogin.FieldLastCurrencyUom:
		m.ClearLastCurrencyUom()
		return nil
	case userlogin.FieldLastLocale:
		m.ClearLastLocale()
		return nil
	case userlogin.FieldLastTimeZone:
		m.ClearLastTimeZone()
		return nil
	case userlogin.FieldDisabledDateTime:
		m.ClearDisabledDateTime()
		return nil
	case userlogin.FieldSuccessiveFailedLogins:
		m.ClearSuccessiveFailedLogins()
		return nil
	case userlogin.FieldExternalAuthID:
		m.ClearExternalAuthID()
		return nil
	case userlogin.FieldUserLdapDn:
		m.ClearUserLdapDn()
		return nil
	case userlogin.FieldDisabledBy:
		m.ClearDisabledBy()
		return nil
	}
	return fmt.Errorf("unknown UserLogin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginMutation) ResetField(name string) error {
	switch name {
	case userlogin.FieldCurrentPassword:
		m.ResetCurrentPassword()
		return nil
	case userlogin.FieldPasswordHint:
		m.ResetPasswordHint()
		return nil
	case userlogin.FieldIsSystem:
		m.ResetIsSystem()
		return nil
	case userlogin.FieldEnabled:
		m.ResetEnabled()
		return nil
	case userlogin.FieldHasLoggedOut:
		m.ResetHasLoggedOut()
		return nil
	case userlogin.FieldRequirePasswordChange:
		m.ResetRequirePasswordChange()
		return nil
	case userlogin.FieldLastCurrencyUom:
		m.ResetLastCurrencyUom()
		return nil
	case userlogin.FieldLastLocale:
		m.ResetLastLocale()
		return nil
	case userlogin.FieldLastTimeZone:
		m.ResetLastTimeZone()
		return nil
	case userlogin.FieldDisabledDateTime:
		m.ResetDisabledDateTime()
		return nil
	case userlogin.FieldSuccessiveFailedLogins:
		m.ResetSuccessiveFailedLogins()
		return nil
	case userlogin.FieldExternalAuthID:
		m.ResetExternalAuthID()
		return nil
	case userlogin.FieldUserLdapDn:
		m.ResetUserLdapDn()
		return nil
	case userlogin.FieldDisabledBy:
		m.ResetDisabledBy()
		return nil
	}
	return fmt.Errorf("unknown UserLogin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.party != nil {
		edges = append(edges, userlogin.EdgeParty)
	}
	if m.person != nil {
		edges = append(edges, userlogin.EdgePerson)
	}
	if m.created_by_parties != nil {
		edges = append(edges, userlogin.EdgeCreatedByParties)
	}
	if m.last_modified_by_parties != nil {
		edges = append(edges, userlogin.EdgeLastModifiedByParties)
	}
	if m.change_by_party_statuses != nil {
		edges = append(edges, userlogin.EdgeChangeByPartyStatuses)
	}
	if m.user_login_security_groups != nil {
		edges = append(edges, userlogin.EdgeUserLoginSecurityGroups)
	}
	if m.assigned_by_work_effort_party_assignments != nil {
		edges = append(edges, userlogin.EdgeAssignedByWorkEffortPartyAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlogin.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	case userlogin.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case userlogin.EdgeCreatedByParties:
		ids := make([]ent.Value, 0, len(m.created_by_parties))
		for id := range m.created_by_parties {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeLastModifiedByParties:
		ids := make([]ent.Value, 0, len(m.last_modified_by_parties))
		for id := range m.last_modified_by_parties {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeChangeByPartyStatuses:
		ids := make([]ent.Value, 0, len(m.change_by_party_statuses))
		for id := range m.change_by_party_statuses {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeUserLoginSecurityGroups:
		ids := make([]ent.Value, 0, len(m.user_login_security_groups))
		for id := range m.user_login_security_groups {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeAssignedByWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.assigned_by_work_effort_party_assignments))
		for id := range m.assigned_by_work_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcreated_by_parties != nil {
		edges = append(edges, userlogin.EdgeCreatedByParties)
	}
	if m.removedlast_modified_by_parties != nil {
		edges = append(edges, userlogin.EdgeLastModifiedByParties)
	}
	if m.removedchange_by_party_statuses != nil {
		edges = append(edges, userlogin.EdgeChangeByPartyStatuses)
	}
	if m.removeduser_login_security_groups != nil {
		edges = append(edges, userlogin.EdgeUserLoginSecurityGroups)
	}
	if m.removedassigned_by_work_effort_party_assignments != nil {
		edges = append(edges, userlogin.EdgeAssignedByWorkEffortPartyAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userlogin.EdgeCreatedByParties:
		ids := make([]ent.Value, 0, len(m.removedcreated_by_parties))
		for id := range m.removedcreated_by_parties {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeLastModifiedByParties:
		ids := make([]ent.Value, 0, len(m.removedlast_modified_by_parties))
		for id := range m.removedlast_modified_by_parties {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeChangeByPartyStatuses:
		ids := make([]ent.Value, 0, len(m.removedchange_by_party_statuses))
		for id := range m.removedchange_by_party_statuses {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeUserLoginSecurityGroups:
		ids := make([]ent.Value, 0, len(m.removeduser_login_security_groups))
		for id := range m.removeduser_login_security_groups {
			ids = append(ids, id)
		}
		return ids
	case userlogin.EdgeAssignedByWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.removedassigned_by_work_effort_party_assignments))
		for id := range m.removedassigned_by_work_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedparty {
		edges = append(edges, userlogin.EdgeParty)
	}
	if m.clearedperson {
		edges = append(edges, userlogin.EdgePerson)
	}
	if m.clearedcreated_by_parties {
		edges = append(edges, userlogin.EdgeCreatedByParties)
	}
	if m.clearedlast_modified_by_parties {
		edges = append(edges, userlogin.EdgeLastModifiedByParties)
	}
	if m.clearedchange_by_party_statuses {
		edges = append(edges, userlogin.EdgeChangeByPartyStatuses)
	}
	if m.cleareduser_login_security_groups {
		edges = append(edges, userlogin.EdgeUserLoginSecurityGroups)
	}
	if m.clearedassigned_by_work_effort_party_assignments {
		edges = append(edges, userlogin.EdgeAssignedByWorkEffortPartyAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginMutation) EdgeCleared(name string) bool {
	switch name {
	case userlogin.EdgeParty:
		return m.clearedparty
	case userlogin.EdgePerson:
		return m.clearedperson
	case userlogin.EdgeCreatedByParties:
		return m.clearedcreated_by_parties
	case userlogin.EdgeLastModifiedByParties:
		return m.clearedlast_modified_by_parties
	case userlogin.EdgeChangeByPartyStatuses:
		return m.clearedchange_by_party_statuses
	case userlogin.EdgeUserLoginSecurityGroups:
		return m.cleareduser_login_security_groups
	case userlogin.EdgeAssignedByWorkEffortPartyAssignments:
		return m.clearedassigned_by_work_effort_party_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginMutation) ClearEdge(name string) error {
	switch name {
	case userlogin.EdgeParty:
		m.ClearParty()
		return nil
	case userlogin.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown UserLogin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginMutation) ResetEdge(name string) error {
	switch name {
	case userlogin.EdgeParty:
		m.ResetParty()
		return nil
	case userlogin.EdgePerson:
		m.ResetPerson()
		return nil
	case userlogin.EdgeCreatedByParties:
		m.ResetCreatedByParties()
		return nil
	case userlogin.EdgeLastModifiedByParties:
		m.ResetLastModifiedByParties()
		return nil
	case userlogin.EdgeChangeByPartyStatuses:
		m.ResetChangeByPartyStatuses()
		return nil
	case userlogin.EdgeUserLoginSecurityGroups:
		m.ResetUserLoginSecurityGroups()
		return nil
	case userlogin.EdgeAssignedByWorkEffortPartyAssignments:
		m.ResetAssignedByWorkEffortPartyAssignments()
		return nil
	}
	return fmt.Errorf("unknown UserLogin edge %s", name)
}

// UserLoginSecurityGroupMutation represents an operation that mutates the UserLoginSecurityGroup nodes in the graph.
type UserLoginSecurityGroupMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	from_date                         *time.Time
	thru_date                         *time.Time
	clearedFields                     map[string]struct{}
	user_login                        *int
	cleareduser_login                 bool
	security_group                    *int
	clearedsecurity_group             bool
	security_group_permissions        map[int]struct{}
	removedsecurity_group_permissions map[int]struct{}
	clearedsecurity_group_permissions bool
	done                              bool
	oldValue                          func(context.Context) (*UserLoginSecurityGroup, error)
	predicates                        []predicate.UserLoginSecurityGroup
}

var _ ent.Mutation = (*UserLoginSecurityGroupMutation)(nil)

// userloginsecuritygroupOption allows management of the mutation configuration using functional options.
type userloginsecuritygroupOption func(*UserLoginSecurityGroupMutation)

// newUserLoginSecurityGroupMutation creates new mutation for the UserLoginSecurityGroup entity.
func newUserLoginSecurityGroupMutation(c config, op Op, opts ...userloginsecuritygroupOption) *UserLoginSecurityGroupMutation {
	m := &UserLoginSecurityGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLoginSecurityGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLoginSecurityGroupID sets the ID field of the mutation.
func withUserLoginSecurityGroupID(id int) userloginsecuritygroupOption {
	return func(m *UserLoginSecurityGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLoginSecurityGroup
		)
		m.oldValue = func(ctx context.Context) (*UserLoginSecurityGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLoginSecurityGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLoginSecurityGroup sets the old UserLoginSecurityGroup of the mutation.
func withUserLoginSecurityGroup(node *UserLoginSecurityGroup) userloginsecuritygroupOption {
	return func(m *UserLoginSecurityGroupMutation) {
		m.oldValue = func(context.Context) (*UserLoginSecurityGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLoginSecurityGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLoginSecurityGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserLoginSecurityGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFromDate sets the "from_date" field.
func (m *UserLoginSecurityGroupMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *UserLoginSecurityGroupMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the UserLoginSecurityGroup entity.
// If the UserLoginSecurityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginSecurityGroupMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *UserLoginSecurityGroupMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *UserLoginSecurityGroupMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *UserLoginSecurityGroupMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the UserLoginSecurityGroup entity.
// If the UserLoginSecurityGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLoginSecurityGroupMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *UserLoginSecurityGroupMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[userloginsecuritygroup.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *UserLoginSecurityGroupMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[userloginsecuritygroup.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *UserLoginSecurityGroupMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, userloginsecuritygroup.FieldThruDate)
}

// SetUserLoginID sets the "user_login" edge to the UserLogin entity by id.
func (m *UserLoginSecurityGroupMutation) SetUserLoginID(id int) {
	m.user_login = &id
}

// ClearUserLogin clears the "user_login" edge to the UserLogin entity.
func (m *UserLoginSecurityGroupMutation) ClearUserLogin() {
	m.cleareduser_login = true
}

// UserLoginCleared reports if the "user_login" edge to the UserLogin entity was cleared.
func (m *UserLoginSecurityGroupMutation) UserLoginCleared() bool {
	return m.cleareduser_login
}

// UserLoginID returns the "user_login" edge ID in the mutation.
func (m *UserLoginSecurityGroupMutation) UserLoginID() (id int, exists bool) {
	if m.user_login != nil {
		return *m.user_login, true
	}
	return
}

// UserLoginIDs returns the "user_login" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserLoginID instead. It exists only for internal usage by the builders.
func (m *UserLoginSecurityGroupMutation) UserLoginIDs() (ids []int) {
	if id := m.user_login; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserLogin resets all changes to the "user_login" edge.
func (m *UserLoginSecurityGroupMutation) ResetUserLogin() {
	m.user_login = nil
	m.cleareduser_login = false
}

// SetSecurityGroupID sets the "security_group" edge to the SecurityGroup entity by id.
func (m *UserLoginSecurityGroupMutation) SetSecurityGroupID(id int) {
	m.security_group = &id
}

// ClearSecurityGroup clears the "security_group" edge to the SecurityGroup entity.
func (m *UserLoginSecurityGroupMutation) ClearSecurityGroup() {
	m.clearedsecurity_group = true
}

// SecurityGroupCleared reports if the "security_group" edge to the SecurityGroup entity was cleared.
func (m *UserLoginSecurityGroupMutation) SecurityGroupCleared() bool {
	return m.clearedsecurity_group
}

// SecurityGroupID returns the "security_group" edge ID in the mutation.
func (m *UserLoginSecurityGroupMutation) SecurityGroupID() (id int, exists bool) {
	if m.security_group != nil {
		return *m.security_group, true
	}
	return
}

// SecurityGroupIDs returns the "security_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecurityGroupID instead. It exists only for internal usage by the builders.
func (m *UserLoginSecurityGroupMutation) SecurityGroupIDs() (ids []int) {
	if id := m.security_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecurityGroup resets all changes to the "security_group" edge.
func (m *UserLoginSecurityGroupMutation) ResetSecurityGroup() {
	m.security_group = nil
	m.clearedsecurity_group = false
}

// AddSecurityGroupPermissionIDs adds the "security_group_permissions" edge to the SecurityGroupPermission entity by ids.
func (m *UserLoginSecurityGroupMutation) AddSecurityGroupPermissionIDs(ids ...int) {
	if m.security_group_permissions == nil {
		m.security_group_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.security_group_permissions[ids[i]] = struct{}{}
	}
}

// ClearSecurityGroupPermissions clears the "security_group_permissions" edge to the SecurityGroupPermission entity.
func (m *UserLoginSecurityGroupMutation) ClearSecurityGroupPermissions() {
	m.clearedsecurity_group_permissions = true
}

// SecurityGroupPermissionsCleared reports if the "security_group_permissions" edge to the SecurityGroupPermission entity was cleared.
func (m *UserLoginSecurityGroupMutation) SecurityGroupPermissionsCleared() bool {
	return m.clearedsecurity_group_permissions
}

// RemoveSecurityGroupPermissionIDs removes the "security_group_permissions" edge to the SecurityGroupPermission entity by IDs.
func (m *UserLoginSecurityGroupMutation) RemoveSecurityGroupPermissionIDs(ids ...int) {
	if m.removedsecurity_group_permissions == nil {
		m.removedsecurity_group_permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsecurity_group_permissions[ids[i]] = struct{}{}
	}
}

// RemovedSecurityGroupPermissions returns the removed IDs of the "security_group_permissions" edge to the SecurityGroupPermission entity.
func (m *UserLoginSecurityGroupMutation) RemovedSecurityGroupPermissionsIDs() (ids []int) {
	for id := range m.removedsecurity_group_permissions {
		ids = append(ids, id)
	}
	return
}

// SecurityGroupPermissionsIDs returns the "security_group_permissions" edge IDs in the mutation.
func (m *UserLoginSecurityGroupMutation) SecurityGroupPermissionsIDs() (ids []int) {
	for id := range m.security_group_permissions {
		ids = append(ids, id)
	}
	return
}

// ResetSecurityGroupPermissions resets all changes to the "security_group_permissions" edge.
func (m *UserLoginSecurityGroupMutation) ResetSecurityGroupPermissions() {
	m.security_group_permissions = nil
	m.clearedsecurity_group_permissions = false
	m.removedsecurity_group_permissions = nil
}

// Op returns the operation name.
func (m *UserLoginSecurityGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserLoginSecurityGroup).
func (m *UserLoginSecurityGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLoginSecurityGroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.from_date != nil {
		fields = append(fields, userloginsecuritygroup.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, userloginsecuritygroup.FieldThruDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLoginSecurityGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userloginsecuritygroup.FieldFromDate:
		return m.FromDate()
	case userloginsecuritygroup.FieldThruDate:
		return m.ThruDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLoginSecurityGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userloginsecuritygroup.FieldFromDate:
		return m.OldFromDate(ctx)
	case userloginsecuritygroup.FieldThruDate:
		return m.OldThruDate(ctx)
	}
	return nil, fmt.Errorf("unknown UserLoginSecurityGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginSecurityGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userloginsecuritygroup.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case userloginsecuritygroup.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	}
	return fmt.Errorf("unknown UserLoginSecurityGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLoginSecurityGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLoginSecurityGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLoginSecurityGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLoginSecurityGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLoginSecurityGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userloginsecuritygroup.FieldThruDate) {
		fields = append(fields, userloginsecuritygroup.FieldThruDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLoginSecurityGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLoginSecurityGroupMutation) ClearField(name string) error {
	switch name {
	case userloginsecuritygroup.FieldThruDate:
		m.ClearThruDate()
		return nil
	}
	return fmt.Errorf("unknown UserLoginSecurityGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLoginSecurityGroupMutation) ResetField(name string) error {
	switch name {
	case userloginsecuritygroup.FieldFromDate:
		m.ResetFromDate()
		return nil
	case userloginsecuritygroup.FieldThruDate:
		m.ResetThruDate()
		return nil
	}
	return fmt.Errorf("unknown UserLoginSecurityGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLoginSecurityGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user_login != nil {
		edges = append(edges, userloginsecuritygroup.EdgeUserLogin)
	}
	if m.security_group != nil {
		edges = append(edges, userloginsecuritygroup.EdgeSecurityGroup)
	}
	if m.security_group_permissions != nil {
		edges = append(edges, userloginsecuritygroup.EdgeSecurityGroupPermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLoginSecurityGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userloginsecuritygroup.EdgeUserLogin:
		if id := m.user_login; id != nil {
			return []ent.Value{*id}
		}
	case userloginsecuritygroup.EdgeSecurityGroup:
		if id := m.security_group; id != nil {
			return []ent.Value{*id}
		}
	case userloginsecuritygroup.EdgeSecurityGroupPermissions:
		ids := make([]ent.Value, 0, len(m.security_group_permissions))
		for id := range m.security_group_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLoginSecurityGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsecurity_group_permissions != nil {
		edges = append(edges, userloginsecuritygroup.EdgeSecurityGroupPermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLoginSecurityGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userloginsecuritygroup.EdgeSecurityGroupPermissions:
		ids := make([]ent.Value, 0, len(m.removedsecurity_group_permissions))
		for id := range m.removedsecurity_group_permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLoginSecurityGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser_login {
		edges = append(edges, userloginsecuritygroup.EdgeUserLogin)
	}
	if m.clearedsecurity_group {
		edges = append(edges, userloginsecuritygroup.EdgeSecurityGroup)
	}
	if m.clearedsecurity_group_permissions {
		edges = append(edges, userloginsecuritygroup.EdgeSecurityGroupPermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLoginSecurityGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case userloginsecuritygroup.EdgeUserLogin:
		return m.cleareduser_login
	case userloginsecuritygroup.EdgeSecurityGroup:
		return m.clearedsecurity_group
	case userloginsecuritygroup.EdgeSecurityGroupPermissions:
		return m.clearedsecurity_group_permissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLoginSecurityGroupMutation) ClearEdge(name string) error {
	switch name {
	case userloginsecuritygroup.EdgeUserLogin:
		m.ClearUserLogin()
		return nil
	case userloginsecuritygroup.EdgeSecurityGroup:
		m.ClearSecurityGroup()
		return nil
	}
	return fmt.Errorf("unknown UserLoginSecurityGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLoginSecurityGroupMutation) ResetEdge(name string) error {
	switch name {
	case userloginsecuritygroup.EdgeUserLogin:
		m.ResetUserLogin()
		return nil
	case userloginsecuritygroup.EdgeSecurityGroup:
		m.ResetSecurityGroup()
		return nil
	case userloginsecuritygroup.EdgeSecurityGroupPermissions:
		m.ResetSecurityGroupPermissions()
		return nil
	}
	return fmt.Errorf("unknown UserLoginSecurityGroup edge %s", name)
}

// WorkEffortMutation represents an operation that mutates the WorkEffort nodes in the graph.
type WorkEffortMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	work_effort_type_id                    *int
	addwork_effort_type_id                 *int
	current_status_id                      *int
	addcurrent_status_id                   *int
	last_status_update                     *time.Time
	work_effort_purpose_type_id            *int
	addwork_effort_purpose_type_id         *int
	scope_enum_id                          *int
	addscope_enum_id                       *int
	priority                               *int
	addpriority                            *int
	percent_complete                       *int
	addpercent_complete                    *int
	work_effort_name                       *string
	show_as_enum_id                        *int
	addshow_as_enum_id                     *int
	send_notification_email                *workeffort.SendNotificationEmail
	description                            *string
	location_desc                          *string
	estimated_start_date                   *time.Time
	estimated_completion_date              *time.Time
	actual_start_date                      *time.Time
	actual_completion_date                 *time.Time
	estimated_milli_seconds                *float64
	addestimated_milli_seconds             *float64
	estimated_setup_millis                 *float64
	addestimated_setup_millis              *float64
	estimate_calc_method                   *int
	addestimate_calc_method                *int
	actual_milli_seconds                   *float64
	addactual_milli_seconds                *float64
	actual_setup_millis                    *float64
	addactual_setup_millis                 *float64
	total_milli_seconds_allowed            *float64
	addtotal_milli_seconds_allowed         *float64
	total_money_allowed                    *float64
	addtotal_money_allowed                 *float64
	money_uom_id                           *int
	addmoney_uom_id                        *int
	special_terms                          *string
	time_transparency                      *int
	addtime_transparency                   *int
	universal_id                           *string
	source_reference_id                    *string
	facility_id                            *int
	addfacility_id                         *int
	info_url                               *string
	recurrence_info_id                     *int
	addrecurrence_info_id                  *int
	runtime_data_id                        *int
	addruntime_data_id                     *int
	note_id                                *int
	addnote_id                             *int
	service_loader_name                    *string
	quantity_to_produce                    *float64
	addquantity_to_produce                 *float64
	quantity_produced                      *float64
	addquantity_produced                   *float64
	quantity_rejected                      *float64
	addquantity_rejected                   *float64
	reserv_persons                         *float64
	addreserv_persons                      *float64
	reserv_2_nd_pp_perc                    *float64
	addreserv_2_nd_pp_perc                 *float64
	reserv_nth_pp_perc                     *float64
	addreserv_nth_pp_perc                  *float64
	accommodation_map_id                   *int
	addaccommodation_map_id                *int
	accommodation_spot_id                  *int
	addaccommodation_spot_id               *int
	revision_number                        *int
	addrevision_number                     *int
	created_date                           *time.Time
	created_by_user_login                  *string
	last_modified_date                     *time.Time
	last_modified_by_user_login            *string
	sequence_num                           *int
	addsequence_num                        *int
	clearedFields                          map[string]struct{}
	parent                                 *int
	clearedparent                          bool
	children                               map[int]struct{}
	removedchildren                        map[int]struct{}
	clearedchildren                        bool
	fixed_asset                            *int
	clearedfixed_asset                     bool
	temporal_expression                    *int
	clearedtemporal_expression             bool
	child_work_efforts                     map[int]struct{}
	removedchild_work_efforts              map[int]struct{}
	clearedchild_work_efforts              bool
	from_work_effort_assocs                map[int]struct{}
	removedfrom_work_effort_assocs         map[int]struct{}
	clearedfrom_work_effort_assocs         bool
	to_work_effort_assocs                  map[int]struct{}
	removedto_work_effort_assocs           map[int]struct{}
	clearedto_work_effort_assocs           bool
	work_effort_fixed_asset_assigns        map[int]struct{}
	removedwork_effort_fixed_asset_assigns map[int]struct{}
	clearedwork_effort_fixed_asset_assigns bool
	work_effort_party_assignments          map[int]struct{}
	removedwork_effort_party_assignments   map[int]struct{}
	clearedwork_effort_party_assignments   bool
	done                                   bool
	oldValue                               func(context.Context) (*WorkEffort, error)
	predicates                             []predicate.WorkEffort
}

var _ ent.Mutation = (*WorkEffortMutation)(nil)

// workeffortOption allows management of the mutation configuration using functional options.
type workeffortOption func(*WorkEffortMutation)

// newWorkEffortMutation creates new mutation for the WorkEffort entity.
func newWorkEffortMutation(c config, op Op, opts ...workeffortOption) *WorkEffortMutation {
	m := &WorkEffortMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkEffort,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkEffortID sets the ID field of the mutation.
func withWorkEffortID(id int) workeffortOption {
	return func(m *WorkEffortMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkEffort
		)
		m.oldValue = func(ctx context.Context) (*WorkEffort, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkEffort.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkEffort sets the old WorkEffort of the mutation.
func withWorkEffort(node *WorkEffort) workeffortOption {
	return func(m *WorkEffortMutation) {
		m.oldValue = func(context.Context) (*WorkEffort, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkEffortMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkEffortMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkEffortMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWorkEffortTypeID sets the "work_effort_type_id" field.
func (m *WorkEffortMutation) SetWorkEffortTypeID(i int) {
	m.work_effort_type_id = &i
	m.addwork_effort_type_id = nil
}

// WorkEffortTypeID returns the value of the "work_effort_type_id" field in the mutation.
func (m *WorkEffortMutation) WorkEffortTypeID() (r int, exists bool) {
	v := m.work_effort_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEffortTypeID returns the old "work_effort_type_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldWorkEffortTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkEffortTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkEffortTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEffortTypeID: %w", err)
	}
	return oldValue.WorkEffortTypeID, nil
}

// AddWorkEffortTypeID adds i to the "work_effort_type_id" field.
func (m *WorkEffortMutation) AddWorkEffortTypeID(i int) {
	if m.addwork_effort_type_id != nil {
		*m.addwork_effort_type_id += i
	} else {
		m.addwork_effort_type_id = &i
	}
}

// AddedWorkEffortTypeID returns the value that was added to the "work_effort_type_id" field in this mutation.
func (m *WorkEffortMutation) AddedWorkEffortTypeID() (r int, exists bool) {
	v := m.addwork_effort_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkEffortTypeID clears the value of the "work_effort_type_id" field.
func (m *WorkEffortMutation) ClearWorkEffortTypeID() {
	m.work_effort_type_id = nil
	m.addwork_effort_type_id = nil
	m.clearedFields[workeffort.FieldWorkEffortTypeID] = struct{}{}
}

// WorkEffortTypeIDCleared returns if the "work_effort_type_id" field was cleared in this mutation.
func (m *WorkEffortMutation) WorkEffortTypeIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldWorkEffortTypeID]
	return ok
}

// ResetWorkEffortTypeID resets all changes to the "work_effort_type_id" field.
func (m *WorkEffortMutation) ResetWorkEffortTypeID() {
	m.work_effort_type_id = nil
	m.addwork_effort_type_id = nil
	delete(m.clearedFields, workeffort.FieldWorkEffortTypeID)
}

// SetCurrentStatusID sets the "current_status_id" field.
func (m *WorkEffortMutation) SetCurrentStatusID(i int) {
	m.current_status_id = &i
	m.addcurrent_status_id = nil
}

// CurrentStatusID returns the value of the "current_status_id" field in the mutation.
func (m *WorkEffortMutation) CurrentStatusID() (r int, exists bool) {
	v := m.current_status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStatusID returns the old "current_status_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldCurrentStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrentStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrentStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStatusID: %w", err)
	}
	return oldValue.CurrentStatusID, nil
}

// AddCurrentStatusID adds i to the "current_status_id" field.
func (m *WorkEffortMutation) AddCurrentStatusID(i int) {
	if m.addcurrent_status_id != nil {
		*m.addcurrent_status_id += i
	} else {
		m.addcurrent_status_id = &i
	}
}

// AddedCurrentStatusID returns the value that was added to the "current_status_id" field in this mutation.
func (m *WorkEffortMutation) AddedCurrentStatusID() (r int, exists bool) {
	v := m.addcurrent_status_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentStatusID clears the value of the "current_status_id" field.
func (m *WorkEffortMutation) ClearCurrentStatusID() {
	m.current_status_id = nil
	m.addcurrent_status_id = nil
	m.clearedFields[workeffort.FieldCurrentStatusID] = struct{}{}
}

// CurrentStatusIDCleared returns if the "current_status_id" field was cleared in this mutation.
func (m *WorkEffortMutation) CurrentStatusIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldCurrentStatusID]
	return ok
}

// ResetCurrentStatusID resets all changes to the "current_status_id" field.
func (m *WorkEffortMutation) ResetCurrentStatusID() {
	m.current_status_id = nil
	m.addcurrent_status_id = nil
	delete(m.clearedFields, workeffort.FieldCurrentStatusID)
}

// SetLastStatusUpdate sets the "last_status_update" field.
func (m *WorkEffortMutation) SetLastStatusUpdate(t time.Time) {
	m.last_status_update = &t
}

// LastStatusUpdate returns the value of the "last_status_update" field in the mutation.
func (m *WorkEffortMutation) LastStatusUpdate() (r time.Time, exists bool) {
	v := m.last_status_update
	if v == nil {
		return
	}
	return *v, true
}

// OldLastStatusUpdate returns the old "last_status_update" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldLastStatusUpdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastStatusUpdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastStatusUpdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastStatusUpdate: %w", err)
	}
	return oldValue.LastStatusUpdate, nil
}

// ClearLastStatusUpdate clears the value of the "last_status_update" field.
func (m *WorkEffortMutation) ClearLastStatusUpdate() {
	m.last_status_update = nil
	m.clearedFields[workeffort.FieldLastStatusUpdate] = struct{}{}
}

// LastStatusUpdateCleared returns if the "last_status_update" field was cleared in this mutation.
func (m *WorkEffortMutation) LastStatusUpdateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldLastStatusUpdate]
	return ok
}

// ResetLastStatusUpdate resets all changes to the "last_status_update" field.
func (m *WorkEffortMutation) ResetLastStatusUpdate() {
	m.last_status_update = nil
	delete(m.clearedFields, workeffort.FieldLastStatusUpdate)
}

// SetWorkEffortPurposeTypeID sets the "work_effort_purpose_type_id" field.
func (m *WorkEffortMutation) SetWorkEffortPurposeTypeID(i int) {
	m.work_effort_purpose_type_id = &i
	m.addwork_effort_purpose_type_id = nil
}

// WorkEffortPurposeTypeID returns the value of the "work_effort_purpose_type_id" field in the mutation.
func (m *WorkEffortMutation) WorkEffortPurposeTypeID() (r int, exists bool) {
	v := m.work_effort_purpose_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEffortPurposeTypeID returns the old "work_effort_purpose_type_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldWorkEffortPurposeTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkEffortPurposeTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkEffortPurposeTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEffortPurposeTypeID: %w", err)
	}
	return oldValue.WorkEffortPurposeTypeID, nil
}

// AddWorkEffortPurposeTypeID adds i to the "work_effort_purpose_type_id" field.
func (m *WorkEffortMutation) AddWorkEffortPurposeTypeID(i int) {
	if m.addwork_effort_purpose_type_id != nil {
		*m.addwork_effort_purpose_type_id += i
	} else {
		m.addwork_effort_purpose_type_id = &i
	}
}

// AddedWorkEffortPurposeTypeID returns the value that was added to the "work_effort_purpose_type_id" field in this mutation.
func (m *WorkEffortMutation) AddedWorkEffortPurposeTypeID() (r int, exists bool) {
	v := m.addwork_effort_purpose_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkEffortPurposeTypeID clears the value of the "work_effort_purpose_type_id" field.
func (m *WorkEffortMutation) ClearWorkEffortPurposeTypeID() {
	m.work_effort_purpose_type_id = nil
	m.addwork_effort_purpose_type_id = nil
	m.clearedFields[workeffort.FieldWorkEffortPurposeTypeID] = struct{}{}
}

// WorkEffortPurposeTypeIDCleared returns if the "work_effort_purpose_type_id" field was cleared in this mutation.
func (m *WorkEffortMutation) WorkEffortPurposeTypeIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldWorkEffortPurposeTypeID]
	return ok
}

// ResetWorkEffortPurposeTypeID resets all changes to the "work_effort_purpose_type_id" field.
func (m *WorkEffortMutation) ResetWorkEffortPurposeTypeID() {
	m.work_effort_purpose_type_id = nil
	m.addwork_effort_purpose_type_id = nil
	delete(m.clearedFields, workeffort.FieldWorkEffortPurposeTypeID)
}

// SetScopeEnumID sets the "scope_enum_id" field.
func (m *WorkEffortMutation) SetScopeEnumID(i int) {
	m.scope_enum_id = &i
	m.addscope_enum_id = nil
}

// ScopeEnumID returns the value of the "scope_enum_id" field in the mutation.
func (m *WorkEffortMutation) ScopeEnumID() (r int, exists bool) {
	v := m.scope_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldScopeEnumID returns the old "scope_enum_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldScopeEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScopeEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScopeEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopeEnumID: %w", err)
	}
	return oldValue.ScopeEnumID, nil
}

// AddScopeEnumID adds i to the "scope_enum_id" field.
func (m *WorkEffortMutation) AddScopeEnumID(i int) {
	if m.addscope_enum_id != nil {
		*m.addscope_enum_id += i
	} else {
		m.addscope_enum_id = &i
	}
}

// AddedScopeEnumID returns the value that was added to the "scope_enum_id" field in this mutation.
func (m *WorkEffortMutation) AddedScopeEnumID() (r int, exists bool) {
	v := m.addscope_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearScopeEnumID clears the value of the "scope_enum_id" field.
func (m *WorkEffortMutation) ClearScopeEnumID() {
	m.scope_enum_id = nil
	m.addscope_enum_id = nil
	m.clearedFields[workeffort.FieldScopeEnumID] = struct{}{}
}

// ScopeEnumIDCleared returns if the "scope_enum_id" field was cleared in this mutation.
func (m *WorkEffortMutation) ScopeEnumIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldScopeEnumID]
	return ok
}

// ResetScopeEnumID resets all changes to the "scope_enum_id" field.
func (m *WorkEffortMutation) ResetScopeEnumID() {
	m.scope_enum_id = nil
	m.addscope_enum_id = nil
	delete(m.clearedFields, workeffort.FieldScopeEnumID)
}

// SetPriority sets the "priority" field.
func (m *WorkEffortMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *WorkEffortMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *WorkEffortMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *WorkEffortMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ClearPriority clears the value of the "priority" field.
func (m *WorkEffortMutation) ClearPriority() {
	m.priority = nil
	m.addpriority = nil
	m.clearedFields[workeffort.FieldPriority] = struct{}{}
}

// PriorityCleared returns if the "priority" field was cleared in this mutation.
func (m *WorkEffortMutation) PriorityCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldPriority]
	return ok
}

// ResetPriority resets all changes to the "priority" field.
func (m *WorkEffortMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
	delete(m.clearedFields, workeffort.FieldPriority)
}

// SetPercentComplete sets the "percent_complete" field.
func (m *WorkEffortMutation) SetPercentComplete(i int) {
	m.percent_complete = &i
	m.addpercent_complete = nil
}

// PercentComplete returns the value of the "percent_complete" field in the mutation.
func (m *WorkEffortMutation) PercentComplete() (r int, exists bool) {
	v := m.percent_complete
	if v == nil {
		return
	}
	return *v, true
}

// OldPercentComplete returns the old "percent_complete" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldPercentComplete(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPercentComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPercentComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercentComplete: %w", err)
	}
	return oldValue.PercentComplete, nil
}

// AddPercentComplete adds i to the "percent_complete" field.
func (m *WorkEffortMutation) AddPercentComplete(i int) {
	if m.addpercent_complete != nil {
		*m.addpercent_complete += i
	} else {
		m.addpercent_complete = &i
	}
}

// AddedPercentComplete returns the value that was added to the "percent_complete" field in this mutation.
func (m *WorkEffortMutation) AddedPercentComplete() (r int, exists bool) {
	v := m.addpercent_complete
	if v == nil {
		return
	}
	return *v, true
}

// ClearPercentComplete clears the value of the "percent_complete" field.
func (m *WorkEffortMutation) ClearPercentComplete() {
	m.percent_complete = nil
	m.addpercent_complete = nil
	m.clearedFields[workeffort.FieldPercentComplete] = struct{}{}
}

// PercentCompleteCleared returns if the "percent_complete" field was cleared in this mutation.
func (m *WorkEffortMutation) PercentCompleteCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldPercentComplete]
	return ok
}

// ResetPercentComplete resets all changes to the "percent_complete" field.
func (m *WorkEffortMutation) ResetPercentComplete() {
	m.percent_complete = nil
	m.addpercent_complete = nil
	delete(m.clearedFields, workeffort.FieldPercentComplete)
}

// SetWorkEffortName sets the "work_effort_name" field.
func (m *WorkEffortMutation) SetWorkEffortName(s string) {
	m.work_effort_name = &s
}

// WorkEffortName returns the value of the "work_effort_name" field in the mutation.
func (m *WorkEffortMutation) WorkEffortName() (r string, exists bool) {
	v := m.work_effort_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEffortName returns the old "work_effort_name" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldWorkEffortName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkEffortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkEffortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEffortName: %w", err)
	}
	return oldValue.WorkEffortName, nil
}

// ClearWorkEffortName clears the value of the "work_effort_name" field.
func (m *WorkEffortMutation) ClearWorkEffortName() {
	m.work_effort_name = nil
	m.clearedFields[workeffort.FieldWorkEffortName] = struct{}{}
}

// WorkEffortNameCleared returns if the "work_effort_name" field was cleared in this mutation.
func (m *WorkEffortMutation) WorkEffortNameCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldWorkEffortName]
	return ok
}

// ResetWorkEffortName resets all changes to the "work_effort_name" field.
func (m *WorkEffortMutation) ResetWorkEffortName() {
	m.work_effort_name = nil
	delete(m.clearedFields, workeffort.FieldWorkEffortName)
}

// SetShowAsEnumID sets the "show_as_enum_id" field.
func (m *WorkEffortMutation) SetShowAsEnumID(i int) {
	m.show_as_enum_id = &i
	m.addshow_as_enum_id = nil
}

// ShowAsEnumID returns the value of the "show_as_enum_id" field in the mutation.
func (m *WorkEffortMutation) ShowAsEnumID() (r int, exists bool) {
	v := m.show_as_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAsEnumID returns the old "show_as_enum_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldShowAsEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShowAsEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShowAsEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAsEnumID: %w", err)
	}
	return oldValue.ShowAsEnumID, nil
}

// AddShowAsEnumID adds i to the "show_as_enum_id" field.
func (m *WorkEffortMutation) AddShowAsEnumID(i int) {
	if m.addshow_as_enum_id != nil {
		*m.addshow_as_enum_id += i
	} else {
		m.addshow_as_enum_id = &i
	}
}

// AddedShowAsEnumID returns the value that was added to the "show_as_enum_id" field in this mutation.
func (m *WorkEffortMutation) AddedShowAsEnumID() (r int, exists bool) {
	v := m.addshow_as_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShowAsEnumID clears the value of the "show_as_enum_id" field.
func (m *WorkEffortMutation) ClearShowAsEnumID() {
	m.show_as_enum_id = nil
	m.addshow_as_enum_id = nil
	m.clearedFields[workeffort.FieldShowAsEnumID] = struct{}{}
}

// ShowAsEnumIDCleared returns if the "show_as_enum_id" field was cleared in this mutation.
func (m *WorkEffortMutation) ShowAsEnumIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldShowAsEnumID]
	return ok
}

// ResetShowAsEnumID resets all changes to the "show_as_enum_id" field.
func (m *WorkEffortMutation) ResetShowAsEnumID() {
	m.show_as_enum_id = nil
	m.addshow_as_enum_id = nil
	delete(m.clearedFields, workeffort.FieldShowAsEnumID)
}

// SetSendNotificationEmail sets the "send_notification_email" field.
func (m *WorkEffortMutation) SetSendNotificationEmail(wne workeffort.SendNotificationEmail) {
	m.send_notification_email = &wne
}

// SendNotificationEmail returns the value of the "send_notification_email" field in the mutation.
func (m *WorkEffortMutation) SendNotificationEmail() (r workeffort.SendNotificationEmail, exists bool) {
	v := m.send_notification_email
	if v == nil {
		return
	}
	return *v, true
}

// OldSendNotificationEmail returns the old "send_notification_email" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldSendNotificationEmail(ctx context.Context) (v workeffort.SendNotificationEmail, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSendNotificationEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSendNotificationEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendNotificationEmail: %w", err)
	}
	return oldValue.SendNotificationEmail, nil
}

// ClearSendNotificationEmail clears the value of the "send_notification_email" field.
func (m *WorkEffortMutation) ClearSendNotificationEmail() {
	m.send_notification_email = nil
	m.clearedFields[workeffort.FieldSendNotificationEmail] = struct{}{}
}

// SendNotificationEmailCleared returns if the "send_notification_email" field was cleared in this mutation.
func (m *WorkEffortMutation) SendNotificationEmailCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldSendNotificationEmail]
	return ok
}

// ResetSendNotificationEmail resets all changes to the "send_notification_email" field.
func (m *WorkEffortMutation) ResetSendNotificationEmail() {
	m.send_notification_email = nil
	delete(m.clearedFields, workeffort.FieldSendNotificationEmail)
}

// SetDescription sets the "description" field.
func (m *WorkEffortMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkEffortMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkEffortMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workeffort.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkEffortMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkEffortMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workeffort.FieldDescription)
}

// SetLocationDesc sets the "location_desc" field.
func (m *WorkEffortMutation) SetLocationDesc(s string) {
	m.location_desc = &s
}

// LocationDesc returns the value of the "location_desc" field in the mutation.
func (m *WorkEffortMutation) LocationDesc() (r string, exists bool) {
	v := m.location_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationDesc returns the old "location_desc" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldLocationDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationDesc: %w", err)
	}
	return oldValue.LocationDesc, nil
}

// ClearLocationDesc clears the value of the "location_desc" field.
func (m *WorkEffortMutation) ClearLocationDesc() {
	m.location_desc = nil
	m.clearedFields[workeffort.FieldLocationDesc] = struct{}{}
}

// LocationDescCleared returns if the "location_desc" field was cleared in this mutation.
func (m *WorkEffortMutation) LocationDescCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldLocationDesc]
	return ok
}

// ResetLocationDesc resets all changes to the "location_desc" field.
func (m *WorkEffortMutation) ResetLocationDesc() {
	m.location_desc = nil
	delete(m.clearedFields, workeffort.FieldLocationDesc)
}

// SetEstimatedStartDate sets the "estimated_start_date" field.
func (m *WorkEffortMutation) SetEstimatedStartDate(t time.Time) {
	m.estimated_start_date = &t
}

// EstimatedStartDate returns the value of the "estimated_start_date" field in the mutation.
func (m *WorkEffortMutation) EstimatedStartDate() (r time.Time, exists bool) {
	v := m.estimated_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedStartDate returns the old "estimated_start_date" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldEstimatedStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedStartDate: %w", err)
	}
	return oldValue.EstimatedStartDate, nil
}

// ClearEstimatedStartDate clears the value of the "estimated_start_date" field.
func (m *WorkEffortMutation) ClearEstimatedStartDate() {
	m.estimated_start_date = nil
	m.clearedFields[workeffort.FieldEstimatedStartDate] = struct{}{}
}

// EstimatedStartDateCleared returns if the "estimated_start_date" field was cleared in this mutation.
func (m *WorkEffortMutation) EstimatedStartDateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldEstimatedStartDate]
	return ok
}

// ResetEstimatedStartDate resets all changes to the "estimated_start_date" field.
func (m *WorkEffortMutation) ResetEstimatedStartDate() {
	m.estimated_start_date = nil
	delete(m.clearedFields, workeffort.FieldEstimatedStartDate)
}

// SetEstimatedCompletionDate sets the "estimated_completion_date" field.
func (m *WorkEffortMutation) SetEstimatedCompletionDate(t time.Time) {
	m.estimated_completion_date = &t
}

// EstimatedCompletionDate returns the value of the "estimated_completion_date" field in the mutation.
func (m *WorkEffortMutation) EstimatedCompletionDate() (r time.Time, exists bool) {
	v := m.estimated_completion_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedCompletionDate returns the old "estimated_completion_date" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldEstimatedCompletionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedCompletionDate: %w", err)
	}
	return oldValue.EstimatedCompletionDate, nil
}

// ClearEstimatedCompletionDate clears the value of the "estimated_completion_date" field.
func (m *WorkEffortMutation) ClearEstimatedCompletionDate() {
	m.estimated_completion_date = nil
	m.clearedFields[workeffort.FieldEstimatedCompletionDate] = struct{}{}
}

// EstimatedCompletionDateCleared returns if the "estimated_completion_date" field was cleared in this mutation.
func (m *WorkEffortMutation) EstimatedCompletionDateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldEstimatedCompletionDate]
	return ok
}

// ResetEstimatedCompletionDate resets all changes to the "estimated_completion_date" field.
func (m *WorkEffortMutation) ResetEstimatedCompletionDate() {
	m.estimated_completion_date = nil
	delete(m.clearedFields, workeffort.FieldEstimatedCompletionDate)
}

// SetActualStartDate sets the "actual_start_date" field.
func (m *WorkEffortMutation) SetActualStartDate(t time.Time) {
	m.actual_start_date = &t
}

// ActualStartDate returns the value of the "actual_start_date" field in the mutation.
func (m *WorkEffortMutation) ActualStartDate() (r time.Time, exists bool) {
	v := m.actual_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStartDate returns the old "actual_start_date" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldActualStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActualStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActualStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStartDate: %w", err)
	}
	return oldValue.ActualStartDate, nil
}

// ClearActualStartDate clears the value of the "actual_start_date" field.
func (m *WorkEffortMutation) ClearActualStartDate() {
	m.actual_start_date = nil
	m.clearedFields[workeffort.FieldActualStartDate] = struct{}{}
}

// ActualStartDateCleared returns if the "actual_start_date" field was cleared in this mutation.
func (m *WorkEffortMutation) ActualStartDateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldActualStartDate]
	return ok
}

// ResetActualStartDate resets all changes to the "actual_start_date" field.
func (m *WorkEffortMutation) ResetActualStartDate() {
	m.actual_start_date = nil
	delete(m.clearedFields, workeffort.FieldActualStartDate)
}

// SetActualCompletionDate sets the "actual_completion_date" field.
func (m *WorkEffortMutation) SetActualCompletionDate(t time.Time) {
	m.actual_completion_date = &t
}

// ActualCompletionDate returns the value of the "actual_completion_date" field in the mutation.
func (m *WorkEffortMutation) ActualCompletionDate() (r time.Time, exists bool) {
	v := m.actual_completion_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualCompletionDate returns the old "actual_completion_date" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldActualCompletionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActualCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActualCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualCompletionDate: %w", err)
	}
	return oldValue.ActualCompletionDate, nil
}

// ClearActualCompletionDate clears the value of the "actual_completion_date" field.
func (m *WorkEffortMutation) ClearActualCompletionDate() {
	m.actual_completion_date = nil
	m.clearedFields[workeffort.FieldActualCompletionDate] = struct{}{}
}

// ActualCompletionDateCleared returns if the "actual_completion_date" field was cleared in this mutation.
func (m *WorkEffortMutation) ActualCompletionDateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldActualCompletionDate]
	return ok
}

// ResetActualCompletionDate resets all changes to the "actual_completion_date" field.
func (m *WorkEffortMutation) ResetActualCompletionDate() {
	m.actual_completion_date = nil
	delete(m.clearedFields, workeffort.FieldActualCompletionDate)
}

// SetEstimatedMilliSeconds sets the "estimated_milli_seconds" field.
func (m *WorkEffortMutation) SetEstimatedMilliSeconds(f float64) {
	m.estimated_milli_seconds = &f
	m.addestimated_milli_seconds = nil
}

// EstimatedMilliSeconds returns the value of the "estimated_milli_seconds" field in the mutation.
func (m *WorkEffortMutation) EstimatedMilliSeconds() (r float64, exists bool) {
	v := m.estimated_milli_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedMilliSeconds returns the old "estimated_milli_seconds" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldEstimatedMilliSeconds(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedMilliSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedMilliSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedMilliSeconds: %w", err)
	}
	return oldValue.EstimatedMilliSeconds, nil
}

// AddEstimatedMilliSeconds adds f to the "estimated_milli_seconds" field.
func (m *WorkEffortMutation) AddEstimatedMilliSeconds(f float64) {
	if m.addestimated_milli_seconds != nil {
		*m.addestimated_milli_seconds += f
	} else {
		m.addestimated_milli_seconds = &f
	}
}

// AddedEstimatedMilliSeconds returns the value that was added to the "estimated_milli_seconds" field in this mutation.
func (m *WorkEffortMutation) AddedEstimatedMilliSeconds() (r float64, exists bool) {
	v := m.addestimated_milli_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedMilliSeconds clears the value of the "estimated_milli_seconds" field.
func (m *WorkEffortMutation) ClearEstimatedMilliSeconds() {
	m.estimated_milli_seconds = nil
	m.addestimated_milli_seconds = nil
	m.clearedFields[workeffort.FieldEstimatedMilliSeconds] = struct{}{}
}

// EstimatedMilliSecondsCleared returns if the "estimated_milli_seconds" field was cleared in this mutation.
func (m *WorkEffortMutation) EstimatedMilliSecondsCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldEstimatedMilliSeconds]
	return ok
}

// ResetEstimatedMilliSeconds resets all changes to the "estimated_milli_seconds" field.
func (m *WorkEffortMutation) ResetEstimatedMilliSeconds() {
	m.estimated_milli_seconds = nil
	m.addestimated_milli_seconds = nil
	delete(m.clearedFields, workeffort.FieldEstimatedMilliSeconds)
}

// SetEstimatedSetupMillis sets the "estimated_setup_millis" field.
func (m *WorkEffortMutation) SetEstimatedSetupMillis(f float64) {
	m.estimated_setup_millis = &f
	m.addestimated_setup_millis = nil
}

// EstimatedSetupMillis returns the value of the "estimated_setup_millis" field in the mutation.
func (m *WorkEffortMutation) EstimatedSetupMillis() (r float64, exists bool) {
	v := m.estimated_setup_millis
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedSetupMillis returns the old "estimated_setup_millis" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldEstimatedSetupMillis(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimatedSetupMillis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimatedSetupMillis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedSetupMillis: %w", err)
	}
	return oldValue.EstimatedSetupMillis, nil
}

// AddEstimatedSetupMillis adds f to the "estimated_setup_millis" field.
func (m *WorkEffortMutation) AddEstimatedSetupMillis(f float64) {
	if m.addestimated_setup_millis != nil {
		*m.addestimated_setup_millis += f
	} else {
		m.addestimated_setup_millis = &f
	}
}

// AddedEstimatedSetupMillis returns the value that was added to the "estimated_setup_millis" field in this mutation.
func (m *WorkEffortMutation) AddedEstimatedSetupMillis() (r float64, exists bool) {
	v := m.addestimated_setup_millis
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedSetupMillis clears the value of the "estimated_setup_millis" field.
func (m *WorkEffortMutation) ClearEstimatedSetupMillis() {
	m.estimated_setup_millis = nil
	m.addestimated_setup_millis = nil
	m.clearedFields[workeffort.FieldEstimatedSetupMillis] = struct{}{}
}

// EstimatedSetupMillisCleared returns if the "estimated_setup_millis" field was cleared in this mutation.
func (m *WorkEffortMutation) EstimatedSetupMillisCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldEstimatedSetupMillis]
	return ok
}

// ResetEstimatedSetupMillis resets all changes to the "estimated_setup_millis" field.
func (m *WorkEffortMutation) ResetEstimatedSetupMillis() {
	m.estimated_setup_millis = nil
	m.addestimated_setup_millis = nil
	delete(m.clearedFields, workeffort.FieldEstimatedSetupMillis)
}

// SetEstimateCalcMethod sets the "estimate_calc_method" field.
func (m *WorkEffortMutation) SetEstimateCalcMethod(i int) {
	m.estimate_calc_method = &i
	m.addestimate_calc_method = nil
}

// EstimateCalcMethod returns the value of the "estimate_calc_method" field in the mutation.
func (m *WorkEffortMutation) EstimateCalcMethod() (r int, exists bool) {
	v := m.estimate_calc_method
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimateCalcMethod returns the old "estimate_calc_method" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldEstimateCalcMethod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstimateCalcMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstimateCalcMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimateCalcMethod: %w", err)
	}
	return oldValue.EstimateCalcMethod, nil
}

// AddEstimateCalcMethod adds i to the "estimate_calc_method" field.
func (m *WorkEffortMutation) AddEstimateCalcMethod(i int) {
	if m.addestimate_calc_method != nil {
		*m.addestimate_calc_method += i
	} else {
		m.addestimate_calc_method = &i
	}
}

// AddedEstimateCalcMethod returns the value that was added to the "estimate_calc_method" field in this mutation.
func (m *WorkEffortMutation) AddedEstimateCalcMethod() (r int, exists bool) {
	v := m.addestimate_calc_method
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimateCalcMethod clears the value of the "estimate_calc_method" field.
func (m *WorkEffortMutation) ClearEstimateCalcMethod() {
	m.estimate_calc_method = nil
	m.addestimate_calc_method = nil
	m.clearedFields[workeffort.FieldEstimateCalcMethod] = struct{}{}
}

// EstimateCalcMethodCleared returns if the "estimate_calc_method" field was cleared in this mutation.
func (m *WorkEffortMutation) EstimateCalcMethodCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldEstimateCalcMethod]
	return ok
}

// ResetEstimateCalcMethod resets all changes to the "estimate_calc_method" field.
func (m *WorkEffortMutation) ResetEstimateCalcMethod() {
	m.estimate_calc_method = nil
	m.addestimate_calc_method = nil
	delete(m.clearedFields, workeffort.FieldEstimateCalcMethod)
}

// SetActualMilliSeconds sets the "actual_milli_seconds" field.
func (m *WorkEffortMutation) SetActualMilliSeconds(f float64) {
	m.actual_milli_seconds = &f
	m.addactual_milli_seconds = nil
}

// ActualMilliSeconds returns the value of the "actual_milli_seconds" field in the mutation.
func (m *WorkEffortMutation) ActualMilliSeconds() (r float64, exists bool) {
	v := m.actual_milli_seconds
	if v == nil {
		return
	}
	return *v, true
}

// OldActualMilliSeconds returns the old "actual_milli_seconds" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldActualMilliSeconds(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActualMilliSeconds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActualMilliSeconds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualMilliSeconds: %w", err)
	}
	return oldValue.ActualMilliSeconds, nil
}

// AddActualMilliSeconds adds f to the "actual_milli_seconds" field.
func (m *WorkEffortMutation) AddActualMilliSeconds(f float64) {
	if m.addactual_milli_seconds != nil {
		*m.addactual_milli_seconds += f
	} else {
		m.addactual_milli_seconds = &f
	}
}

// AddedActualMilliSeconds returns the value that was added to the "actual_milli_seconds" field in this mutation.
func (m *WorkEffortMutation) AddedActualMilliSeconds() (r float64, exists bool) {
	v := m.addactual_milli_seconds
	if v == nil {
		return
	}
	return *v, true
}

// ClearActualMilliSeconds clears the value of the "actual_milli_seconds" field.
func (m *WorkEffortMutation) ClearActualMilliSeconds() {
	m.actual_milli_seconds = nil
	m.addactual_milli_seconds = nil
	m.clearedFields[workeffort.FieldActualMilliSeconds] = struct{}{}
}

// ActualMilliSecondsCleared returns if the "actual_milli_seconds" field was cleared in this mutation.
func (m *WorkEffortMutation) ActualMilliSecondsCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldActualMilliSeconds]
	return ok
}

// ResetActualMilliSeconds resets all changes to the "actual_milli_seconds" field.
func (m *WorkEffortMutation) ResetActualMilliSeconds() {
	m.actual_milli_seconds = nil
	m.addactual_milli_seconds = nil
	delete(m.clearedFields, workeffort.FieldActualMilliSeconds)
}

// SetActualSetupMillis sets the "actual_setup_millis" field.
func (m *WorkEffortMutation) SetActualSetupMillis(f float64) {
	m.actual_setup_millis = &f
	m.addactual_setup_millis = nil
}

// ActualSetupMillis returns the value of the "actual_setup_millis" field in the mutation.
func (m *WorkEffortMutation) ActualSetupMillis() (r float64, exists bool) {
	v := m.actual_setup_millis
	if v == nil {
		return
	}
	return *v, true
}

// OldActualSetupMillis returns the old "actual_setup_millis" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldActualSetupMillis(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActualSetupMillis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActualSetupMillis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualSetupMillis: %w", err)
	}
	return oldValue.ActualSetupMillis, nil
}

// AddActualSetupMillis adds f to the "actual_setup_millis" field.
func (m *WorkEffortMutation) AddActualSetupMillis(f float64) {
	if m.addactual_setup_millis != nil {
		*m.addactual_setup_millis += f
	} else {
		m.addactual_setup_millis = &f
	}
}

// AddedActualSetupMillis returns the value that was added to the "actual_setup_millis" field in this mutation.
func (m *WorkEffortMutation) AddedActualSetupMillis() (r float64, exists bool) {
	v := m.addactual_setup_millis
	if v == nil {
		return
	}
	return *v, true
}

// ClearActualSetupMillis clears the value of the "actual_setup_millis" field.
func (m *WorkEffortMutation) ClearActualSetupMillis() {
	m.actual_setup_millis = nil
	m.addactual_setup_millis = nil
	m.clearedFields[workeffort.FieldActualSetupMillis] = struct{}{}
}

// ActualSetupMillisCleared returns if the "actual_setup_millis" field was cleared in this mutation.
func (m *WorkEffortMutation) ActualSetupMillisCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldActualSetupMillis]
	return ok
}

// ResetActualSetupMillis resets all changes to the "actual_setup_millis" field.
func (m *WorkEffortMutation) ResetActualSetupMillis() {
	m.actual_setup_millis = nil
	m.addactual_setup_millis = nil
	delete(m.clearedFields, workeffort.FieldActualSetupMillis)
}

// SetTotalMilliSecondsAllowed sets the "total_milli_seconds_allowed" field.
func (m *WorkEffortMutation) SetTotalMilliSecondsAllowed(f float64) {
	m.total_milli_seconds_allowed = &f
	m.addtotal_milli_seconds_allowed = nil
}

// TotalMilliSecondsAllowed returns the value of the "total_milli_seconds_allowed" field in the mutation.
func (m *WorkEffortMutation) TotalMilliSecondsAllowed() (r float64, exists bool) {
	v := m.total_milli_seconds_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMilliSecondsAllowed returns the old "total_milli_seconds_allowed" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldTotalMilliSecondsAllowed(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalMilliSecondsAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalMilliSecondsAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMilliSecondsAllowed: %w", err)
	}
	return oldValue.TotalMilliSecondsAllowed, nil
}

// AddTotalMilliSecondsAllowed adds f to the "total_milli_seconds_allowed" field.
func (m *WorkEffortMutation) AddTotalMilliSecondsAllowed(f float64) {
	if m.addtotal_milli_seconds_allowed != nil {
		*m.addtotal_milli_seconds_allowed += f
	} else {
		m.addtotal_milli_seconds_allowed = &f
	}
}

// AddedTotalMilliSecondsAllowed returns the value that was added to the "total_milli_seconds_allowed" field in this mutation.
func (m *WorkEffortMutation) AddedTotalMilliSecondsAllowed() (r float64, exists bool) {
	v := m.addtotal_milli_seconds_allowed
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalMilliSecondsAllowed clears the value of the "total_milli_seconds_allowed" field.
func (m *WorkEffortMutation) ClearTotalMilliSecondsAllowed() {
	m.total_milli_seconds_allowed = nil
	m.addtotal_milli_seconds_allowed = nil
	m.clearedFields[workeffort.FieldTotalMilliSecondsAllowed] = struct{}{}
}

// TotalMilliSecondsAllowedCleared returns if the "total_milli_seconds_allowed" field was cleared in this mutation.
func (m *WorkEffortMutation) TotalMilliSecondsAllowedCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldTotalMilliSecondsAllowed]
	return ok
}

// ResetTotalMilliSecondsAllowed resets all changes to the "total_milli_seconds_allowed" field.
func (m *WorkEffortMutation) ResetTotalMilliSecondsAllowed() {
	m.total_milli_seconds_allowed = nil
	m.addtotal_milli_seconds_allowed = nil
	delete(m.clearedFields, workeffort.FieldTotalMilliSecondsAllowed)
}

// SetTotalMoneyAllowed sets the "total_money_allowed" field.
func (m *WorkEffortMutation) SetTotalMoneyAllowed(f float64) {
	m.total_money_allowed = &f
	m.addtotal_money_allowed = nil
}

// TotalMoneyAllowed returns the value of the "total_money_allowed" field in the mutation.
func (m *WorkEffortMutation) TotalMoneyAllowed() (r float64, exists bool) {
	v := m.total_money_allowed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMoneyAllowed returns the old "total_money_allowed" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldTotalMoneyAllowed(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalMoneyAllowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalMoneyAllowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMoneyAllowed: %w", err)
	}
	return oldValue.TotalMoneyAllowed, nil
}

// AddTotalMoneyAllowed adds f to the "total_money_allowed" field.
func (m *WorkEffortMutation) AddTotalMoneyAllowed(f float64) {
	if m.addtotal_money_allowed != nil {
		*m.addtotal_money_allowed += f
	} else {
		m.addtotal_money_allowed = &f
	}
}

// AddedTotalMoneyAllowed returns the value that was added to the "total_money_allowed" field in this mutation.
func (m *WorkEffortMutation) AddedTotalMoneyAllowed() (r float64, exists bool) {
	v := m.addtotal_money_allowed
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalMoneyAllowed clears the value of the "total_money_allowed" field.
func (m *WorkEffortMutation) ClearTotalMoneyAllowed() {
	m.total_money_allowed = nil
	m.addtotal_money_allowed = nil
	m.clearedFields[workeffort.FieldTotalMoneyAllowed] = struct{}{}
}

// TotalMoneyAllowedCleared returns if the "total_money_allowed" field was cleared in this mutation.
func (m *WorkEffortMutation) TotalMoneyAllowedCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldTotalMoneyAllowed]
	return ok
}

// ResetTotalMoneyAllowed resets all changes to the "total_money_allowed" field.
func (m *WorkEffortMutation) ResetTotalMoneyAllowed() {
	m.total_money_allowed = nil
	m.addtotal_money_allowed = nil
	delete(m.clearedFields, workeffort.FieldTotalMoneyAllowed)
}

// SetMoneyUomID sets the "money_uom_id" field.
func (m *WorkEffortMutation) SetMoneyUomID(i int) {
	m.money_uom_id = &i
	m.addmoney_uom_id = nil
}

// MoneyUomID returns the value of the "money_uom_id" field in the mutation.
func (m *WorkEffortMutation) MoneyUomID() (r int, exists bool) {
	v := m.money_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMoneyUomID returns the old "money_uom_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldMoneyUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMoneyUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMoneyUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoneyUomID: %w", err)
	}
	return oldValue.MoneyUomID, nil
}

// AddMoneyUomID adds i to the "money_uom_id" field.
func (m *WorkEffortMutation) AddMoneyUomID(i int) {
	if m.addmoney_uom_id != nil {
		*m.addmoney_uom_id += i
	} else {
		m.addmoney_uom_id = &i
	}
}

// AddedMoneyUomID returns the value that was added to the "money_uom_id" field in this mutation.
func (m *WorkEffortMutation) AddedMoneyUomID() (r int, exists bool) {
	v := m.addmoney_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMoneyUomID clears the value of the "money_uom_id" field.
func (m *WorkEffortMutation) ClearMoneyUomID() {
	m.money_uom_id = nil
	m.addmoney_uom_id = nil
	m.clearedFields[workeffort.FieldMoneyUomID] = struct{}{}
}

// MoneyUomIDCleared returns if the "money_uom_id" field was cleared in this mutation.
func (m *WorkEffortMutation) MoneyUomIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldMoneyUomID]
	return ok
}

// ResetMoneyUomID resets all changes to the "money_uom_id" field.
func (m *WorkEffortMutation) ResetMoneyUomID() {
	m.money_uom_id = nil
	m.addmoney_uom_id = nil
	delete(m.clearedFields, workeffort.FieldMoneyUomID)
}

// SetSpecialTerms sets the "special_terms" field.
func (m *WorkEffortMutation) SetSpecialTerms(s string) {
	m.special_terms = &s
}

// SpecialTerms returns the value of the "special_terms" field in the mutation.
func (m *WorkEffortMutation) SpecialTerms() (r string, exists bool) {
	v := m.special_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialTerms returns the old "special_terms" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldSpecialTerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecialTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecialTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialTerms: %w", err)
	}
	return oldValue.SpecialTerms, nil
}

// ClearSpecialTerms clears the value of the "special_terms" field.
func (m *WorkEffortMutation) ClearSpecialTerms() {
	m.special_terms = nil
	m.clearedFields[workeffort.FieldSpecialTerms] = struct{}{}
}

// SpecialTermsCleared returns if the "special_terms" field was cleared in this mutation.
func (m *WorkEffortMutation) SpecialTermsCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldSpecialTerms]
	return ok
}

// ResetSpecialTerms resets all changes to the "special_terms" field.
func (m *WorkEffortMutation) ResetSpecialTerms() {
	m.special_terms = nil
	delete(m.clearedFields, workeffort.FieldSpecialTerms)
}

// SetTimeTransparency sets the "time_transparency" field.
func (m *WorkEffortMutation) SetTimeTransparency(i int) {
	m.time_transparency = &i
	m.addtime_transparency = nil
}

// TimeTransparency returns the value of the "time_transparency" field in the mutation.
func (m *WorkEffortMutation) TimeTransparency() (r int, exists bool) {
	v := m.time_transparency
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeTransparency returns the old "time_transparency" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldTimeTransparency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeTransparency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeTransparency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeTransparency: %w", err)
	}
	return oldValue.TimeTransparency, nil
}

// AddTimeTransparency adds i to the "time_transparency" field.
func (m *WorkEffortMutation) AddTimeTransparency(i int) {
	if m.addtime_transparency != nil {
		*m.addtime_transparency += i
	} else {
		m.addtime_transparency = &i
	}
}

// AddedTimeTransparency returns the value that was added to the "time_transparency" field in this mutation.
func (m *WorkEffortMutation) AddedTimeTransparency() (r int, exists bool) {
	v := m.addtime_transparency
	if v == nil {
		return
	}
	return *v, true
}

// ClearTimeTransparency clears the value of the "time_transparency" field.
func (m *WorkEffortMutation) ClearTimeTransparency() {
	m.time_transparency = nil
	m.addtime_transparency = nil
	m.clearedFields[workeffort.FieldTimeTransparency] = struct{}{}
}

// TimeTransparencyCleared returns if the "time_transparency" field was cleared in this mutation.
func (m *WorkEffortMutation) TimeTransparencyCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldTimeTransparency]
	return ok
}

// ResetTimeTransparency resets all changes to the "time_transparency" field.
func (m *WorkEffortMutation) ResetTimeTransparency() {
	m.time_transparency = nil
	m.addtime_transparency = nil
	delete(m.clearedFields, workeffort.FieldTimeTransparency)
}

// SetUniversalID sets the "universal_id" field.
func (m *WorkEffortMutation) SetUniversalID(s string) {
	m.universal_id = &s
}

// UniversalID returns the value of the "universal_id" field in the mutation.
func (m *WorkEffortMutation) UniversalID() (r string, exists bool) {
	v := m.universal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUniversalID returns the old "universal_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldUniversalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUniversalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUniversalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniversalID: %w", err)
	}
	return oldValue.UniversalID, nil
}

// ClearUniversalID clears the value of the "universal_id" field.
func (m *WorkEffortMutation) ClearUniversalID() {
	m.universal_id = nil
	m.clearedFields[workeffort.FieldUniversalID] = struct{}{}
}

// UniversalIDCleared returns if the "universal_id" field was cleared in this mutation.
func (m *WorkEffortMutation) UniversalIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldUniversalID]
	return ok
}

// ResetUniversalID resets all changes to the "universal_id" field.
func (m *WorkEffortMutation) ResetUniversalID() {
	m.universal_id = nil
	delete(m.clearedFields, workeffort.FieldUniversalID)
}

// SetSourceReferenceID sets the "source_reference_id" field.
func (m *WorkEffortMutation) SetSourceReferenceID(s string) {
	m.source_reference_id = &s
}

// SourceReferenceID returns the value of the "source_reference_id" field in the mutation.
func (m *WorkEffortMutation) SourceReferenceID() (r string, exists bool) {
	v := m.source_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceReferenceID returns the old "source_reference_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldSourceReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSourceReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSourceReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceReferenceID: %w", err)
	}
	return oldValue.SourceReferenceID, nil
}

// ClearSourceReferenceID clears the value of the "source_reference_id" field.
func (m *WorkEffortMutation) ClearSourceReferenceID() {
	m.source_reference_id = nil
	m.clearedFields[workeffort.FieldSourceReferenceID] = struct{}{}
}

// SourceReferenceIDCleared returns if the "source_reference_id" field was cleared in this mutation.
func (m *WorkEffortMutation) SourceReferenceIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldSourceReferenceID]
	return ok
}

// ResetSourceReferenceID resets all changes to the "source_reference_id" field.
func (m *WorkEffortMutation) ResetSourceReferenceID() {
	m.source_reference_id = nil
	delete(m.clearedFields, workeffort.FieldSourceReferenceID)
}

// SetFacilityID sets the "facility_id" field.
func (m *WorkEffortMutation) SetFacilityID(i int) {
	m.facility_id = &i
	m.addfacility_id = nil
}

// FacilityID returns the value of the "facility_id" field in the mutation.
func (m *WorkEffortMutation) FacilityID() (r int, exists bool) {
	v := m.facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "facility_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// AddFacilityID adds i to the "facility_id" field.
func (m *WorkEffortMutation) AddFacilityID(i int) {
	if m.addfacility_id != nil {
		*m.addfacility_id += i
	} else {
		m.addfacility_id = &i
	}
}

// AddedFacilityID returns the value that was added to the "facility_id" field in this mutation.
func (m *WorkEffortMutation) AddedFacilityID() (r int, exists bool) {
	v := m.addfacility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFacilityID clears the value of the "facility_id" field.
func (m *WorkEffortMutation) ClearFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	m.clearedFields[workeffort.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "facility_id" field was cleared in this mutation.
func (m *WorkEffortMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "facility_id" field.
func (m *WorkEffortMutation) ResetFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	delete(m.clearedFields, workeffort.FieldFacilityID)
}

// SetInfoURL sets the "info_url" field.
func (m *WorkEffortMutation) SetInfoURL(s string) {
	m.info_url = &s
}

// InfoURL returns the value of the "info_url" field in the mutation.
func (m *WorkEffortMutation) InfoURL() (r string, exists bool) {
	v := m.info_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInfoURL returns the old "info_url" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldInfoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfoURL: %w", err)
	}
	return oldValue.InfoURL, nil
}

// ClearInfoURL clears the value of the "info_url" field.
func (m *WorkEffortMutation) ClearInfoURL() {
	m.info_url = nil
	m.clearedFields[workeffort.FieldInfoURL] = struct{}{}
}

// InfoURLCleared returns if the "info_url" field was cleared in this mutation.
func (m *WorkEffortMutation) InfoURLCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldInfoURL]
	return ok
}

// ResetInfoURL resets all changes to the "info_url" field.
func (m *WorkEffortMutation) ResetInfoURL() {
	m.info_url = nil
	delete(m.clearedFields, workeffort.FieldInfoURL)
}

// SetRecurrenceInfoID sets the "recurrence_info_id" field.
func (m *WorkEffortMutation) SetRecurrenceInfoID(i int) {
	m.recurrence_info_id = &i
	m.addrecurrence_info_id = nil
}

// RecurrenceInfoID returns the value of the "recurrence_info_id" field in the mutation.
func (m *WorkEffortMutation) RecurrenceInfoID() (r int, exists bool) {
	v := m.recurrence_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecurrenceInfoID returns the old "recurrence_info_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldRecurrenceInfoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecurrenceInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecurrenceInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecurrenceInfoID: %w", err)
	}
	return oldValue.RecurrenceInfoID, nil
}

// AddRecurrenceInfoID adds i to the "recurrence_info_id" field.
func (m *WorkEffortMutation) AddRecurrenceInfoID(i int) {
	if m.addrecurrence_info_id != nil {
		*m.addrecurrence_info_id += i
	} else {
		m.addrecurrence_info_id = &i
	}
}

// AddedRecurrenceInfoID returns the value that was added to the "recurrence_info_id" field in this mutation.
func (m *WorkEffortMutation) AddedRecurrenceInfoID() (r int, exists bool) {
	v := m.addrecurrence_info_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecurrenceInfoID clears the value of the "recurrence_info_id" field.
func (m *WorkEffortMutation) ClearRecurrenceInfoID() {
	m.recurrence_info_id = nil
	m.addrecurrence_info_id = nil
	m.clearedFields[workeffort.FieldRecurrenceInfoID] = struct{}{}
}

// RecurrenceInfoIDCleared returns if the "recurrence_info_id" field was cleared in this mutation.
func (m *WorkEffortMutation) RecurrenceInfoIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldRecurrenceInfoID]
	return ok
}

// ResetRecurrenceInfoID resets all changes to the "recurrence_info_id" field.
func (m *WorkEffortMutation) ResetRecurrenceInfoID() {
	m.recurrence_info_id = nil
	m.addrecurrence_info_id = nil
	delete(m.clearedFields, workeffort.FieldRecurrenceInfoID)
}

// SetRuntimeDataID sets the "runtime_data_id" field.
func (m *WorkEffortMutation) SetRuntimeDataID(i int) {
	m.runtime_data_id = &i
	m.addruntime_data_id = nil
}

// RuntimeDataID returns the value of the "runtime_data_id" field in the mutation.
func (m *WorkEffortMutation) RuntimeDataID() (r int, exists bool) {
	v := m.runtime_data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRuntimeDataID returns the old "runtime_data_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldRuntimeDataID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRuntimeDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRuntimeDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRuntimeDataID: %w", err)
	}
	return oldValue.RuntimeDataID, nil
}

// AddRuntimeDataID adds i to the "runtime_data_id" field.
func (m *WorkEffortMutation) AddRuntimeDataID(i int) {
	if m.addruntime_data_id != nil {
		*m.addruntime_data_id += i
	} else {
		m.addruntime_data_id = &i
	}
}

// AddedRuntimeDataID returns the value that was added to the "runtime_data_id" field in this mutation.
func (m *WorkEffortMutation) AddedRuntimeDataID() (r int, exists bool) {
	v := m.addruntime_data_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRuntimeDataID clears the value of the "runtime_data_id" field.
func (m *WorkEffortMutation) ClearRuntimeDataID() {
	m.runtime_data_id = nil
	m.addruntime_data_id = nil
	m.clearedFields[workeffort.FieldRuntimeDataID] = struct{}{}
}

// RuntimeDataIDCleared returns if the "runtime_data_id" field was cleared in this mutation.
func (m *WorkEffortMutation) RuntimeDataIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldRuntimeDataID]
	return ok
}

// ResetRuntimeDataID resets all changes to the "runtime_data_id" field.
func (m *WorkEffortMutation) ResetRuntimeDataID() {
	m.runtime_data_id = nil
	m.addruntime_data_id = nil
	delete(m.clearedFields, workeffort.FieldRuntimeDataID)
}

// SetNoteID sets the "note_id" field.
func (m *WorkEffortMutation) SetNoteID(i int) {
	m.note_id = &i
	m.addnote_id = nil
}

// NoteID returns the value of the "note_id" field in the mutation.
func (m *WorkEffortMutation) NoteID() (r int, exists bool) {
	v := m.note_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNoteID returns the old "note_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldNoteID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNoteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNoteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoteID: %w", err)
	}
	return oldValue.NoteID, nil
}

// AddNoteID adds i to the "note_id" field.
func (m *WorkEffortMutation) AddNoteID(i int) {
	if m.addnote_id != nil {
		*m.addnote_id += i
	} else {
		m.addnote_id = &i
	}
}

// AddedNoteID returns the value that was added to the "note_id" field in this mutation.
func (m *WorkEffortMutation) AddedNoteID() (r int, exists bool) {
	v := m.addnote_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearNoteID clears the value of the "note_id" field.
func (m *WorkEffortMutation) ClearNoteID() {
	m.note_id = nil
	m.addnote_id = nil
	m.clearedFields[workeffort.FieldNoteID] = struct{}{}
}

// NoteIDCleared returns if the "note_id" field was cleared in this mutation.
func (m *WorkEffortMutation) NoteIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldNoteID]
	return ok
}

// ResetNoteID resets all changes to the "note_id" field.
func (m *WorkEffortMutation) ResetNoteID() {
	m.note_id = nil
	m.addnote_id = nil
	delete(m.clearedFields, workeffort.FieldNoteID)
}

// SetServiceLoaderName sets the "service_loader_name" field.
func (m *WorkEffortMutation) SetServiceLoaderName(s string) {
	m.service_loader_name = &s
}

// ServiceLoaderName returns the value of the "service_loader_name" field in the mutation.
func (m *WorkEffortMutation) ServiceLoaderName() (r string, exists bool) {
	v := m.service_loader_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceLoaderName returns the old "service_loader_name" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldServiceLoaderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceLoaderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceLoaderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceLoaderName: %w", err)
	}
	return oldValue.ServiceLoaderName, nil
}

// ClearServiceLoaderName clears the value of the "service_loader_name" field.
func (m *WorkEffortMutation) ClearServiceLoaderName() {
	m.service_loader_name = nil
	m.clearedFields[workeffort.FieldServiceLoaderName] = struct{}{}
}

// ServiceLoaderNameCleared returns if the "service_loader_name" field was cleared in this mutation.
func (m *WorkEffortMutation) ServiceLoaderNameCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldServiceLoaderName]
	return ok
}

// ResetServiceLoaderName resets all changes to the "service_loader_name" field.
func (m *WorkEffortMutation) ResetServiceLoaderName() {
	m.service_loader_name = nil
	delete(m.clearedFields, workeffort.FieldServiceLoaderName)
}

// SetQuantityToProduce sets the "quantity_to_produce" field.
func (m *WorkEffortMutation) SetQuantityToProduce(f float64) {
	m.quantity_to_produce = &f
	m.addquantity_to_produce = nil
}

// QuantityToProduce returns the value of the "quantity_to_produce" field in the mutation.
func (m *WorkEffortMutation) QuantityToProduce() (r float64, exists bool) {
	v := m.quantity_to_produce
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityToProduce returns the old "quantity_to_produce" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldQuantityToProduce(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityToProduce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityToProduce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityToProduce: %w", err)
	}
	return oldValue.QuantityToProduce, nil
}

// AddQuantityToProduce adds f to the "quantity_to_produce" field.
func (m *WorkEffortMutation) AddQuantityToProduce(f float64) {
	if m.addquantity_to_produce != nil {
		*m.addquantity_to_produce += f
	} else {
		m.addquantity_to_produce = &f
	}
}

// AddedQuantityToProduce returns the value that was added to the "quantity_to_produce" field in this mutation.
func (m *WorkEffortMutation) AddedQuantityToProduce() (r float64, exists bool) {
	v := m.addquantity_to_produce
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityToProduce clears the value of the "quantity_to_produce" field.
func (m *WorkEffortMutation) ClearQuantityToProduce() {
	m.quantity_to_produce = nil
	m.addquantity_to_produce = nil
	m.clearedFields[workeffort.FieldQuantityToProduce] = struct{}{}
}

// QuantityToProduceCleared returns if the "quantity_to_produce" field was cleared in this mutation.
func (m *WorkEffortMutation) QuantityToProduceCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldQuantityToProduce]
	return ok
}

// ResetQuantityToProduce resets all changes to the "quantity_to_produce" field.
func (m *WorkEffortMutation) ResetQuantityToProduce() {
	m.quantity_to_produce = nil
	m.addquantity_to_produce = nil
	delete(m.clearedFields, workeffort.FieldQuantityToProduce)
}

// SetQuantityProduced sets the "quantity_produced" field.
func (m *WorkEffortMutation) SetQuantityProduced(f float64) {
	m.quantity_produced = &f
	m.addquantity_produced = nil
}

// QuantityProduced returns the value of the "quantity_produced" field in the mutation.
func (m *WorkEffortMutation) QuantityProduced() (r float64, exists bool) {
	v := m.quantity_produced
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityProduced returns the old "quantity_produced" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldQuantityProduced(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityProduced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityProduced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityProduced: %w", err)
	}
	return oldValue.QuantityProduced, nil
}

// AddQuantityProduced adds f to the "quantity_produced" field.
func (m *WorkEffortMutation) AddQuantityProduced(f float64) {
	if m.addquantity_produced != nil {
		*m.addquantity_produced += f
	} else {
		m.addquantity_produced = &f
	}
}

// AddedQuantityProduced returns the value that was added to the "quantity_produced" field in this mutation.
func (m *WorkEffortMutation) AddedQuantityProduced() (r float64, exists bool) {
	v := m.addquantity_produced
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityProduced clears the value of the "quantity_produced" field.
func (m *WorkEffortMutation) ClearQuantityProduced() {
	m.quantity_produced = nil
	m.addquantity_produced = nil
	m.clearedFields[workeffort.FieldQuantityProduced] = struct{}{}
}

// QuantityProducedCleared returns if the "quantity_produced" field was cleared in this mutation.
func (m *WorkEffortMutation) QuantityProducedCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldQuantityProduced]
	return ok
}

// ResetQuantityProduced resets all changes to the "quantity_produced" field.
func (m *WorkEffortMutation) ResetQuantityProduced() {
	m.quantity_produced = nil
	m.addquantity_produced = nil
	delete(m.clearedFields, workeffort.FieldQuantityProduced)
}

// SetQuantityRejected sets the "quantity_rejected" field.
func (m *WorkEffortMutation) SetQuantityRejected(f float64) {
	m.quantity_rejected = &f
	m.addquantity_rejected = nil
}

// QuantityRejected returns the value of the "quantity_rejected" field in the mutation.
func (m *WorkEffortMutation) QuantityRejected() (r float64, exists bool) {
	v := m.quantity_rejected
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityRejected returns the old "quantity_rejected" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldQuantityRejected(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantityRejected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantityRejected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityRejected: %w", err)
	}
	return oldValue.QuantityRejected, nil
}

// AddQuantityRejected adds f to the "quantity_rejected" field.
func (m *WorkEffortMutation) AddQuantityRejected(f float64) {
	if m.addquantity_rejected != nil {
		*m.addquantity_rejected += f
	} else {
		m.addquantity_rejected = &f
	}
}

// AddedQuantityRejected returns the value that was added to the "quantity_rejected" field in this mutation.
func (m *WorkEffortMutation) AddedQuantityRejected() (r float64, exists bool) {
	v := m.addquantity_rejected
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantityRejected clears the value of the "quantity_rejected" field.
func (m *WorkEffortMutation) ClearQuantityRejected() {
	m.quantity_rejected = nil
	m.addquantity_rejected = nil
	m.clearedFields[workeffort.FieldQuantityRejected] = struct{}{}
}

// QuantityRejectedCleared returns if the "quantity_rejected" field was cleared in this mutation.
func (m *WorkEffortMutation) QuantityRejectedCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldQuantityRejected]
	return ok
}

// ResetQuantityRejected resets all changes to the "quantity_rejected" field.
func (m *WorkEffortMutation) ResetQuantityRejected() {
	m.quantity_rejected = nil
	m.addquantity_rejected = nil
	delete(m.clearedFields, workeffort.FieldQuantityRejected)
}

// SetReservPersons sets the "reserv_persons" field.
func (m *WorkEffortMutation) SetReservPersons(f float64) {
	m.reserv_persons = &f
	m.addreserv_persons = nil
}

// ReservPersons returns the value of the "reserv_persons" field in the mutation.
func (m *WorkEffortMutation) ReservPersons() (r float64, exists bool) {
	v := m.reserv_persons
	if v == nil {
		return
	}
	return *v, true
}

// OldReservPersons returns the old "reserv_persons" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldReservPersons(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReservPersons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReservPersons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservPersons: %w", err)
	}
	return oldValue.ReservPersons, nil
}

// AddReservPersons adds f to the "reserv_persons" field.
func (m *WorkEffortMutation) AddReservPersons(f float64) {
	if m.addreserv_persons != nil {
		*m.addreserv_persons += f
	} else {
		m.addreserv_persons = &f
	}
}

// AddedReservPersons returns the value that was added to the "reserv_persons" field in this mutation.
func (m *WorkEffortMutation) AddedReservPersons() (r float64, exists bool) {
	v := m.addreserv_persons
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservPersons clears the value of the "reserv_persons" field.
func (m *WorkEffortMutation) ClearReservPersons() {
	m.reserv_persons = nil
	m.addreserv_persons = nil
	m.clearedFields[workeffort.FieldReservPersons] = struct{}{}
}

// ReservPersonsCleared returns if the "reserv_persons" field was cleared in this mutation.
func (m *WorkEffortMutation) ReservPersonsCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldReservPersons]
	return ok
}

// ResetReservPersons resets all changes to the "reserv_persons" field.
func (m *WorkEffortMutation) ResetReservPersons() {
	m.reserv_persons = nil
	m.addreserv_persons = nil
	delete(m.clearedFields, workeffort.FieldReservPersons)
}

// SetReserv2NdPpPerc sets the "reserv_2_nd_pp_perc" field.
func (m *WorkEffortMutation) SetReserv2NdPpPerc(f float64) {
	m.reserv_2_nd_pp_perc = &f
	m.addreserv_2_nd_pp_perc = nil
}

// Reserv2NdPpPerc returns the value of the "reserv_2_nd_pp_perc" field in the mutation.
func (m *WorkEffortMutation) Reserv2NdPpPerc() (r float64, exists bool) {
	v := m.reserv_2_nd_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// OldReserv2NdPpPerc returns the old "reserv_2_nd_pp_perc" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldReserv2NdPpPerc(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReserv2NdPpPerc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReserv2NdPpPerc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserv2NdPpPerc: %w", err)
	}
	return oldValue.Reserv2NdPpPerc, nil
}

// AddReserv2NdPpPerc adds f to the "reserv_2_nd_pp_perc" field.
func (m *WorkEffortMutation) AddReserv2NdPpPerc(f float64) {
	if m.addreserv_2_nd_pp_perc != nil {
		*m.addreserv_2_nd_pp_perc += f
	} else {
		m.addreserv_2_nd_pp_perc = &f
	}
}

// AddedReserv2NdPpPerc returns the value that was added to the "reserv_2_nd_pp_perc" field in this mutation.
func (m *WorkEffortMutation) AddedReserv2NdPpPerc() (r float64, exists bool) {
	v := m.addreserv_2_nd_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// ClearReserv2NdPpPerc clears the value of the "reserv_2_nd_pp_perc" field.
func (m *WorkEffortMutation) ClearReserv2NdPpPerc() {
	m.reserv_2_nd_pp_perc = nil
	m.addreserv_2_nd_pp_perc = nil
	m.clearedFields[workeffort.FieldReserv2NdPpPerc] = struct{}{}
}

// Reserv2NdPpPercCleared returns if the "reserv_2_nd_pp_perc" field was cleared in this mutation.
func (m *WorkEffortMutation) Reserv2NdPpPercCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldReserv2NdPpPerc]
	return ok
}

// ResetReserv2NdPpPerc resets all changes to the "reserv_2_nd_pp_perc" field.
func (m *WorkEffortMutation) ResetReserv2NdPpPerc() {
	m.reserv_2_nd_pp_perc = nil
	m.addreserv_2_nd_pp_perc = nil
	delete(m.clearedFields, workeffort.FieldReserv2NdPpPerc)
}

// SetReservNthPpPerc sets the "reserv_nth_pp_perc" field.
func (m *WorkEffortMutation) SetReservNthPpPerc(f float64) {
	m.reserv_nth_pp_perc = &f
	m.addreserv_nth_pp_perc = nil
}

// ReservNthPpPerc returns the value of the "reserv_nth_pp_perc" field in the mutation.
func (m *WorkEffortMutation) ReservNthPpPerc() (r float64, exists bool) {
	v := m.reserv_nth_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// OldReservNthPpPerc returns the old "reserv_nth_pp_perc" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldReservNthPpPerc(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReservNthPpPerc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReservNthPpPerc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservNthPpPerc: %w", err)
	}
	return oldValue.ReservNthPpPerc, nil
}

// AddReservNthPpPerc adds f to the "reserv_nth_pp_perc" field.
func (m *WorkEffortMutation) AddReservNthPpPerc(f float64) {
	if m.addreserv_nth_pp_perc != nil {
		*m.addreserv_nth_pp_perc += f
	} else {
		m.addreserv_nth_pp_perc = &f
	}
}

// AddedReservNthPpPerc returns the value that was added to the "reserv_nth_pp_perc" field in this mutation.
func (m *WorkEffortMutation) AddedReservNthPpPerc() (r float64, exists bool) {
	v := m.addreserv_nth_pp_perc
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservNthPpPerc clears the value of the "reserv_nth_pp_perc" field.
func (m *WorkEffortMutation) ClearReservNthPpPerc() {
	m.reserv_nth_pp_perc = nil
	m.addreserv_nth_pp_perc = nil
	m.clearedFields[workeffort.FieldReservNthPpPerc] = struct{}{}
}

// ReservNthPpPercCleared returns if the "reserv_nth_pp_perc" field was cleared in this mutation.
func (m *WorkEffortMutation) ReservNthPpPercCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldReservNthPpPerc]
	return ok
}

// ResetReservNthPpPerc resets all changes to the "reserv_nth_pp_perc" field.
func (m *WorkEffortMutation) ResetReservNthPpPerc() {
	m.reserv_nth_pp_perc = nil
	m.addreserv_nth_pp_perc = nil
	delete(m.clearedFields, workeffort.FieldReservNthPpPerc)
}

// SetAccommodationMapID sets the "accommodation_map_id" field.
func (m *WorkEffortMutation) SetAccommodationMapID(i int) {
	m.accommodation_map_id = &i
	m.addaccommodation_map_id = nil
}

// AccommodationMapID returns the value of the "accommodation_map_id" field in the mutation.
func (m *WorkEffortMutation) AccommodationMapID() (r int, exists bool) {
	v := m.accommodation_map_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccommodationMapID returns the old "accommodation_map_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldAccommodationMapID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccommodationMapID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccommodationMapID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccommodationMapID: %w", err)
	}
	return oldValue.AccommodationMapID, nil
}

// AddAccommodationMapID adds i to the "accommodation_map_id" field.
func (m *WorkEffortMutation) AddAccommodationMapID(i int) {
	if m.addaccommodation_map_id != nil {
		*m.addaccommodation_map_id += i
	} else {
		m.addaccommodation_map_id = &i
	}
}

// AddedAccommodationMapID returns the value that was added to the "accommodation_map_id" field in this mutation.
func (m *WorkEffortMutation) AddedAccommodationMapID() (r int, exists bool) {
	v := m.addaccommodation_map_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccommodationMapID clears the value of the "accommodation_map_id" field.
func (m *WorkEffortMutation) ClearAccommodationMapID() {
	m.accommodation_map_id = nil
	m.addaccommodation_map_id = nil
	m.clearedFields[workeffort.FieldAccommodationMapID] = struct{}{}
}

// AccommodationMapIDCleared returns if the "accommodation_map_id" field was cleared in this mutation.
func (m *WorkEffortMutation) AccommodationMapIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldAccommodationMapID]
	return ok
}

// ResetAccommodationMapID resets all changes to the "accommodation_map_id" field.
func (m *WorkEffortMutation) ResetAccommodationMapID() {
	m.accommodation_map_id = nil
	m.addaccommodation_map_id = nil
	delete(m.clearedFields, workeffort.FieldAccommodationMapID)
}

// SetAccommodationSpotID sets the "accommodation_spot_id" field.
func (m *WorkEffortMutation) SetAccommodationSpotID(i int) {
	m.accommodation_spot_id = &i
	m.addaccommodation_spot_id = nil
}

// AccommodationSpotID returns the value of the "accommodation_spot_id" field in the mutation.
func (m *WorkEffortMutation) AccommodationSpotID() (r int, exists bool) {
	v := m.accommodation_spot_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccommodationSpotID returns the old "accommodation_spot_id" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldAccommodationSpotID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccommodationSpotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccommodationSpotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccommodationSpotID: %w", err)
	}
	return oldValue.AccommodationSpotID, nil
}

// AddAccommodationSpotID adds i to the "accommodation_spot_id" field.
func (m *WorkEffortMutation) AddAccommodationSpotID(i int) {
	if m.addaccommodation_spot_id != nil {
		*m.addaccommodation_spot_id += i
	} else {
		m.addaccommodation_spot_id = &i
	}
}

// AddedAccommodationSpotID returns the value that was added to the "accommodation_spot_id" field in this mutation.
func (m *WorkEffortMutation) AddedAccommodationSpotID() (r int, exists bool) {
	v := m.addaccommodation_spot_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccommodationSpotID clears the value of the "accommodation_spot_id" field.
func (m *WorkEffortMutation) ClearAccommodationSpotID() {
	m.accommodation_spot_id = nil
	m.addaccommodation_spot_id = nil
	m.clearedFields[workeffort.FieldAccommodationSpotID] = struct{}{}
}

// AccommodationSpotIDCleared returns if the "accommodation_spot_id" field was cleared in this mutation.
func (m *WorkEffortMutation) AccommodationSpotIDCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldAccommodationSpotID]
	return ok
}

// ResetAccommodationSpotID resets all changes to the "accommodation_spot_id" field.
func (m *WorkEffortMutation) ResetAccommodationSpotID() {
	m.accommodation_spot_id = nil
	m.addaccommodation_spot_id = nil
	delete(m.clearedFields, workeffort.FieldAccommodationSpotID)
}

// SetRevisionNumber sets the "revision_number" field.
func (m *WorkEffortMutation) SetRevisionNumber(i int) {
	m.revision_number = &i
	m.addrevision_number = nil
}

// RevisionNumber returns the value of the "revision_number" field in the mutation.
func (m *WorkEffortMutation) RevisionNumber() (r int, exists bool) {
	v := m.revision_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRevisionNumber returns the old "revision_number" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldRevisionNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevisionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevisionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevisionNumber: %w", err)
	}
	return oldValue.RevisionNumber, nil
}

// AddRevisionNumber adds i to the "revision_number" field.
func (m *WorkEffortMutation) AddRevisionNumber(i int) {
	if m.addrevision_number != nil {
		*m.addrevision_number += i
	} else {
		m.addrevision_number = &i
	}
}

// AddedRevisionNumber returns the value that was added to the "revision_number" field in this mutation.
func (m *WorkEffortMutation) AddedRevisionNumber() (r int, exists bool) {
	v := m.addrevision_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevisionNumber clears the value of the "revision_number" field.
func (m *WorkEffortMutation) ClearRevisionNumber() {
	m.revision_number = nil
	m.addrevision_number = nil
	m.clearedFields[workeffort.FieldRevisionNumber] = struct{}{}
}

// RevisionNumberCleared returns if the "revision_number" field was cleared in this mutation.
func (m *WorkEffortMutation) RevisionNumberCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldRevisionNumber]
	return ok
}

// ResetRevisionNumber resets all changes to the "revision_number" field.
func (m *WorkEffortMutation) ResetRevisionNumber() {
	m.revision_number = nil
	m.addrevision_number = nil
	delete(m.clearedFields, workeffort.FieldRevisionNumber)
}

// SetCreatedDate sets the "created_date" field.
func (m *WorkEffortMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *WorkEffortMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ClearCreatedDate clears the value of the "created_date" field.
func (m *WorkEffortMutation) ClearCreatedDate() {
	m.created_date = nil
	m.clearedFields[workeffort.FieldCreatedDate] = struct{}{}
}

// CreatedDateCleared returns if the "created_date" field was cleared in this mutation.
func (m *WorkEffortMutation) CreatedDateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldCreatedDate]
	return ok
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *WorkEffortMutation) ResetCreatedDate() {
	m.created_date = nil
	delete(m.clearedFields, workeffort.FieldCreatedDate)
}

// SetCreatedByUserLogin sets the "created_by_user_login" field.
func (m *WorkEffortMutation) SetCreatedByUserLogin(s string) {
	m.created_by_user_login = &s
}

// CreatedByUserLogin returns the value of the "created_by_user_login" field in the mutation.
func (m *WorkEffortMutation) CreatedByUserLogin() (r string, exists bool) {
	v := m.created_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByUserLogin returns the old "created_by_user_login" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldCreatedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByUserLogin: %w", err)
	}
	return oldValue.CreatedByUserLogin, nil
}

// ClearCreatedByUserLogin clears the value of the "created_by_user_login" field.
func (m *WorkEffortMutation) ClearCreatedByUserLogin() {
	m.created_by_user_login = nil
	m.clearedFields[workeffort.FieldCreatedByUserLogin] = struct{}{}
}

// CreatedByUserLoginCleared returns if the "created_by_user_login" field was cleared in this mutation.
func (m *WorkEffortMutation) CreatedByUserLoginCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldCreatedByUserLogin]
	return ok
}

// ResetCreatedByUserLogin resets all changes to the "created_by_user_login" field.
func (m *WorkEffortMutation) ResetCreatedByUserLogin() {
	m.created_by_user_login = nil
	delete(m.clearedFields, workeffort.FieldCreatedByUserLogin)
}

// SetLastModifiedDate sets the "last_modified_date" field.
func (m *WorkEffortMutation) SetLastModifiedDate(t time.Time) {
	m.last_modified_date = &t
}

// LastModifiedDate returns the value of the "last_modified_date" field in the mutation.
func (m *WorkEffortMutation) LastModifiedDate() (r time.Time, exists bool) {
	v := m.last_modified_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedDate returns the old "last_modified_date" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldLastModifiedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedDate: %w", err)
	}
	return oldValue.LastModifiedDate, nil
}

// ClearLastModifiedDate clears the value of the "last_modified_date" field.
func (m *WorkEffortMutation) ClearLastModifiedDate() {
	m.last_modified_date = nil
	m.clearedFields[workeffort.FieldLastModifiedDate] = struct{}{}
}

// LastModifiedDateCleared returns if the "last_modified_date" field was cleared in this mutation.
func (m *WorkEffortMutation) LastModifiedDateCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldLastModifiedDate]
	return ok
}

// ResetLastModifiedDate resets all changes to the "last_modified_date" field.
func (m *WorkEffortMutation) ResetLastModifiedDate() {
	m.last_modified_date = nil
	delete(m.clearedFields, workeffort.FieldLastModifiedDate)
}

// SetLastModifiedByUserLogin sets the "last_modified_by_user_login" field.
func (m *WorkEffortMutation) SetLastModifiedByUserLogin(s string) {
	m.last_modified_by_user_login = &s
}

// LastModifiedByUserLogin returns the value of the "last_modified_by_user_login" field in the mutation.
func (m *WorkEffortMutation) LastModifiedByUserLogin() (r string, exists bool) {
	v := m.last_modified_by_user_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifiedByUserLogin returns the old "last_modified_by_user_login" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldLastModifiedByUserLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastModifiedByUserLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastModifiedByUserLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifiedByUserLogin: %w", err)
	}
	return oldValue.LastModifiedByUserLogin, nil
}

// ClearLastModifiedByUserLogin clears the value of the "last_modified_by_user_login" field.
func (m *WorkEffortMutation) ClearLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	m.clearedFields[workeffort.FieldLastModifiedByUserLogin] = struct{}{}
}

// LastModifiedByUserLoginCleared returns if the "last_modified_by_user_login" field was cleared in this mutation.
func (m *WorkEffortMutation) LastModifiedByUserLoginCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldLastModifiedByUserLogin]
	return ok
}

// ResetLastModifiedByUserLogin resets all changes to the "last_modified_by_user_login" field.
func (m *WorkEffortMutation) ResetLastModifiedByUserLogin() {
	m.last_modified_by_user_login = nil
	delete(m.clearedFields, workeffort.FieldLastModifiedByUserLogin)
}

// SetSequenceNum sets the "sequence_num" field.
func (m *WorkEffortMutation) SetSequenceNum(i int) {
	m.sequence_num = &i
	m.addsequence_num = nil
}

// SequenceNum returns the value of the "sequence_num" field in the mutation.
func (m *WorkEffortMutation) SequenceNum() (r int, exists bool) {
	v := m.sequence_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNum returns the old "sequence_num" field's value of the WorkEffort entity.
// If the WorkEffort object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortMutation) OldSequenceNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNum: %w", err)
	}
	return oldValue.SequenceNum, nil
}

// AddSequenceNum adds i to the "sequence_num" field.
func (m *WorkEffortMutation) AddSequenceNum(i int) {
	if m.addsequence_num != nil {
		*m.addsequence_num += i
	} else {
		m.addsequence_num = &i
	}
}

// AddedSequenceNum returns the value that was added to the "sequence_num" field in this mutation.
func (m *WorkEffortMutation) AddedSequenceNum() (r int, exists bool) {
	v := m.addsequence_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNum clears the value of the "sequence_num" field.
func (m *WorkEffortMutation) ClearSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	m.clearedFields[workeffort.FieldSequenceNum] = struct{}{}
}

// SequenceNumCleared returns if the "sequence_num" field was cleared in this mutation.
func (m *WorkEffortMutation) SequenceNumCleared() bool {
	_, ok := m.clearedFields[workeffort.FieldSequenceNum]
	return ok
}

// ResetSequenceNum resets all changes to the "sequence_num" field.
func (m *WorkEffortMutation) ResetSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	delete(m.clearedFields, workeffort.FieldSequenceNum)
}

// SetParentID sets the "parent" edge to the WorkEffort entity by id.
func (m *WorkEffortMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the WorkEffort entity.
func (m *WorkEffortMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the WorkEffort entity was cleared.
func (m *WorkEffortMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *WorkEffortMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *WorkEffortMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *WorkEffortMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the WorkEffort entity by ids.
func (m *WorkEffortMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the WorkEffort entity.
func (m *WorkEffortMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the WorkEffort entity was cleared.
func (m *WorkEffortMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the WorkEffort entity by IDs.
func (m *WorkEffortMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the WorkEffort entity.
func (m *WorkEffortMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *WorkEffortMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *WorkEffortMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetFixedAssetID sets the "fixed_asset" edge to the FixedAsset entity by id.
func (m *WorkEffortMutation) SetFixedAssetID(id int) {
	m.fixed_asset = &id
}

// ClearFixedAsset clears the "fixed_asset" edge to the FixedAsset entity.
func (m *WorkEffortMutation) ClearFixedAsset() {
	m.clearedfixed_asset = true
}

// FixedAssetCleared reports if the "fixed_asset" edge to the FixedAsset entity was cleared.
func (m *WorkEffortMutation) FixedAssetCleared() bool {
	return m.clearedfixed_asset
}

// FixedAssetID returns the "fixed_asset" edge ID in the mutation.
func (m *WorkEffortMutation) FixedAssetID() (id int, exists bool) {
	if m.fixed_asset != nil {
		return *m.fixed_asset, true
	}
	return
}

// FixedAssetIDs returns the "fixed_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FixedAssetID instead. It exists only for internal usage by the builders.
func (m *WorkEffortMutation) FixedAssetIDs() (ids []int) {
	if id := m.fixed_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFixedAsset resets all changes to the "fixed_asset" edge.
func (m *WorkEffortMutation) ResetFixedAsset() {
	m.fixed_asset = nil
	m.clearedfixed_asset = false
}

// SetTemporalExpressionID sets the "temporal_expression" edge to the TemporalExpression entity by id.
func (m *WorkEffortMutation) SetTemporalExpressionID(id int) {
	m.temporal_expression = &id
}

// ClearTemporalExpression clears the "temporal_expression" edge to the TemporalExpression entity.
func (m *WorkEffortMutation) ClearTemporalExpression() {
	m.clearedtemporal_expression = true
}

// TemporalExpressionCleared reports if the "temporal_expression" edge to the TemporalExpression entity was cleared.
func (m *WorkEffortMutation) TemporalExpressionCleared() bool {
	return m.clearedtemporal_expression
}

// TemporalExpressionID returns the "temporal_expression" edge ID in the mutation.
func (m *WorkEffortMutation) TemporalExpressionID() (id int, exists bool) {
	if m.temporal_expression != nil {
		return *m.temporal_expression, true
	}
	return
}

// TemporalExpressionIDs returns the "temporal_expression" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemporalExpressionID instead. It exists only for internal usage by the builders.
func (m *WorkEffortMutation) TemporalExpressionIDs() (ids []int) {
	if id := m.temporal_expression; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemporalExpression resets all changes to the "temporal_expression" edge.
func (m *WorkEffortMutation) ResetTemporalExpression() {
	m.temporal_expression = nil
	m.clearedtemporal_expression = false
}

// AddChildWorkEffortIDs adds the "child_work_efforts" edge to the WorkEffort entity by ids.
func (m *WorkEffortMutation) AddChildWorkEffortIDs(ids ...int) {
	if m.child_work_efforts == nil {
		m.child_work_efforts = make(map[int]struct{})
	}
	for i := range ids {
		m.child_work_efforts[ids[i]] = struct{}{}
	}
}

// ClearChildWorkEfforts clears the "child_work_efforts" edge to the WorkEffort entity.
func (m *WorkEffortMutation) ClearChildWorkEfforts() {
	m.clearedchild_work_efforts = true
}

// ChildWorkEffortsCleared reports if the "child_work_efforts" edge to the WorkEffort entity was cleared.
func (m *WorkEffortMutation) ChildWorkEffortsCleared() bool {
	return m.clearedchild_work_efforts
}

// RemoveChildWorkEffortIDs removes the "child_work_efforts" edge to the WorkEffort entity by IDs.
func (m *WorkEffortMutation) RemoveChildWorkEffortIDs(ids ...int) {
	if m.removedchild_work_efforts == nil {
		m.removedchild_work_efforts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchild_work_efforts[ids[i]] = struct{}{}
	}
}

// RemovedChildWorkEfforts returns the removed IDs of the "child_work_efforts" edge to the WorkEffort entity.
func (m *WorkEffortMutation) RemovedChildWorkEffortsIDs() (ids []int) {
	for id := range m.removedchild_work_efforts {
		ids = append(ids, id)
	}
	return
}

// ChildWorkEffortsIDs returns the "child_work_efforts" edge IDs in the mutation.
func (m *WorkEffortMutation) ChildWorkEffortsIDs() (ids []int) {
	for id := range m.child_work_efforts {
		ids = append(ids, id)
	}
	return
}

// ResetChildWorkEfforts resets all changes to the "child_work_efforts" edge.
func (m *WorkEffortMutation) ResetChildWorkEfforts() {
	m.child_work_efforts = nil
	m.clearedchild_work_efforts = false
	m.removedchild_work_efforts = nil
}

// AddFromWorkEffortAssocIDs adds the "from_work_effort_assocs" edge to the WorkEffortAssoc entity by ids.
func (m *WorkEffortMutation) AddFromWorkEffortAssocIDs(ids ...int) {
	if m.from_work_effort_assocs == nil {
		m.from_work_effort_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.from_work_effort_assocs[ids[i]] = struct{}{}
	}
}

// ClearFromWorkEffortAssocs clears the "from_work_effort_assocs" edge to the WorkEffortAssoc entity.
func (m *WorkEffortMutation) ClearFromWorkEffortAssocs() {
	m.clearedfrom_work_effort_assocs = true
}

// FromWorkEffortAssocsCleared reports if the "from_work_effort_assocs" edge to the WorkEffortAssoc entity was cleared.
func (m *WorkEffortMutation) FromWorkEffortAssocsCleared() bool {
	return m.clearedfrom_work_effort_assocs
}

// RemoveFromWorkEffortAssocIDs removes the "from_work_effort_assocs" edge to the WorkEffortAssoc entity by IDs.
func (m *WorkEffortMutation) RemoveFromWorkEffortAssocIDs(ids ...int) {
	if m.removedfrom_work_effort_assocs == nil {
		m.removedfrom_work_effort_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfrom_work_effort_assocs[ids[i]] = struct{}{}
	}
}

// RemovedFromWorkEffortAssocs returns the removed IDs of the "from_work_effort_assocs" edge to the WorkEffortAssoc entity.
func (m *WorkEffortMutation) RemovedFromWorkEffortAssocsIDs() (ids []int) {
	for id := range m.removedfrom_work_effort_assocs {
		ids = append(ids, id)
	}
	return
}

// FromWorkEffortAssocsIDs returns the "from_work_effort_assocs" edge IDs in the mutation.
func (m *WorkEffortMutation) FromWorkEffortAssocsIDs() (ids []int) {
	for id := range m.from_work_effort_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetFromWorkEffortAssocs resets all changes to the "from_work_effort_assocs" edge.
func (m *WorkEffortMutation) ResetFromWorkEffortAssocs() {
	m.from_work_effort_assocs = nil
	m.clearedfrom_work_effort_assocs = false
	m.removedfrom_work_effort_assocs = nil
}

// AddToWorkEffortAssocIDs adds the "to_work_effort_assocs" edge to the WorkEffortAssoc entity by ids.
func (m *WorkEffortMutation) AddToWorkEffortAssocIDs(ids ...int) {
	if m.to_work_effort_assocs == nil {
		m.to_work_effort_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.to_work_effort_assocs[ids[i]] = struct{}{}
	}
}

// ClearToWorkEffortAssocs clears the "to_work_effort_assocs" edge to the WorkEffortAssoc entity.
func (m *WorkEffortMutation) ClearToWorkEffortAssocs() {
	m.clearedto_work_effort_assocs = true
}

// ToWorkEffortAssocsCleared reports if the "to_work_effort_assocs" edge to the WorkEffortAssoc entity was cleared.
func (m *WorkEffortMutation) ToWorkEffortAssocsCleared() bool {
	return m.clearedto_work_effort_assocs
}

// RemoveToWorkEffortAssocIDs removes the "to_work_effort_assocs" edge to the WorkEffortAssoc entity by IDs.
func (m *WorkEffortMutation) RemoveToWorkEffortAssocIDs(ids ...int) {
	if m.removedto_work_effort_assocs == nil {
		m.removedto_work_effort_assocs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedto_work_effort_assocs[ids[i]] = struct{}{}
	}
}

// RemovedToWorkEffortAssocs returns the removed IDs of the "to_work_effort_assocs" edge to the WorkEffortAssoc entity.
func (m *WorkEffortMutation) RemovedToWorkEffortAssocsIDs() (ids []int) {
	for id := range m.removedto_work_effort_assocs {
		ids = append(ids, id)
	}
	return
}

// ToWorkEffortAssocsIDs returns the "to_work_effort_assocs" edge IDs in the mutation.
func (m *WorkEffortMutation) ToWorkEffortAssocsIDs() (ids []int) {
	for id := range m.to_work_effort_assocs {
		ids = append(ids, id)
	}
	return
}

// ResetToWorkEffortAssocs resets all changes to the "to_work_effort_assocs" edge.
func (m *WorkEffortMutation) ResetToWorkEffortAssocs() {
	m.to_work_effort_assocs = nil
	m.clearedto_work_effort_assocs = false
	m.removedto_work_effort_assocs = nil
}

// AddWorkEffortFixedAssetAssignIDs adds the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity by ids.
func (m *WorkEffortMutation) AddWorkEffortFixedAssetAssignIDs(ids ...int) {
	if m.work_effort_fixed_asset_assigns == nil {
		m.work_effort_fixed_asset_assigns = make(map[int]struct{})
	}
	for i := range ids {
		m.work_effort_fixed_asset_assigns[ids[i]] = struct{}{}
	}
}

// ClearWorkEffortFixedAssetAssigns clears the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity.
func (m *WorkEffortMutation) ClearWorkEffortFixedAssetAssigns() {
	m.clearedwork_effort_fixed_asset_assigns = true
}

// WorkEffortFixedAssetAssignsCleared reports if the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity was cleared.
func (m *WorkEffortMutation) WorkEffortFixedAssetAssignsCleared() bool {
	return m.clearedwork_effort_fixed_asset_assigns
}

// RemoveWorkEffortFixedAssetAssignIDs removes the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity by IDs.
func (m *WorkEffortMutation) RemoveWorkEffortFixedAssetAssignIDs(ids ...int) {
	if m.removedwork_effort_fixed_asset_assigns == nil {
		m.removedwork_effort_fixed_asset_assigns = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_effort_fixed_asset_assigns[ids[i]] = struct{}{}
	}
}

// RemovedWorkEffortFixedAssetAssigns returns the removed IDs of the "work_effort_fixed_asset_assigns" edge to the WorkEffortFixedAssetAssign entity.
func (m *WorkEffortMutation) RemovedWorkEffortFixedAssetAssignsIDs() (ids []int) {
	for id := range m.removedwork_effort_fixed_asset_assigns {
		ids = append(ids, id)
	}
	return
}

// WorkEffortFixedAssetAssignsIDs returns the "work_effort_fixed_asset_assigns" edge IDs in the mutation.
func (m *WorkEffortMutation) WorkEffortFixedAssetAssignsIDs() (ids []int) {
	for id := range m.work_effort_fixed_asset_assigns {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEffortFixedAssetAssigns resets all changes to the "work_effort_fixed_asset_assigns" edge.
func (m *WorkEffortMutation) ResetWorkEffortFixedAssetAssigns() {
	m.work_effort_fixed_asset_assigns = nil
	m.clearedwork_effort_fixed_asset_assigns = false
	m.removedwork_effort_fixed_asset_assigns = nil
}

// AddWorkEffortPartyAssignmentIDs adds the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by ids.
func (m *WorkEffortMutation) AddWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.work_effort_party_assignments == nil {
		m.work_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.work_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// ClearWorkEffortPartyAssignments clears the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *WorkEffortMutation) ClearWorkEffortPartyAssignments() {
	m.clearedwork_effort_party_assignments = true
}

// WorkEffortPartyAssignmentsCleared reports if the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity was cleared.
func (m *WorkEffortMutation) WorkEffortPartyAssignmentsCleared() bool {
	return m.clearedwork_effort_party_assignments
}

// RemoveWorkEffortPartyAssignmentIDs removes the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity by IDs.
func (m *WorkEffortMutation) RemoveWorkEffortPartyAssignmentIDs(ids ...int) {
	if m.removedwork_effort_party_assignments == nil {
		m.removedwork_effort_party_assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwork_effort_party_assignments[ids[i]] = struct{}{}
	}
}

// RemovedWorkEffortPartyAssignments returns the removed IDs of the "work_effort_party_assignments" edge to the WorkEffortPartyAssignment entity.
func (m *WorkEffortMutation) RemovedWorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.removedwork_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// WorkEffortPartyAssignmentsIDs returns the "work_effort_party_assignments" edge IDs in the mutation.
func (m *WorkEffortMutation) WorkEffortPartyAssignmentsIDs() (ids []int) {
	for id := range m.work_effort_party_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetWorkEffortPartyAssignments resets all changes to the "work_effort_party_assignments" edge.
func (m *WorkEffortMutation) ResetWorkEffortPartyAssignments() {
	m.work_effort_party_assignments = nil
	m.clearedwork_effort_party_assignments = false
	m.removedwork_effort_party_assignments = nil
}

// Op returns the operation name.
func (m *WorkEffortMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkEffort).
func (m *WorkEffortMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkEffortMutation) Fields() []string {
	fields := make([]string, 0, 48)
	if m.work_effort_type_id != nil {
		fields = append(fields, workeffort.FieldWorkEffortTypeID)
	}
	if m.current_status_id != nil {
		fields = append(fields, workeffort.FieldCurrentStatusID)
	}
	if m.last_status_update != nil {
		fields = append(fields, workeffort.FieldLastStatusUpdate)
	}
	if m.work_effort_purpose_type_id != nil {
		fields = append(fields, workeffort.FieldWorkEffortPurposeTypeID)
	}
	if m.scope_enum_id != nil {
		fields = append(fields, workeffort.FieldScopeEnumID)
	}
	if m.priority != nil {
		fields = append(fields, workeffort.FieldPriority)
	}
	if m.percent_complete != nil {
		fields = append(fields, workeffort.FieldPercentComplete)
	}
	if m.work_effort_name != nil {
		fields = append(fields, workeffort.FieldWorkEffortName)
	}
	if m.show_as_enum_id != nil {
		fields = append(fields, workeffort.FieldShowAsEnumID)
	}
	if m.send_notification_email != nil {
		fields = append(fields, workeffort.FieldSendNotificationEmail)
	}
	if m.description != nil {
		fields = append(fields, workeffort.FieldDescription)
	}
	if m.location_desc != nil {
		fields = append(fields, workeffort.FieldLocationDesc)
	}
	if m.estimated_start_date != nil {
		fields = append(fields, workeffort.FieldEstimatedStartDate)
	}
	if m.estimated_completion_date != nil {
		fields = append(fields, workeffort.FieldEstimatedCompletionDate)
	}
	if m.actual_start_date != nil {
		fields = append(fields, workeffort.FieldActualStartDate)
	}
	if m.actual_completion_date != nil {
		fields = append(fields, workeffort.FieldActualCompletionDate)
	}
	if m.estimated_milli_seconds != nil {
		fields = append(fields, workeffort.FieldEstimatedMilliSeconds)
	}
	if m.estimated_setup_millis != nil {
		fields = append(fields, workeffort.FieldEstimatedSetupMillis)
	}
	if m.estimate_calc_method != nil {
		fields = append(fields, workeffort.FieldEstimateCalcMethod)
	}
	if m.actual_milli_seconds != nil {
		fields = append(fields, workeffort.FieldActualMilliSeconds)
	}
	if m.actual_setup_millis != nil {
		fields = append(fields, workeffort.FieldActualSetupMillis)
	}
	if m.total_milli_seconds_allowed != nil {
		fields = append(fields, workeffort.FieldTotalMilliSecondsAllowed)
	}
	if m.total_money_allowed != nil {
		fields = append(fields, workeffort.FieldTotalMoneyAllowed)
	}
	if m.money_uom_id != nil {
		fields = append(fields, workeffort.FieldMoneyUomID)
	}
	if m.special_terms != nil {
		fields = append(fields, workeffort.FieldSpecialTerms)
	}
	if m.time_transparency != nil {
		fields = append(fields, workeffort.FieldTimeTransparency)
	}
	if m.universal_id != nil {
		fields = append(fields, workeffort.FieldUniversalID)
	}
	if m.source_reference_id != nil {
		fields = append(fields, workeffort.FieldSourceReferenceID)
	}
	if m.facility_id != nil {
		fields = append(fields, workeffort.FieldFacilityID)
	}
	if m.info_url != nil {
		fields = append(fields, workeffort.FieldInfoURL)
	}
	if m.recurrence_info_id != nil {
		fields = append(fields, workeffort.FieldRecurrenceInfoID)
	}
	if m.runtime_data_id != nil {
		fields = append(fields, workeffort.FieldRuntimeDataID)
	}
	if m.note_id != nil {
		fields = append(fields, workeffort.FieldNoteID)
	}
	if m.service_loader_name != nil {
		fields = append(fields, workeffort.FieldServiceLoaderName)
	}
	if m.quantity_to_produce != nil {
		fields = append(fields, workeffort.FieldQuantityToProduce)
	}
	if m.quantity_produced != nil {
		fields = append(fields, workeffort.FieldQuantityProduced)
	}
	if m.quantity_rejected != nil {
		fields = append(fields, workeffort.FieldQuantityRejected)
	}
	if m.reserv_persons != nil {
		fields = append(fields, workeffort.FieldReservPersons)
	}
	if m.reserv_2_nd_pp_perc != nil {
		fields = append(fields, workeffort.FieldReserv2NdPpPerc)
	}
	if m.reserv_nth_pp_perc != nil {
		fields = append(fields, workeffort.FieldReservNthPpPerc)
	}
	if m.accommodation_map_id != nil {
		fields = append(fields, workeffort.FieldAccommodationMapID)
	}
	if m.accommodation_spot_id != nil {
		fields = append(fields, workeffort.FieldAccommodationSpotID)
	}
	if m.revision_number != nil {
		fields = append(fields, workeffort.FieldRevisionNumber)
	}
	if m.created_date != nil {
		fields = append(fields, workeffort.FieldCreatedDate)
	}
	if m.created_by_user_login != nil {
		fields = append(fields, workeffort.FieldCreatedByUserLogin)
	}
	if m.last_modified_date != nil {
		fields = append(fields, workeffort.FieldLastModifiedDate)
	}
	if m.last_modified_by_user_login != nil {
		fields = append(fields, workeffort.FieldLastModifiedByUserLogin)
	}
	if m.sequence_num != nil {
		fields = append(fields, workeffort.FieldSequenceNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkEffortMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		return m.WorkEffortTypeID()
	case workeffort.FieldCurrentStatusID:
		return m.CurrentStatusID()
	case workeffort.FieldLastStatusUpdate:
		return m.LastStatusUpdate()
	case workeffort.FieldWorkEffortPurposeTypeID:
		return m.WorkEffortPurposeTypeID()
	case workeffort.FieldScopeEnumID:
		return m.ScopeEnumID()
	case workeffort.FieldPriority:
		return m.Priority()
	case workeffort.FieldPercentComplete:
		return m.PercentComplete()
	case workeffort.FieldWorkEffortName:
		return m.WorkEffortName()
	case workeffort.FieldShowAsEnumID:
		return m.ShowAsEnumID()
	case workeffort.FieldSendNotificationEmail:
		return m.SendNotificationEmail()
	case workeffort.FieldDescription:
		return m.Description()
	case workeffort.FieldLocationDesc:
		return m.LocationDesc()
	case workeffort.FieldEstimatedStartDate:
		return m.EstimatedStartDate()
	case workeffort.FieldEstimatedCompletionDate:
		return m.EstimatedCompletionDate()
	case workeffort.FieldActualStartDate:
		return m.ActualStartDate()
	case workeffort.FieldActualCompletionDate:
		return m.ActualCompletionDate()
	case workeffort.FieldEstimatedMilliSeconds:
		return m.EstimatedMilliSeconds()
	case workeffort.FieldEstimatedSetupMillis:
		return m.EstimatedSetupMillis()
	case workeffort.FieldEstimateCalcMethod:
		return m.EstimateCalcMethod()
	case workeffort.FieldActualMilliSeconds:
		return m.ActualMilliSeconds()
	case workeffort.FieldActualSetupMillis:
		return m.ActualSetupMillis()
	case workeffort.FieldTotalMilliSecondsAllowed:
		return m.TotalMilliSecondsAllowed()
	case workeffort.FieldTotalMoneyAllowed:
		return m.TotalMoneyAllowed()
	case workeffort.FieldMoneyUomID:
		return m.MoneyUomID()
	case workeffort.FieldSpecialTerms:
		return m.SpecialTerms()
	case workeffort.FieldTimeTransparency:
		return m.TimeTransparency()
	case workeffort.FieldUniversalID:
		return m.UniversalID()
	case workeffort.FieldSourceReferenceID:
		return m.SourceReferenceID()
	case workeffort.FieldFacilityID:
		return m.FacilityID()
	case workeffort.FieldInfoURL:
		return m.InfoURL()
	case workeffort.FieldRecurrenceInfoID:
		return m.RecurrenceInfoID()
	case workeffort.FieldRuntimeDataID:
		return m.RuntimeDataID()
	case workeffort.FieldNoteID:
		return m.NoteID()
	case workeffort.FieldServiceLoaderName:
		return m.ServiceLoaderName()
	case workeffort.FieldQuantityToProduce:
		return m.QuantityToProduce()
	case workeffort.FieldQuantityProduced:
		return m.QuantityProduced()
	case workeffort.FieldQuantityRejected:
		return m.QuantityRejected()
	case workeffort.FieldReservPersons:
		return m.ReservPersons()
	case workeffort.FieldReserv2NdPpPerc:
		return m.Reserv2NdPpPerc()
	case workeffort.FieldReservNthPpPerc:
		return m.ReservNthPpPerc()
	case workeffort.FieldAccommodationMapID:
		return m.AccommodationMapID()
	case workeffort.FieldAccommodationSpotID:
		return m.AccommodationSpotID()
	case workeffort.FieldRevisionNumber:
		return m.RevisionNumber()
	case workeffort.FieldCreatedDate:
		return m.CreatedDate()
	case workeffort.FieldCreatedByUserLogin:
		return m.CreatedByUserLogin()
	case workeffort.FieldLastModifiedDate:
		return m.LastModifiedDate()
	case workeffort.FieldLastModifiedByUserLogin:
		return m.LastModifiedByUserLogin()
	case workeffort.FieldSequenceNum:
		return m.SequenceNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkEffortMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		return m.OldWorkEffortTypeID(ctx)
	case workeffort.FieldCurrentStatusID:
		return m.OldCurrentStatusID(ctx)
	case workeffort.FieldLastStatusUpdate:
		return m.OldLastStatusUpdate(ctx)
	case workeffort.FieldWorkEffortPurposeTypeID:
		return m.OldWorkEffortPurposeTypeID(ctx)
	case workeffort.FieldScopeEnumID:
		return m.OldScopeEnumID(ctx)
	case workeffort.FieldPriority:
		return m.OldPriority(ctx)
	case workeffort.FieldPercentComplete:
		return m.OldPercentComplete(ctx)
	case workeffort.FieldWorkEffortName:
		return m.OldWorkEffortName(ctx)
	case workeffort.FieldShowAsEnumID:
		return m.OldShowAsEnumID(ctx)
	case workeffort.FieldSendNotificationEmail:
		return m.OldSendNotificationEmail(ctx)
	case workeffort.FieldDescription:
		return m.OldDescription(ctx)
	case workeffort.FieldLocationDesc:
		return m.OldLocationDesc(ctx)
	case workeffort.FieldEstimatedStartDate:
		return m.OldEstimatedStartDate(ctx)
	case workeffort.FieldEstimatedCompletionDate:
		return m.OldEstimatedCompletionDate(ctx)
	case workeffort.FieldActualStartDate:
		return m.OldActualStartDate(ctx)
	case workeffort.FieldActualCompletionDate:
		return m.OldActualCompletionDate(ctx)
	case workeffort.FieldEstimatedMilliSeconds:
		return m.OldEstimatedMilliSeconds(ctx)
	case workeffort.FieldEstimatedSetupMillis:
		return m.OldEstimatedSetupMillis(ctx)
	case workeffort.FieldEstimateCalcMethod:
		return m.OldEstimateCalcMethod(ctx)
	case workeffort.FieldActualMilliSeconds:
		return m.OldActualMilliSeconds(ctx)
	case workeffort.FieldActualSetupMillis:
		return m.OldActualSetupMillis(ctx)
	case workeffort.FieldTotalMilliSecondsAllowed:
		return m.OldTotalMilliSecondsAllowed(ctx)
	case workeffort.FieldTotalMoneyAllowed:
		return m.OldTotalMoneyAllowed(ctx)
	case workeffort.FieldMoneyUomID:
		return m.OldMoneyUomID(ctx)
	case workeffort.FieldSpecialTerms:
		return m.OldSpecialTerms(ctx)
	case workeffort.FieldTimeTransparency:
		return m.OldTimeTransparency(ctx)
	case workeffort.FieldUniversalID:
		return m.OldUniversalID(ctx)
	case workeffort.FieldSourceReferenceID:
		return m.OldSourceReferenceID(ctx)
	case workeffort.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case workeffort.FieldInfoURL:
		return m.OldInfoURL(ctx)
	case workeffort.FieldRecurrenceInfoID:
		return m.OldRecurrenceInfoID(ctx)
	case workeffort.FieldRuntimeDataID:
		return m.OldRuntimeDataID(ctx)
	case workeffort.FieldNoteID:
		return m.OldNoteID(ctx)
	case workeffort.FieldServiceLoaderName:
		return m.OldServiceLoaderName(ctx)
	case workeffort.FieldQuantityToProduce:
		return m.OldQuantityToProduce(ctx)
	case workeffort.FieldQuantityProduced:
		return m.OldQuantityProduced(ctx)
	case workeffort.FieldQuantityRejected:
		return m.OldQuantityRejected(ctx)
	case workeffort.FieldReservPersons:
		return m.OldReservPersons(ctx)
	case workeffort.FieldReserv2NdPpPerc:
		return m.OldReserv2NdPpPerc(ctx)
	case workeffort.FieldReservNthPpPerc:
		return m.OldReservNthPpPerc(ctx)
	case workeffort.FieldAccommodationMapID:
		return m.OldAccommodationMapID(ctx)
	case workeffort.FieldAccommodationSpotID:
		return m.OldAccommodationSpotID(ctx)
	case workeffort.FieldRevisionNumber:
		return m.OldRevisionNumber(ctx)
	case workeffort.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case workeffort.FieldCreatedByUserLogin:
		return m.OldCreatedByUserLogin(ctx)
	case workeffort.FieldLastModifiedDate:
		return m.OldLastModifiedDate(ctx)
	case workeffort.FieldLastModifiedByUserLogin:
		return m.OldLastModifiedByUserLogin(ctx)
	case workeffort.FieldSequenceNum:
		return m.OldSequenceNum(ctx)
	}
	return nil, fmt.Errorf("unknown WorkEffort field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEffortTypeID(v)
		return nil
	case workeffort.FieldCurrentStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStatusID(v)
		return nil
	case workeffort.FieldLastStatusUpdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastStatusUpdate(v)
		return nil
	case workeffort.FieldWorkEffortPurposeTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEffortPurposeTypeID(v)
		return nil
	case workeffort.FieldScopeEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopeEnumID(v)
		return nil
	case workeffort.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case workeffort.FieldPercentComplete:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercentComplete(v)
		return nil
	case workeffort.FieldWorkEffortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEffortName(v)
		return nil
	case workeffort.FieldShowAsEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAsEnumID(v)
		return nil
	case workeffort.FieldSendNotificationEmail:
		v, ok := value.(workeffort.SendNotificationEmail)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendNotificationEmail(v)
		return nil
	case workeffort.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workeffort.FieldLocationDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationDesc(v)
		return nil
	case workeffort.FieldEstimatedStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedStartDate(v)
		return nil
	case workeffort.FieldEstimatedCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedCompletionDate(v)
		return nil
	case workeffort.FieldActualStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStartDate(v)
		return nil
	case workeffort.FieldActualCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualCompletionDate(v)
		return nil
	case workeffort.FieldEstimatedMilliSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedMilliSeconds(v)
		return nil
	case workeffort.FieldEstimatedSetupMillis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedSetupMillis(v)
		return nil
	case workeffort.FieldEstimateCalcMethod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimateCalcMethod(v)
		return nil
	case workeffort.FieldActualMilliSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualMilliSeconds(v)
		return nil
	case workeffort.FieldActualSetupMillis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualSetupMillis(v)
		return nil
	case workeffort.FieldTotalMilliSecondsAllowed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMilliSecondsAllowed(v)
		return nil
	case workeffort.FieldTotalMoneyAllowed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMoneyAllowed(v)
		return nil
	case workeffort.FieldMoneyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoneyUomID(v)
		return nil
	case workeffort.FieldSpecialTerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialTerms(v)
		return nil
	case workeffort.FieldTimeTransparency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeTransparency(v)
		return nil
	case workeffort.FieldUniversalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniversalID(v)
		return nil
	case workeffort.FieldSourceReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceReferenceID(v)
		return nil
	case workeffort.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case workeffort.FieldInfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfoURL(v)
		return nil
	case workeffort.FieldRecurrenceInfoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecurrenceInfoID(v)
		return nil
	case workeffort.FieldRuntimeDataID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRuntimeDataID(v)
		return nil
	case workeffort.FieldNoteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoteID(v)
		return nil
	case workeffort.FieldServiceLoaderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceLoaderName(v)
		return nil
	case workeffort.FieldQuantityToProduce:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityToProduce(v)
		return nil
	case workeffort.FieldQuantityProduced:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityProduced(v)
		return nil
	case workeffort.FieldQuantityRejected:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityRejected(v)
		return nil
	case workeffort.FieldReservPersons:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservPersons(v)
		return nil
	case workeffort.FieldReserv2NdPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserv2NdPpPerc(v)
		return nil
	case workeffort.FieldReservNthPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservNthPpPerc(v)
		return nil
	case workeffort.FieldAccommodationMapID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccommodationMapID(v)
		return nil
	case workeffort.FieldAccommodationSpotID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccommodationSpotID(v)
		return nil
	case workeffort.FieldRevisionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevisionNumber(v)
		return nil
	case workeffort.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case workeffort.FieldCreatedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByUserLogin(v)
		return nil
	case workeffort.FieldLastModifiedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedDate(v)
		return nil
	case workeffort.FieldLastModifiedByUserLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifiedByUserLogin(v)
		return nil
	case workeffort.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNum(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffort field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkEffortMutation) AddedFields() []string {
	var fields []string
	if m.addwork_effort_type_id != nil {
		fields = append(fields, workeffort.FieldWorkEffortTypeID)
	}
	if m.addcurrent_status_id != nil {
		fields = append(fields, workeffort.FieldCurrentStatusID)
	}
	if m.addwork_effort_purpose_type_id != nil {
		fields = append(fields, workeffort.FieldWorkEffortPurposeTypeID)
	}
	if m.addscope_enum_id != nil {
		fields = append(fields, workeffort.FieldScopeEnumID)
	}
	if m.addpriority != nil {
		fields = append(fields, workeffort.FieldPriority)
	}
	if m.addpercent_complete != nil {
		fields = append(fields, workeffort.FieldPercentComplete)
	}
	if m.addshow_as_enum_id != nil {
		fields = append(fields, workeffort.FieldShowAsEnumID)
	}
	if m.addestimated_milli_seconds != nil {
		fields = append(fields, workeffort.FieldEstimatedMilliSeconds)
	}
	if m.addestimated_setup_millis != nil {
		fields = append(fields, workeffort.FieldEstimatedSetupMillis)
	}
	if m.addestimate_calc_method != nil {
		fields = append(fields, workeffort.FieldEstimateCalcMethod)
	}
	if m.addactual_milli_seconds != nil {
		fields = append(fields, workeffort.FieldActualMilliSeconds)
	}
	if m.addactual_setup_millis != nil {
		fields = append(fields, workeffort.FieldActualSetupMillis)
	}
	if m.addtotal_milli_seconds_allowed != nil {
		fields = append(fields, workeffort.FieldTotalMilliSecondsAllowed)
	}
	if m.addtotal_money_allowed != nil {
		fields = append(fields, workeffort.FieldTotalMoneyAllowed)
	}
	if m.addmoney_uom_id != nil {
		fields = append(fields, workeffort.FieldMoneyUomID)
	}
	if m.addtime_transparency != nil {
		fields = append(fields, workeffort.FieldTimeTransparency)
	}
	if m.addfacility_id != nil {
		fields = append(fields, workeffort.FieldFacilityID)
	}
	if m.addrecurrence_info_id != nil {
		fields = append(fields, workeffort.FieldRecurrenceInfoID)
	}
	if m.addruntime_data_id != nil {
		fields = append(fields, workeffort.FieldRuntimeDataID)
	}
	if m.addnote_id != nil {
		fields = append(fields, workeffort.FieldNoteID)
	}
	if m.addquantity_to_produce != nil {
		fields = append(fields, workeffort.FieldQuantityToProduce)
	}
	if m.addquantity_produced != nil {
		fields = append(fields, workeffort.FieldQuantityProduced)
	}
	if m.addquantity_rejected != nil {
		fields = append(fields, workeffort.FieldQuantityRejected)
	}
	if m.addreserv_persons != nil {
		fields = append(fields, workeffort.FieldReservPersons)
	}
	if m.addreserv_2_nd_pp_perc != nil {
		fields = append(fields, workeffort.FieldReserv2NdPpPerc)
	}
	if m.addreserv_nth_pp_perc != nil {
		fields = append(fields, workeffort.FieldReservNthPpPerc)
	}
	if m.addaccommodation_map_id != nil {
		fields = append(fields, workeffort.FieldAccommodationMapID)
	}
	if m.addaccommodation_spot_id != nil {
		fields = append(fields, workeffort.FieldAccommodationSpotID)
	}
	if m.addrevision_number != nil {
		fields = append(fields, workeffort.FieldRevisionNumber)
	}
	if m.addsequence_num != nil {
		fields = append(fields, workeffort.FieldSequenceNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkEffortMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		return m.AddedWorkEffortTypeID()
	case workeffort.FieldCurrentStatusID:
		return m.AddedCurrentStatusID()
	case workeffort.FieldWorkEffortPurposeTypeID:
		return m.AddedWorkEffortPurposeTypeID()
	case workeffort.FieldScopeEnumID:
		return m.AddedScopeEnumID()
	case workeffort.FieldPriority:
		return m.AddedPriority()
	case workeffort.FieldPercentComplete:
		return m.AddedPercentComplete()
	case workeffort.FieldShowAsEnumID:
		return m.AddedShowAsEnumID()
	case workeffort.FieldEstimatedMilliSeconds:
		return m.AddedEstimatedMilliSeconds()
	case workeffort.FieldEstimatedSetupMillis:
		return m.AddedEstimatedSetupMillis()
	case workeffort.FieldEstimateCalcMethod:
		return m.AddedEstimateCalcMethod()
	case workeffort.FieldActualMilliSeconds:
		return m.AddedActualMilliSeconds()
	case workeffort.FieldActualSetupMillis:
		return m.AddedActualSetupMillis()
	case workeffort.FieldTotalMilliSecondsAllowed:
		return m.AddedTotalMilliSecondsAllowed()
	case workeffort.FieldTotalMoneyAllowed:
		return m.AddedTotalMoneyAllowed()
	case workeffort.FieldMoneyUomID:
		return m.AddedMoneyUomID()
	case workeffort.FieldTimeTransparency:
		return m.AddedTimeTransparency()
	case workeffort.FieldFacilityID:
		return m.AddedFacilityID()
	case workeffort.FieldRecurrenceInfoID:
		return m.AddedRecurrenceInfoID()
	case workeffort.FieldRuntimeDataID:
		return m.AddedRuntimeDataID()
	case workeffort.FieldNoteID:
		return m.AddedNoteID()
	case workeffort.FieldQuantityToProduce:
		return m.AddedQuantityToProduce()
	case workeffort.FieldQuantityProduced:
		return m.AddedQuantityProduced()
	case workeffort.FieldQuantityRejected:
		return m.AddedQuantityRejected()
	case workeffort.FieldReservPersons:
		return m.AddedReservPersons()
	case workeffort.FieldReserv2NdPpPerc:
		return m.AddedReserv2NdPpPerc()
	case workeffort.FieldReservNthPpPerc:
		return m.AddedReservNthPpPerc()
	case workeffort.FieldAccommodationMapID:
		return m.AddedAccommodationMapID()
	case workeffort.FieldAccommodationSpotID:
		return m.AddedAccommodationSpotID()
	case workeffort.FieldRevisionNumber:
		return m.AddedRevisionNumber()
	case workeffort.FieldSequenceNum:
		return m.AddedSequenceNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkEffortTypeID(v)
		return nil
	case workeffort.FieldCurrentStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentStatusID(v)
		return nil
	case workeffort.FieldWorkEffortPurposeTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkEffortPurposeTypeID(v)
		return nil
	case workeffort.FieldScopeEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScopeEnumID(v)
		return nil
	case workeffort.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case workeffort.FieldPercentComplete:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPercentComplete(v)
		return nil
	case workeffort.FieldShowAsEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShowAsEnumID(v)
		return nil
	case workeffort.FieldEstimatedMilliSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedMilliSeconds(v)
		return nil
	case workeffort.FieldEstimatedSetupMillis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedSetupMillis(v)
		return nil
	case workeffort.FieldEstimateCalcMethod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimateCalcMethod(v)
		return nil
	case workeffort.FieldActualMilliSeconds:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualMilliSeconds(v)
		return nil
	case workeffort.FieldActualSetupMillis:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualSetupMillis(v)
		return nil
	case workeffort.FieldTotalMilliSecondsAllowed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMilliSecondsAllowed(v)
		return nil
	case workeffort.FieldTotalMoneyAllowed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMoneyAllowed(v)
		return nil
	case workeffort.FieldMoneyUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoneyUomID(v)
		return nil
	case workeffort.FieldTimeTransparency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeTransparency(v)
		return nil
	case workeffort.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFacilityID(v)
		return nil
	case workeffort.FieldRecurrenceInfoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecurrenceInfoID(v)
		return nil
	case workeffort.FieldRuntimeDataID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRuntimeDataID(v)
		return nil
	case workeffort.FieldNoteID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNoteID(v)
		return nil
	case workeffort.FieldQuantityToProduce:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityToProduce(v)
		return nil
	case workeffort.FieldQuantityProduced:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityProduced(v)
		return nil
	case workeffort.FieldQuantityRejected:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantityRejected(v)
		return nil
	case workeffort.FieldReservPersons:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservPersons(v)
		return nil
	case workeffort.FieldReserv2NdPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReserv2NdPpPerc(v)
		return nil
	case workeffort.FieldReservNthPpPerc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservNthPpPerc(v)
		return nil
	case workeffort.FieldAccommodationMapID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccommodationMapID(v)
		return nil
	case workeffort.FieldAccommodationSpotID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccommodationSpotID(v)
		return nil
	case workeffort.FieldRevisionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevisionNumber(v)
		return nil
	case workeffort.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNum(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffort numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkEffortMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workeffort.FieldWorkEffortTypeID) {
		fields = append(fields, workeffort.FieldWorkEffortTypeID)
	}
	if m.FieldCleared(workeffort.FieldCurrentStatusID) {
		fields = append(fields, workeffort.FieldCurrentStatusID)
	}
	if m.FieldCleared(workeffort.FieldLastStatusUpdate) {
		fields = append(fields, workeffort.FieldLastStatusUpdate)
	}
	if m.FieldCleared(workeffort.FieldWorkEffortPurposeTypeID) {
		fields = append(fields, workeffort.FieldWorkEffortPurposeTypeID)
	}
	if m.FieldCleared(workeffort.FieldScopeEnumID) {
		fields = append(fields, workeffort.FieldScopeEnumID)
	}
	if m.FieldCleared(workeffort.FieldPriority) {
		fields = append(fields, workeffort.FieldPriority)
	}
	if m.FieldCleared(workeffort.FieldPercentComplete) {
		fields = append(fields, workeffort.FieldPercentComplete)
	}
	if m.FieldCleared(workeffort.FieldWorkEffortName) {
		fields = append(fields, workeffort.FieldWorkEffortName)
	}
	if m.FieldCleared(workeffort.FieldShowAsEnumID) {
		fields = append(fields, workeffort.FieldShowAsEnumID)
	}
	if m.FieldCleared(workeffort.FieldSendNotificationEmail) {
		fields = append(fields, workeffort.FieldSendNotificationEmail)
	}
	if m.FieldCleared(workeffort.FieldDescription) {
		fields = append(fields, workeffort.FieldDescription)
	}
	if m.FieldCleared(workeffort.FieldLocationDesc) {
		fields = append(fields, workeffort.FieldLocationDesc)
	}
	if m.FieldCleared(workeffort.FieldEstimatedStartDate) {
		fields = append(fields, workeffort.FieldEstimatedStartDate)
	}
	if m.FieldCleared(workeffort.FieldEstimatedCompletionDate) {
		fields = append(fields, workeffort.FieldEstimatedCompletionDate)
	}
	if m.FieldCleared(workeffort.FieldActualStartDate) {
		fields = append(fields, workeffort.FieldActualStartDate)
	}
	if m.FieldCleared(workeffort.FieldActualCompletionDate) {
		fields = append(fields, workeffort.FieldActualCompletionDate)
	}
	if m.FieldCleared(workeffort.FieldEstimatedMilliSeconds) {
		fields = append(fields, workeffort.FieldEstimatedMilliSeconds)
	}
	if m.FieldCleared(workeffort.FieldEstimatedSetupMillis) {
		fields = append(fields, workeffort.FieldEstimatedSetupMillis)
	}
	if m.FieldCleared(workeffort.FieldEstimateCalcMethod) {
		fields = append(fields, workeffort.FieldEstimateCalcMethod)
	}
	if m.FieldCleared(workeffort.FieldActualMilliSeconds) {
		fields = append(fields, workeffort.FieldActualMilliSeconds)
	}
	if m.FieldCleared(workeffort.FieldActualSetupMillis) {
		fields = append(fields, workeffort.FieldActualSetupMillis)
	}
	if m.FieldCleared(workeffort.FieldTotalMilliSecondsAllowed) {
		fields = append(fields, workeffort.FieldTotalMilliSecondsAllowed)
	}
	if m.FieldCleared(workeffort.FieldTotalMoneyAllowed) {
		fields = append(fields, workeffort.FieldTotalMoneyAllowed)
	}
	if m.FieldCleared(workeffort.FieldMoneyUomID) {
		fields = append(fields, workeffort.FieldMoneyUomID)
	}
	if m.FieldCleared(workeffort.FieldSpecialTerms) {
		fields = append(fields, workeffort.FieldSpecialTerms)
	}
	if m.FieldCleared(workeffort.FieldTimeTransparency) {
		fields = append(fields, workeffort.FieldTimeTransparency)
	}
	if m.FieldCleared(workeffort.FieldUniversalID) {
		fields = append(fields, workeffort.FieldUniversalID)
	}
	if m.FieldCleared(workeffort.FieldSourceReferenceID) {
		fields = append(fields, workeffort.FieldSourceReferenceID)
	}
	if m.FieldCleared(workeffort.FieldFacilityID) {
		fields = append(fields, workeffort.FieldFacilityID)
	}
	if m.FieldCleared(workeffort.FieldInfoURL) {
		fields = append(fields, workeffort.FieldInfoURL)
	}
	if m.FieldCleared(workeffort.FieldRecurrenceInfoID) {
		fields = append(fields, workeffort.FieldRecurrenceInfoID)
	}
	if m.FieldCleared(workeffort.FieldRuntimeDataID) {
		fields = append(fields, workeffort.FieldRuntimeDataID)
	}
	if m.FieldCleared(workeffort.FieldNoteID) {
		fields = append(fields, workeffort.FieldNoteID)
	}
	if m.FieldCleared(workeffort.FieldServiceLoaderName) {
		fields = append(fields, workeffort.FieldServiceLoaderName)
	}
	if m.FieldCleared(workeffort.FieldQuantityToProduce) {
		fields = append(fields, workeffort.FieldQuantityToProduce)
	}
	if m.FieldCleared(workeffort.FieldQuantityProduced) {
		fields = append(fields, workeffort.FieldQuantityProduced)
	}
	if m.FieldCleared(workeffort.FieldQuantityRejected) {
		fields = append(fields, workeffort.FieldQuantityRejected)
	}
	if m.FieldCleared(workeffort.FieldReservPersons) {
		fields = append(fields, workeffort.FieldReservPersons)
	}
	if m.FieldCleared(workeffort.FieldReserv2NdPpPerc) {
		fields = append(fields, workeffort.FieldReserv2NdPpPerc)
	}
	if m.FieldCleared(workeffort.FieldReservNthPpPerc) {
		fields = append(fields, workeffort.FieldReservNthPpPerc)
	}
	if m.FieldCleared(workeffort.FieldAccommodationMapID) {
		fields = append(fields, workeffort.FieldAccommodationMapID)
	}
	if m.FieldCleared(workeffort.FieldAccommodationSpotID) {
		fields = append(fields, workeffort.FieldAccommodationSpotID)
	}
	if m.FieldCleared(workeffort.FieldRevisionNumber) {
		fields = append(fields, workeffort.FieldRevisionNumber)
	}
	if m.FieldCleared(workeffort.FieldCreatedDate) {
		fields = append(fields, workeffort.FieldCreatedDate)
	}
	if m.FieldCleared(workeffort.FieldCreatedByUserLogin) {
		fields = append(fields, workeffort.FieldCreatedByUserLogin)
	}
	if m.FieldCleared(workeffort.FieldLastModifiedDate) {
		fields = append(fields, workeffort.FieldLastModifiedDate)
	}
	if m.FieldCleared(workeffort.FieldLastModifiedByUserLogin) {
		fields = append(fields, workeffort.FieldLastModifiedByUserLogin)
	}
	if m.FieldCleared(workeffort.FieldSequenceNum) {
		fields = append(fields, workeffort.FieldSequenceNum)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkEffortMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkEffortMutation) ClearField(name string) error {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		m.ClearWorkEffortTypeID()
		return nil
	case workeffort.FieldCurrentStatusID:
		m.ClearCurrentStatusID()
		return nil
	case workeffort.FieldLastStatusUpdate:
		m.ClearLastStatusUpdate()
		return nil
	case workeffort.FieldWorkEffortPurposeTypeID:
		m.ClearWorkEffortPurposeTypeID()
		return nil
	case workeffort.FieldScopeEnumID:
		m.ClearScopeEnumID()
		return nil
	case workeffort.FieldPriority:
		m.ClearPriority()
		return nil
	case workeffort.FieldPercentComplete:
		m.ClearPercentComplete()
		return nil
	case workeffort.FieldWorkEffortName:
		m.ClearWorkEffortName()
		return nil
	case workeffort.FieldShowAsEnumID:
		m.ClearShowAsEnumID()
		return nil
	case workeffort.FieldSendNotificationEmail:
		m.ClearSendNotificationEmail()
		return nil
	case workeffort.FieldDescription:
		m.ClearDescription()
		return nil
	case workeffort.FieldLocationDesc:
		m.ClearLocationDesc()
		return nil
	case workeffort.FieldEstimatedStartDate:
		m.ClearEstimatedStartDate()
		return nil
	case workeffort.FieldEstimatedCompletionDate:
		m.ClearEstimatedCompletionDate()
		return nil
	case workeffort.FieldActualStartDate:
		m.ClearActualStartDate()
		return nil
	case workeffort.FieldActualCompletionDate:
		m.ClearActualCompletionDate()
		return nil
	case workeffort.FieldEstimatedMilliSeconds:
		m.ClearEstimatedMilliSeconds()
		return nil
	case workeffort.FieldEstimatedSetupMillis:
		m.ClearEstimatedSetupMillis()
		return nil
	case workeffort.FieldEstimateCalcMethod:
		m.ClearEstimateCalcMethod()
		return nil
	case workeffort.FieldActualMilliSeconds:
		m.ClearActualMilliSeconds()
		return nil
	case workeffort.FieldActualSetupMillis:
		m.ClearActualSetupMillis()
		return nil
	case workeffort.FieldTotalMilliSecondsAllowed:
		m.ClearTotalMilliSecondsAllowed()
		return nil
	case workeffort.FieldTotalMoneyAllowed:
		m.ClearTotalMoneyAllowed()
		return nil
	case workeffort.FieldMoneyUomID:
		m.ClearMoneyUomID()
		return nil
	case workeffort.FieldSpecialTerms:
		m.ClearSpecialTerms()
		return nil
	case workeffort.FieldTimeTransparency:
		m.ClearTimeTransparency()
		return nil
	case workeffort.FieldUniversalID:
		m.ClearUniversalID()
		return nil
	case workeffort.FieldSourceReferenceID:
		m.ClearSourceReferenceID()
		return nil
	case workeffort.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case workeffort.FieldInfoURL:
		m.ClearInfoURL()
		return nil
	case workeffort.FieldRecurrenceInfoID:
		m.ClearRecurrenceInfoID()
		return nil
	case workeffort.FieldRuntimeDataID:
		m.ClearRuntimeDataID()
		return nil
	case workeffort.FieldNoteID:
		m.ClearNoteID()
		return nil
	case workeffort.FieldServiceLoaderName:
		m.ClearServiceLoaderName()
		return nil
	case workeffort.FieldQuantityToProduce:
		m.ClearQuantityToProduce()
		return nil
	case workeffort.FieldQuantityProduced:
		m.ClearQuantityProduced()
		return nil
	case workeffort.FieldQuantityRejected:
		m.ClearQuantityRejected()
		return nil
	case workeffort.FieldReservPersons:
		m.ClearReservPersons()
		return nil
	case workeffort.FieldReserv2NdPpPerc:
		m.ClearReserv2NdPpPerc()
		return nil
	case workeffort.FieldReservNthPpPerc:
		m.ClearReservNthPpPerc()
		return nil
	case workeffort.FieldAccommodationMapID:
		m.ClearAccommodationMapID()
		return nil
	case workeffort.FieldAccommodationSpotID:
		m.ClearAccommodationSpotID()
		return nil
	case workeffort.FieldRevisionNumber:
		m.ClearRevisionNumber()
		return nil
	case workeffort.FieldCreatedDate:
		m.ClearCreatedDate()
		return nil
	case workeffort.FieldCreatedByUserLogin:
		m.ClearCreatedByUserLogin()
		return nil
	case workeffort.FieldLastModifiedDate:
		m.ClearLastModifiedDate()
		return nil
	case workeffort.FieldLastModifiedByUserLogin:
		m.ClearLastModifiedByUserLogin()
		return nil
	case workeffort.FieldSequenceNum:
		m.ClearSequenceNum()
		return nil
	}
	return fmt.Errorf("unknown WorkEffort nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkEffortMutation) ResetField(name string) error {
	switch name {
	case workeffort.FieldWorkEffortTypeID:
		m.ResetWorkEffortTypeID()
		return nil
	case workeffort.FieldCurrentStatusID:
		m.ResetCurrentStatusID()
		return nil
	case workeffort.FieldLastStatusUpdate:
		m.ResetLastStatusUpdate()
		return nil
	case workeffort.FieldWorkEffortPurposeTypeID:
		m.ResetWorkEffortPurposeTypeID()
		return nil
	case workeffort.FieldScopeEnumID:
		m.ResetScopeEnumID()
		return nil
	case workeffort.FieldPriority:
		m.ResetPriority()
		return nil
	case workeffort.FieldPercentComplete:
		m.ResetPercentComplete()
		return nil
	case workeffort.FieldWorkEffortName:
		m.ResetWorkEffortName()
		return nil
	case workeffort.FieldShowAsEnumID:
		m.ResetShowAsEnumID()
		return nil
	case workeffort.FieldSendNotificationEmail:
		m.ResetSendNotificationEmail()
		return nil
	case workeffort.FieldDescription:
		m.ResetDescription()
		return nil
	case workeffort.FieldLocationDesc:
		m.ResetLocationDesc()
		return nil
	case workeffort.FieldEstimatedStartDate:
		m.ResetEstimatedStartDate()
		return nil
	case workeffort.FieldEstimatedCompletionDate:
		m.ResetEstimatedCompletionDate()
		return nil
	case workeffort.FieldActualStartDate:
		m.ResetActualStartDate()
		return nil
	case workeffort.FieldActualCompletionDate:
		m.ResetActualCompletionDate()
		return nil
	case workeffort.FieldEstimatedMilliSeconds:
		m.ResetEstimatedMilliSeconds()
		return nil
	case workeffort.FieldEstimatedSetupMillis:
		m.ResetEstimatedSetupMillis()
		return nil
	case workeffort.FieldEstimateCalcMethod:
		m.ResetEstimateCalcMethod()
		return nil
	case workeffort.FieldActualMilliSeconds:
		m.ResetActualMilliSeconds()
		return nil
	case workeffort.FieldActualSetupMillis:
		m.ResetActualSetupMillis()
		return nil
	case workeffort.FieldTotalMilliSecondsAllowed:
		m.ResetTotalMilliSecondsAllowed()
		return nil
	case workeffort.FieldTotalMoneyAllowed:
		m.ResetTotalMoneyAllowed()
		return nil
	case workeffort.FieldMoneyUomID:
		m.ResetMoneyUomID()
		return nil
	case workeffort.FieldSpecialTerms:
		m.ResetSpecialTerms()
		return nil
	case workeffort.FieldTimeTransparency:
		m.ResetTimeTransparency()
		return nil
	case workeffort.FieldUniversalID:
		m.ResetUniversalID()
		return nil
	case workeffort.FieldSourceReferenceID:
		m.ResetSourceReferenceID()
		return nil
	case workeffort.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case workeffort.FieldInfoURL:
		m.ResetInfoURL()
		return nil
	case workeffort.FieldRecurrenceInfoID:
		m.ResetRecurrenceInfoID()
		return nil
	case workeffort.FieldRuntimeDataID:
		m.ResetRuntimeDataID()
		return nil
	case workeffort.FieldNoteID:
		m.ResetNoteID()
		return nil
	case workeffort.FieldServiceLoaderName:
		m.ResetServiceLoaderName()
		return nil
	case workeffort.FieldQuantityToProduce:
		m.ResetQuantityToProduce()
		return nil
	case workeffort.FieldQuantityProduced:
		m.ResetQuantityProduced()
		return nil
	case workeffort.FieldQuantityRejected:
		m.ResetQuantityRejected()
		return nil
	case workeffort.FieldReservPersons:
		m.ResetReservPersons()
		return nil
	case workeffort.FieldReserv2NdPpPerc:
		m.ResetReserv2NdPpPerc()
		return nil
	case workeffort.FieldReservNthPpPerc:
		m.ResetReservNthPpPerc()
		return nil
	case workeffort.FieldAccommodationMapID:
		m.ResetAccommodationMapID()
		return nil
	case workeffort.FieldAccommodationSpotID:
		m.ResetAccommodationSpotID()
		return nil
	case workeffort.FieldRevisionNumber:
		m.ResetRevisionNumber()
		return nil
	case workeffort.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case workeffort.FieldCreatedByUserLogin:
		m.ResetCreatedByUserLogin()
		return nil
	case workeffort.FieldLastModifiedDate:
		m.ResetLastModifiedDate()
		return nil
	case workeffort.FieldLastModifiedByUserLogin:
		m.ResetLastModifiedByUserLogin()
		return nil
	case workeffort.FieldSequenceNum:
		m.ResetSequenceNum()
		return nil
	}
	return fmt.Errorf("unknown WorkEffort field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkEffortMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.parent != nil {
		edges = append(edges, workeffort.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, workeffort.EdgeChildren)
	}
	if m.fixed_asset != nil {
		edges = append(edges, workeffort.EdgeFixedAsset)
	}
	if m.temporal_expression != nil {
		edges = append(edges, workeffort.EdgeTemporalExpression)
	}
	if m.child_work_efforts != nil {
		edges = append(edges, workeffort.EdgeChildWorkEfforts)
	}
	if m.from_work_effort_assocs != nil {
		edges = append(edges, workeffort.EdgeFromWorkEffortAssocs)
	}
	if m.to_work_effort_assocs != nil {
		edges = append(edges, workeffort.EdgeToWorkEffortAssocs)
	}
	if m.work_effort_fixed_asset_assigns != nil {
		edges = append(edges, workeffort.EdgeWorkEffortFixedAssetAssigns)
	}
	if m.work_effort_party_assignments != nil {
		edges = append(edges, workeffort.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkEffortMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workeffort.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case workeffort.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeFixedAsset:
		if id := m.fixed_asset; id != nil {
			return []ent.Value{*id}
		}
	case workeffort.EdgeTemporalExpression:
		if id := m.temporal_expression; id != nil {
			return []ent.Value{*id}
		}
	case workeffort.EdgeChildWorkEfforts:
		ids := make([]ent.Value, 0, len(m.child_work_efforts))
		for id := range m.child_work_efforts {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeFromWorkEffortAssocs:
		ids := make([]ent.Value, 0, len(m.from_work_effort_assocs))
		for id := range m.from_work_effort_assocs {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeToWorkEffortAssocs:
		ids := make([]ent.Value, 0, len(m.to_work_effort_assocs))
		for id := range m.to_work_effort_assocs {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeWorkEffortFixedAssetAssigns:
		ids := make([]ent.Value, 0, len(m.work_effort_fixed_asset_assigns))
		for id := range m.work_effort_fixed_asset_assigns {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.work_effort_party_assignments))
		for id := range m.work_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkEffortMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedchildren != nil {
		edges = append(edges, workeffort.EdgeChildren)
	}
	if m.removedchild_work_efforts != nil {
		edges = append(edges, workeffort.EdgeChildWorkEfforts)
	}
	if m.removedfrom_work_effort_assocs != nil {
		edges = append(edges, workeffort.EdgeFromWorkEffortAssocs)
	}
	if m.removedto_work_effort_assocs != nil {
		edges = append(edges, workeffort.EdgeToWorkEffortAssocs)
	}
	if m.removedwork_effort_fixed_asset_assigns != nil {
		edges = append(edges, workeffort.EdgeWorkEffortFixedAssetAssigns)
	}
	if m.removedwork_effort_party_assignments != nil {
		edges = append(edges, workeffort.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkEffortMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workeffort.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeChildWorkEfforts:
		ids := make([]ent.Value, 0, len(m.removedchild_work_efforts))
		for id := range m.removedchild_work_efforts {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeFromWorkEffortAssocs:
		ids := make([]ent.Value, 0, len(m.removedfrom_work_effort_assocs))
		for id := range m.removedfrom_work_effort_assocs {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeToWorkEffortAssocs:
		ids := make([]ent.Value, 0, len(m.removedto_work_effort_assocs))
		for id := range m.removedto_work_effort_assocs {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeWorkEffortFixedAssetAssigns:
		ids := make([]ent.Value, 0, len(m.removedwork_effort_fixed_asset_assigns))
		for id := range m.removedwork_effort_fixed_asset_assigns {
			ids = append(ids, id)
		}
		return ids
	case workeffort.EdgeWorkEffortPartyAssignments:
		ids := make([]ent.Value, 0, len(m.removedwork_effort_party_assignments))
		for id := range m.removedwork_effort_party_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkEffortMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedparent {
		edges = append(edges, workeffort.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, workeffort.EdgeChildren)
	}
	if m.clearedfixed_asset {
		edges = append(edges, workeffort.EdgeFixedAsset)
	}
	if m.clearedtemporal_expression {
		edges = append(edges, workeffort.EdgeTemporalExpression)
	}
	if m.clearedchild_work_efforts {
		edges = append(edges, workeffort.EdgeChildWorkEfforts)
	}
	if m.clearedfrom_work_effort_assocs {
		edges = append(edges, workeffort.EdgeFromWorkEffortAssocs)
	}
	if m.clearedto_work_effort_assocs {
		edges = append(edges, workeffort.EdgeToWorkEffortAssocs)
	}
	if m.clearedwork_effort_fixed_asset_assigns {
		edges = append(edges, workeffort.EdgeWorkEffortFixedAssetAssigns)
	}
	if m.clearedwork_effort_party_assignments {
		edges = append(edges, workeffort.EdgeWorkEffortPartyAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkEffortMutation) EdgeCleared(name string) bool {
	switch name {
	case workeffort.EdgeParent:
		return m.clearedparent
	case workeffort.EdgeChildren:
		return m.clearedchildren
	case workeffort.EdgeFixedAsset:
		return m.clearedfixed_asset
	case workeffort.EdgeTemporalExpression:
		return m.clearedtemporal_expression
	case workeffort.EdgeChildWorkEfforts:
		return m.clearedchild_work_efforts
	case workeffort.EdgeFromWorkEffortAssocs:
		return m.clearedfrom_work_effort_assocs
	case workeffort.EdgeToWorkEffortAssocs:
		return m.clearedto_work_effort_assocs
	case workeffort.EdgeWorkEffortFixedAssetAssigns:
		return m.clearedwork_effort_fixed_asset_assigns
	case workeffort.EdgeWorkEffortPartyAssignments:
		return m.clearedwork_effort_party_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkEffortMutation) ClearEdge(name string) error {
	switch name {
	case workeffort.EdgeParent:
		m.ClearParent()
		return nil
	case workeffort.EdgeFixedAsset:
		m.ClearFixedAsset()
		return nil
	case workeffort.EdgeTemporalExpression:
		m.ClearTemporalExpression()
		return nil
	}
	return fmt.Errorf("unknown WorkEffort unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkEffortMutation) ResetEdge(name string) error {
	switch name {
	case workeffort.EdgeParent:
		m.ResetParent()
		return nil
	case workeffort.EdgeChildren:
		m.ResetChildren()
		return nil
	case workeffort.EdgeFixedAsset:
		m.ResetFixedAsset()
		return nil
	case workeffort.EdgeTemporalExpression:
		m.ResetTemporalExpression()
		return nil
	case workeffort.EdgeChildWorkEfforts:
		m.ResetChildWorkEfforts()
		return nil
	case workeffort.EdgeFromWorkEffortAssocs:
		m.ResetFromWorkEffortAssocs()
		return nil
	case workeffort.EdgeToWorkEffortAssocs:
		m.ResetToWorkEffortAssocs()
		return nil
	case workeffort.EdgeWorkEffortFixedAssetAssigns:
		m.ResetWorkEffortFixedAssetAssigns()
		return nil
	case workeffort.EdgeWorkEffortPartyAssignments:
		m.ResetWorkEffortPartyAssignments()
		return nil
	}
	return fmt.Errorf("unknown WorkEffort edge %s", name)
}

// WorkEffortAssocMutation represents an operation that mutates the WorkEffortAssoc nodes in the graph.
type WorkEffortAssocMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	work_effort_assoc_type_id    *int
	addwork_effort_assoc_type_id *int
	sequence_num                 *int
	addsequence_num              *int
	from_date                    *time.Time
	thru_date                    *time.Time
	clearedFields                map[string]struct{}
	from_work_effort             *int
	clearedfrom_work_effort      bool
	to_work_effort               *int
	clearedto_work_effort        bool
	done                         bool
	oldValue                     func(context.Context) (*WorkEffortAssoc, error)
	predicates                   []predicate.WorkEffortAssoc
}

var _ ent.Mutation = (*WorkEffortAssocMutation)(nil)

// workeffortassocOption allows management of the mutation configuration using functional options.
type workeffortassocOption func(*WorkEffortAssocMutation)

// newWorkEffortAssocMutation creates new mutation for the WorkEffortAssoc entity.
func newWorkEffortAssocMutation(c config, op Op, opts ...workeffortassocOption) *WorkEffortAssocMutation {
	m := &WorkEffortAssocMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkEffortAssoc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkEffortAssocID sets the ID field of the mutation.
func withWorkEffortAssocID(id int) workeffortassocOption {
	return func(m *WorkEffortAssocMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkEffortAssoc
		)
		m.oldValue = func(ctx context.Context) (*WorkEffortAssoc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkEffortAssoc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkEffortAssoc sets the old WorkEffortAssoc of the mutation.
func withWorkEffortAssoc(node *WorkEffortAssoc) workeffortassocOption {
	return func(m *WorkEffortAssocMutation) {
		m.oldValue = func(context.Context) (*WorkEffortAssoc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkEffortAssocMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkEffortAssocMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkEffortAssocMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWorkEffortAssocTypeID sets the "work_effort_assoc_type_id" field.
func (m *WorkEffortAssocMutation) SetWorkEffortAssocTypeID(i int) {
	m.work_effort_assoc_type_id = &i
	m.addwork_effort_assoc_type_id = nil
}

// WorkEffortAssocTypeID returns the value of the "work_effort_assoc_type_id" field in the mutation.
func (m *WorkEffortAssocMutation) WorkEffortAssocTypeID() (r int, exists bool) {
	v := m.work_effort_assoc_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkEffortAssocTypeID returns the old "work_effort_assoc_type_id" field's value of the WorkEffortAssoc entity.
// If the WorkEffortAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortAssocMutation) OldWorkEffortAssocTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkEffortAssocTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkEffortAssocTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkEffortAssocTypeID: %w", err)
	}
	return oldValue.WorkEffortAssocTypeID, nil
}

// AddWorkEffortAssocTypeID adds i to the "work_effort_assoc_type_id" field.
func (m *WorkEffortAssocMutation) AddWorkEffortAssocTypeID(i int) {
	if m.addwork_effort_assoc_type_id != nil {
		*m.addwork_effort_assoc_type_id += i
	} else {
		m.addwork_effort_assoc_type_id = &i
	}
}

// AddedWorkEffortAssocTypeID returns the value that was added to the "work_effort_assoc_type_id" field in this mutation.
func (m *WorkEffortAssocMutation) AddedWorkEffortAssocTypeID() (r int, exists bool) {
	v := m.addwork_effort_assoc_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkEffortAssocTypeID resets all changes to the "work_effort_assoc_type_id" field.
func (m *WorkEffortAssocMutation) ResetWorkEffortAssocTypeID() {
	m.work_effort_assoc_type_id = nil
	m.addwork_effort_assoc_type_id = nil
}

// SetSequenceNum sets the "sequence_num" field.
func (m *WorkEffortAssocMutation) SetSequenceNum(i int) {
	m.sequence_num = &i
	m.addsequence_num = nil
}

// SequenceNum returns the value of the "sequence_num" field in the mutation.
func (m *WorkEffortAssocMutation) SequenceNum() (r int, exists bool) {
	v := m.sequence_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNum returns the old "sequence_num" field's value of the WorkEffortAssoc entity.
// If the WorkEffortAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortAssocMutation) OldSequenceNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNum: %w", err)
	}
	return oldValue.SequenceNum, nil
}

// AddSequenceNum adds i to the "sequence_num" field.
func (m *WorkEffortAssocMutation) AddSequenceNum(i int) {
	if m.addsequence_num != nil {
		*m.addsequence_num += i
	} else {
		m.addsequence_num = &i
	}
}

// AddedSequenceNum returns the value that was added to the "sequence_num" field in this mutation.
func (m *WorkEffortAssocMutation) AddedSequenceNum() (r int, exists bool) {
	v := m.addsequence_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNum clears the value of the "sequence_num" field.
func (m *WorkEffortAssocMutation) ClearSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	m.clearedFields[workeffortassoc.FieldSequenceNum] = struct{}{}
}

// SequenceNumCleared returns if the "sequence_num" field was cleared in this mutation.
func (m *WorkEffortAssocMutation) SequenceNumCleared() bool {
	_, ok := m.clearedFields[workeffortassoc.FieldSequenceNum]
	return ok
}

// ResetSequenceNum resets all changes to the "sequence_num" field.
func (m *WorkEffortAssocMutation) ResetSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	delete(m.clearedFields, workeffortassoc.FieldSequenceNum)
}

// SetFromDate sets the "from_date" field.
func (m *WorkEffortAssocMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *WorkEffortAssocMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the WorkEffortAssoc entity.
// If the WorkEffortAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortAssocMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *WorkEffortAssocMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *WorkEffortAssocMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *WorkEffortAssocMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the WorkEffortAssoc entity.
// If the WorkEffortAssoc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortAssocMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *WorkEffortAssocMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[workeffortassoc.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *WorkEffortAssocMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[workeffortassoc.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *WorkEffortAssocMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, workeffortassoc.FieldThruDate)
}

// SetFromWorkEffortID sets the "from_work_effort" edge to the WorkEffort entity by id.
func (m *WorkEffortAssocMutation) SetFromWorkEffortID(id int) {
	m.from_work_effort = &id
}

// ClearFromWorkEffort clears the "from_work_effort" edge to the WorkEffort entity.
func (m *WorkEffortAssocMutation) ClearFromWorkEffort() {
	m.clearedfrom_work_effort = true
}

// FromWorkEffortCleared reports if the "from_work_effort" edge to the WorkEffort entity was cleared.
func (m *WorkEffortAssocMutation) FromWorkEffortCleared() bool {
	return m.clearedfrom_work_effort
}

// FromWorkEffortID returns the "from_work_effort" edge ID in the mutation.
func (m *WorkEffortAssocMutation) FromWorkEffortID() (id int, exists bool) {
	if m.from_work_effort != nil {
		return *m.from_work_effort, true
	}
	return
}

// FromWorkEffortIDs returns the "from_work_effort" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromWorkEffortID instead. It exists only for internal usage by the builders.
func (m *WorkEffortAssocMutation) FromWorkEffortIDs() (ids []int) {
	if id := m.from_work_effort; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromWorkEffort resets all changes to the "from_work_effort" edge.
func (m *WorkEffortAssocMutation) ResetFromWorkEffort() {
	m.from_work_effort = nil
	m.clearedfrom_work_effort = false
}

// SetToWorkEffortID sets the "to_work_effort" edge to the WorkEffort entity by id.
func (m *WorkEffortAssocMutation) SetToWorkEffortID(id int) {
	m.to_work_effort = &id
}

// ClearToWorkEffort clears the "to_work_effort" edge to the WorkEffort entity.
func (m *WorkEffortAssocMutation) ClearToWorkEffort() {
	m.clearedto_work_effort = true
}

// ToWorkEffortCleared reports if the "to_work_effort" edge to the WorkEffort entity was cleared.
func (m *WorkEffortAssocMutation) ToWorkEffortCleared() bool {
	return m.clearedto_work_effort
}

// ToWorkEffortID returns the "to_work_effort" edge ID in the mutation.
func (m *WorkEffortAssocMutation) ToWorkEffortID() (id int, exists bool) {
	if m.to_work_effort != nil {
		return *m.to_work_effort, true
	}
	return
}

// ToWorkEffortIDs returns the "to_work_effort" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToWorkEffortID instead. It exists only for internal usage by the builders.
func (m *WorkEffortAssocMutation) ToWorkEffortIDs() (ids []int) {
	if id := m.to_work_effort; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToWorkEffort resets all changes to the "to_work_effort" edge.
func (m *WorkEffortAssocMutation) ResetToWorkEffort() {
	m.to_work_effort = nil
	m.clearedto_work_effort = false
}

// Op returns the operation name.
func (m *WorkEffortAssocMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkEffortAssoc).
func (m *WorkEffortAssocMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkEffortAssocMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.work_effort_assoc_type_id != nil {
		fields = append(fields, workeffortassoc.FieldWorkEffortAssocTypeID)
	}
	if m.sequence_num != nil {
		fields = append(fields, workeffortassoc.FieldSequenceNum)
	}
	if m.from_date != nil {
		fields = append(fields, workeffortassoc.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, workeffortassoc.FieldThruDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkEffortAssocMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workeffortassoc.FieldWorkEffortAssocTypeID:
		return m.WorkEffortAssocTypeID()
	case workeffortassoc.FieldSequenceNum:
		return m.SequenceNum()
	case workeffortassoc.FieldFromDate:
		return m.FromDate()
	case workeffortassoc.FieldThruDate:
		return m.ThruDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkEffortAssocMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workeffortassoc.FieldWorkEffortAssocTypeID:
		return m.OldWorkEffortAssocTypeID(ctx)
	case workeffortassoc.FieldSequenceNum:
		return m.OldSequenceNum(ctx)
	case workeffortassoc.FieldFromDate:
		return m.OldFromDate(ctx)
	case workeffortassoc.FieldThruDate:
		return m.OldThruDate(ctx)
	}
	return nil, fmt.Errorf("unknown WorkEffortAssoc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortAssocMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workeffortassoc.FieldWorkEffortAssocTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkEffortAssocTypeID(v)
		return nil
	case workeffortassoc.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNum(v)
		return nil
	case workeffortassoc.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case workeffortassoc.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffortAssoc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkEffortAssocMutation) AddedFields() []string {
	var fields []string
	if m.addwork_effort_assoc_type_id != nil {
		fields = append(fields, workeffortassoc.FieldWorkEffortAssocTypeID)
	}
	if m.addsequence_num != nil {
		fields = append(fields, workeffortassoc.FieldSequenceNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkEffortAssocMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workeffortassoc.FieldWorkEffortAssocTypeID:
		return m.AddedWorkEffortAssocTypeID()
	case workeffortassoc.FieldSequenceNum:
		return m.AddedSequenceNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortAssocMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workeffortassoc.FieldWorkEffortAssocTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkEffortAssocTypeID(v)
		return nil
	case workeffortassoc.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNum(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffortAssoc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkEffortAssocMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workeffortassoc.FieldSequenceNum) {
		fields = append(fields, workeffortassoc.FieldSequenceNum)
	}
	if m.FieldCleared(workeffortassoc.FieldThruDate) {
		fields = append(fields, workeffortassoc.FieldThruDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkEffortAssocMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkEffortAssocMutation) ClearField(name string) error {
	switch name {
	case workeffortassoc.FieldSequenceNum:
		m.ClearSequenceNum()
		return nil
	case workeffortassoc.FieldThruDate:
		m.ClearThruDate()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortAssoc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkEffortAssocMutation) ResetField(name string) error {
	switch name {
	case workeffortassoc.FieldWorkEffortAssocTypeID:
		m.ResetWorkEffortAssocTypeID()
		return nil
	case workeffortassoc.FieldSequenceNum:
		m.ResetSequenceNum()
		return nil
	case workeffortassoc.FieldFromDate:
		m.ResetFromDate()
		return nil
	case workeffortassoc.FieldThruDate:
		m.ResetThruDate()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortAssoc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkEffortAssocMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_work_effort != nil {
		edges = append(edges, workeffortassoc.EdgeFromWorkEffort)
	}
	if m.to_work_effort != nil {
		edges = append(edges, workeffortassoc.EdgeToWorkEffort)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkEffortAssocMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workeffortassoc.EdgeFromWorkEffort:
		if id := m.from_work_effort; id != nil {
			return []ent.Value{*id}
		}
	case workeffortassoc.EdgeToWorkEffort:
		if id := m.to_work_effort; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkEffortAssocMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkEffortAssocMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkEffortAssocMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_work_effort {
		edges = append(edges, workeffortassoc.EdgeFromWorkEffort)
	}
	if m.clearedto_work_effort {
		edges = append(edges, workeffortassoc.EdgeToWorkEffort)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkEffortAssocMutation) EdgeCleared(name string) bool {
	switch name {
	case workeffortassoc.EdgeFromWorkEffort:
		return m.clearedfrom_work_effort
	case workeffortassoc.EdgeToWorkEffort:
		return m.clearedto_work_effort
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkEffortAssocMutation) ClearEdge(name string) error {
	switch name {
	case workeffortassoc.EdgeFromWorkEffort:
		m.ClearFromWorkEffort()
		return nil
	case workeffortassoc.EdgeToWorkEffort:
		m.ClearToWorkEffort()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortAssoc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkEffortAssocMutation) ResetEdge(name string) error {
	switch name {
	case workeffortassoc.EdgeFromWorkEffort:
		m.ResetFromWorkEffort()
		return nil
	case workeffortassoc.EdgeToWorkEffort:
		m.ResetToWorkEffort()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortAssoc edge %s", name)
}

// WorkEffortFixedAssetAssignMutation represents an operation that mutates the WorkEffortFixedAssetAssign nodes in the graph.
type WorkEffortFixedAssetAssignMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	status_id                 *int
	addstatus_id              *int
	from_date                 *time.Time
	thru_date                 *time.Time
	availability_status_id    *int
	addavailability_status_id *int
	allocated_cost            *float64
	addallocated_cost         *float64
	comments                  *string
	clearedFields             map[string]struct{}
	work_effort               *int
	clearedwork_effort        bool
	fixed_asset               *int
	clearedfixed_asset        bool
	done                      bool
	oldValue                  func(context.Context) (*WorkEffortFixedAssetAssign, error)
	predicates                []predicate.WorkEffortFixedAssetAssign
}

var _ ent.Mutation = (*WorkEffortFixedAssetAssignMutation)(nil)

// workeffortfixedassetassignOption allows management of the mutation configuration using functional options.
type workeffortfixedassetassignOption func(*WorkEffortFixedAssetAssignMutation)

// newWorkEffortFixedAssetAssignMutation creates new mutation for the WorkEffortFixedAssetAssign entity.
func newWorkEffortFixedAssetAssignMutation(c config, op Op, opts ...workeffortfixedassetassignOption) *WorkEffortFixedAssetAssignMutation {
	m := &WorkEffortFixedAssetAssignMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkEffortFixedAssetAssign,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkEffortFixedAssetAssignID sets the ID field of the mutation.
func withWorkEffortFixedAssetAssignID(id int) workeffortfixedassetassignOption {
	return func(m *WorkEffortFixedAssetAssignMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkEffortFixedAssetAssign
		)
		m.oldValue = func(ctx context.Context) (*WorkEffortFixedAssetAssign, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkEffortFixedAssetAssign.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkEffortFixedAssetAssign sets the old WorkEffortFixedAssetAssign of the mutation.
func withWorkEffortFixedAssetAssign(node *WorkEffortFixedAssetAssign) workeffortfixedassetassignOption {
	return func(m *WorkEffortFixedAssetAssignMutation) {
		m.oldValue = func(context.Context) (*WorkEffortFixedAssetAssign, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkEffortFixedAssetAssignMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkEffortFixedAssetAssignMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkEffortFixedAssetAssignMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusID sets the "status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) SetStatusID(i int) {
	m.status_id = &i
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) StatusID() (r int, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the WorkEffortFixedAssetAssign entity.
// If the WorkEffortFixedAssetAssign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortFixedAssetAssignMutation) OldStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds i to the "status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) AddStatusID(i int) {
	if m.addstatus_id != nil {
		*m.addstatus_id += i
	} else {
		m.addstatus_id = &i
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AddedStatusID() (r int, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusID clears the value of the "status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) ClearStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	m.clearedFields[workeffortfixedassetassign.FieldStatusID] = struct{}{}
}

// StatusIDCleared returns if the "status_id" field was cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) StatusIDCleared() bool {
	_, ok := m.clearedFields[workeffortfixedassetassign.FieldStatusID]
	return ok
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	delete(m.clearedFields, workeffortfixedassetassign.FieldStatusID)
}

// SetFromDate sets the "from_date" field.
func (m *WorkEffortFixedAssetAssignMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the WorkEffortFixedAssetAssign entity.
// If the WorkEffortFixedAssetAssign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortFixedAssetAssignMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *WorkEffortFixedAssetAssignMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *WorkEffortFixedAssetAssignMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the WorkEffortFixedAssetAssign entity.
// If the WorkEffortFixedAssetAssign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortFixedAssetAssignMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *WorkEffortFixedAssetAssignMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[workeffortfixedassetassign.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[workeffortfixedassetassign.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *WorkEffortFixedAssetAssignMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, workeffortfixedassetassign.FieldThruDate)
}

// SetAvailabilityStatusID sets the "availability_status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) SetAvailabilityStatusID(i int) {
	m.availability_status_id = &i
	m.addavailability_status_id = nil
}

// AvailabilityStatusID returns the value of the "availability_status_id" field in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) AvailabilityStatusID() (r int, exists bool) {
	v := m.availability_status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailabilityStatusID returns the old "availability_status_id" field's value of the WorkEffortFixedAssetAssign entity.
// If the WorkEffortFixedAssetAssign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortFixedAssetAssignMutation) OldAvailabilityStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvailabilityStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvailabilityStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailabilityStatusID: %w", err)
	}
	return oldValue.AvailabilityStatusID, nil
}

// AddAvailabilityStatusID adds i to the "availability_status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) AddAvailabilityStatusID(i int) {
	if m.addavailability_status_id != nil {
		*m.addavailability_status_id += i
	} else {
		m.addavailability_status_id = &i
	}
}

// AddedAvailabilityStatusID returns the value that was added to the "availability_status_id" field in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AddedAvailabilityStatusID() (r int, exists bool) {
	v := m.addavailability_status_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvailabilityStatusID clears the value of the "availability_status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) ClearAvailabilityStatusID() {
	m.availability_status_id = nil
	m.addavailability_status_id = nil
	m.clearedFields[workeffortfixedassetassign.FieldAvailabilityStatusID] = struct{}{}
}

// AvailabilityStatusIDCleared returns if the "availability_status_id" field was cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AvailabilityStatusIDCleared() bool {
	_, ok := m.clearedFields[workeffortfixedassetassign.FieldAvailabilityStatusID]
	return ok
}

// ResetAvailabilityStatusID resets all changes to the "availability_status_id" field.
func (m *WorkEffortFixedAssetAssignMutation) ResetAvailabilityStatusID() {
	m.availability_status_id = nil
	m.addavailability_status_id = nil
	delete(m.clearedFields, workeffortfixedassetassign.FieldAvailabilityStatusID)
}

// SetAllocatedCost sets the "allocated_cost" field.
func (m *WorkEffortFixedAssetAssignMutation) SetAllocatedCost(f float64) {
	m.allocated_cost = &f
	m.addallocated_cost = nil
}

// AllocatedCost returns the value of the "allocated_cost" field in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) AllocatedCost() (r float64, exists bool) {
	v := m.allocated_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocatedCost returns the old "allocated_cost" field's value of the WorkEffortFixedAssetAssign entity.
// If the WorkEffortFixedAssetAssign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortFixedAssetAssignMutation) OldAllocatedCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAllocatedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAllocatedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocatedCost: %w", err)
	}
	return oldValue.AllocatedCost, nil
}

// AddAllocatedCost adds f to the "allocated_cost" field.
func (m *WorkEffortFixedAssetAssignMutation) AddAllocatedCost(f float64) {
	if m.addallocated_cost != nil {
		*m.addallocated_cost += f
	} else {
		m.addallocated_cost = &f
	}
}

// AddedAllocatedCost returns the value that was added to the "allocated_cost" field in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AddedAllocatedCost() (r float64, exists bool) {
	v := m.addallocated_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearAllocatedCost clears the value of the "allocated_cost" field.
func (m *WorkEffortFixedAssetAssignMutation) ClearAllocatedCost() {
	m.allocated_cost = nil
	m.addallocated_cost = nil
	m.clearedFields[workeffortfixedassetassign.FieldAllocatedCost] = struct{}{}
}

// AllocatedCostCleared returns if the "allocated_cost" field was cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AllocatedCostCleared() bool {
	_, ok := m.clearedFields[workeffortfixedassetassign.FieldAllocatedCost]
	return ok
}

// ResetAllocatedCost resets all changes to the "allocated_cost" field.
func (m *WorkEffortFixedAssetAssignMutation) ResetAllocatedCost() {
	m.allocated_cost = nil
	m.addallocated_cost = nil
	delete(m.clearedFields, workeffortfixedassetassign.FieldAllocatedCost)
}

// SetComments sets the "comments" field.
func (m *WorkEffortFixedAssetAssignMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the WorkEffortFixedAssetAssign entity.
// If the WorkEffortFixedAssetAssign object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortFixedAssetAssignMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *WorkEffortFixedAssetAssignMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[workeffortfixedassetassign.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[workeffortfixedassetassign.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *WorkEffortFixedAssetAssignMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, workeffortfixedassetassign.FieldComments)
}

// SetWorkEffortID sets the "work_effort" edge to the WorkEffort entity by id.
func (m *WorkEffortFixedAssetAssignMutation) SetWorkEffortID(id int) {
	m.work_effort = &id
}

// ClearWorkEffort clears the "work_effort" edge to the WorkEffort entity.
func (m *WorkEffortFixedAssetAssignMutation) ClearWorkEffort() {
	m.clearedwork_effort = true
}

// WorkEffortCleared reports if the "work_effort" edge to the WorkEffort entity was cleared.
func (m *WorkEffortFixedAssetAssignMutation) WorkEffortCleared() bool {
	return m.clearedwork_effort
}

// WorkEffortID returns the "work_effort" edge ID in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) WorkEffortID() (id int, exists bool) {
	if m.work_effort != nil {
		return *m.work_effort, true
	}
	return
}

// WorkEffortIDs returns the "work_effort" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkEffortID instead. It exists only for internal usage by the builders.
func (m *WorkEffortFixedAssetAssignMutation) WorkEffortIDs() (ids []int) {
	if id := m.work_effort; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkEffort resets all changes to the "work_effort" edge.
func (m *WorkEffortFixedAssetAssignMutation) ResetWorkEffort() {
	m.work_effort = nil
	m.clearedwork_effort = false
}

// SetFixedAssetID sets the "fixed_asset" edge to the FixedAsset entity by id.
func (m *WorkEffortFixedAssetAssignMutation) SetFixedAssetID(id int) {
	m.fixed_asset = &id
}

// ClearFixedAsset clears the "fixed_asset" edge to the FixedAsset entity.
func (m *WorkEffortFixedAssetAssignMutation) ClearFixedAsset() {
	m.clearedfixed_asset = true
}

// FixedAssetCleared reports if the "fixed_asset" edge to the FixedAsset entity was cleared.
func (m *WorkEffortFixedAssetAssignMutation) FixedAssetCleared() bool {
	return m.clearedfixed_asset
}

// FixedAssetID returns the "fixed_asset" edge ID in the mutation.
func (m *WorkEffortFixedAssetAssignMutation) FixedAssetID() (id int, exists bool) {
	if m.fixed_asset != nil {
		return *m.fixed_asset, true
	}
	return
}

// FixedAssetIDs returns the "fixed_asset" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FixedAssetID instead. It exists only for internal usage by the builders.
func (m *WorkEffortFixedAssetAssignMutation) FixedAssetIDs() (ids []int) {
	if id := m.fixed_asset; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFixedAsset resets all changes to the "fixed_asset" edge.
func (m *WorkEffortFixedAssetAssignMutation) ResetFixedAsset() {
	m.fixed_asset = nil
	m.clearedfixed_asset = false
}

// Op returns the operation name.
func (m *WorkEffortFixedAssetAssignMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkEffortFixedAssetAssign).
func (m *WorkEffortFixedAssetAssignMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkEffortFixedAssetAssignMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.status_id != nil {
		fields = append(fields, workeffortfixedassetassign.FieldStatusID)
	}
	if m.from_date != nil {
		fields = append(fields, workeffortfixedassetassign.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, workeffortfixedassetassign.FieldThruDate)
	}
	if m.availability_status_id != nil {
		fields = append(fields, workeffortfixedassetassign.FieldAvailabilityStatusID)
	}
	if m.allocated_cost != nil {
		fields = append(fields, workeffortfixedassetassign.FieldAllocatedCost)
	}
	if m.comments != nil {
		fields = append(fields, workeffortfixedassetassign.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkEffortFixedAssetAssignMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		return m.StatusID()
	case workeffortfixedassetassign.FieldFromDate:
		return m.FromDate()
	case workeffortfixedassetassign.FieldThruDate:
		return m.ThruDate()
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		return m.AvailabilityStatusID()
	case workeffortfixedassetassign.FieldAllocatedCost:
		return m.AllocatedCost()
	case workeffortfixedassetassign.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkEffortFixedAssetAssignMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		return m.OldStatusID(ctx)
	case workeffortfixedassetassign.FieldFromDate:
		return m.OldFromDate(ctx)
	case workeffortfixedassetassign.FieldThruDate:
		return m.OldThruDate(ctx)
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		return m.OldAvailabilityStatusID(ctx)
	case workeffortfixedassetassign.FieldAllocatedCost:
		return m.OldAllocatedCost(ctx)
	case workeffortfixedassetassign.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown WorkEffortFixedAssetAssign field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortFixedAssetAssignMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	case workeffortfixedassetassign.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case workeffortfixedassetassign.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailabilityStatusID(v)
		return nil
	case workeffortfixedassetassign.FieldAllocatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocatedCost(v)
		return nil
	case workeffortfixedassetassign.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffortFixedAssetAssign field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_id != nil {
		fields = append(fields, workeffortfixedassetassign.FieldStatusID)
	}
	if m.addavailability_status_id != nil {
		fields = append(fields, workeffortfixedassetassign.FieldAvailabilityStatusID)
	}
	if m.addallocated_cost != nil {
		fields = append(fields, workeffortfixedassetassign.FieldAllocatedCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkEffortFixedAssetAssignMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		return m.AddedStatusID()
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		return m.AddedAvailabilityStatusID()
	case workeffortfixedassetassign.FieldAllocatedCost:
		return m.AddedAllocatedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortFixedAssetAssignMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailabilityStatusID(v)
		return nil
	case workeffortfixedassetassign.FieldAllocatedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllocatedCost(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffortFixedAssetAssign numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkEffortFixedAssetAssignMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workeffortfixedassetassign.FieldStatusID) {
		fields = append(fields, workeffortfixedassetassign.FieldStatusID)
	}
	if m.FieldCleared(workeffortfixedassetassign.FieldThruDate) {
		fields = append(fields, workeffortfixedassetassign.FieldThruDate)
	}
	if m.FieldCleared(workeffortfixedassetassign.FieldAvailabilityStatusID) {
		fields = append(fields, workeffortfixedassetassign.FieldAvailabilityStatusID)
	}
	if m.FieldCleared(workeffortfixedassetassign.FieldAllocatedCost) {
		fields = append(fields, workeffortfixedassetassign.FieldAllocatedCost)
	}
	if m.FieldCleared(workeffortfixedassetassign.FieldComments) {
		fields = append(fields, workeffortfixedassetassign.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkEffortFixedAssetAssignMutation) ClearField(name string) error {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		m.ClearStatusID()
		return nil
	case workeffortfixedassetassign.FieldThruDate:
		m.ClearThruDate()
		return nil
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		m.ClearAvailabilityStatusID()
		return nil
	case workeffortfixedassetassign.FieldAllocatedCost:
		m.ClearAllocatedCost()
		return nil
	case workeffortfixedassetassign.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortFixedAssetAssign nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkEffortFixedAssetAssignMutation) ResetField(name string) error {
	switch name {
	case workeffortfixedassetassign.FieldStatusID:
		m.ResetStatusID()
		return nil
	case workeffortfixedassetassign.FieldFromDate:
		m.ResetFromDate()
		return nil
	case workeffortfixedassetassign.FieldThruDate:
		m.ResetThruDate()
		return nil
	case workeffortfixedassetassign.FieldAvailabilityStatusID:
		m.ResetAvailabilityStatusID()
		return nil
	case workeffortfixedassetassign.FieldAllocatedCost:
		m.ResetAllocatedCost()
		return nil
	case workeffortfixedassetassign.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortFixedAssetAssign field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.work_effort != nil {
		edges = append(edges, workeffortfixedassetassign.EdgeWorkEffort)
	}
	if m.fixed_asset != nil {
		edges = append(edges, workeffortfixedassetassign.EdgeFixedAsset)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workeffortfixedassetassign.EdgeWorkEffort:
		if id := m.work_effort; id != nil {
			return []ent.Value{*id}
		}
	case workeffortfixedassetassign.EdgeFixedAsset:
		if id := m.fixed_asset; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwork_effort {
		edges = append(edges, workeffortfixedassetassign.EdgeWorkEffort)
	}
	if m.clearedfixed_asset {
		edges = append(edges, workeffortfixedassetassign.EdgeFixedAsset)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkEffortFixedAssetAssignMutation) EdgeCleared(name string) bool {
	switch name {
	case workeffortfixedassetassign.EdgeWorkEffort:
		return m.clearedwork_effort
	case workeffortfixedassetassign.EdgeFixedAsset:
		return m.clearedfixed_asset
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkEffortFixedAssetAssignMutation) ClearEdge(name string) error {
	switch name {
	case workeffortfixedassetassign.EdgeWorkEffort:
		m.ClearWorkEffort()
		return nil
	case workeffortfixedassetassign.EdgeFixedAsset:
		m.ClearFixedAsset()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortFixedAssetAssign unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkEffortFixedAssetAssignMutation) ResetEdge(name string) error {
	switch name {
	case workeffortfixedassetassign.EdgeWorkEffort:
		m.ResetWorkEffort()
		return nil
	case workeffortfixedassetassign.EdgeFixedAsset:
		m.ResetFixedAsset()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortFixedAssetAssign edge %s", name)
}

// WorkEffortPartyAssignmentMutation represents an operation that mutates the WorkEffortPartyAssignment nodes in the graph.
type WorkEffortPartyAssignmentMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	role_type_id                  *int
	addrole_type_id               *int
	from_date                     *time.Time
	thru_date                     *time.Time
	status_id                     *int
	addstatus_id                  *int
	status_date_time              *time.Time
	expectation_enum_id           *int
	addexpectation_enum_id        *int
	delegate_reason_enum_id       *int
	adddelegate_reason_enum_id    *int
	facility_id                   *int
	addfacility_id                *int
	comments                      *string
	must_rsvp                     *workeffortpartyassignment.MustRsvp
	availability_status_id        *int
	addavailability_status_id     *int
	clearedFields                 map[string]struct{}
	work_effort                   *int
	clearedwork_effort            bool
	party                         *int
	clearedparty                  bool
	party_role                    *int
	clearedparty_role             bool
	assigned_by_user_login        *int
	clearedassigned_by_user_login bool
	done                          bool
	oldValue                      func(context.Context) (*WorkEffortPartyAssignment, error)
	predicates                    []predicate.WorkEffortPartyAssignment
}

var _ ent.Mutation = (*WorkEffortPartyAssignmentMutation)(nil)

// workeffortpartyassignmentOption allows management of the mutation configuration using functional options.
type workeffortpartyassignmentOption func(*WorkEffortPartyAssignmentMutation)

// newWorkEffortPartyAssignmentMutation creates new mutation for the WorkEffortPartyAssignment entity.
func newWorkEffortPartyAssignmentMutation(c config, op Op, opts ...workeffortpartyassignmentOption) *WorkEffortPartyAssignmentMutation {
	m := &WorkEffortPartyAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkEffortPartyAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkEffortPartyAssignmentID sets the ID field of the mutation.
func withWorkEffortPartyAssignmentID(id int) workeffortpartyassignmentOption {
	return func(m *WorkEffortPartyAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkEffortPartyAssignment
		)
		m.oldValue = func(ctx context.Context) (*WorkEffortPartyAssignment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkEffortPartyAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkEffortPartyAssignment sets the old WorkEffortPartyAssignment of the mutation.
func withWorkEffortPartyAssignment(node *WorkEffortPartyAssignment) workeffortpartyassignmentOption {
	return func(m *WorkEffortPartyAssignmentMutation) {
		m.oldValue = func(context.Context) (*WorkEffortPartyAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkEffortPartyAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkEffortPartyAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkEffortPartyAssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRoleTypeID sets the "role_type_id" field.
func (m *WorkEffortPartyAssignmentMutation) SetRoleTypeID(i int) {
	m.role_type_id = &i
	m.addrole_type_id = nil
}

// RoleTypeID returns the value of the "role_type_id" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) RoleTypeID() (r int, exists bool) {
	v := m.role_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleTypeID returns the old "role_type_id" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldRoleTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoleTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoleTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleTypeID: %w", err)
	}
	return oldValue.RoleTypeID, nil
}

// AddRoleTypeID adds i to the "role_type_id" field.
func (m *WorkEffortPartyAssignmentMutation) AddRoleTypeID(i int) {
	if m.addrole_type_id != nil {
		*m.addrole_type_id += i
	} else {
		m.addrole_type_id = &i
	}
}

// AddedRoleTypeID returns the value that was added to the "role_type_id" field in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedRoleTypeID() (r int, exists bool) {
	v := m.addrole_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleTypeID resets all changes to the "role_type_id" field.
func (m *WorkEffortPartyAssignmentMutation) ResetRoleTypeID() {
	m.role_type_id = nil
	m.addrole_type_id = nil
}

// SetFromDate sets the "from_date" field.
func (m *WorkEffortPartyAssignmentMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *WorkEffortPartyAssignmentMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *WorkEffortPartyAssignmentMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *WorkEffortPartyAssignmentMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[workeffortpartyassignment.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *WorkEffortPartyAssignmentMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldThruDate)
}

// SetStatusID sets the "status_id" field.
func (m *WorkEffortPartyAssignmentMutation) SetStatusID(i int) {
	m.status_id = &i
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) StatusID() (r int, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds i to the "status_id" field.
func (m *WorkEffortPartyAssignmentMutation) AddStatusID(i int) {
	if m.addstatus_id != nil {
		*m.addstatus_id += i
	} else {
		m.addstatus_id = &i
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedStatusID() (r int, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusID clears the value of the "status_id" field.
func (m *WorkEffortPartyAssignmentMutation) ClearStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	m.clearedFields[workeffortpartyassignment.FieldStatusID] = struct{}{}
}

// StatusIDCleared returns if the "status_id" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) StatusIDCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldStatusID]
	return ok
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *WorkEffortPartyAssignmentMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldStatusID)
}

// SetStatusDateTime sets the "status_date_time" field.
func (m *WorkEffortPartyAssignmentMutation) SetStatusDateTime(t time.Time) {
	m.status_date_time = &t
}

// StatusDateTime returns the value of the "status_date_time" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) StatusDateTime() (r time.Time, exists bool) {
	v := m.status_date_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDateTime returns the old "status_date_time" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldStatusDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDateTime: %w", err)
	}
	return oldValue.StatusDateTime, nil
}

// ClearStatusDateTime clears the value of the "status_date_time" field.
func (m *WorkEffortPartyAssignmentMutation) ClearStatusDateTime() {
	m.status_date_time = nil
	m.clearedFields[workeffortpartyassignment.FieldStatusDateTime] = struct{}{}
}

// StatusDateTimeCleared returns if the "status_date_time" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) StatusDateTimeCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldStatusDateTime]
	return ok
}

// ResetStatusDateTime resets all changes to the "status_date_time" field.
func (m *WorkEffortPartyAssignmentMutation) ResetStatusDateTime() {
	m.status_date_time = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldStatusDateTime)
}

// SetExpectationEnumID sets the "expectation_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) SetExpectationEnumID(i int) {
	m.expectation_enum_id = &i
	m.addexpectation_enum_id = nil
}

// ExpectationEnumID returns the value of the "expectation_enum_id" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) ExpectationEnumID() (r int, exists bool) {
	v := m.expectation_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectationEnumID returns the old "expectation_enum_id" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldExpectationEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpectationEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpectationEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectationEnumID: %w", err)
	}
	return oldValue.ExpectationEnumID, nil
}

// AddExpectationEnumID adds i to the "expectation_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) AddExpectationEnumID(i int) {
	if m.addexpectation_enum_id != nil {
		*m.addexpectation_enum_id += i
	} else {
		m.addexpectation_enum_id = &i
	}
}

// AddedExpectationEnumID returns the value that was added to the "expectation_enum_id" field in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedExpectationEnumID() (r int, exists bool) {
	v := m.addexpectation_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpectationEnumID clears the value of the "expectation_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) ClearExpectationEnumID() {
	m.expectation_enum_id = nil
	m.addexpectation_enum_id = nil
	m.clearedFields[workeffortpartyassignment.FieldExpectationEnumID] = struct{}{}
}

// ExpectationEnumIDCleared returns if the "expectation_enum_id" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) ExpectationEnumIDCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldExpectationEnumID]
	return ok
}

// ResetExpectationEnumID resets all changes to the "expectation_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) ResetExpectationEnumID() {
	m.expectation_enum_id = nil
	m.addexpectation_enum_id = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldExpectationEnumID)
}

// SetDelegateReasonEnumID sets the "delegate_reason_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) SetDelegateReasonEnumID(i int) {
	m.delegate_reason_enum_id = &i
	m.adddelegate_reason_enum_id = nil
}

// DelegateReasonEnumID returns the value of the "delegate_reason_enum_id" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) DelegateReasonEnumID() (r int, exists bool) {
	v := m.delegate_reason_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDelegateReasonEnumID returns the old "delegate_reason_enum_id" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldDelegateReasonEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDelegateReasonEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDelegateReasonEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDelegateReasonEnumID: %w", err)
	}
	return oldValue.DelegateReasonEnumID, nil
}

// AddDelegateReasonEnumID adds i to the "delegate_reason_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) AddDelegateReasonEnumID(i int) {
	if m.adddelegate_reason_enum_id != nil {
		*m.adddelegate_reason_enum_id += i
	} else {
		m.adddelegate_reason_enum_id = &i
	}
}

// AddedDelegateReasonEnumID returns the value that was added to the "delegate_reason_enum_id" field in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedDelegateReasonEnumID() (r int, exists bool) {
	v := m.adddelegate_reason_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDelegateReasonEnumID clears the value of the "delegate_reason_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) ClearDelegateReasonEnumID() {
	m.delegate_reason_enum_id = nil
	m.adddelegate_reason_enum_id = nil
	m.clearedFields[workeffortpartyassignment.FieldDelegateReasonEnumID] = struct{}{}
}

// DelegateReasonEnumIDCleared returns if the "delegate_reason_enum_id" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) DelegateReasonEnumIDCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldDelegateReasonEnumID]
	return ok
}

// ResetDelegateReasonEnumID resets all changes to the "delegate_reason_enum_id" field.
func (m *WorkEffortPartyAssignmentMutation) ResetDelegateReasonEnumID() {
	m.delegate_reason_enum_id = nil
	m.adddelegate_reason_enum_id = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldDelegateReasonEnumID)
}

// SetFacilityID sets the "facility_id" field.
func (m *WorkEffortPartyAssignmentMutation) SetFacilityID(i int) {
	m.facility_id = &i
	m.addfacility_id = nil
}

// FacilityID returns the value of the "facility_id" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) FacilityID() (r int, exists bool) {
	v := m.facility_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFacilityID returns the old "facility_id" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldFacilityID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFacilityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFacilityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFacilityID: %w", err)
	}
	return oldValue.FacilityID, nil
}

// AddFacilityID adds i to the "facility_id" field.
func (m *WorkEffortPartyAssignmentMutation) AddFacilityID(i int) {
	if m.addfacility_id != nil {
		*m.addfacility_id += i
	} else {
		m.addfacility_id = &i
	}
}

// AddedFacilityID returns the value that was added to the "facility_id" field in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedFacilityID() (r int, exists bool) {
	v := m.addfacility_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFacilityID clears the value of the "facility_id" field.
func (m *WorkEffortPartyAssignmentMutation) ClearFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	m.clearedFields[workeffortpartyassignment.FieldFacilityID] = struct{}{}
}

// FacilityIDCleared returns if the "facility_id" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) FacilityIDCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldFacilityID]
	return ok
}

// ResetFacilityID resets all changes to the "facility_id" field.
func (m *WorkEffortPartyAssignmentMutation) ResetFacilityID() {
	m.facility_id = nil
	m.addfacility_id = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldFacilityID)
}

// SetComments sets the "comments" field.
func (m *WorkEffortPartyAssignmentMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *WorkEffortPartyAssignmentMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[workeffortpartyassignment.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *WorkEffortPartyAssignmentMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldComments)
}

// SetMustRsvp sets the "must_rsvp" field.
func (m *WorkEffortPartyAssignmentMutation) SetMustRsvp(wr workeffortpartyassignment.MustRsvp) {
	m.must_rsvp = &wr
}

// MustRsvp returns the value of the "must_rsvp" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) MustRsvp() (r workeffortpartyassignment.MustRsvp, exists bool) {
	v := m.must_rsvp
	if v == nil {
		return
	}
	return *v, true
}

// OldMustRsvp returns the old "must_rsvp" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldMustRsvp(ctx context.Context) (v workeffortpartyassignment.MustRsvp, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMustRsvp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMustRsvp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMustRsvp: %w", err)
	}
	return oldValue.MustRsvp, nil
}

// ClearMustRsvp clears the value of the "must_rsvp" field.
func (m *WorkEffortPartyAssignmentMutation) ClearMustRsvp() {
	m.must_rsvp = nil
	m.clearedFields[workeffortpartyassignment.FieldMustRsvp] = struct{}{}
}

// MustRsvpCleared returns if the "must_rsvp" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) MustRsvpCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldMustRsvp]
	return ok
}

// ResetMustRsvp resets all changes to the "must_rsvp" field.
func (m *WorkEffortPartyAssignmentMutation) ResetMustRsvp() {
	m.must_rsvp = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldMustRsvp)
}

// SetAvailabilityStatusID sets the "availability_status_id" field.
func (m *WorkEffortPartyAssignmentMutation) SetAvailabilityStatusID(i int) {
	m.availability_status_id = &i
	m.addavailability_status_id = nil
}

// AvailabilityStatusID returns the value of the "availability_status_id" field in the mutation.
func (m *WorkEffortPartyAssignmentMutation) AvailabilityStatusID() (r int, exists bool) {
	v := m.availability_status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailabilityStatusID returns the old "availability_status_id" field's value of the WorkEffortPartyAssignment entity.
// If the WorkEffortPartyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkEffortPartyAssignmentMutation) OldAvailabilityStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvailabilityStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvailabilityStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailabilityStatusID: %w", err)
	}
	return oldValue.AvailabilityStatusID, nil
}

// AddAvailabilityStatusID adds i to the "availability_status_id" field.
func (m *WorkEffortPartyAssignmentMutation) AddAvailabilityStatusID(i int) {
	if m.addavailability_status_id != nil {
		*m.addavailability_status_id += i
	} else {
		m.addavailability_status_id = &i
	}
}

// AddedAvailabilityStatusID returns the value that was added to the "availability_status_id" field in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedAvailabilityStatusID() (r int, exists bool) {
	v := m.addavailability_status_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvailabilityStatusID clears the value of the "availability_status_id" field.
func (m *WorkEffortPartyAssignmentMutation) ClearAvailabilityStatusID() {
	m.availability_status_id = nil
	m.addavailability_status_id = nil
	m.clearedFields[workeffortpartyassignment.FieldAvailabilityStatusID] = struct{}{}
}

// AvailabilityStatusIDCleared returns if the "availability_status_id" field was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AvailabilityStatusIDCleared() bool {
	_, ok := m.clearedFields[workeffortpartyassignment.FieldAvailabilityStatusID]
	return ok
}

// ResetAvailabilityStatusID resets all changes to the "availability_status_id" field.
func (m *WorkEffortPartyAssignmentMutation) ResetAvailabilityStatusID() {
	m.availability_status_id = nil
	m.addavailability_status_id = nil
	delete(m.clearedFields, workeffortpartyassignment.FieldAvailabilityStatusID)
}

// SetWorkEffortID sets the "work_effort" edge to the WorkEffort entity by id.
func (m *WorkEffortPartyAssignmentMutation) SetWorkEffortID(id int) {
	m.work_effort = &id
}

// ClearWorkEffort clears the "work_effort" edge to the WorkEffort entity.
func (m *WorkEffortPartyAssignmentMutation) ClearWorkEffort() {
	m.clearedwork_effort = true
}

// WorkEffortCleared reports if the "work_effort" edge to the WorkEffort entity was cleared.
func (m *WorkEffortPartyAssignmentMutation) WorkEffortCleared() bool {
	return m.clearedwork_effort
}

// WorkEffortID returns the "work_effort" edge ID in the mutation.
func (m *WorkEffortPartyAssignmentMutation) WorkEffortID() (id int, exists bool) {
	if m.work_effort != nil {
		return *m.work_effort, true
	}
	return
}

// WorkEffortIDs returns the "work_effort" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkEffortID instead. It exists only for internal usage by the builders.
func (m *WorkEffortPartyAssignmentMutation) WorkEffortIDs() (ids []int) {
	if id := m.work_effort; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkEffort resets all changes to the "work_effort" edge.
func (m *WorkEffortPartyAssignmentMutation) ResetWorkEffort() {
	m.work_effort = nil
	m.clearedwork_effort = false
}

// SetPartyID sets the "party" edge to the Party entity by id.
func (m *WorkEffortPartyAssignmentMutation) SetPartyID(id int) {
	m.party = &id
}

// ClearParty clears the "party" edge to the Party entity.
func (m *WorkEffortPartyAssignmentMutation) ClearParty() {
	m.clearedparty = true
}

// PartyCleared reports if the "party" edge to the Party entity was cleared.
func (m *WorkEffortPartyAssignmentMutation) PartyCleared() bool {
	return m.clearedparty
}

// PartyID returns the "party" edge ID in the mutation.
func (m *WorkEffortPartyAssignmentMutation) PartyID() (id int, exists bool) {
	if m.party != nil {
		return *m.party, true
	}
	return
}

// PartyIDs returns the "party" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyID instead. It exists only for internal usage by the builders.
func (m *WorkEffortPartyAssignmentMutation) PartyIDs() (ids []int) {
	if id := m.party; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParty resets all changes to the "party" edge.
func (m *WorkEffortPartyAssignmentMutation) ResetParty() {
	m.party = nil
	m.clearedparty = false
}

// SetPartyRoleID sets the "party_role" edge to the PartyRole entity by id.
func (m *WorkEffortPartyAssignmentMutation) SetPartyRoleID(id int) {
	m.party_role = &id
}

// ClearPartyRole clears the "party_role" edge to the PartyRole entity.
func (m *WorkEffortPartyAssignmentMutation) ClearPartyRole() {
	m.clearedparty_role = true
}

// PartyRoleCleared reports if the "party_role" edge to the PartyRole entity was cleared.
func (m *WorkEffortPartyAssignmentMutation) PartyRoleCleared() bool {
	return m.clearedparty_role
}

// PartyRoleID returns the "party_role" edge ID in the mutation.
func (m *WorkEffortPartyAssignmentMutation) PartyRoleID() (id int, exists bool) {
	if m.party_role != nil {
		return *m.party_role, true
	}
	return
}

// PartyRoleIDs returns the "party_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartyRoleID instead. It exists only for internal usage by the builders.
func (m *WorkEffortPartyAssignmentMutation) PartyRoleIDs() (ids []int) {
	if id := m.party_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartyRole resets all changes to the "party_role" edge.
func (m *WorkEffortPartyAssignmentMutation) ResetPartyRole() {
	m.party_role = nil
	m.clearedparty_role = false
}

// SetAssignedByUserLoginID sets the "assigned_by_user_login" edge to the UserLogin entity by id.
func (m *WorkEffortPartyAssignmentMutation) SetAssignedByUserLoginID(id int) {
	m.assigned_by_user_login = &id
}

// ClearAssignedByUserLogin clears the "assigned_by_user_login" edge to the UserLogin entity.
func (m *WorkEffortPartyAssignmentMutation) ClearAssignedByUserLogin() {
	m.clearedassigned_by_user_login = true
}

// AssignedByUserLoginCleared reports if the "assigned_by_user_login" edge to the UserLogin entity was cleared.
func (m *WorkEffortPartyAssignmentMutation) AssignedByUserLoginCleared() bool {
	return m.clearedassigned_by_user_login
}

// AssignedByUserLoginID returns the "assigned_by_user_login" edge ID in the mutation.
func (m *WorkEffortPartyAssignmentMutation) AssignedByUserLoginID() (id int, exists bool) {
	if m.assigned_by_user_login != nil {
		return *m.assigned_by_user_login, true
	}
	return
}

// AssignedByUserLoginIDs returns the "assigned_by_user_login" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByUserLoginID instead. It exists only for internal usage by the builders.
func (m *WorkEffortPartyAssignmentMutation) AssignedByUserLoginIDs() (ids []int) {
	if id := m.assigned_by_user_login; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedByUserLogin resets all changes to the "assigned_by_user_login" edge.
func (m *WorkEffortPartyAssignmentMutation) ResetAssignedByUserLogin() {
	m.assigned_by_user_login = nil
	m.clearedassigned_by_user_login = false
}

// Op returns the operation name.
func (m *WorkEffortPartyAssignmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkEffortPartyAssignment).
func (m *WorkEffortPartyAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkEffortPartyAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.role_type_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldRoleTypeID)
	}
	if m.from_date != nil {
		fields = append(fields, workeffortpartyassignment.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, workeffortpartyassignment.FieldThruDate)
	}
	if m.status_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldStatusID)
	}
	if m.status_date_time != nil {
		fields = append(fields, workeffortpartyassignment.FieldStatusDateTime)
	}
	if m.expectation_enum_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldExpectationEnumID)
	}
	if m.delegate_reason_enum_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldDelegateReasonEnumID)
	}
	if m.facility_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldFacilityID)
	}
	if m.comments != nil {
		fields = append(fields, workeffortpartyassignment.FieldComments)
	}
	if m.must_rsvp != nil {
		fields = append(fields, workeffortpartyassignment.FieldMustRsvp)
	}
	if m.availability_status_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldAvailabilityStatusID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkEffortPartyAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workeffortpartyassignment.FieldRoleTypeID:
		return m.RoleTypeID()
	case workeffortpartyassignment.FieldFromDate:
		return m.FromDate()
	case workeffortpartyassignment.FieldThruDate:
		return m.ThruDate()
	case workeffortpartyassignment.FieldStatusID:
		return m.StatusID()
	case workeffortpartyassignment.FieldStatusDateTime:
		return m.StatusDateTime()
	case workeffortpartyassignment.FieldExpectationEnumID:
		return m.ExpectationEnumID()
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		return m.DelegateReasonEnumID()
	case workeffortpartyassignment.FieldFacilityID:
		return m.FacilityID()
	case workeffortpartyassignment.FieldComments:
		return m.Comments()
	case workeffortpartyassignment.FieldMustRsvp:
		return m.MustRsvp()
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		return m.AvailabilityStatusID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkEffortPartyAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workeffortpartyassignment.FieldRoleTypeID:
		return m.OldRoleTypeID(ctx)
	case workeffortpartyassignment.FieldFromDate:
		return m.OldFromDate(ctx)
	case workeffortpartyassignment.FieldThruDate:
		return m.OldThruDate(ctx)
	case workeffortpartyassignment.FieldStatusID:
		return m.OldStatusID(ctx)
	case workeffortpartyassignment.FieldStatusDateTime:
		return m.OldStatusDateTime(ctx)
	case workeffortpartyassignment.FieldExpectationEnumID:
		return m.OldExpectationEnumID(ctx)
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		return m.OldDelegateReasonEnumID(ctx)
	case workeffortpartyassignment.FieldFacilityID:
		return m.OldFacilityID(ctx)
	case workeffortpartyassignment.FieldComments:
		return m.OldComments(ctx)
	case workeffortpartyassignment.FieldMustRsvp:
		return m.OldMustRsvp(ctx)
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		return m.OldAvailabilityStatusID(ctx)
	}
	return nil, fmt.Errorf("unknown WorkEffortPartyAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortPartyAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workeffortpartyassignment.FieldRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleTypeID(v)
		return nil
	case workeffortpartyassignment.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case workeffortpartyassignment.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	case workeffortpartyassignment.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	case workeffortpartyassignment.FieldStatusDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDateTime(v)
		return nil
	case workeffortpartyassignment.FieldExpectationEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectationEnumID(v)
		return nil
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDelegateReasonEnumID(v)
		return nil
	case workeffortpartyassignment.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFacilityID(v)
		return nil
	case workeffortpartyassignment.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case workeffortpartyassignment.FieldMustRsvp:
		v, ok := value.(workeffortpartyassignment.MustRsvp)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMustRsvp(v)
		return nil
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailabilityStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffortPartyAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addrole_type_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldRoleTypeID)
	}
	if m.addstatus_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldStatusID)
	}
	if m.addexpectation_enum_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldExpectationEnumID)
	}
	if m.adddelegate_reason_enum_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldDelegateReasonEnumID)
	}
	if m.addfacility_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldFacilityID)
	}
	if m.addavailability_status_id != nil {
		fields = append(fields, workeffortpartyassignment.FieldAvailabilityStatusID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkEffortPartyAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workeffortpartyassignment.FieldRoleTypeID:
		return m.AddedRoleTypeID()
	case workeffortpartyassignment.FieldStatusID:
		return m.AddedStatusID()
	case workeffortpartyassignment.FieldExpectationEnumID:
		return m.AddedExpectationEnumID()
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		return m.AddedDelegateReasonEnumID()
	case workeffortpartyassignment.FieldFacilityID:
		return m.AddedFacilityID()
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		return m.AddedAvailabilityStatusID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkEffortPartyAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workeffortpartyassignment.FieldRoleTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleTypeID(v)
		return nil
	case workeffortpartyassignment.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	case workeffortpartyassignment.FieldExpectationEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpectationEnumID(v)
		return nil
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDelegateReasonEnumID(v)
		return nil
	case workeffortpartyassignment.FieldFacilityID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFacilityID(v)
		return nil
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailabilityStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkEffortPartyAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkEffortPartyAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workeffortpartyassignment.FieldThruDate) {
		fields = append(fields, workeffortpartyassignment.FieldThruDate)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldStatusID) {
		fields = append(fields, workeffortpartyassignment.FieldStatusID)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldStatusDateTime) {
		fields = append(fields, workeffortpartyassignment.FieldStatusDateTime)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldExpectationEnumID) {
		fields = append(fields, workeffortpartyassignment.FieldExpectationEnumID)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldDelegateReasonEnumID) {
		fields = append(fields, workeffortpartyassignment.FieldDelegateReasonEnumID)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldFacilityID) {
		fields = append(fields, workeffortpartyassignment.FieldFacilityID)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldComments) {
		fields = append(fields, workeffortpartyassignment.FieldComments)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldMustRsvp) {
		fields = append(fields, workeffortpartyassignment.FieldMustRsvp)
	}
	if m.FieldCleared(workeffortpartyassignment.FieldAvailabilityStatusID) {
		fields = append(fields, workeffortpartyassignment.FieldAvailabilityStatusID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkEffortPartyAssignmentMutation) ClearField(name string) error {
	switch name {
	case workeffortpartyassignment.FieldThruDate:
		m.ClearThruDate()
		return nil
	case workeffortpartyassignment.FieldStatusID:
		m.ClearStatusID()
		return nil
	case workeffortpartyassignment.FieldStatusDateTime:
		m.ClearStatusDateTime()
		return nil
	case workeffortpartyassignment.FieldExpectationEnumID:
		m.ClearExpectationEnumID()
		return nil
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		m.ClearDelegateReasonEnumID()
		return nil
	case workeffortpartyassignment.FieldFacilityID:
		m.ClearFacilityID()
		return nil
	case workeffortpartyassignment.FieldComments:
		m.ClearComments()
		return nil
	case workeffortpartyassignment.FieldMustRsvp:
		m.ClearMustRsvp()
		return nil
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		m.ClearAvailabilityStatusID()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortPartyAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkEffortPartyAssignmentMutation) ResetField(name string) error {
	switch name {
	case workeffortpartyassignment.FieldRoleTypeID:
		m.ResetRoleTypeID()
		return nil
	case workeffortpartyassignment.FieldFromDate:
		m.ResetFromDate()
		return nil
	case workeffortpartyassignment.FieldThruDate:
		m.ResetThruDate()
		return nil
	case workeffortpartyassignment.FieldStatusID:
		m.ResetStatusID()
		return nil
	case workeffortpartyassignment.FieldStatusDateTime:
		m.ResetStatusDateTime()
		return nil
	case workeffortpartyassignment.FieldExpectationEnumID:
		m.ResetExpectationEnumID()
		return nil
	case workeffortpartyassignment.FieldDelegateReasonEnumID:
		m.ResetDelegateReasonEnumID()
		return nil
	case workeffortpartyassignment.FieldFacilityID:
		m.ResetFacilityID()
		return nil
	case workeffortpartyassignment.FieldComments:
		m.ResetComments()
		return nil
	case workeffortpartyassignment.FieldMustRsvp:
		m.ResetMustRsvp()
		return nil
	case workeffortpartyassignment.FieldAvailabilityStatusID:
		m.ResetAvailabilityStatusID()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortPartyAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.work_effort != nil {
		edges = append(edges, workeffortpartyassignment.EdgeWorkEffort)
	}
	if m.party != nil {
		edges = append(edges, workeffortpartyassignment.EdgeParty)
	}
	if m.party_role != nil {
		edges = append(edges, workeffortpartyassignment.EdgePartyRole)
	}
	if m.assigned_by_user_login != nil {
		edges = append(edges, workeffortpartyassignment.EdgeAssignedByUserLogin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkEffortPartyAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workeffortpartyassignment.EdgeWorkEffort:
		if id := m.work_effort; id != nil {
			return []ent.Value{*id}
		}
	case workeffortpartyassignment.EdgeParty:
		if id := m.party; id != nil {
			return []ent.Value{*id}
		}
	case workeffortpartyassignment.EdgePartyRole:
		if id := m.party_role; id != nil {
			return []ent.Value{*id}
		}
	case workeffortpartyassignment.EdgeAssignedByUserLogin:
		if id := m.assigned_by_user_login; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkEffortPartyAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkEffortPartyAssignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedwork_effort {
		edges = append(edges, workeffortpartyassignment.EdgeWorkEffort)
	}
	if m.clearedparty {
		edges = append(edges, workeffortpartyassignment.EdgeParty)
	}
	if m.clearedparty_role {
		edges = append(edges, workeffortpartyassignment.EdgePartyRole)
	}
	if m.clearedassigned_by_user_login {
		edges = append(edges, workeffortpartyassignment.EdgeAssignedByUserLogin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkEffortPartyAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case workeffortpartyassignment.EdgeWorkEffort:
		return m.clearedwork_effort
	case workeffortpartyassignment.EdgeParty:
		return m.clearedparty
	case workeffortpartyassignment.EdgePartyRole:
		return m.clearedparty_role
	case workeffortpartyassignment.EdgeAssignedByUserLogin:
		return m.clearedassigned_by_user_login
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkEffortPartyAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case workeffortpartyassignment.EdgeWorkEffort:
		m.ClearWorkEffort()
		return nil
	case workeffortpartyassignment.EdgeParty:
		m.ClearParty()
		return nil
	case workeffortpartyassignment.EdgePartyRole:
		m.ClearPartyRole()
		return nil
	case workeffortpartyassignment.EdgeAssignedByUserLogin:
		m.ClearAssignedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortPartyAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkEffortPartyAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case workeffortpartyassignment.EdgeWorkEffort:
		m.ResetWorkEffort()
		return nil
	case workeffortpartyassignment.EdgeParty:
		m.ResetParty()
		return nil
	case workeffortpartyassignment.EdgePartyRole:
		m.ResetPartyRole()
		return nil
	case workeffortpartyassignment.EdgeAssignedByUserLogin:
		m.ResetAssignedByUserLogin()
		return nil
	}
	return fmt.Errorf("unknown WorkEffortPartyAssignment edge %s", name)
}
