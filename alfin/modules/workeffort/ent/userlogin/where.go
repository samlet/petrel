// Code generated by entc, DO NOT EDIT.

package userlogin

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/samlet/petrel/alfin/modules/workeffort/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// CurrentPassword applies equality check predicate on the "current_password" field. It's identical to CurrentPasswordEQ.
func CurrentPassword(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCurrentPassword), v))
	})
}

// PasswordHint applies equality check predicate on the "password_hint" field. It's identical to PasswordHintEQ.
func PasswordHint(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPasswordHint), v))
	})
}

// LastCurrencyUom applies equality check predicate on the "last_currency_uom" field. It's identical to LastCurrencyUomEQ.
func LastCurrencyUom(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastCurrencyUom), v))
	})
}

// LastLocale applies equality check predicate on the "last_locale" field. It's identical to LastLocaleEQ.
func LastLocale(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastLocale), v))
	})
}

// LastTimeZone applies equality check predicate on the "last_time_zone" field. It's identical to LastTimeZoneEQ.
func LastTimeZone(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastTimeZone), v))
	})
}

// DisabledDateTime applies equality check predicate on the "disabled_date_time" field. It's identical to DisabledDateTimeEQ.
func DisabledDateTime(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDisabledDateTime), v))
	})
}

// SuccessiveFailedLogins applies equality check predicate on the "successive_failed_logins" field. It's identical to SuccessiveFailedLoginsEQ.
func SuccessiveFailedLogins(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// ExternalAuthID applies equality check predicate on the "external_auth_id" field. It's identical to ExternalAuthIDEQ.
func ExternalAuthID(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExternalAuthID), v))
	})
}

// UserLdapDn applies equality check predicate on the "user_ldap_dn" field. It's identical to UserLdapDnEQ.
func UserLdapDn(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserLdapDn), v))
	})
}

// DisabledBy applies equality check predicate on the "disabled_by" field. It's identical to DisabledByEQ.
func DisabledBy(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDisabledBy), v))
	})
}

// CurrentPasswordEQ applies the EQ predicate on the "current_password" field.
func CurrentPasswordEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordNEQ applies the NEQ predicate on the "current_password" field.
func CurrentPasswordNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordIn applies the In predicate on the "current_password" field.
func CurrentPasswordIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCurrentPassword), v...))
	})
}

// CurrentPasswordNotIn applies the NotIn predicate on the "current_password" field.
func CurrentPasswordNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCurrentPassword), v...))
	})
}

// CurrentPasswordGT applies the GT predicate on the "current_password" field.
func CurrentPasswordGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordGTE applies the GTE predicate on the "current_password" field.
func CurrentPasswordGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordLT applies the LT predicate on the "current_password" field.
func CurrentPasswordLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordLTE applies the LTE predicate on the "current_password" field.
func CurrentPasswordLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordContains applies the Contains predicate on the "current_password" field.
func CurrentPasswordContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordHasPrefix applies the HasPrefix predicate on the "current_password" field.
func CurrentPasswordHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordHasSuffix applies the HasSuffix predicate on the "current_password" field.
func CurrentPasswordHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordIsNil applies the IsNil predicate on the "current_password" field.
func CurrentPasswordIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCurrentPassword)))
	})
}

// CurrentPasswordNotNil applies the NotNil predicate on the "current_password" field.
func CurrentPasswordNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCurrentPassword)))
	})
}

// CurrentPasswordEqualFold applies the EqualFold predicate on the "current_password" field.
func CurrentPasswordEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCurrentPassword), v))
	})
}

// CurrentPasswordContainsFold applies the ContainsFold predicate on the "current_password" field.
func CurrentPasswordContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCurrentPassword), v))
	})
}

// PasswordHintEQ applies the EQ predicate on the "password_hint" field.
func PasswordHintEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintNEQ applies the NEQ predicate on the "password_hint" field.
func PasswordHintNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintIn applies the In predicate on the "password_hint" field.
func PasswordHintIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPasswordHint), v...))
	})
}

// PasswordHintNotIn applies the NotIn predicate on the "password_hint" field.
func PasswordHintNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPasswordHint), v...))
	})
}

// PasswordHintGT applies the GT predicate on the "password_hint" field.
func PasswordHintGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintGTE applies the GTE predicate on the "password_hint" field.
func PasswordHintGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintLT applies the LT predicate on the "password_hint" field.
func PasswordHintLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintLTE applies the LTE predicate on the "password_hint" field.
func PasswordHintLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintContains applies the Contains predicate on the "password_hint" field.
func PasswordHintContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintHasPrefix applies the HasPrefix predicate on the "password_hint" field.
func PasswordHintHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintHasSuffix applies the HasSuffix predicate on the "password_hint" field.
func PasswordHintHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintIsNil applies the IsNil predicate on the "password_hint" field.
func PasswordHintIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPasswordHint)))
	})
}

// PasswordHintNotNil applies the NotNil predicate on the "password_hint" field.
func PasswordHintNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPasswordHint)))
	})
}

// PasswordHintEqualFold applies the EqualFold predicate on the "password_hint" field.
func PasswordHintEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPasswordHint), v))
	})
}

// PasswordHintContainsFold applies the ContainsFold predicate on the "password_hint" field.
func PasswordHintContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPasswordHint), v))
	})
}

// IsSystemEQ applies the EQ predicate on the "is_system" field.
func IsSystemEQ(v IsSystem) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldIsSystem), v))
	})
}

// IsSystemNEQ applies the NEQ predicate on the "is_system" field.
func IsSystemNEQ(v IsSystem) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldIsSystem), v))
	})
}

// IsSystemIn applies the In predicate on the "is_system" field.
func IsSystemIn(vs ...IsSystem) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldIsSystem), v...))
	})
}

// IsSystemNotIn applies the NotIn predicate on the "is_system" field.
func IsSystemNotIn(vs ...IsSystem) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldIsSystem), v...))
	})
}

// IsSystemIsNil applies the IsNil predicate on the "is_system" field.
func IsSystemIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldIsSystem)))
	})
}

// IsSystemNotNil applies the NotNil predicate on the "is_system" field.
func IsSystemNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldIsSystem)))
	})
}

// EnabledEQ applies the EQ predicate on the "enabled" field.
func EnabledEQ(v Enabled) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEnabled), v))
	})
}

// EnabledNEQ applies the NEQ predicate on the "enabled" field.
func EnabledNEQ(v Enabled) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEnabled), v))
	})
}

// EnabledIn applies the In predicate on the "enabled" field.
func EnabledIn(vs ...Enabled) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEnabled), v...))
	})
}

// EnabledNotIn applies the NotIn predicate on the "enabled" field.
func EnabledNotIn(vs ...Enabled) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEnabled), v...))
	})
}

// EnabledIsNil applies the IsNil predicate on the "enabled" field.
func EnabledIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldEnabled)))
	})
}

// EnabledNotNil applies the NotNil predicate on the "enabled" field.
func EnabledNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldEnabled)))
	})
}

// HasLoggedOutEQ applies the EQ predicate on the "has_logged_out" field.
func HasLoggedOutEQ(v HasLoggedOut) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHasLoggedOut), v))
	})
}

// HasLoggedOutNEQ applies the NEQ predicate on the "has_logged_out" field.
func HasLoggedOutNEQ(v HasLoggedOut) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHasLoggedOut), v))
	})
}

// HasLoggedOutIn applies the In predicate on the "has_logged_out" field.
func HasLoggedOutIn(vs ...HasLoggedOut) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHasLoggedOut), v...))
	})
}

// HasLoggedOutNotIn applies the NotIn predicate on the "has_logged_out" field.
func HasLoggedOutNotIn(vs ...HasLoggedOut) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHasLoggedOut), v...))
	})
}

// HasLoggedOutIsNil applies the IsNil predicate on the "has_logged_out" field.
func HasLoggedOutIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldHasLoggedOut)))
	})
}

// HasLoggedOutNotNil applies the NotNil predicate on the "has_logged_out" field.
func HasLoggedOutNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldHasLoggedOut)))
	})
}

// RequirePasswordChangeEQ applies the EQ predicate on the "require_password_change" field.
func RequirePasswordChangeEQ(v RequirePasswordChange) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRequirePasswordChange), v))
	})
}

// RequirePasswordChangeNEQ applies the NEQ predicate on the "require_password_change" field.
func RequirePasswordChangeNEQ(v RequirePasswordChange) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRequirePasswordChange), v))
	})
}

// RequirePasswordChangeIn applies the In predicate on the "require_password_change" field.
func RequirePasswordChangeIn(vs ...RequirePasswordChange) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRequirePasswordChange), v...))
	})
}

// RequirePasswordChangeNotIn applies the NotIn predicate on the "require_password_change" field.
func RequirePasswordChangeNotIn(vs ...RequirePasswordChange) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRequirePasswordChange), v...))
	})
}

// RequirePasswordChangeIsNil applies the IsNil predicate on the "require_password_change" field.
func RequirePasswordChangeIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRequirePasswordChange)))
	})
}

// RequirePasswordChangeNotNil applies the NotNil predicate on the "require_password_change" field.
func RequirePasswordChangeNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRequirePasswordChange)))
	})
}

// LastCurrencyUomEQ applies the EQ predicate on the "last_currency_uom" field.
func LastCurrencyUomEQ(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastCurrencyUom), v))
	})
}

// LastCurrencyUomNEQ applies the NEQ predicate on the "last_currency_uom" field.
func LastCurrencyUomNEQ(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastCurrencyUom), v))
	})
}

// LastCurrencyUomIn applies the In predicate on the "last_currency_uom" field.
func LastCurrencyUomIn(vs ...int) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastCurrencyUom), v...))
	})
}

// LastCurrencyUomNotIn applies the NotIn predicate on the "last_currency_uom" field.
func LastCurrencyUomNotIn(vs ...int) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastCurrencyUom), v...))
	})
}

// LastCurrencyUomGT applies the GT predicate on the "last_currency_uom" field.
func LastCurrencyUomGT(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastCurrencyUom), v))
	})
}

// LastCurrencyUomGTE applies the GTE predicate on the "last_currency_uom" field.
func LastCurrencyUomGTE(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastCurrencyUom), v))
	})
}

// LastCurrencyUomLT applies the LT predicate on the "last_currency_uom" field.
func LastCurrencyUomLT(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastCurrencyUom), v))
	})
}

// LastCurrencyUomLTE applies the LTE predicate on the "last_currency_uom" field.
func LastCurrencyUomLTE(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastCurrencyUom), v))
	})
}

// LastCurrencyUomIsNil applies the IsNil predicate on the "last_currency_uom" field.
func LastCurrencyUomIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastCurrencyUom)))
	})
}

// LastCurrencyUomNotNil applies the NotNil predicate on the "last_currency_uom" field.
func LastCurrencyUomNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastCurrencyUom)))
	})
}

// LastLocaleEQ applies the EQ predicate on the "last_locale" field.
func LastLocaleEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastLocale), v))
	})
}

// LastLocaleNEQ applies the NEQ predicate on the "last_locale" field.
func LastLocaleNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastLocale), v))
	})
}

// LastLocaleIn applies the In predicate on the "last_locale" field.
func LastLocaleIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastLocale), v...))
	})
}

// LastLocaleNotIn applies the NotIn predicate on the "last_locale" field.
func LastLocaleNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastLocale), v...))
	})
}

// LastLocaleGT applies the GT predicate on the "last_locale" field.
func LastLocaleGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastLocale), v))
	})
}

// LastLocaleGTE applies the GTE predicate on the "last_locale" field.
func LastLocaleGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastLocale), v))
	})
}

// LastLocaleLT applies the LT predicate on the "last_locale" field.
func LastLocaleLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastLocale), v))
	})
}

// LastLocaleLTE applies the LTE predicate on the "last_locale" field.
func LastLocaleLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastLocale), v))
	})
}

// LastLocaleContains applies the Contains predicate on the "last_locale" field.
func LastLocaleContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLastLocale), v))
	})
}

// LastLocaleHasPrefix applies the HasPrefix predicate on the "last_locale" field.
func LastLocaleHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLastLocale), v))
	})
}

// LastLocaleHasSuffix applies the HasSuffix predicate on the "last_locale" field.
func LastLocaleHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLastLocale), v))
	})
}

// LastLocaleIsNil applies the IsNil predicate on the "last_locale" field.
func LastLocaleIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastLocale)))
	})
}

// LastLocaleNotNil applies the NotNil predicate on the "last_locale" field.
func LastLocaleNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastLocale)))
	})
}

// LastLocaleEqualFold applies the EqualFold predicate on the "last_locale" field.
func LastLocaleEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLastLocale), v))
	})
}

// LastLocaleContainsFold applies the ContainsFold predicate on the "last_locale" field.
func LastLocaleContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLastLocale), v))
	})
}

// LastTimeZoneEQ applies the EQ predicate on the "last_time_zone" field.
func LastTimeZoneEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneNEQ applies the NEQ predicate on the "last_time_zone" field.
func LastTimeZoneNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneIn applies the In predicate on the "last_time_zone" field.
func LastTimeZoneIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastTimeZone), v...))
	})
}

// LastTimeZoneNotIn applies the NotIn predicate on the "last_time_zone" field.
func LastTimeZoneNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastTimeZone), v...))
	})
}

// LastTimeZoneGT applies the GT predicate on the "last_time_zone" field.
func LastTimeZoneGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneGTE applies the GTE predicate on the "last_time_zone" field.
func LastTimeZoneGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneLT applies the LT predicate on the "last_time_zone" field.
func LastTimeZoneLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneLTE applies the LTE predicate on the "last_time_zone" field.
func LastTimeZoneLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneContains applies the Contains predicate on the "last_time_zone" field.
func LastTimeZoneContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneHasPrefix applies the HasPrefix predicate on the "last_time_zone" field.
func LastTimeZoneHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneHasSuffix applies the HasSuffix predicate on the "last_time_zone" field.
func LastTimeZoneHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneIsNil applies the IsNil predicate on the "last_time_zone" field.
func LastTimeZoneIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLastTimeZone)))
	})
}

// LastTimeZoneNotNil applies the NotNil predicate on the "last_time_zone" field.
func LastTimeZoneNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLastTimeZone)))
	})
}

// LastTimeZoneEqualFold applies the EqualFold predicate on the "last_time_zone" field.
func LastTimeZoneEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLastTimeZone), v))
	})
}

// LastTimeZoneContainsFold applies the ContainsFold predicate on the "last_time_zone" field.
func LastTimeZoneContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLastTimeZone), v))
	})
}

// DisabledDateTimeEQ applies the EQ predicate on the "disabled_date_time" field.
func DisabledDateTimeEQ(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDisabledDateTime), v))
	})
}

// DisabledDateTimeNEQ applies the NEQ predicate on the "disabled_date_time" field.
func DisabledDateTimeNEQ(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDisabledDateTime), v))
	})
}

// DisabledDateTimeIn applies the In predicate on the "disabled_date_time" field.
func DisabledDateTimeIn(vs ...time.Time) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDisabledDateTime), v...))
	})
}

// DisabledDateTimeNotIn applies the NotIn predicate on the "disabled_date_time" field.
func DisabledDateTimeNotIn(vs ...time.Time) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDisabledDateTime), v...))
	})
}

// DisabledDateTimeGT applies the GT predicate on the "disabled_date_time" field.
func DisabledDateTimeGT(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDisabledDateTime), v))
	})
}

// DisabledDateTimeGTE applies the GTE predicate on the "disabled_date_time" field.
func DisabledDateTimeGTE(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDisabledDateTime), v))
	})
}

// DisabledDateTimeLT applies the LT predicate on the "disabled_date_time" field.
func DisabledDateTimeLT(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDisabledDateTime), v))
	})
}

// DisabledDateTimeLTE applies the LTE predicate on the "disabled_date_time" field.
func DisabledDateTimeLTE(v time.Time) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDisabledDateTime), v))
	})
}

// DisabledDateTimeIsNil applies the IsNil predicate on the "disabled_date_time" field.
func DisabledDateTimeIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDisabledDateTime)))
	})
}

// DisabledDateTimeNotNil applies the NotNil predicate on the "disabled_date_time" field.
func DisabledDateTimeNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDisabledDateTime)))
	})
}

// SuccessiveFailedLoginsEQ applies the EQ predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsEQ(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// SuccessiveFailedLoginsNEQ applies the NEQ predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsNEQ(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// SuccessiveFailedLoginsIn applies the In predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsIn(vs ...int) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSuccessiveFailedLogins), v...))
	})
}

// SuccessiveFailedLoginsNotIn applies the NotIn predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsNotIn(vs ...int) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSuccessiveFailedLogins), v...))
	})
}

// SuccessiveFailedLoginsGT applies the GT predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsGT(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// SuccessiveFailedLoginsGTE applies the GTE predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsGTE(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// SuccessiveFailedLoginsLT applies the LT predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsLT(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// SuccessiveFailedLoginsLTE applies the LTE predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsLTE(v int) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSuccessiveFailedLogins), v))
	})
}

// SuccessiveFailedLoginsIsNil applies the IsNil predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldSuccessiveFailedLogins)))
	})
}

// SuccessiveFailedLoginsNotNil applies the NotNil predicate on the "successive_failed_logins" field.
func SuccessiveFailedLoginsNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldSuccessiveFailedLogins)))
	})
}

// ExternalAuthIDEQ applies the EQ predicate on the "external_auth_id" field.
func ExternalAuthIDEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDNEQ applies the NEQ predicate on the "external_auth_id" field.
func ExternalAuthIDNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDIn applies the In predicate on the "external_auth_id" field.
func ExternalAuthIDIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExternalAuthID), v...))
	})
}

// ExternalAuthIDNotIn applies the NotIn predicate on the "external_auth_id" field.
func ExternalAuthIDNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExternalAuthID), v...))
	})
}

// ExternalAuthIDGT applies the GT predicate on the "external_auth_id" field.
func ExternalAuthIDGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDGTE applies the GTE predicate on the "external_auth_id" field.
func ExternalAuthIDGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDLT applies the LT predicate on the "external_auth_id" field.
func ExternalAuthIDLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDLTE applies the LTE predicate on the "external_auth_id" field.
func ExternalAuthIDLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDContains applies the Contains predicate on the "external_auth_id" field.
func ExternalAuthIDContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDHasPrefix applies the HasPrefix predicate on the "external_auth_id" field.
func ExternalAuthIDHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDHasSuffix applies the HasSuffix predicate on the "external_auth_id" field.
func ExternalAuthIDHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDIsNil applies the IsNil predicate on the "external_auth_id" field.
func ExternalAuthIDIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldExternalAuthID)))
	})
}

// ExternalAuthIDNotNil applies the NotNil predicate on the "external_auth_id" field.
func ExternalAuthIDNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldExternalAuthID)))
	})
}

// ExternalAuthIDEqualFold applies the EqualFold predicate on the "external_auth_id" field.
func ExternalAuthIDEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldExternalAuthID), v))
	})
}

// ExternalAuthIDContainsFold applies the ContainsFold predicate on the "external_auth_id" field.
func ExternalAuthIDContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldExternalAuthID), v))
	})
}

// UserLdapDnEQ applies the EQ predicate on the "user_ldap_dn" field.
func UserLdapDnEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnNEQ applies the NEQ predicate on the "user_ldap_dn" field.
func UserLdapDnNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnIn applies the In predicate on the "user_ldap_dn" field.
func UserLdapDnIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserLdapDn), v...))
	})
}

// UserLdapDnNotIn applies the NotIn predicate on the "user_ldap_dn" field.
func UserLdapDnNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserLdapDn), v...))
	})
}

// UserLdapDnGT applies the GT predicate on the "user_ldap_dn" field.
func UserLdapDnGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnGTE applies the GTE predicate on the "user_ldap_dn" field.
func UserLdapDnGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnLT applies the LT predicate on the "user_ldap_dn" field.
func UserLdapDnLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnLTE applies the LTE predicate on the "user_ldap_dn" field.
func UserLdapDnLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnContains applies the Contains predicate on the "user_ldap_dn" field.
func UserLdapDnContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnHasPrefix applies the HasPrefix predicate on the "user_ldap_dn" field.
func UserLdapDnHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnHasSuffix applies the HasSuffix predicate on the "user_ldap_dn" field.
func UserLdapDnHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnIsNil applies the IsNil predicate on the "user_ldap_dn" field.
func UserLdapDnIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUserLdapDn)))
	})
}

// UserLdapDnNotNil applies the NotNil predicate on the "user_ldap_dn" field.
func UserLdapDnNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUserLdapDn)))
	})
}

// UserLdapDnEqualFold applies the EqualFold predicate on the "user_ldap_dn" field.
func UserLdapDnEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserLdapDn), v))
	})
}

// UserLdapDnContainsFold applies the ContainsFold predicate on the "user_ldap_dn" field.
func UserLdapDnContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserLdapDn), v))
	})
}

// DisabledByEQ applies the EQ predicate on the "disabled_by" field.
func DisabledByEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDisabledBy), v))
	})
}

// DisabledByNEQ applies the NEQ predicate on the "disabled_by" field.
func DisabledByNEQ(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDisabledBy), v))
	})
}

// DisabledByIn applies the In predicate on the "disabled_by" field.
func DisabledByIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDisabledBy), v...))
	})
}

// DisabledByNotIn applies the NotIn predicate on the "disabled_by" field.
func DisabledByNotIn(vs ...string) predicate.UserLogin {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.UserLogin(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDisabledBy), v...))
	})
}

// DisabledByGT applies the GT predicate on the "disabled_by" field.
func DisabledByGT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDisabledBy), v))
	})
}

// DisabledByGTE applies the GTE predicate on the "disabled_by" field.
func DisabledByGTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDisabledBy), v))
	})
}

// DisabledByLT applies the LT predicate on the "disabled_by" field.
func DisabledByLT(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDisabledBy), v))
	})
}

// DisabledByLTE applies the LTE predicate on the "disabled_by" field.
func DisabledByLTE(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDisabledBy), v))
	})
}

// DisabledByContains applies the Contains predicate on the "disabled_by" field.
func DisabledByContains(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDisabledBy), v))
	})
}

// DisabledByHasPrefix applies the HasPrefix predicate on the "disabled_by" field.
func DisabledByHasPrefix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDisabledBy), v))
	})
}

// DisabledByHasSuffix applies the HasSuffix predicate on the "disabled_by" field.
func DisabledByHasSuffix(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDisabledBy), v))
	})
}

// DisabledByIsNil applies the IsNil predicate on the "disabled_by" field.
func DisabledByIsNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDisabledBy)))
	})
}

// DisabledByNotNil applies the NotNil predicate on the "disabled_by" field.
func DisabledByNotNil() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDisabledBy)))
	})
}

// DisabledByEqualFold applies the EqualFold predicate on the "disabled_by" field.
func DisabledByEqualFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDisabledBy), v))
	})
}

// DisabledByContainsFold applies the ContainsFold predicate on the "disabled_by" field.
func DisabledByContainsFold(v string) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDisabledBy), v))
	})
}

// HasParty applies the HasEdge predicate on the "party" edge.
func HasParty() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PartyTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PartyTable, PartyColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasPartyWith applies the HasEdge predicate on the "party" edge with a given conditions (other predicates).
func HasPartyWith(preds ...predicate.Party) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PartyInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PartyTable, PartyColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasPerson applies the HasEdge predicate on the "person" edge.
func HasPerson() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PersonTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PersonTable, PersonColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasPersonWith applies the HasEdge predicate on the "person" edge with a given conditions (other predicates).
func HasPersonWith(preds ...predicate.Person) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(PersonInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, PersonTable, PersonColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasCreatedByParties applies the HasEdge predicate on the "created_by_parties" edge.
func HasCreatedByParties() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CreatedByPartiesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CreatedByPartiesTable, CreatedByPartiesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCreatedByPartiesWith applies the HasEdge predicate on the "created_by_parties" edge with a given conditions (other predicates).
func HasCreatedByPartiesWith(preds ...predicate.Party) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(CreatedByPartiesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, CreatedByPartiesTable, CreatedByPartiesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasLastModifiedByParties applies the HasEdge predicate on the "last_modified_by_parties" edge.
func HasLastModifiedByParties() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(LastModifiedByPartiesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, LastModifiedByPartiesTable, LastModifiedByPartiesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasLastModifiedByPartiesWith applies the HasEdge predicate on the "last_modified_by_parties" edge with a given conditions (other predicates).
func HasLastModifiedByPartiesWith(preds ...predicate.Party) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(LastModifiedByPartiesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, LastModifiedByPartiesTable, LastModifiedByPartiesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasChangeByPartyStatuses applies the HasEdge predicate on the "change_by_party_statuses" edge.
func HasChangeByPartyStatuses() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChangeByPartyStatusesTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ChangeByPartyStatusesTable, ChangeByPartyStatusesColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasChangeByPartyStatusesWith applies the HasEdge predicate on the "change_by_party_statuses" edge with a given conditions (other predicates).
func HasChangeByPartyStatusesWith(preds ...predicate.PartyStatus) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(ChangeByPartyStatusesInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ChangeByPartyStatusesTable, ChangeByPartyStatusesColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasUserLoginSecurityGroups applies the HasEdge predicate on the "user_login_security_groups" edge.
func HasUserLoginSecurityGroups() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserLoginSecurityGroupsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, UserLoginSecurityGroupsTable, UserLoginSecurityGroupsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserLoginSecurityGroupsWith applies the HasEdge predicate on the "user_login_security_groups" edge with a given conditions (other predicates).
func HasUserLoginSecurityGroupsWith(preds ...predicate.UserLoginSecurityGroup) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserLoginSecurityGroupsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, UserLoginSecurityGroupsTable, UserLoginSecurityGroupsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasAssignedByWorkEffortPartyAssignments applies the HasEdge predicate on the "assigned_by_work_effort_party_assignments" edge.
func HasAssignedByWorkEffortPartyAssignments() predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AssignedByWorkEffortPartyAssignmentsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AssignedByWorkEffortPartyAssignmentsTable, AssignedByWorkEffortPartyAssignmentsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasAssignedByWorkEffortPartyAssignmentsWith applies the HasEdge predicate on the "assigned_by_work_effort_party_assignments" edge with a given conditions (other predicates).
func HasAssignedByWorkEffortPartyAssignmentsWith(preds ...predicate.WorkEffortPartyAssignment) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(AssignedByWorkEffortPartyAssignmentsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, AssignedByWorkEffortPartyAssignmentsTable, AssignedByWorkEffortPartyAssignmentsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.UserLogin) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.UserLogin) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.UserLogin) predicate.UserLogin {
	return predicate.UserLogin(func(s *sql.Selector) {
		p(s.Not())
	})
}
