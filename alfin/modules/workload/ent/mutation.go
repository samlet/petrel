// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/samlet/petrel/alfin/modules/workload/ent/predicate"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workload"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadfeature"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadfeatureappl"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadfeatureappltype"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloaditem"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadstatus"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadtype"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeWorkload                = "Workload"
	TypeWorkloadFeature         = "WorkloadFeature"
	TypeWorkloadFeatureAppl     = "WorkloadFeatureAppl"
	TypeWorkloadFeatureApplType = "WorkloadFeatureApplType"
	TypeWorkloadItem            = "WorkloadItem"
	TypeWorkloadStatus          = "WorkloadStatus"
	TypeWorkloadType            = "WorkloadType"
)

// WorkloadMutation represents an operation that mutates the Workload nodes in the graph.
type WorkloadMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	status_id                     *int
	addstatus_id                  *int
	workload_name                 *string
	description                   *string
	long_description              *string
	comments                      *string
	workload_size                 *int
	addworkload_size              *int
	workload_date                 *time.Time
	another_date                  *time.Time
	another_text                  *string
	clearedFields                 map[string]struct{}
	workload_type                 *int
	clearedworkload_type          bool
	workload_feature_appls        map[int]struct{}
	removedworkload_feature_appls map[int]struct{}
	clearedworkload_feature_appls bool
	workload_items                map[int]struct{}
	removedworkload_items         map[int]struct{}
	clearedworkload_items         bool
	workload_statuses             map[int]struct{}
	removedworkload_statuses      map[int]struct{}
	clearedworkload_statuses      bool
	done                          bool
	oldValue                      func(context.Context) (*Workload, error)
	predicates                    []predicate.Workload
}

var _ ent.Mutation = (*WorkloadMutation)(nil)

// workloadOption allows management of the mutation configuration using functional options.
type workloadOption func(*WorkloadMutation)

// newWorkloadMutation creates new mutation for the Workload entity.
func newWorkloadMutation(c config, op Op, opts ...workloadOption) *WorkloadMutation {
	m := &WorkloadMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadID sets the ID field of the mutation.
func withWorkloadID(id int) workloadOption {
	return func(m *WorkloadMutation) {
		var (
			err   error
			once  sync.Once
			value *Workload
		)
		m.oldValue = func(ctx context.Context) (*Workload, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkload sets the old Workload of the mutation.
func withWorkload(node *Workload) workloadOption {
	return func(m *WorkloadMutation) {
		m.oldValue = func(context.Context) (*Workload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatusID sets the "status_id" field.
func (m *WorkloadMutation) SetStatusID(i int) {
	m.status_id = &i
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *WorkloadMutation) StatusID() (r int, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds i to the "status_id" field.
func (m *WorkloadMutation) AddStatusID(i int) {
	if m.addstatus_id != nil {
		*m.addstatus_id += i
	} else {
		m.addstatus_id = &i
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *WorkloadMutation) AddedStatusID() (r int, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusID clears the value of the "status_id" field.
func (m *WorkloadMutation) ClearStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	m.clearedFields[workload.FieldStatusID] = struct{}{}
}

// StatusIDCleared returns if the "status_id" field was cleared in this mutation.
func (m *WorkloadMutation) StatusIDCleared() bool {
	_, ok := m.clearedFields[workload.FieldStatusID]
	return ok
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *WorkloadMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	delete(m.clearedFields, workload.FieldStatusID)
}

// SetWorkloadName sets the "workload_name" field.
func (m *WorkloadMutation) SetWorkloadName(s string) {
	m.workload_name = &s
}

// WorkloadName returns the value of the "workload_name" field in the mutation.
func (m *WorkloadMutation) WorkloadName() (r string, exists bool) {
	v := m.workload_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkloadName returns the old "workload_name" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldWorkloadName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkloadName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkloadName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkloadName: %w", err)
	}
	return oldValue.WorkloadName, nil
}

// ClearWorkloadName clears the value of the "workload_name" field.
func (m *WorkloadMutation) ClearWorkloadName() {
	m.workload_name = nil
	m.clearedFields[workload.FieldWorkloadName] = struct{}{}
}

// WorkloadNameCleared returns if the "workload_name" field was cleared in this mutation.
func (m *WorkloadMutation) WorkloadNameCleared() bool {
	_, ok := m.clearedFields[workload.FieldWorkloadName]
	return ok
}

// ResetWorkloadName resets all changes to the "workload_name" field.
func (m *WorkloadMutation) ResetWorkloadName() {
	m.workload_name = nil
	delete(m.clearedFields, workload.FieldWorkloadName)
}

// SetDescription sets the "description" field.
func (m *WorkloadMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkloadMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkloadMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workload.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkloadMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workload.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkloadMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workload.FieldDescription)
}

// SetLongDescription sets the "long_description" field.
func (m *WorkloadMutation) SetLongDescription(s string) {
	m.long_description = &s
}

// LongDescription returns the value of the "long_description" field in the mutation.
func (m *WorkloadMutation) LongDescription() (r string, exists bool) {
	v := m.long_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLongDescription returns the old "long_description" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldLongDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongDescription: %w", err)
	}
	return oldValue.LongDescription, nil
}

// ClearLongDescription clears the value of the "long_description" field.
func (m *WorkloadMutation) ClearLongDescription() {
	m.long_description = nil
	m.clearedFields[workload.FieldLongDescription] = struct{}{}
}

// LongDescriptionCleared returns if the "long_description" field was cleared in this mutation.
func (m *WorkloadMutation) LongDescriptionCleared() bool {
	_, ok := m.clearedFields[workload.FieldLongDescription]
	return ok
}

// ResetLongDescription resets all changes to the "long_description" field.
func (m *WorkloadMutation) ResetLongDescription() {
	m.long_description = nil
	delete(m.clearedFields, workload.FieldLongDescription)
}

// SetComments sets the "comments" field.
func (m *WorkloadMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *WorkloadMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *WorkloadMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[workload.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *WorkloadMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[workload.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *WorkloadMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, workload.FieldComments)
}

// SetWorkloadSize sets the "workload_size" field.
func (m *WorkloadMutation) SetWorkloadSize(i int) {
	m.workload_size = &i
	m.addworkload_size = nil
}

// WorkloadSize returns the value of the "workload_size" field in the mutation.
func (m *WorkloadMutation) WorkloadSize() (r int, exists bool) {
	v := m.workload_size
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkloadSize returns the old "workload_size" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldWorkloadSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkloadSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkloadSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkloadSize: %w", err)
	}
	return oldValue.WorkloadSize, nil
}

// AddWorkloadSize adds i to the "workload_size" field.
func (m *WorkloadMutation) AddWorkloadSize(i int) {
	if m.addworkload_size != nil {
		*m.addworkload_size += i
	} else {
		m.addworkload_size = &i
	}
}

// AddedWorkloadSize returns the value that was added to the "workload_size" field in this mutation.
func (m *WorkloadMutation) AddedWorkloadSize() (r int, exists bool) {
	v := m.addworkload_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkloadSize clears the value of the "workload_size" field.
func (m *WorkloadMutation) ClearWorkloadSize() {
	m.workload_size = nil
	m.addworkload_size = nil
	m.clearedFields[workload.FieldWorkloadSize] = struct{}{}
}

// WorkloadSizeCleared returns if the "workload_size" field was cleared in this mutation.
func (m *WorkloadMutation) WorkloadSizeCleared() bool {
	_, ok := m.clearedFields[workload.FieldWorkloadSize]
	return ok
}

// ResetWorkloadSize resets all changes to the "workload_size" field.
func (m *WorkloadMutation) ResetWorkloadSize() {
	m.workload_size = nil
	m.addworkload_size = nil
	delete(m.clearedFields, workload.FieldWorkloadSize)
}

// SetWorkloadDate sets the "workload_date" field.
func (m *WorkloadMutation) SetWorkloadDate(t time.Time) {
	m.workload_date = &t
}

// WorkloadDate returns the value of the "workload_date" field in the mutation.
func (m *WorkloadMutation) WorkloadDate() (r time.Time, exists bool) {
	v := m.workload_date
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkloadDate returns the old "workload_date" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldWorkloadDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkloadDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkloadDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkloadDate: %w", err)
	}
	return oldValue.WorkloadDate, nil
}

// ClearWorkloadDate clears the value of the "workload_date" field.
func (m *WorkloadMutation) ClearWorkloadDate() {
	m.workload_date = nil
	m.clearedFields[workload.FieldWorkloadDate] = struct{}{}
}

// WorkloadDateCleared returns if the "workload_date" field was cleared in this mutation.
func (m *WorkloadMutation) WorkloadDateCleared() bool {
	_, ok := m.clearedFields[workload.FieldWorkloadDate]
	return ok
}

// ResetWorkloadDate resets all changes to the "workload_date" field.
func (m *WorkloadMutation) ResetWorkloadDate() {
	m.workload_date = nil
	delete(m.clearedFields, workload.FieldWorkloadDate)
}

// SetAnotherDate sets the "another_date" field.
func (m *WorkloadMutation) SetAnotherDate(t time.Time) {
	m.another_date = &t
}

// AnotherDate returns the value of the "another_date" field in the mutation.
func (m *WorkloadMutation) AnotherDate() (r time.Time, exists bool) {
	v := m.another_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAnotherDate returns the old "another_date" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldAnotherDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnotherDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnotherDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnotherDate: %w", err)
	}
	return oldValue.AnotherDate, nil
}

// ClearAnotherDate clears the value of the "another_date" field.
func (m *WorkloadMutation) ClearAnotherDate() {
	m.another_date = nil
	m.clearedFields[workload.FieldAnotherDate] = struct{}{}
}

// AnotherDateCleared returns if the "another_date" field was cleared in this mutation.
func (m *WorkloadMutation) AnotherDateCleared() bool {
	_, ok := m.clearedFields[workload.FieldAnotherDate]
	return ok
}

// ResetAnotherDate resets all changes to the "another_date" field.
func (m *WorkloadMutation) ResetAnotherDate() {
	m.another_date = nil
	delete(m.clearedFields, workload.FieldAnotherDate)
}

// SetAnotherText sets the "another_text" field.
func (m *WorkloadMutation) SetAnotherText(s string) {
	m.another_text = &s
}

// AnotherText returns the value of the "another_text" field in the mutation.
func (m *WorkloadMutation) AnotherText() (r string, exists bool) {
	v := m.another_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAnotherText returns the old "another_text" field's value of the Workload entity.
// If the Workload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadMutation) OldAnotherText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnotherText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnotherText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnotherText: %w", err)
	}
	return oldValue.AnotherText, nil
}

// ClearAnotherText clears the value of the "another_text" field.
func (m *WorkloadMutation) ClearAnotherText() {
	m.another_text = nil
	m.clearedFields[workload.FieldAnotherText] = struct{}{}
}

// AnotherTextCleared returns if the "another_text" field was cleared in this mutation.
func (m *WorkloadMutation) AnotherTextCleared() bool {
	_, ok := m.clearedFields[workload.FieldAnotherText]
	return ok
}

// ResetAnotherText resets all changes to the "another_text" field.
func (m *WorkloadMutation) ResetAnotherText() {
	m.another_text = nil
	delete(m.clearedFields, workload.FieldAnotherText)
}

// SetWorkloadTypeID sets the "workload_type" edge to the WorkloadType entity by id.
func (m *WorkloadMutation) SetWorkloadTypeID(id int) {
	m.workload_type = &id
}

// ClearWorkloadType clears the "workload_type" edge to the WorkloadType entity.
func (m *WorkloadMutation) ClearWorkloadType() {
	m.clearedworkload_type = true
}

// WorkloadTypeCleared reports if the "workload_type" edge to the WorkloadType entity was cleared.
func (m *WorkloadMutation) WorkloadTypeCleared() bool {
	return m.clearedworkload_type
}

// WorkloadTypeID returns the "workload_type" edge ID in the mutation.
func (m *WorkloadMutation) WorkloadTypeID() (id int, exists bool) {
	if m.workload_type != nil {
		return *m.workload_type, true
	}
	return
}

// WorkloadTypeIDs returns the "workload_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkloadTypeID instead. It exists only for internal usage by the builders.
func (m *WorkloadMutation) WorkloadTypeIDs() (ids []int) {
	if id := m.workload_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkloadType resets all changes to the "workload_type" edge.
func (m *WorkloadMutation) ResetWorkloadType() {
	m.workload_type = nil
	m.clearedworkload_type = false
}

// AddWorkloadFeatureApplIDs adds the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by ids.
func (m *WorkloadMutation) AddWorkloadFeatureApplIDs(ids ...int) {
	if m.workload_feature_appls == nil {
		m.workload_feature_appls = make(map[int]struct{})
	}
	for i := range ids {
		m.workload_feature_appls[ids[i]] = struct{}{}
	}
}

// ClearWorkloadFeatureAppls clears the "workload_feature_appls" edge to the WorkloadFeatureAppl entity.
func (m *WorkloadMutation) ClearWorkloadFeatureAppls() {
	m.clearedworkload_feature_appls = true
}

// WorkloadFeatureApplsCleared reports if the "workload_feature_appls" edge to the WorkloadFeatureAppl entity was cleared.
func (m *WorkloadMutation) WorkloadFeatureApplsCleared() bool {
	return m.clearedworkload_feature_appls
}

// RemoveWorkloadFeatureApplIDs removes the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by IDs.
func (m *WorkloadMutation) RemoveWorkloadFeatureApplIDs(ids ...int) {
	if m.removedworkload_feature_appls == nil {
		m.removedworkload_feature_appls = make(map[int]struct{})
	}
	for i := range ids {
		m.removedworkload_feature_appls[ids[i]] = struct{}{}
	}
}

// RemovedWorkloadFeatureAppls returns the removed IDs of the "workload_feature_appls" edge to the WorkloadFeatureAppl entity.
func (m *WorkloadMutation) RemovedWorkloadFeatureApplsIDs() (ids []int) {
	for id := range m.removedworkload_feature_appls {
		ids = append(ids, id)
	}
	return
}

// WorkloadFeatureApplsIDs returns the "workload_feature_appls" edge IDs in the mutation.
func (m *WorkloadMutation) WorkloadFeatureApplsIDs() (ids []int) {
	for id := range m.workload_feature_appls {
		ids = append(ids, id)
	}
	return
}

// ResetWorkloadFeatureAppls resets all changes to the "workload_feature_appls" edge.
func (m *WorkloadMutation) ResetWorkloadFeatureAppls() {
	m.workload_feature_appls = nil
	m.clearedworkload_feature_appls = false
	m.removedworkload_feature_appls = nil
}

// AddWorkloadItemIDs adds the "workload_items" edge to the WorkloadItem entity by ids.
func (m *WorkloadMutation) AddWorkloadItemIDs(ids ...int) {
	if m.workload_items == nil {
		m.workload_items = make(map[int]struct{})
	}
	for i := range ids {
		m.workload_items[ids[i]] = struct{}{}
	}
}

// ClearWorkloadItems clears the "workload_items" edge to the WorkloadItem entity.
func (m *WorkloadMutation) ClearWorkloadItems() {
	m.clearedworkload_items = true
}

// WorkloadItemsCleared reports if the "workload_items" edge to the WorkloadItem entity was cleared.
func (m *WorkloadMutation) WorkloadItemsCleared() bool {
	return m.clearedworkload_items
}

// RemoveWorkloadItemIDs removes the "workload_items" edge to the WorkloadItem entity by IDs.
func (m *WorkloadMutation) RemoveWorkloadItemIDs(ids ...int) {
	if m.removedworkload_items == nil {
		m.removedworkload_items = make(map[int]struct{})
	}
	for i := range ids {
		m.removedworkload_items[ids[i]] = struct{}{}
	}
}

// RemovedWorkloadItems returns the removed IDs of the "workload_items" edge to the WorkloadItem entity.
func (m *WorkloadMutation) RemovedWorkloadItemsIDs() (ids []int) {
	for id := range m.removedworkload_items {
		ids = append(ids, id)
	}
	return
}

// WorkloadItemsIDs returns the "workload_items" edge IDs in the mutation.
func (m *WorkloadMutation) WorkloadItemsIDs() (ids []int) {
	for id := range m.workload_items {
		ids = append(ids, id)
	}
	return
}

// ResetWorkloadItems resets all changes to the "workload_items" edge.
func (m *WorkloadMutation) ResetWorkloadItems() {
	m.workload_items = nil
	m.clearedworkload_items = false
	m.removedworkload_items = nil
}

// AddWorkloadStatusIDs adds the "workload_statuses" edge to the WorkloadStatus entity by ids.
func (m *WorkloadMutation) AddWorkloadStatusIDs(ids ...int) {
	if m.workload_statuses == nil {
		m.workload_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.workload_statuses[ids[i]] = struct{}{}
	}
}

// ClearWorkloadStatuses clears the "workload_statuses" edge to the WorkloadStatus entity.
func (m *WorkloadMutation) ClearWorkloadStatuses() {
	m.clearedworkload_statuses = true
}

// WorkloadStatusesCleared reports if the "workload_statuses" edge to the WorkloadStatus entity was cleared.
func (m *WorkloadMutation) WorkloadStatusesCleared() bool {
	return m.clearedworkload_statuses
}

// RemoveWorkloadStatusIDs removes the "workload_statuses" edge to the WorkloadStatus entity by IDs.
func (m *WorkloadMutation) RemoveWorkloadStatusIDs(ids ...int) {
	if m.removedworkload_statuses == nil {
		m.removedworkload_statuses = make(map[int]struct{})
	}
	for i := range ids {
		m.removedworkload_statuses[ids[i]] = struct{}{}
	}
}

// RemovedWorkloadStatuses returns the removed IDs of the "workload_statuses" edge to the WorkloadStatus entity.
func (m *WorkloadMutation) RemovedWorkloadStatusesIDs() (ids []int) {
	for id := range m.removedworkload_statuses {
		ids = append(ids, id)
	}
	return
}

// WorkloadStatusesIDs returns the "workload_statuses" edge IDs in the mutation.
func (m *WorkloadMutation) WorkloadStatusesIDs() (ids []int) {
	for id := range m.workload_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetWorkloadStatuses resets all changes to the "workload_statuses" edge.
func (m *WorkloadMutation) ResetWorkloadStatuses() {
	m.workload_statuses = nil
	m.clearedworkload_statuses = false
	m.removedworkload_statuses = nil
}

// Op returns the operation name.
func (m *WorkloadMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Workload).
func (m *WorkloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, workload.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workload.FieldUpdateTime)
	}
	if m.status_id != nil {
		fields = append(fields, workload.FieldStatusID)
	}
	if m.workload_name != nil {
		fields = append(fields, workload.FieldWorkloadName)
	}
	if m.description != nil {
		fields = append(fields, workload.FieldDescription)
	}
	if m.long_description != nil {
		fields = append(fields, workload.FieldLongDescription)
	}
	if m.comments != nil {
		fields = append(fields, workload.FieldComments)
	}
	if m.workload_size != nil {
		fields = append(fields, workload.FieldWorkloadSize)
	}
	if m.workload_date != nil {
		fields = append(fields, workload.FieldWorkloadDate)
	}
	if m.another_date != nil {
		fields = append(fields, workload.FieldAnotherDate)
	}
	if m.another_text != nil {
		fields = append(fields, workload.FieldAnotherText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workload.FieldCreateTime:
		return m.CreateTime()
	case workload.FieldUpdateTime:
		return m.UpdateTime()
	case workload.FieldStatusID:
		return m.StatusID()
	case workload.FieldWorkloadName:
		return m.WorkloadName()
	case workload.FieldDescription:
		return m.Description()
	case workload.FieldLongDescription:
		return m.LongDescription()
	case workload.FieldComments:
		return m.Comments()
	case workload.FieldWorkloadSize:
		return m.WorkloadSize()
	case workload.FieldWorkloadDate:
		return m.WorkloadDate()
	case workload.FieldAnotherDate:
		return m.AnotherDate()
	case workload.FieldAnotherText:
		return m.AnotherText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workload.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workload.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workload.FieldStatusID:
		return m.OldStatusID(ctx)
	case workload.FieldWorkloadName:
		return m.OldWorkloadName(ctx)
	case workload.FieldDescription:
		return m.OldDescription(ctx)
	case workload.FieldLongDescription:
		return m.OldLongDescription(ctx)
	case workload.FieldComments:
		return m.OldComments(ctx)
	case workload.FieldWorkloadSize:
		return m.OldWorkloadSize(ctx)
	case workload.FieldWorkloadDate:
		return m.OldWorkloadDate(ctx)
	case workload.FieldAnotherDate:
		return m.OldAnotherDate(ctx)
	case workload.FieldAnotherText:
		return m.OldAnotherText(ctx)
	}
	return nil, fmt.Errorf("unknown Workload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workload.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workload.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workload.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	case workload.FieldWorkloadName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkloadName(v)
		return nil
	case workload.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workload.FieldLongDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongDescription(v)
		return nil
	case workload.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case workload.FieldWorkloadSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkloadSize(v)
		return nil
	case workload.FieldWorkloadDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkloadDate(v)
		return nil
	case workload.FieldAnotherDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnotherDate(v)
		return nil
	case workload.FieldAnotherText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnotherText(v)
		return nil
	}
	return fmt.Errorf("unknown Workload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_id != nil {
		fields = append(fields, workload.FieldStatusID)
	}
	if m.addworkload_size != nil {
		fields = append(fields, workload.FieldWorkloadSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workload.FieldStatusID:
		return m.AddedStatusID()
	case workload.FieldWorkloadSize:
		return m.AddedWorkloadSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workload.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	case workload.FieldWorkloadSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkloadSize(v)
		return nil
	}
	return fmt.Errorf("unknown Workload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workload.FieldStatusID) {
		fields = append(fields, workload.FieldStatusID)
	}
	if m.FieldCleared(workload.FieldWorkloadName) {
		fields = append(fields, workload.FieldWorkloadName)
	}
	if m.FieldCleared(workload.FieldDescription) {
		fields = append(fields, workload.FieldDescription)
	}
	if m.FieldCleared(workload.FieldLongDescription) {
		fields = append(fields, workload.FieldLongDescription)
	}
	if m.FieldCleared(workload.FieldComments) {
		fields = append(fields, workload.FieldComments)
	}
	if m.FieldCleared(workload.FieldWorkloadSize) {
		fields = append(fields, workload.FieldWorkloadSize)
	}
	if m.FieldCleared(workload.FieldWorkloadDate) {
		fields = append(fields, workload.FieldWorkloadDate)
	}
	if m.FieldCleared(workload.FieldAnotherDate) {
		fields = append(fields, workload.FieldAnotherDate)
	}
	if m.FieldCleared(workload.FieldAnotherText) {
		fields = append(fields, workload.FieldAnotherText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadMutation) ClearField(name string) error {
	switch name {
	case workload.FieldStatusID:
		m.ClearStatusID()
		return nil
	case workload.FieldWorkloadName:
		m.ClearWorkloadName()
		return nil
	case workload.FieldDescription:
		m.ClearDescription()
		return nil
	case workload.FieldLongDescription:
		m.ClearLongDescription()
		return nil
	case workload.FieldComments:
		m.ClearComments()
		return nil
	case workload.FieldWorkloadSize:
		m.ClearWorkloadSize()
		return nil
	case workload.FieldWorkloadDate:
		m.ClearWorkloadDate()
		return nil
	case workload.FieldAnotherDate:
		m.ClearAnotherDate()
		return nil
	case workload.FieldAnotherText:
		m.ClearAnotherText()
		return nil
	}
	return fmt.Errorf("unknown Workload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadMutation) ResetField(name string) error {
	switch name {
	case workload.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workload.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workload.FieldStatusID:
		m.ResetStatusID()
		return nil
	case workload.FieldWorkloadName:
		m.ResetWorkloadName()
		return nil
	case workload.FieldDescription:
		m.ResetDescription()
		return nil
	case workload.FieldLongDescription:
		m.ResetLongDescription()
		return nil
	case workload.FieldComments:
		m.ResetComments()
		return nil
	case workload.FieldWorkloadSize:
		m.ResetWorkloadSize()
		return nil
	case workload.FieldWorkloadDate:
		m.ResetWorkloadDate()
		return nil
	case workload.FieldAnotherDate:
		m.ResetAnotherDate()
		return nil
	case workload.FieldAnotherText:
		m.ResetAnotherText()
		return nil
	}
	return fmt.Errorf("unknown Workload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workload_type != nil {
		edges = append(edges, workload.EdgeWorkloadType)
	}
	if m.workload_feature_appls != nil {
		edges = append(edges, workload.EdgeWorkloadFeatureAppls)
	}
	if m.workload_items != nil {
		edges = append(edges, workload.EdgeWorkloadItems)
	}
	if m.workload_statuses != nil {
		edges = append(edges, workload.EdgeWorkloadStatuses)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workload.EdgeWorkloadType:
		if id := m.workload_type; id != nil {
			return []ent.Value{*id}
		}
	case workload.EdgeWorkloadFeatureAppls:
		ids := make([]ent.Value, 0, len(m.workload_feature_appls))
		for id := range m.workload_feature_appls {
			ids = append(ids, id)
		}
		return ids
	case workload.EdgeWorkloadItems:
		ids := make([]ent.Value, 0, len(m.workload_items))
		for id := range m.workload_items {
			ids = append(ids, id)
		}
		return ids
	case workload.EdgeWorkloadStatuses:
		ids := make([]ent.Value, 0, len(m.workload_statuses))
		for id := range m.workload_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedworkload_feature_appls != nil {
		edges = append(edges, workload.EdgeWorkloadFeatureAppls)
	}
	if m.removedworkload_items != nil {
		edges = append(edges, workload.EdgeWorkloadItems)
	}
	if m.removedworkload_statuses != nil {
		edges = append(edges, workload.EdgeWorkloadStatuses)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workload.EdgeWorkloadFeatureAppls:
		ids := make([]ent.Value, 0, len(m.removedworkload_feature_appls))
		for id := range m.removedworkload_feature_appls {
			ids = append(ids, id)
		}
		return ids
	case workload.EdgeWorkloadItems:
		ids := make([]ent.Value, 0, len(m.removedworkload_items))
		for id := range m.removedworkload_items {
			ids = append(ids, id)
		}
		return ids
	case workload.EdgeWorkloadStatuses:
		ids := make([]ent.Value, 0, len(m.removedworkload_statuses))
		for id := range m.removedworkload_statuses {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkload_type {
		edges = append(edges, workload.EdgeWorkloadType)
	}
	if m.clearedworkload_feature_appls {
		edges = append(edges, workload.EdgeWorkloadFeatureAppls)
	}
	if m.clearedworkload_items {
		edges = append(edges, workload.EdgeWorkloadItems)
	}
	if m.clearedworkload_statuses {
		edges = append(edges, workload.EdgeWorkloadStatuses)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadMutation) EdgeCleared(name string) bool {
	switch name {
	case workload.EdgeWorkloadType:
		return m.clearedworkload_type
	case workload.EdgeWorkloadFeatureAppls:
		return m.clearedworkload_feature_appls
	case workload.EdgeWorkloadItems:
		return m.clearedworkload_items
	case workload.EdgeWorkloadStatuses:
		return m.clearedworkload_statuses
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadMutation) ClearEdge(name string) error {
	switch name {
	case workload.EdgeWorkloadType:
		m.ClearWorkloadType()
		return nil
	}
	return fmt.Errorf("unknown Workload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadMutation) ResetEdge(name string) error {
	switch name {
	case workload.EdgeWorkloadType:
		m.ResetWorkloadType()
		return nil
	case workload.EdgeWorkloadFeatureAppls:
		m.ResetWorkloadFeatureAppls()
		return nil
	case workload.EdgeWorkloadItems:
		m.ResetWorkloadItems()
		return nil
	case workload.EdgeWorkloadStatuses:
		m.ResetWorkloadStatuses()
		return nil
	}
	return fmt.Errorf("unknown Workload edge %s", name)
}

// WorkloadFeatureMutation represents an operation that mutates the WorkloadFeature nodes in the graph.
type WorkloadFeatureMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	feature_source_enum_id        *int
	addfeature_source_enum_id     *int
	description                   *string
	clearedFields                 map[string]struct{}
	workload_feature_appls        map[int]struct{}
	removedworkload_feature_appls map[int]struct{}
	clearedworkload_feature_appls bool
	done                          bool
	oldValue                      func(context.Context) (*WorkloadFeature, error)
	predicates                    []predicate.WorkloadFeature
}

var _ ent.Mutation = (*WorkloadFeatureMutation)(nil)

// workloadfeatureOption allows management of the mutation configuration using functional options.
type workloadfeatureOption func(*WorkloadFeatureMutation)

// newWorkloadFeatureMutation creates new mutation for the WorkloadFeature entity.
func newWorkloadFeatureMutation(c config, op Op, opts ...workloadfeatureOption) *WorkloadFeatureMutation {
	m := &WorkloadFeatureMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkloadFeature,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadFeatureID sets the ID field of the mutation.
func withWorkloadFeatureID(id int) workloadfeatureOption {
	return func(m *WorkloadFeatureMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkloadFeature
		)
		m.oldValue = func(ctx context.Context) (*WorkloadFeature, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkloadFeature.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkloadFeature sets the old WorkloadFeature of the mutation.
func withWorkloadFeature(node *WorkloadFeature) workloadfeatureOption {
	return func(m *WorkloadFeatureMutation) {
		m.oldValue = func(context.Context) (*WorkloadFeature, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadFeatureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadFeatureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadFeatureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadFeatureMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadFeatureMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkloadFeature entity.
// If the WorkloadFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadFeatureMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadFeatureMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadFeatureMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkloadFeature entity.
// If the WorkloadFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadFeatureMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFeatureSourceEnumID sets the "feature_source_enum_id" field.
func (m *WorkloadFeatureMutation) SetFeatureSourceEnumID(i int) {
	m.feature_source_enum_id = &i
	m.addfeature_source_enum_id = nil
}

// FeatureSourceEnumID returns the value of the "feature_source_enum_id" field in the mutation.
func (m *WorkloadFeatureMutation) FeatureSourceEnumID() (r int, exists bool) {
	v := m.feature_source_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureSourceEnumID returns the old "feature_source_enum_id" field's value of the WorkloadFeature entity.
// If the WorkloadFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureMutation) OldFeatureSourceEnumID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFeatureSourceEnumID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFeatureSourceEnumID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureSourceEnumID: %w", err)
	}
	return oldValue.FeatureSourceEnumID, nil
}

// AddFeatureSourceEnumID adds i to the "feature_source_enum_id" field.
func (m *WorkloadFeatureMutation) AddFeatureSourceEnumID(i int) {
	if m.addfeature_source_enum_id != nil {
		*m.addfeature_source_enum_id += i
	} else {
		m.addfeature_source_enum_id = &i
	}
}

// AddedFeatureSourceEnumID returns the value that was added to the "feature_source_enum_id" field in this mutation.
func (m *WorkloadFeatureMutation) AddedFeatureSourceEnumID() (r int, exists bool) {
	v := m.addfeature_source_enum_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFeatureSourceEnumID clears the value of the "feature_source_enum_id" field.
func (m *WorkloadFeatureMutation) ClearFeatureSourceEnumID() {
	m.feature_source_enum_id = nil
	m.addfeature_source_enum_id = nil
	m.clearedFields[workloadfeature.FieldFeatureSourceEnumID] = struct{}{}
}

// FeatureSourceEnumIDCleared returns if the "feature_source_enum_id" field was cleared in this mutation.
func (m *WorkloadFeatureMutation) FeatureSourceEnumIDCleared() bool {
	_, ok := m.clearedFields[workloadfeature.FieldFeatureSourceEnumID]
	return ok
}

// ResetFeatureSourceEnumID resets all changes to the "feature_source_enum_id" field.
func (m *WorkloadFeatureMutation) ResetFeatureSourceEnumID() {
	m.feature_source_enum_id = nil
	m.addfeature_source_enum_id = nil
	delete(m.clearedFields, workloadfeature.FieldFeatureSourceEnumID)
}

// SetDescription sets the "description" field.
func (m *WorkloadFeatureMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkloadFeatureMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkloadFeature entity.
// If the WorkloadFeature object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkloadFeatureMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workloadfeature.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkloadFeatureMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workloadfeature.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkloadFeatureMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workloadfeature.FieldDescription)
}

// AddWorkloadFeatureApplIDs adds the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by ids.
func (m *WorkloadFeatureMutation) AddWorkloadFeatureApplIDs(ids ...int) {
	if m.workload_feature_appls == nil {
		m.workload_feature_appls = make(map[int]struct{})
	}
	for i := range ids {
		m.workload_feature_appls[ids[i]] = struct{}{}
	}
}

// ClearWorkloadFeatureAppls clears the "workload_feature_appls" edge to the WorkloadFeatureAppl entity.
func (m *WorkloadFeatureMutation) ClearWorkloadFeatureAppls() {
	m.clearedworkload_feature_appls = true
}

// WorkloadFeatureApplsCleared reports if the "workload_feature_appls" edge to the WorkloadFeatureAppl entity was cleared.
func (m *WorkloadFeatureMutation) WorkloadFeatureApplsCleared() bool {
	return m.clearedworkload_feature_appls
}

// RemoveWorkloadFeatureApplIDs removes the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by IDs.
func (m *WorkloadFeatureMutation) RemoveWorkloadFeatureApplIDs(ids ...int) {
	if m.removedworkload_feature_appls == nil {
		m.removedworkload_feature_appls = make(map[int]struct{})
	}
	for i := range ids {
		m.removedworkload_feature_appls[ids[i]] = struct{}{}
	}
}

// RemovedWorkloadFeatureAppls returns the removed IDs of the "workload_feature_appls" edge to the WorkloadFeatureAppl entity.
func (m *WorkloadFeatureMutation) RemovedWorkloadFeatureApplsIDs() (ids []int) {
	for id := range m.removedworkload_feature_appls {
		ids = append(ids, id)
	}
	return
}

// WorkloadFeatureApplsIDs returns the "workload_feature_appls" edge IDs in the mutation.
func (m *WorkloadFeatureMutation) WorkloadFeatureApplsIDs() (ids []int) {
	for id := range m.workload_feature_appls {
		ids = append(ids, id)
	}
	return
}

// ResetWorkloadFeatureAppls resets all changes to the "workload_feature_appls" edge.
func (m *WorkloadFeatureMutation) ResetWorkloadFeatureAppls() {
	m.workload_feature_appls = nil
	m.clearedworkload_feature_appls = false
	m.removedworkload_feature_appls = nil
}

// Op returns the operation name.
func (m *WorkloadFeatureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkloadFeature).
func (m *WorkloadFeatureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadFeatureMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, workloadfeature.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workloadfeature.FieldUpdateTime)
	}
	if m.feature_source_enum_id != nil {
		fields = append(fields, workloadfeature.FieldFeatureSourceEnumID)
	}
	if m.description != nil {
		fields = append(fields, workloadfeature.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadFeatureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workloadfeature.FieldCreateTime:
		return m.CreateTime()
	case workloadfeature.FieldUpdateTime:
		return m.UpdateTime()
	case workloadfeature.FieldFeatureSourceEnumID:
		return m.FeatureSourceEnumID()
	case workloadfeature.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadFeatureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workloadfeature.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workloadfeature.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workloadfeature.FieldFeatureSourceEnumID:
		return m.OldFeatureSourceEnumID(ctx)
	case workloadfeature.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown WorkloadFeature field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadFeatureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workloadfeature.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workloadfeature.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workloadfeature.FieldFeatureSourceEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureSourceEnumID(v)
		return nil
	case workloadfeature.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeature field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadFeatureMutation) AddedFields() []string {
	var fields []string
	if m.addfeature_source_enum_id != nil {
		fields = append(fields, workloadfeature.FieldFeatureSourceEnumID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadFeatureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workloadfeature.FieldFeatureSourceEnumID:
		return m.AddedFeatureSourceEnumID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadFeatureMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workloadfeature.FieldFeatureSourceEnumID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeatureSourceEnumID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeature numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadFeatureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workloadfeature.FieldFeatureSourceEnumID) {
		fields = append(fields, workloadfeature.FieldFeatureSourceEnumID)
	}
	if m.FieldCleared(workloadfeature.FieldDescription) {
		fields = append(fields, workloadfeature.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadFeatureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadFeatureMutation) ClearField(name string) error {
	switch name {
	case workloadfeature.FieldFeatureSourceEnumID:
		m.ClearFeatureSourceEnumID()
		return nil
	case workloadfeature.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeature nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadFeatureMutation) ResetField(name string) error {
	switch name {
	case workloadfeature.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workloadfeature.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workloadfeature.FieldFeatureSourceEnumID:
		m.ResetFeatureSourceEnumID()
		return nil
	case workloadfeature.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeature field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadFeatureMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workload_feature_appls != nil {
		edges = append(edges, workloadfeature.EdgeWorkloadFeatureAppls)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadFeatureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workloadfeature.EdgeWorkloadFeatureAppls:
		ids := make([]ent.Value, 0, len(m.workload_feature_appls))
		for id := range m.workload_feature_appls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadFeatureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedworkload_feature_appls != nil {
		edges = append(edges, workloadfeature.EdgeWorkloadFeatureAppls)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadFeatureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workloadfeature.EdgeWorkloadFeatureAppls:
		ids := make([]ent.Value, 0, len(m.removedworkload_feature_appls))
		for id := range m.removedworkload_feature_appls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadFeatureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkload_feature_appls {
		edges = append(edges, workloadfeature.EdgeWorkloadFeatureAppls)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadFeatureMutation) EdgeCleared(name string) bool {
	switch name {
	case workloadfeature.EdgeWorkloadFeatureAppls:
		return m.clearedworkload_feature_appls
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadFeatureMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkloadFeature unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadFeatureMutation) ResetEdge(name string) error {
	switch name {
	case workloadfeature.EdgeWorkloadFeatureAppls:
		m.ResetWorkloadFeatureAppls()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeature edge %s", name)
}

// WorkloadFeatureApplMutation represents an operation that mutates the WorkloadFeatureAppl nodes in the graph.
type WorkloadFeatureApplMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	create_time                       *time.Time
	update_time                       *time.Time
	from_date                         *time.Time
	thru_date                         *time.Time
	sequence_num                      *int
	addsequence_num                   *int
	clearedFields                     map[string]struct{}
	workload                          *int
	clearedworkload                   bool
	workload_feature                  *int
	clearedworkload_feature           bool
	workload_feature_appl_type        *int
	clearedworkload_feature_appl_type bool
	done                              bool
	oldValue                          func(context.Context) (*WorkloadFeatureAppl, error)
	predicates                        []predicate.WorkloadFeatureAppl
}

var _ ent.Mutation = (*WorkloadFeatureApplMutation)(nil)

// workloadfeatureapplOption allows management of the mutation configuration using functional options.
type workloadfeatureapplOption func(*WorkloadFeatureApplMutation)

// newWorkloadFeatureApplMutation creates new mutation for the WorkloadFeatureAppl entity.
func newWorkloadFeatureApplMutation(c config, op Op, opts ...workloadfeatureapplOption) *WorkloadFeatureApplMutation {
	m := &WorkloadFeatureApplMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkloadFeatureAppl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadFeatureApplID sets the ID field of the mutation.
func withWorkloadFeatureApplID(id int) workloadfeatureapplOption {
	return func(m *WorkloadFeatureApplMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkloadFeatureAppl
		)
		m.oldValue = func(ctx context.Context) (*WorkloadFeatureAppl, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkloadFeatureAppl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkloadFeatureAppl sets the old WorkloadFeatureAppl of the mutation.
func withWorkloadFeatureAppl(node *WorkloadFeatureAppl) workloadfeatureapplOption {
	return func(m *WorkloadFeatureApplMutation) {
		m.oldValue = func(context.Context) (*WorkloadFeatureAppl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadFeatureApplMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadFeatureApplMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadFeatureApplMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadFeatureApplMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadFeatureApplMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkloadFeatureAppl entity.
// If the WorkloadFeatureAppl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadFeatureApplMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadFeatureApplMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadFeatureApplMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkloadFeatureAppl entity.
// If the WorkloadFeatureAppl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadFeatureApplMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFromDate sets the "from_date" field.
func (m *WorkloadFeatureApplMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *WorkloadFeatureApplMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the WorkloadFeatureAppl entity.
// If the WorkloadFeatureAppl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *WorkloadFeatureApplMutation) ResetFromDate() {
	m.from_date = nil
}

// SetThruDate sets the "thru_date" field.
func (m *WorkloadFeatureApplMutation) SetThruDate(t time.Time) {
	m.thru_date = &t
}

// ThruDate returns the value of the "thru_date" field in the mutation.
func (m *WorkloadFeatureApplMutation) ThruDate() (r time.Time, exists bool) {
	v := m.thru_date
	if v == nil {
		return
	}
	return *v, true
}

// OldThruDate returns the old "thru_date" field's value of the WorkloadFeatureAppl entity.
// If the WorkloadFeatureAppl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplMutation) OldThruDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThruDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThruDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThruDate: %w", err)
	}
	return oldValue.ThruDate, nil
}

// ClearThruDate clears the value of the "thru_date" field.
func (m *WorkloadFeatureApplMutation) ClearThruDate() {
	m.thru_date = nil
	m.clearedFields[workloadfeatureappl.FieldThruDate] = struct{}{}
}

// ThruDateCleared returns if the "thru_date" field was cleared in this mutation.
func (m *WorkloadFeatureApplMutation) ThruDateCleared() bool {
	_, ok := m.clearedFields[workloadfeatureappl.FieldThruDate]
	return ok
}

// ResetThruDate resets all changes to the "thru_date" field.
func (m *WorkloadFeatureApplMutation) ResetThruDate() {
	m.thru_date = nil
	delete(m.clearedFields, workloadfeatureappl.FieldThruDate)
}

// SetSequenceNum sets the "sequence_num" field.
func (m *WorkloadFeatureApplMutation) SetSequenceNum(i int) {
	m.sequence_num = &i
	m.addsequence_num = nil
}

// SequenceNum returns the value of the "sequence_num" field in the mutation.
func (m *WorkloadFeatureApplMutation) SequenceNum() (r int, exists bool) {
	v := m.sequence_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNum returns the old "sequence_num" field's value of the WorkloadFeatureAppl entity.
// If the WorkloadFeatureAppl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplMutation) OldSequenceNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSequenceNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSequenceNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNum: %w", err)
	}
	return oldValue.SequenceNum, nil
}

// AddSequenceNum adds i to the "sequence_num" field.
func (m *WorkloadFeatureApplMutation) AddSequenceNum(i int) {
	if m.addsequence_num != nil {
		*m.addsequence_num += i
	} else {
		m.addsequence_num = &i
	}
}

// AddedSequenceNum returns the value that was added to the "sequence_num" field in this mutation.
func (m *WorkloadFeatureApplMutation) AddedSequenceNum() (r int, exists bool) {
	v := m.addsequence_num
	if v == nil {
		return
	}
	return *v, true
}

// ClearSequenceNum clears the value of the "sequence_num" field.
func (m *WorkloadFeatureApplMutation) ClearSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	m.clearedFields[workloadfeatureappl.FieldSequenceNum] = struct{}{}
}

// SequenceNumCleared returns if the "sequence_num" field was cleared in this mutation.
func (m *WorkloadFeatureApplMutation) SequenceNumCleared() bool {
	_, ok := m.clearedFields[workloadfeatureappl.FieldSequenceNum]
	return ok
}

// ResetSequenceNum resets all changes to the "sequence_num" field.
func (m *WorkloadFeatureApplMutation) ResetSequenceNum() {
	m.sequence_num = nil
	m.addsequence_num = nil
	delete(m.clearedFields, workloadfeatureappl.FieldSequenceNum)
}

// SetWorkloadID sets the "workload" edge to the Workload entity by id.
func (m *WorkloadFeatureApplMutation) SetWorkloadID(id int) {
	m.workload = &id
}

// ClearWorkload clears the "workload" edge to the Workload entity.
func (m *WorkloadFeatureApplMutation) ClearWorkload() {
	m.clearedworkload = true
}

// WorkloadCleared reports if the "workload" edge to the Workload entity was cleared.
func (m *WorkloadFeatureApplMutation) WorkloadCleared() bool {
	return m.clearedworkload
}

// WorkloadID returns the "workload" edge ID in the mutation.
func (m *WorkloadFeatureApplMutation) WorkloadID() (id int, exists bool) {
	if m.workload != nil {
		return *m.workload, true
	}
	return
}

// WorkloadIDs returns the "workload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkloadID instead. It exists only for internal usage by the builders.
func (m *WorkloadFeatureApplMutation) WorkloadIDs() (ids []int) {
	if id := m.workload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkload resets all changes to the "workload" edge.
func (m *WorkloadFeatureApplMutation) ResetWorkload() {
	m.workload = nil
	m.clearedworkload = false
}

// SetWorkloadFeatureID sets the "workload_feature" edge to the WorkloadFeature entity by id.
func (m *WorkloadFeatureApplMutation) SetWorkloadFeatureID(id int) {
	m.workload_feature = &id
}

// ClearWorkloadFeature clears the "workload_feature" edge to the WorkloadFeature entity.
func (m *WorkloadFeatureApplMutation) ClearWorkloadFeature() {
	m.clearedworkload_feature = true
}

// WorkloadFeatureCleared reports if the "workload_feature" edge to the WorkloadFeature entity was cleared.
func (m *WorkloadFeatureApplMutation) WorkloadFeatureCleared() bool {
	return m.clearedworkload_feature
}

// WorkloadFeatureID returns the "workload_feature" edge ID in the mutation.
func (m *WorkloadFeatureApplMutation) WorkloadFeatureID() (id int, exists bool) {
	if m.workload_feature != nil {
		return *m.workload_feature, true
	}
	return
}

// WorkloadFeatureIDs returns the "workload_feature" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkloadFeatureID instead. It exists only for internal usage by the builders.
func (m *WorkloadFeatureApplMutation) WorkloadFeatureIDs() (ids []int) {
	if id := m.workload_feature; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkloadFeature resets all changes to the "workload_feature" edge.
func (m *WorkloadFeatureApplMutation) ResetWorkloadFeature() {
	m.workload_feature = nil
	m.clearedworkload_feature = false
}

// SetWorkloadFeatureApplTypeID sets the "workload_feature_appl_type" edge to the WorkloadFeatureApplType entity by id.
func (m *WorkloadFeatureApplMutation) SetWorkloadFeatureApplTypeID(id int) {
	m.workload_feature_appl_type = &id
}

// ClearWorkloadFeatureApplType clears the "workload_feature_appl_type" edge to the WorkloadFeatureApplType entity.
func (m *WorkloadFeatureApplMutation) ClearWorkloadFeatureApplType() {
	m.clearedworkload_feature_appl_type = true
}

// WorkloadFeatureApplTypeCleared reports if the "workload_feature_appl_type" edge to the WorkloadFeatureApplType entity was cleared.
func (m *WorkloadFeatureApplMutation) WorkloadFeatureApplTypeCleared() bool {
	return m.clearedworkload_feature_appl_type
}

// WorkloadFeatureApplTypeID returns the "workload_feature_appl_type" edge ID in the mutation.
func (m *WorkloadFeatureApplMutation) WorkloadFeatureApplTypeID() (id int, exists bool) {
	if m.workload_feature_appl_type != nil {
		return *m.workload_feature_appl_type, true
	}
	return
}

// WorkloadFeatureApplTypeIDs returns the "workload_feature_appl_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkloadFeatureApplTypeID instead. It exists only for internal usage by the builders.
func (m *WorkloadFeatureApplMutation) WorkloadFeatureApplTypeIDs() (ids []int) {
	if id := m.workload_feature_appl_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkloadFeatureApplType resets all changes to the "workload_feature_appl_type" edge.
func (m *WorkloadFeatureApplMutation) ResetWorkloadFeatureApplType() {
	m.workload_feature_appl_type = nil
	m.clearedworkload_feature_appl_type = false
}

// Op returns the operation name.
func (m *WorkloadFeatureApplMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkloadFeatureAppl).
func (m *WorkloadFeatureApplMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadFeatureApplMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, workloadfeatureappl.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workloadfeatureappl.FieldUpdateTime)
	}
	if m.from_date != nil {
		fields = append(fields, workloadfeatureappl.FieldFromDate)
	}
	if m.thru_date != nil {
		fields = append(fields, workloadfeatureappl.FieldThruDate)
	}
	if m.sequence_num != nil {
		fields = append(fields, workloadfeatureappl.FieldSequenceNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadFeatureApplMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workloadfeatureappl.FieldCreateTime:
		return m.CreateTime()
	case workloadfeatureappl.FieldUpdateTime:
		return m.UpdateTime()
	case workloadfeatureappl.FieldFromDate:
		return m.FromDate()
	case workloadfeatureappl.FieldThruDate:
		return m.ThruDate()
	case workloadfeatureappl.FieldSequenceNum:
		return m.SequenceNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadFeatureApplMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workloadfeatureappl.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workloadfeatureappl.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workloadfeatureappl.FieldFromDate:
		return m.OldFromDate(ctx)
	case workloadfeatureappl.FieldThruDate:
		return m.OldThruDate(ctx)
	case workloadfeatureappl.FieldSequenceNum:
		return m.OldSequenceNum(ctx)
	}
	return nil, fmt.Errorf("unknown WorkloadFeatureAppl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadFeatureApplMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workloadfeatureappl.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workloadfeatureappl.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workloadfeatureappl.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case workloadfeatureappl.FieldThruDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThruDate(v)
		return nil
	case workloadfeatureappl.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNum(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureAppl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadFeatureApplMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_num != nil {
		fields = append(fields, workloadfeatureappl.FieldSequenceNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadFeatureApplMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workloadfeatureappl.FieldSequenceNum:
		return m.AddedSequenceNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadFeatureApplMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workloadfeatureappl.FieldSequenceNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNum(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureAppl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadFeatureApplMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workloadfeatureappl.FieldThruDate) {
		fields = append(fields, workloadfeatureappl.FieldThruDate)
	}
	if m.FieldCleared(workloadfeatureappl.FieldSequenceNum) {
		fields = append(fields, workloadfeatureappl.FieldSequenceNum)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadFeatureApplMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadFeatureApplMutation) ClearField(name string) error {
	switch name {
	case workloadfeatureappl.FieldThruDate:
		m.ClearThruDate()
		return nil
	case workloadfeatureappl.FieldSequenceNum:
		m.ClearSequenceNum()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureAppl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadFeatureApplMutation) ResetField(name string) error {
	switch name {
	case workloadfeatureappl.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workloadfeatureappl.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workloadfeatureappl.FieldFromDate:
		m.ResetFromDate()
		return nil
	case workloadfeatureappl.FieldThruDate:
		m.ResetThruDate()
		return nil
	case workloadfeatureappl.FieldSequenceNum:
		m.ResetSequenceNum()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureAppl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadFeatureApplMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workload != nil {
		edges = append(edges, workloadfeatureappl.EdgeWorkload)
	}
	if m.workload_feature != nil {
		edges = append(edges, workloadfeatureappl.EdgeWorkloadFeature)
	}
	if m.workload_feature_appl_type != nil {
		edges = append(edges, workloadfeatureappl.EdgeWorkloadFeatureApplType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadFeatureApplMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workloadfeatureappl.EdgeWorkload:
		if id := m.workload; id != nil {
			return []ent.Value{*id}
		}
	case workloadfeatureappl.EdgeWorkloadFeature:
		if id := m.workload_feature; id != nil {
			return []ent.Value{*id}
		}
	case workloadfeatureappl.EdgeWorkloadFeatureApplType:
		if id := m.workload_feature_appl_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadFeatureApplMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadFeatureApplMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadFeatureApplMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkload {
		edges = append(edges, workloadfeatureappl.EdgeWorkload)
	}
	if m.clearedworkload_feature {
		edges = append(edges, workloadfeatureappl.EdgeWorkloadFeature)
	}
	if m.clearedworkload_feature_appl_type {
		edges = append(edges, workloadfeatureappl.EdgeWorkloadFeatureApplType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadFeatureApplMutation) EdgeCleared(name string) bool {
	switch name {
	case workloadfeatureappl.EdgeWorkload:
		return m.clearedworkload
	case workloadfeatureappl.EdgeWorkloadFeature:
		return m.clearedworkload_feature
	case workloadfeatureappl.EdgeWorkloadFeatureApplType:
		return m.clearedworkload_feature_appl_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadFeatureApplMutation) ClearEdge(name string) error {
	switch name {
	case workloadfeatureappl.EdgeWorkload:
		m.ClearWorkload()
		return nil
	case workloadfeatureappl.EdgeWorkloadFeature:
		m.ClearWorkloadFeature()
		return nil
	case workloadfeatureappl.EdgeWorkloadFeatureApplType:
		m.ClearWorkloadFeatureApplType()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureAppl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadFeatureApplMutation) ResetEdge(name string) error {
	switch name {
	case workloadfeatureappl.EdgeWorkload:
		m.ResetWorkload()
		return nil
	case workloadfeatureappl.EdgeWorkloadFeature:
		m.ResetWorkloadFeature()
		return nil
	case workloadfeatureappl.EdgeWorkloadFeatureApplType:
		m.ResetWorkloadFeatureApplType()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureAppl edge %s", name)
}

// WorkloadFeatureApplTypeMutation represents an operation that mutates the WorkloadFeatureApplType nodes in the graph.
type WorkloadFeatureApplTypeMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	description                   *string
	clearedFields                 map[string]struct{}
	parent                        *int
	clearedparent                 bool
	children                      map[int]struct{}
	removedchildren               map[int]struct{}
	clearedchildren               bool
	workload_feature_appls        map[int]struct{}
	removedworkload_feature_appls map[int]struct{}
	clearedworkload_feature_appls bool
	done                          bool
	oldValue                      func(context.Context) (*WorkloadFeatureApplType, error)
	predicates                    []predicate.WorkloadFeatureApplType
}

var _ ent.Mutation = (*WorkloadFeatureApplTypeMutation)(nil)

// workloadfeatureappltypeOption allows management of the mutation configuration using functional options.
type workloadfeatureappltypeOption func(*WorkloadFeatureApplTypeMutation)

// newWorkloadFeatureApplTypeMutation creates new mutation for the WorkloadFeatureApplType entity.
func newWorkloadFeatureApplTypeMutation(c config, op Op, opts ...workloadfeatureappltypeOption) *WorkloadFeatureApplTypeMutation {
	m := &WorkloadFeatureApplTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkloadFeatureApplType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadFeatureApplTypeID sets the ID field of the mutation.
func withWorkloadFeatureApplTypeID(id int) workloadfeatureappltypeOption {
	return func(m *WorkloadFeatureApplTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkloadFeatureApplType
		)
		m.oldValue = func(ctx context.Context) (*WorkloadFeatureApplType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkloadFeatureApplType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkloadFeatureApplType sets the old WorkloadFeatureApplType of the mutation.
func withWorkloadFeatureApplType(node *WorkloadFeatureApplType) workloadfeatureappltypeOption {
	return func(m *WorkloadFeatureApplTypeMutation) {
		m.oldValue = func(context.Context) (*WorkloadFeatureApplType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadFeatureApplTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadFeatureApplTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadFeatureApplTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadFeatureApplTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadFeatureApplTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkloadFeatureApplType entity.
// If the WorkloadFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadFeatureApplTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadFeatureApplTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadFeatureApplTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkloadFeatureApplType entity.
// If the WorkloadFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadFeatureApplTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDescription sets the "description" field.
func (m *WorkloadFeatureApplTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkloadFeatureApplTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkloadFeatureApplType entity.
// If the WorkloadFeatureApplType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadFeatureApplTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkloadFeatureApplTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workloadfeatureappltype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkloadFeatureApplTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workloadfeatureappltype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkloadFeatureApplTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workloadfeatureappltype.FieldDescription)
}

// SetParentID sets the "parent" edge to the WorkloadFeatureApplType entity by id.
func (m *WorkloadFeatureApplTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the WorkloadFeatureApplType entity.
func (m *WorkloadFeatureApplTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the WorkloadFeatureApplType entity was cleared.
func (m *WorkloadFeatureApplTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *WorkloadFeatureApplTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *WorkloadFeatureApplTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *WorkloadFeatureApplTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the WorkloadFeatureApplType entity by ids.
func (m *WorkloadFeatureApplTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the WorkloadFeatureApplType entity.
func (m *WorkloadFeatureApplTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the WorkloadFeatureApplType entity was cleared.
func (m *WorkloadFeatureApplTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the WorkloadFeatureApplType entity by IDs.
func (m *WorkloadFeatureApplTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the WorkloadFeatureApplType entity.
func (m *WorkloadFeatureApplTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *WorkloadFeatureApplTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *WorkloadFeatureApplTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddWorkloadFeatureApplIDs adds the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by ids.
func (m *WorkloadFeatureApplTypeMutation) AddWorkloadFeatureApplIDs(ids ...int) {
	if m.workload_feature_appls == nil {
		m.workload_feature_appls = make(map[int]struct{})
	}
	for i := range ids {
		m.workload_feature_appls[ids[i]] = struct{}{}
	}
}

// ClearWorkloadFeatureAppls clears the "workload_feature_appls" edge to the WorkloadFeatureAppl entity.
func (m *WorkloadFeatureApplTypeMutation) ClearWorkloadFeatureAppls() {
	m.clearedworkload_feature_appls = true
}

// WorkloadFeatureApplsCleared reports if the "workload_feature_appls" edge to the WorkloadFeatureAppl entity was cleared.
func (m *WorkloadFeatureApplTypeMutation) WorkloadFeatureApplsCleared() bool {
	return m.clearedworkload_feature_appls
}

// RemoveWorkloadFeatureApplIDs removes the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by IDs.
func (m *WorkloadFeatureApplTypeMutation) RemoveWorkloadFeatureApplIDs(ids ...int) {
	if m.removedworkload_feature_appls == nil {
		m.removedworkload_feature_appls = make(map[int]struct{})
	}
	for i := range ids {
		m.removedworkload_feature_appls[ids[i]] = struct{}{}
	}
}

// RemovedWorkloadFeatureAppls returns the removed IDs of the "workload_feature_appls" edge to the WorkloadFeatureAppl entity.
func (m *WorkloadFeatureApplTypeMutation) RemovedWorkloadFeatureApplsIDs() (ids []int) {
	for id := range m.removedworkload_feature_appls {
		ids = append(ids, id)
	}
	return
}

// WorkloadFeatureApplsIDs returns the "workload_feature_appls" edge IDs in the mutation.
func (m *WorkloadFeatureApplTypeMutation) WorkloadFeatureApplsIDs() (ids []int) {
	for id := range m.workload_feature_appls {
		ids = append(ids, id)
	}
	return
}

// ResetWorkloadFeatureAppls resets all changes to the "workload_feature_appls" edge.
func (m *WorkloadFeatureApplTypeMutation) ResetWorkloadFeatureAppls() {
	m.workload_feature_appls = nil
	m.clearedworkload_feature_appls = false
	m.removedworkload_feature_appls = nil
}

// Op returns the operation name.
func (m *WorkloadFeatureApplTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkloadFeatureApplType).
func (m *WorkloadFeatureApplTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadFeatureApplTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, workloadfeatureappltype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workloadfeatureappltype.FieldUpdateTime)
	}
	if m.description != nil {
		fields = append(fields, workloadfeatureappltype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadFeatureApplTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workloadfeatureappltype.FieldCreateTime:
		return m.CreateTime()
	case workloadfeatureappltype.FieldUpdateTime:
		return m.UpdateTime()
	case workloadfeatureappltype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadFeatureApplTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workloadfeatureappltype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workloadfeatureappltype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workloadfeatureappltype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown WorkloadFeatureApplType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadFeatureApplTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workloadfeatureappltype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workloadfeatureappltype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workloadfeatureappltype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureApplType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadFeatureApplTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadFeatureApplTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadFeatureApplTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkloadFeatureApplType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadFeatureApplTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workloadfeatureappltype.FieldDescription) {
		fields = append(fields, workloadfeatureappltype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadFeatureApplTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadFeatureApplTypeMutation) ClearField(name string) error {
	switch name {
	case workloadfeatureappltype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureApplType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadFeatureApplTypeMutation) ResetField(name string) error {
	switch name {
	case workloadfeatureappltype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workloadfeatureappltype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workloadfeatureappltype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureApplType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadFeatureApplTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, workloadfeatureappltype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, workloadfeatureappltype.EdgeChildren)
	}
	if m.workload_feature_appls != nil {
		edges = append(edges, workloadfeatureappltype.EdgeWorkloadFeatureAppls)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadFeatureApplTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workloadfeatureappltype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case workloadfeatureappltype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case workloadfeatureappltype.EdgeWorkloadFeatureAppls:
		ids := make([]ent.Value, 0, len(m.workload_feature_appls))
		for id := range m.workload_feature_appls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadFeatureApplTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, workloadfeatureappltype.EdgeChildren)
	}
	if m.removedworkload_feature_appls != nil {
		edges = append(edges, workloadfeatureappltype.EdgeWorkloadFeatureAppls)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadFeatureApplTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workloadfeatureappltype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case workloadfeatureappltype.EdgeWorkloadFeatureAppls:
		ids := make([]ent.Value, 0, len(m.removedworkload_feature_appls))
		for id := range m.removedworkload_feature_appls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadFeatureApplTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, workloadfeatureappltype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, workloadfeatureappltype.EdgeChildren)
	}
	if m.clearedworkload_feature_appls {
		edges = append(edges, workloadfeatureappltype.EdgeWorkloadFeatureAppls)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadFeatureApplTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case workloadfeatureappltype.EdgeParent:
		return m.clearedparent
	case workloadfeatureappltype.EdgeChildren:
		return m.clearedchildren
	case workloadfeatureappltype.EdgeWorkloadFeatureAppls:
		return m.clearedworkload_feature_appls
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadFeatureApplTypeMutation) ClearEdge(name string) error {
	switch name {
	case workloadfeatureappltype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureApplType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadFeatureApplTypeMutation) ResetEdge(name string) error {
	switch name {
	case workloadfeatureappltype.EdgeParent:
		m.ResetParent()
		return nil
	case workloadfeatureappltype.EdgeChildren:
		m.ResetChildren()
		return nil
	case workloadfeatureappltype.EdgeWorkloadFeatureAppls:
		m.ResetWorkloadFeatureAppls()
		return nil
	}
	return fmt.Errorf("unknown WorkloadFeatureApplType edge %s", name)
}

// WorkloadItemMutation represents an operation that mutates the WorkloadItem nodes in the graph.
type WorkloadItemMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	workload_item_seq_id    *int
	addworkload_item_seq_id *int
	description             *string
	amount                  *float64
	addamount               *float64
	amount_uom_id           *int
	addamount_uom_id        *int
	clearedFields           map[string]struct{}
	workload                *int
	clearedworkload         bool
	done                    bool
	oldValue                func(context.Context) (*WorkloadItem, error)
	predicates              []predicate.WorkloadItem
}

var _ ent.Mutation = (*WorkloadItemMutation)(nil)

// workloaditemOption allows management of the mutation configuration using functional options.
type workloaditemOption func(*WorkloadItemMutation)

// newWorkloadItemMutation creates new mutation for the WorkloadItem entity.
func newWorkloadItemMutation(c config, op Op, opts ...workloaditemOption) *WorkloadItemMutation {
	m := &WorkloadItemMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkloadItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadItemID sets the ID field of the mutation.
func withWorkloadItemID(id int) workloaditemOption {
	return func(m *WorkloadItemMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkloadItem
		)
		m.oldValue = func(ctx context.Context) (*WorkloadItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkloadItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkloadItem sets the old WorkloadItem of the mutation.
func withWorkloadItem(node *WorkloadItem) workloaditemOption {
	return func(m *WorkloadItemMutation) {
		m.oldValue = func(context.Context) (*WorkloadItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkloadItem entity.
// If the WorkloadItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkloadItem entity.
// If the WorkloadItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetWorkloadItemSeqID sets the "workload_item_seq_id" field.
func (m *WorkloadItemMutation) SetWorkloadItemSeqID(i int) {
	m.workload_item_seq_id = &i
	m.addworkload_item_seq_id = nil
}

// WorkloadItemSeqID returns the value of the "workload_item_seq_id" field in the mutation.
func (m *WorkloadItemMutation) WorkloadItemSeqID() (r int, exists bool) {
	v := m.workload_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkloadItemSeqID returns the old "workload_item_seq_id" field's value of the WorkloadItem entity.
// If the WorkloadItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadItemMutation) OldWorkloadItemSeqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkloadItemSeqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkloadItemSeqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkloadItemSeqID: %w", err)
	}
	return oldValue.WorkloadItemSeqID, nil
}

// AddWorkloadItemSeqID adds i to the "workload_item_seq_id" field.
func (m *WorkloadItemMutation) AddWorkloadItemSeqID(i int) {
	if m.addworkload_item_seq_id != nil {
		*m.addworkload_item_seq_id += i
	} else {
		m.addworkload_item_seq_id = &i
	}
}

// AddedWorkloadItemSeqID returns the value that was added to the "workload_item_seq_id" field in this mutation.
func (m *WorkloadItemMutation) AddedWorkloadItemSeqID() (r int, exists bool) {
	v := m.addworkload_item_seq_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkloadItemSeqID resets all changes to the "workload_item_seq_id" field.
func (m *WorkloadItemMutation) ResetWorkloadItemSeqID() {
	m.workload_item_seq_id = nil
	m.addworkload_item_seq_id = nil
}

// SetDescription sets the "description" field.
func (m *WorkloadItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkloadItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkloadItem entity.
// If the WorkloadItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkloadItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workloaditem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkloadItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workloaditem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkloadItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workloaditem.FieldDescription)
}

// SetAmount sets the "amount" field.
func (m *WorkloadItemMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *WorkloadItemMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the WorkloadItem entity.
// If the WorkloadItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadItemMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *WorkloadItemMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *WorkloadItemMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *WorkloadItemMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[workloaditem.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *WorkloadItemMutation) AmountCleared() bool {
	_, ok := m.clearedFields[workloaditem.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *WorkloadItemMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, workloaditem.FieldAmount)
}

// SetAmountUomID sets the "amount_uom_id" field.
func (m *WorkloadItemMutation) SetAmountUomID(i int) {
	m.amount_uom_id = &i
	m.addamount_uom_id = nil
}

// AmountUomID returns the value of the "amount_uom_id" field in the mutation.
func (m *WorkloadItemMutation) AmountUomID() (r int, exists bool) {
	v := m.amount_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountUomID returns the old "amount_uom_id" field's value of the WorkloadItem entity.
// If the WorkloadItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadItemMutation) OldAmountUomID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmountUomID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmountUomID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountUomID: %w", err)
	}
	return oldValue.AmountUomID, nil
}

// AddAmountUomID adds i to the "amount_uom_id" field.
func (m *WorkloadItemMutation) AddAmountUomID(i int) {
	if m.addamount_uom_id != nil {
		*m.addamount_uom_id += i
	} else {
		m.addamount_uom_id = &i
	}
}

// AddedAmountUomID returns the value that was added to the "amount_uom_id" field in this mutation.
func (m *WorkloadItemMutation) AddedAmountUomID() (r int, exists bool) {
	v := m.addamount_uom_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmountUomID clears the value of the "amount_uom_id" field.
func (m *WorkloadItemMutation) ClearAmountUomID() {
	m.amount_uom_id = nil
	m.addamount_uom_id = nil
	m.clearedFields[workloaditem.FieldAmountUomID] = struct{}{}
}

// AmountUomIDCleared returns if the "amount_uom_id" field was cleared in this mutation.
func (m *WorkloadItemMutation) AmountUomIDCleared() bool {
	_, ok := m.clearedFields[workloaditem.FieldAmountUomID]
	return ok
}

// ResetAmountUomID resets all changes to the "amount_uom_id" field.
func (m *WorkloadItemMutation) ResetAmountUomID() {
	m.amount_uom_id = nil
	m.addamount_uom_id = nil
	delete(m.clearedFields, workloaditem.FieldAmountUomID)
}

// SetWorkloadID sets the "workload" edge to the Workload entity by id.
func (m *WorkloadItemMutation) SetWorkloadID(id int) {
	m.workload = &id
}

// ClearWorkload clears the "workload" edge to the Workload entity.
func (m *WorkloadItemMutation) ClearWorkload() {
	m.clearedworkload = true
}

// WorkloadCleared reports if the "workload" edge to the Workload entity was cleared.
func (m *WorkloadItemMutation) WorkloadCleared() bool {
	return m.clearedworkload
}

// WorkloadID returns the "workload" edge ID in the mutation.
func (m *WorkloadItemMutation) WorkloadID() (id int, exists bool) {
	if m.workload != nil {
		return *m.workload, true
	}
	return
}

// WorkloadIDs returns the "workload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkloadID instead. It exists only for internal usage by the builders.
func (m *WorkloadItemMutation) WorkloadIDs() (ids []int) {
	if id := m.workload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkload resets all changes to the "workload" edge.
func (m *WorkloadItemMutation) ResetWorkload() {
	m.workload = nil
	m.clearedworkload = false
}

// Op returns the operation name.
func (m *WorkloadItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkloadItem).
func (m *WorkloadItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, workloaditem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workloaditem.FieldUpdateTime)
	}
	if m.workload_item_seq_id != nil {
		fields = append(fields, workloaditem.FieldWorkloadItemSeqID)
	}
	if m.description != nil {
		fields = append(fields, workloaditem.FieldDescription)
	}
	if m.amount != nil {
		fields = append(fields, workloaditem.FieldAmount)
	}
	if m.amount_uom_id != nil {
		fields = append(fields, workloaditem.FieldAmountUomID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workloaditem.FieldCreateTime:
		return m.CreateTime()
	case workloaditem.FieldUpdateTime:
		return m.UpdateTime()
	case workloaditem.FieldWorkloadItemSeqID:
		return m.WorkloadItemSeqID()
	case workloaditem.FieldDescription:
		return m.Description()
	case workloaditem.FieldAmount:
		return m.Amount()
	case workloaditem.FieldAmountUomID:
		return m.AmountUomID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workloaditem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workloaditem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workloaditem.FieldWorkloadItemSeqID:
		return m.OldWorkloadItemSeqID(ctx)
	case workloaditem.FieldDescription:
		return m.OldDescription(ctx)
	case workloaditem.FieldAmount:
		return m.OldAmount(ctx)
	case workloaditem.FieldAmountUomID:
		return m.OldAmountUomID(ctx)
	}
	return nil, fmt.Errorf("unknown WorkloadItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workloaditem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workloaditem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workloaditem.FieldWorkloadItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkloadItemSeqID(v)
		return nil
	case workloaditem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workloaditem.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case workloaditem.FieldAmountUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountUomID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadItemMutation) AddedFields() []string {
	var fields []string
	if m.addworkload_item_seq_id != nil {
		fields = append(fields, workloaditem.FieldWorkloadItemSeqID)
	}
	if m.addamount != nil {
		fields = append(fields, workloaditem.FieldAmount)
	}
	if m.addamount_uom_id != nil {
		fields = append(fields, workloaditem.FieldAmountUomID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workloaditem.FieldWorkloadItemSeqID:
		return m.AddedWorkloadItemSeqID()
	case workloaditem.FieldAmount:
		return m.AddedAmount()
	case workloaditem.FieldAmountUomID:
		return m.AddedAmountUomID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workloaditem.FieldWorkloadItemSeqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkloadItemSeqID(v)
		return nil
	case workloaditem.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case workloaditem.FieldAmountUomID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountUomID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workloaditem.FieldDescription) {
		fields = append(fields, workloaditem.FieldDescription)
	}
	if m.FieldCleared(workloaditem.FieldAmount) {
		fields = append(fields, workloaditem.FieldAmount)
	}
	if m.FieldCleared(workloaditem.FieldAmountUomID) {
		fields = append(fields, workloaditem.FieldAmountUomID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadItemMutation) ClearField(name string) error {
	switch name {
	case workloaditem.FieldDescription:
		m.ClearDescription()
		return nil
	case workloaditem.FieldAmount:
		m.ClearAmount()
		return nil
	case workloaditem.FieldAmountUomID:
		m.ClearAmountUomID()
		return nil
	}
	return fmt.Errorf("unknown WorkloadItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadItemMutation) ResetField(name string) error {
	switch name {
	case workloaditem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workloaditem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workloaditem.FieldWorkloadItemSeqID:
		m.ResetWorkloadItemSeqID()
		return nil
	case workloaditem.FieldDescription:
		m.ResetDescription()
		return nil
	case workloaditem.FieldAmount:
		m.ResetAmount()
		return nil
	case workloaditem.FieldAmountUomID:
		m.ResetAmountUomID()
		return nil
	}
	return fmt.Errorf("unknown WorkloadItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workload != nil {
		edges = append(edges, workloaditem.EdgeWorkload)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workloaditem.EdgeWorkload:
		if id := m.workload; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkload {
		edges = append(edges, workloaditem.EdgeWorkload)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadItemMutation) EdgeCleared(name string) bool {
	switch name {
	case workloaditem.EdgeWorkload:
		return m.clearedworkload
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadItemMutation) ClearEdge(name string) error {
	switch name {
	case workloaditem.EdgeWorkload:
		m.ClearWorkload()
		return nil
	}
	return fmt.Errorf("unknown WorkloadItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadItemMutation) ResetEdge(name string) error {
	switch name {
	case workloaditem.EdgeWorkload:
		m.ResetWorkload()
		return nil
	}
	return fmt.Errorf("unknown WorkloadItem edge %s", name)
}

// WorkloadStatusMutation represents an operation that mutates the WorkloadStatus nodes in the graph.
type WorkloadStatusMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	create_time             *time.Time
	update_time             *time.Time
	status_date             *time.Time
	status_end_date         *time.Time
	change_by_user_login_id *string
	status_id               *int
	addstatus_id            *int
	clearedFields           map[string]struct{}
	workload                *int
	clearedworkload         bool
	done                    bool
	oldValue                func(context.Context) (*WorkloadStatus, error)
	predicates              []predicate.WorkloadStatus
}

var _ ent.Mutation = (*WorkloadStatusMutation)(nil)

// workloadstatusOption allows management of the mutation configuration using functional options.
type workloadstatusOption func(*WorkloadStatusMutation)

// newWorkloadStatusMutation creates new mutation for the WorkloadStatus entity.
func newWorkloadStatusMutation(c config, op Op, opts ...workloadstatusOption) *WorkloadStatusMutation {
	m := &WorkloadStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkloadStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadStatusID sets the ID field of the mutation.
func withWorkloadStatusID(id int) workloadstatusOption {
	return func(m *WorkloadStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkloadStatus
		)
		m.oldValue = func(ctx context.Context) (*WorkloadStatus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkloadStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkloadStatus sets the old WorkloadStatus of the mutation.
func withWorkloadStatus(node *WorkloadStatus) workloadstatusOption {
	return func(m *WorkloadStatusMutation) {
		m.oldValue = func(context.Context) (*WorkloadStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadStatusMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadStatusMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkloadStatus entity.
// If the WorkloadStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadStatusMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadStatusMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadStatusMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadStatusMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkloadStatus entity.
// If the WorkloadStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadStatusMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadStatusMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatusDate sets the "status_date" field.
func (m *WorkloadStatusMutation) SetStatusDate(t time.Time) {
	m.status_date = &t
}

// StatusDate returns the value of the "status_date" field in the mutation.
func (m *WorkloadStatusMutation) StatusDate() (r time.Time, exists bool) {
	v := m.status_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDate returns the old "status_date" field's value of the WorkloadStatus entity.
// If the WorkloadStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadStatusMutation) OldStatusDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDate: %w", err)
	}
	return oldValue.StatusDate, nil
}

// ResetStatusDate resets all changes to the "status_date" field.
func (m *WorkloadStatusMutation) ResetStatusDate() {
	m.status_date = nil
}

// SetStatusEndDate sets the "status_end_date" field.
func (m *WorkloadStatusMutation) SetStatusEndDate(t time.Time) {
	m.status_end_date = &t
}

// StatusEndDate returns the value of the "status_end_date" field in the mutation.
func (m *WorkloadStatusMutation) StatusEndDate() (r time.Time, exists bool) {
	v := m.status_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusEndDate returns the old "status_end_date" field's value of the WorkloadStatus entity.
// If the WorkloadStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadStatusMutation) OldStatusEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusEndDate: %w", err)
	}
	return oldValue.StatusEndDate, nil
}

// ClearStatusEndDate clears the value of the "status_end_date" field.
func (m *WorkloadStatusMutation) ClearStatusEndDate() {
	m.status_end_date = nil
	m.clearedFields[workloadstatus.FieldStatusEndDate] = struct{}{}
}

// StatusEndDateCleared returns if the "status_end_date" field was cleared in this mutation.
func (m *WorkloadStatusMutation) StatusEndDateCleared() bool {
	_, ok := m.clearedFields[workloadstatus.FieldStatusEndDate]
	return ok
}

// ResetStatusEndDate resets all changes to the "status_end_date" field.
func (m *WorkloadStatusMutation) ResetStatusEndDate() {
	m.status_end_date = nil
	delete(m.clearedFields, workloadstatus.FieldStatusEndDate)
}

// SetChangeByUserLoginID sets the "change_by_user_login_id" field.
func (m *WorkloadStatusMutation) SetChangeByUserLoginID(s string) {
	m.change_by_user_login_id = &s
}

// ChangeByUserLoginID returns the value of the "change_by_user_login_id" field in the mutation.
func (m *WorkloadStatusMutation) ChangeByUserLoginID() (r string, exists bool) {
	v := m.change_by_user_login_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeByUserLoginID returns the old "change_by_user_login_id" field's value of the WorkloadStatus entity.
// If the WorkloadStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadStatusMutation) OldChangeByUserLoginID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChangeByUserLoginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChangeByUserLoginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeByUserLoginID: %w", err)
	}
	return oldValue.ChangeByUserLoginID, nil
}

// ClearChangeByUserLoginID clears the value of the "change_by_user_login_id" field.
func (m *WorkloadStatusMutation) ClearChangeByUserLoginID() {
	m.change_by_user_login_id = nil
	m.clearedFields[workloadstatus.FieldChangeByUserLoginID] = struct{}{}
}

// ChangeByUserLoginIDCleared returns if the "change_by_user_login_id" field was cleared in this mutation.
func (m *WorkloadStatusMutation) ChangeByUserLoginIDCleared() bool {
	_, ok := m.clearedFields[workloadstatus.FieldChangeByUserLoginID]
	return ok
}

// ResetChangeByUserLoginID resets all changes to the "change_by_user_login_id" field.
func (m *WorkloadStatusMutation) ResetChangeByUserLoginID() {
	m.change_by_user_login_id = nil
	delete(m.clearedFields, workloadstatus.FieldChangeByUserLoginID)
}

// SetStatusID sets the "status_id" field.
func (m *WorkloadStatusMutation) SetStatusID(i int) {
	m.status_id = &i
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *WorkloadStatusMutation) StatusID() (r int, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the WorkloadStatus entity.
// If the WorkloadStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadStatusMutation) OldStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds i to the "status_id" field.
func (m *WorkloadStatusMutation) AddStatusID(i int) {
	if m.addstatus_id != nil {
		*m.addstatus_id += i
	} else {
		m.addstatus_id = &i
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *WorkloadStatusMutation) AddedStatusID() (r int, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusID clears the value of the "status_id" field.
func (m *WorkloadStatusMutation) ClearStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	m.clearedFields[workloadstatus.FieldStatusID] = struct{}{}
}

// StatusIDCleared returns if the "status_id" field was cleared in this mutation.
func (m *WorkloadStatusMutation) StatusIDCleared() bool {
	_, ok := m.clearedFields[workloadstatus.FieldStatusID]
	return ok
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *WorkloadStatusMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
	delete(m.clearedFields, workloadstatus.FieldStatusID)
}

// SetWorkloadID sets the "workload" edge to the Workload entity by id.
func (m *WorkloadStatusMutation) SetWorkloadID(id int) {
	m.workload = &id
}

// ClearWorkload clears the "workload" edge to the Workload entity.
func (m *WorkloadStatusMutation) ClearWorkload() {
	m.clearedworkload = true
}

// WorkloadCleared reports if the "workload" edge to the Workload entity was cleared.
func (m *WorkloadStatusMutation) WorkloadCleared() bool {
	return m.clearedworkload
}

// WorkloadID returns the "workload" edge ID in the mutation.
func (m *WorkloadStatusMutation) WorkloadID() (id int, exists bool) {
	if m.workload != nil {
		return *m.workload, true
	}
	return
}

// WorkloadIDs returns the "workload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkloadID instead. It exists only for internal usage by the builders.
func (m *WorkloadStatusMutation) WorkloadIDs() (ids []int) {
	if id := m.workload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkload resets all changes to the "workload" edge.
func (m *WorkloadStatusMutation) ResetWorkload() {
	m.workload = nil
	m.clearedworkload = false
}

// Op returns the operation name.
func (m *WorkloadStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkloadStatus).
func (m *WorkloadStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadStatusMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, workloadstatus.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workloadstatus.FieldUpdateTime)
	}
	if m.status_date != nil {
		fields = append(fields, workloadstatus.FieldStatusDate)
	}
	if m.status_end_date != nil {
		fields = append(fields, workloadstatus.FieldStatusEndDate)
	}
	if m.change_by_user_login_id != nil {
		fields = append(fields, workloadstatus.FieldChangeByUserLoginID)
	}
	if m.status_id != nil {
		fields = append(fields, workloadstatus.FieldStatusID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workloadstatus.FieldCreateTime:
		return m.CreateTime()
	case workloadstatus.FieldUpdateTime:
		return m.UpdateTime()
	case workloadstatus.FieldStatusDate:
		return m.StatusDate()
	case workloadstatus.FieldStatusEndDate:
		return m.StatusEndDate()
	case workloadstatus.FieldChangeByUserLoginID:
		return m.ChangeByUserLoginID()
	case workloadstatus.FieldStatusID:
		return m.StatusID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workloadstatus.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workloadstatus.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workloadstatus.FieldStatusDate:
		return m.OldStatusDate(ctx)
	case workloadstatus.FieldStatusEndDate:
		return m.OldStatusEndDate(ctx)
	case workloadstatus.FieldChangeByUserLoginID:
		return m.OldChangeByUserLoginID(ctx)
	case workloadstatus.FieldStatusID:
		return m.OldStatusID(ctx)
	}
	return nil, fmt.Errorf("unknown WorkloadStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workloadstatus.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workloadstatus.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workloadstatus.FieldStatusDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDate(v)
		return nil
	case workloadstatus.FieldStatusEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusEndDate(v)
		return nil
	case workloadstatus.FieldChangeByUserLoginID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeByUserLoginID(v)
		return nil
	case workloadstatus.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadStatusMutation) AddedFields() []string {
	var fields []string
	if m.addstatus_id != nil {
		fields = append(fields, workloadstatus.FieldStatusID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workloadstatus.FieldStatusID:
		return m.AddedStatusID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workloadstatus.FieldStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workloadstatus.FieldStatusEndDate) {
		fields = append(fields, workloadstatus.FieldStatusEndDate)
	}
	if m.FieldCleared(workloadstatus.FieldChangeByUserLoginID) {
		fields = append(fields, workloadstatus.FieldChangeByUserLoginID)
	}
	if m.FieldCleared(workloadstatus.FieldStatusID) {
		fields = append(fields, workloadstatus.FieldStatusID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadStatusMutation) ClearField(name string) error {
	switch name {
	case workloadstatus.FieldStatusEndDate:
		m.ClearStatusEndDate()
		return nil
	case workloadstatus.FieldChangeByUserLoginID:
		m.ClearChangeByUserLoginID()
		return nil
	case workloadstatus.FieldStatusID:
		m.ClearStatusID()
		return nil
	}
	return fmt.Errorf("unknown WorkloadStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadStatusMutation) ResetField(name string) error {
	switch name {
	case workloadstatus.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workloadstatus.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workloadstatus.FieldStatusDate:
		m.ResetStatusDate()
		return nil
	case workloadstatus.FieldStatusEndDate:
		m.ResetStatusEndDate()
		return nil
	case workloadstatus.FieldChangeByUserLoginID:
		m.ResetChangeByUserLoginID()
		return nil
	case workloadstatus.FieldStatusID:
		m.ResetStatusID()
		return nil
	}
	return fmt.Errorf("unknown WorkloadStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workload != nil {
		edges = append(edges, workloadstatus.EdgeWorkload)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workloadstatus.EdgeWorkload:
		if id := m.workload; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkload {
		edges = append(edges, workloadstatus.EdgeWorkload)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case workloadstatus.EdgeWorkload:
		return m.clearedworkload
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadStatusMutation) ClearEdge(name string) error {
	switch name {
	case workloadstatus.EdgeWorkload:
		m.ClearWorkload()
		return nil
	}
	return fmt.Errorf("unknown WorkloadStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadStatusMutation) ResetEdge(name string) error {
	switch name {
	case workloadstatus.EdgeWorkload:
		m.ResetWorkload()
		return nil
	}
	return fmt.Errorf("unknown WorkloadStatus edge %s", name)
}

// WorkloadTypeMutation represents an operation that mutates the WorkloadType nodes in the graph.
type WorkloadTypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	description      *string
	clearedFields    map[string]struct{}
	parent           *int
	clearedparent    bool
	children         map[int]struct{}
	removedchildren  map[int]struct{}
	clearedchildren  bool
	workloads        map[int]struct{}
	removedworkloads map[int]struct{}
	clearedworkloads bool
	done             bool
	oldValue         func(context.Context) (*WorkloadType, error)
	predicates       []predicate.WorkloadType
}

var _ ent.Mutation = (*WorkloadTypeMutation)(nil)

// workloadtypeOption allows management of the mutation configuration using functional options.
type workloadtypeOption func(*WorkloadTypeMutation)

// newWorkloadTypeMutation creates new mutation for the WorkloadType entity.
func newWorkloadTypeMutation(c config, op Op, opts ...workloadtypeOption) *WorkloadTypeMutation {
	m := &WorkloadTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkloadType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkloadTypeID sets the ID field of the mutation.
func withWorkloadTypeID(id int) workloadtypeOption {
	return func(m *WorkloadTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkloadType
		)
		m.oldValue = func(ctx context.Context) (*WorkloadType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkloadType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkloadType sets the old WorkloadType of the mutation.
func withWorkloadType(node *WorkloadType) workloadtypeOption {
	return func(m *WorkloadTypeMutation) {
		m.oldValue = func(context.Context) (*WorkloadType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkloadTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkloadTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WorkloadTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *WorkloadTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *WorkloadTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the WorkloadType entity.
// If the WorkloadType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *WorkloadTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *WorkloadTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *WorkloadTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the WorkloadType entity.
// If the WorkloadType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *WorkloadTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDescription sets the "description" field.
func (m *WorkloadTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkloadTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkloadType entity.
// If the WorkloadType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkloadTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkloadTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workloadtype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkloadTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workloadtype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkloadTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workloadtype.FieldDescription)
}

// SetParentID sets the "parent" edge to the WorkloadType entity by id.
func (m *WorkloadTypeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the WorkloadType entity.
func (m *WorkloadTypeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the WorkloadType entity was cleared.
func (m *WorkloadTypeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *WorkloadTypeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *WorkloadTypeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *WorkloadTypeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the WorkloadType entity by ids.
func (m *WorkloadTypeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the WorkloadType entity.
func (m *WorkloadTypeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the WorkloadType entity was cleared.
func (m *WorkloadTypeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the WorkloadType entity by IDs.
func (m *WorkloadTypeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the WorkloadType entity.
func (m *WorkloadTypeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *WorkloadTypeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *WorkloadTypeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddWorkloadIDs adds the "workloads" edge to the Workload entity by ids.
func (m *WorkloadTypeMutation) AddWorkloadIDs(ids ...int) {
	if m.workloads == nil {
		m.workloads = make(map[int]struct{})
	}
	for i := range ids {
		m.workloads[ids[i]] = struct{}{}
	}
}

// ClearWorkloads clears the "workloads" edge to the Workload entity.
func (m *WorkloadTypeMutation) ClearWorkloads() {
	m.clearedworkloads = true
}

// WorkloadsCleared reports if the "workloads" edge to the Workload entity was cleared.
func (m *WorkloadTypeMutation) WorkloadsCleared() bool {
	return m.clearedworkloads
}

// RemoveWorkloadIDs removes the "workloads" edge to the Workload entity by IDs.
func (m *WorkloadTypeMutation) RemoveWorkloadIDs(ids ...int) {
	if m.removedworkloads == nil {
		m.removedworkloads = make(map[int]struct{})
	}
	for i := range ids {
		m.removedworkloads[ids[i]] = struct{}{}
	}
}

// RemovedWorkloads returns the removed IDs of the "workloads" edge to the Workload entity.
func (m *WorkloadTypeMutation) RemovedWorkloadsIDs() (ids []int) {
	for id := range m.removedworkloads {
		ids = append(ids, id)
	}
	return
}

// WorkloadsIDs returns the "workloads" edge IDs in the mutation.
func (m *WorkloadTypeMutation) WorkloadsIDs() (ids []int) {
	for id := range m.workloads {
		ids = append(ids, id)
	}
	return
}

// ResetWorkloads resets all changes to the "workloads" edge.
func (m *WorkloadTypeMutation) ResetWorkloads() {
	m.workloads = nil
	m.clearedworkloads = false
	m.removedworkloads = nil
}

// Op returns the operation name.
func (m *WorkloadTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkloadType).
func (m *WorkloadTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkloadTypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, workloadtype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, workloadtype.FieldUpdateTime)
	}
	if m.description != nil {
		fields = append(fields, workloadtype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkloadTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workloadtype.FieldCreateTime:
		return m.CreateTime()
	case workloadtype.FieldUpdateTime:
		return m.UpdateTime()
	case workloadtype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkloadTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workloadtype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case workloadtype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case workloadtype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown WorkloadType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workloadtype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case workloadtype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case workloadtype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown WorkloadType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkloadTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkloadTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkloadTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkloadType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkloadTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workloadtype.FieldDescription) {
		fields = append(fields, workloadtype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkloadTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkloadTypeMutation) ClearField(name string) error {
	switch name {
	case workloadtype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkloadType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkloadTypeMutation) ResetField(name string) error {
	switch name {
	case workloadtype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case workloadtype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case workloadtype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown WorkloadType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkloadTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, workloadtype.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, workloadtype.EdgeChildren)
	}
	if m.workloads != nil {
		edges = append(edges, workloadtype.EdgeWorkloads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkloadTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workloadtype.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case workloadtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case workloadtype.EdgeWorkloads:
		ids := make([]ent.Value, 0, len(m.workloads))
		for id := range m.workloads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkloadTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, workloadtype.EdgeChildren)
	}
	if m.removedworkloads != nil {
		edges = append(edges, workloadtype.EdgeWorkloads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkloadTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workloadtype.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case workloadtype.EdgeWorkloads:
		ids := make([]ent.Value, 0, len(m.removedworkloads))
		for id := range m.removedworkloads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkloadTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, workloadtype.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, workloadtype.EdgeChildren)
	}
	if m.clearedworkloads {
		edges = append(edges, workloadtype.EdgeWorkloads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkloadTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case workloadtype.EdgeParent:
		return m.clearedparent
	case workloadtype.EdgeChildren:
		return m.clearedchildren
	case workloadtype.EdgeWorkloads:
		return m.clearedworkloads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkloadTypeMutation) ClearEdge(name string) error {
	switch name {
	case workloadtype.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown WorkloadType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkloadTypeMutation) ResetEdge(name string) error {
	switch name {
	case workloadtype.EdgeParent:
		m.ResetParent()
		return nil
	case workloadtype.EdgeChildren:
		m.ResetChildren()
		return nil
	case workloadtype.EdgeWorkloads:
		m.ResetWorkloads()
		return nil
	}
	return fmt.Errorf("unknown WorkloadType edge %s", name)
}
