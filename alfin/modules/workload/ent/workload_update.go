// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/samlet/petrel/alfin/modules/workload/ent/predicate"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workload"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadfeatureappl"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloaditem"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadstatus"
	"github.com/samlet/petrel/alfin/modules/workload/ent/workloadtype"
)

// WorkloadUpdate is the builder for updating Workload entities.
type WorkloadUpdate struct {
	config
	hooks    []Hook
	mutation *WorkloadMutation
}

// Where adds a new predicate for the WorkloadUpdate builder.
func (wu *WorkloadUpdate) Where(ps ...predicate.Workload) *WorkloadUpdate {
	wu.mutation.predicates = append(wu.mutation.predicates, ps...)
	return wu
}

// SetStatusID sets the "status_id" field.
func (wu *WorkloadUpdate) SetStatusID(i int) *WorkloadUpdate {
	wu.mutation.ResetStatusID()
	wu.mutation.SetStatusID(i)
	return wu
}

// SetNillableStatusID sets the "status_id" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableStatusID(i *int) *WorkloadUpdate {
	if i != nil {
		wu.SetStatusID(*i)
	}
	return wu
}

// AddStatusID adds i to the "status_id" field.
func (wu *WorkloadUpdate) AddStatusID(i int) *WorkloadUpdate {
	wu.mutation.AddStatusID(i)
	return wu
}

// ClearStatusID clears the value of the "status_id" field.
func (wu *WorkloadUpdate) ClearStatusID() *WorkloadUpdate {
	wu.mutation.ClearStatusID()
	return wu
}

// SetWorkloadName sets the "workload_name" field.
func (wu *WorkloadUpdate) SetWorkloadName(s string) *WorkloadUpdate {
	wu.mutation.SetWorkloadName(s)
	return wu
}

// SetNillableWorkloadName sets the "workload_name" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableWorkloadName(s *string) *WorkloadUpdate {
	if s != nil {
		wu.SetWorkloadName(*s)
	}
	return wu
}

// ClearWorkloadName clears the value of the "workload_name" field.
func (wu *WorkloadUpdate) ClearWorkloadName() *WorkloadUpdate {
	wu.mutation.ClearWorkloadName()
	return wu
}

// SetDescription sets the "description" field.
func (wu *WorkloadUpdate) SetDescription(s string) *WorkloadUpdate {
	wu.mutation.SetDescription(s)
	return wu
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableDescription(s *string) *WorkloadUpdate {
	if s != nil {
		wu.SetDescription(*s)
	}
	return wu
}

// ClearDescription clears the value of the "description" field.
func (wu *WorkloadUpdate) ClearDescription() *WorkloadUpdate {
	wu.mutation.ClearDescription()
	return wu
}

// SetLongDescription sets the "long_description" field.
func (wu *WorkloadUpdate) SetLongDescription(s string) *WorkloadUpdate {
	wu.mutation.SetLongDescription(s)
	return wu
}

// SetNillableLongDescription sets the "long_description" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableLongDescription(s *string) *WorkloadUpdate {
	if s != nil {
		wu.SetLongDescription(*s)
	}
	return wu
}

// ClearLongDescription clears the value of the "long_description" field.
func (wu *WorkloadUpdate) ClearLongDescription() *WorkloadUpdate {
	wu.mutation.ClearLongDescription()
	return wu
}

// SetComments sets the "comments" field.
func (wu *WorkloadUpdate) SetComments(s string) *WorkloadUpdate {
	wu.mutation.SetComments(s)
	return wu
}

// SetNillableComments sets the "comments" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableComments(s *string) *WorkloadUpdate {
	if s != nil {
		wu.SetComments(*s)
	}
	return wu
}

// ClearComments clears the value of the "comments" field.
func (wu *WorkloadUpdate) ClearComments() *WorkloadUpdate {
	wu.mutation.ClearComments()
	return wu
}

// SetWorkloadSize sets the "workload_size" field.
func (wu *WorkloadUpdate) SetWorkloadSize(i int) *WorkloadUpdate {
	wu.mutation.ResetWorkloadSize()
	wu.mutation.SetWorkloadSize(i)
	return wu
}

// SetNillableWorkloadSize sets the "workload_size" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableWorkloadSize(i *int) *WorkloadUpdate {
	if i != nil {
		wu.SetWorkloadSize(*i)
	}
	return wu
}

// AddWorkloadSize adds i to the "workload_size" field.
func (wu *WorkloadUpdate) AddWorkloadSize(i int) *WorkloadUpdate {
	wu.mutation.AddWorkloadSize(i)
	return wu
}

// ClearWorkloadSize clears the value of the "workload_size" field.
func (wu *WorkloadUpdate) ClearWorkloadSize() *WorkloadUpdate {
	wu.mutation.ClearWorkloadSize()
	return wu
}

// SetWorkloadDate sets the "workload_date" field.
func (wu *WorkloadUpdate) SetWorkloadDate(t time.Time) *WorkloadUpdate {
	wu.mutation.SetWorkloadDate(t)
	return wu
}

// SetNillableWorkloadDate sets the "workload_date" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableWorkloadDate(t *time.Time) *WorkloadUpdate {
	if t != nil {
		wu.SetWorkloadDate(*t)
	}
	return wu
}

// ClearWorkloadDate clears the value of the "workload_date" field.
func (wu *WorkloadUpdate) ClearWorkloadDate() *WorkloadUpdate {
	wu.mutation.ClearWorkloadDate()
	return wu
}

// SetAnotherDate sets the "another_date" field.
func (wu *WorkloadUpdate) SetAnotherDate(t time.Time) *WorkloadUpdate {
	wu.mutation.SetAnotherDate(t)
	return wu
}

// SetNillableAnotherDate sets the "another_date" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableAnotherDate(t *time.Time) *WorkloadUpdate {
	if t != nil {
		wu.SetAnotherDate(*t)
	}
	return wu
}

// ClearAnotherDate clears the value of the "another_date" field.
func (wu *WorkloadUpdate) ClearAnotherDate() *WorkloadUpdate {
	wu.mutation.ClearAnotherDate()
	return wu
}

// SetAnotherText sets the "another_text" field.
func (wu *WorkloadUpdate) SetAnotherText(s string) *WorkloadUpdate {
	wu.mutation.SetAnotherText(s)
	return wu
}

// SetNillableAnotherText sets the "another_text" field if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableAnotherText(s *string) *WorkloadUpdate {
	if s != nil {
		wu.SetAnotherText(*s)
	}
	return wu
}

// ClearAnotherText clears the value of the "another_text" field.
func (wu *WorkloadUpdate) ClearAnotherText() *WorkloadUpdate {
	wu.mutation.ClearAnotherText()
	return wu
}

// SetWorkloadTypeID sets the "workload_type" edge to the WorkloadType entity by ID.
func (wu *WorkloadUpdate) SetWorkloadTypeID(id int) *WorkloadUpdate {
	wu.mutation.SetWorkloadTypeID(id)
	return wu
}

// SetNillableWorkloadTypeID sets the "workload_type" edge to the WorkloadType entity by ID if the given value is not nil.
func (wu *WorkloadUpdate) SetNillableWorkloadTypeID(id *int) *WorkloadUpdate {
	if id != nil {
		wu = wu.SetWorkloadTypeID(*id)
	}
	return wu
}

// SetWorkloadType sets the "workload_type" edge to the WorkloadType entity.
func (wu *WorkloadUpdate) SetWorkloadType(w *WorkloadType) *WorkloadUpdate {
	return wu.SetWorkloadTypeID(w.ID)
}

// AddWorkloadFeatureApplIDs adds the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by IDs.
func (wu *WorkloadUpdate) AddWorkloadFeatureApplIDs(ids ...int) *WorkloadUpdate {
	wu.mutation.AddWorkloadFeatureApplIDs(ids...)
	return wu
}

// AddWorkloadFeatureAppls adds the "workload_feature_appls" edges to the WorkloadFeatureAppl entity.
func (wu *WorkloadUpdate) AddWorkloadFeatureAppls(w ...*WorkloadFeatureAppl) *WorkloadUpdate {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wu.AddWorkloadFeatureApplIDs(ids...)
}

// AddWorkloadItemIDs adds the "workload_items" edge to the WorkloadItem entity by IDs.
func (wu *WorkloadUpdate) AddWorkloadItemIDs(ids ...int) *WorkloadUpdate {
	wu.mutation.AddWorkloadItemIDs(ids...)
	return wu
}

// AddWorkloadItems adds the "workload_items" edges to the WorkloadItem entity.
func (wu *WorkloadUpdate) AddWorkloadItems(w ...*WorkloadItem) *WorkloadUpdate {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wu.AddWorkloadItemIDs(ids...)
}

// AddWorkloadStatusIDs adds the "workload_statuses" edge to the WorkloadStatus entity by IDs.
func (wu *WorkloadUpdate) AddWorkloadStatusIDs(ids ...int) *WorkloadUpdate {
	wu.mutation.AddWorkloadStatusIDs(ids...)
	return wu
}

// AddWorkloadStatuses adds the "workload_statuses" edges to the WorkloadStatus entity.
func (wu *WorkloadUpdate) AddWorkloadStatuses(w ...*WorkloadStatus) *WorkloadUpdate {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wu.AddWorkloadStatusIDs(ids...)
}

// Mutation returns the WorkloadMutation object of the builder.
func (wu *WorkloadUpdate) Mutation() *WorkloadMutation {
	return wu.mutation
}

// ClearWorkloadType clears the "workload_type" edge to the WorkloadType entity.
func (wu *WorkloadUpdate) ClearWorkloadType() *WorkloadUpdate {
	wu.mutation.ClearWorkloadType()
	return wu
}

// ClearWorkloadFeatureAppls clears all "workload_feature_appls" edges to the WorkloadFeatureAppl entity.
func (wu *WorkloadUpdate) ClearWorkloadFeatureAppls() *WorkloadUpdate {
	wu.mutation.ClearWorkloadFeatureAppls()
	return wu
}

// RemoveWorkloadFeatureApplIDs removes the "workload_feature_appls" edge to WorkloadFeatureAppl entities by IDs.
func (wu *WorkloadUpdate) RemoveWorkloadFeatureApplIDs(ids ...int) *WorkloadUpdate {
	wu.mutation.RemoveWorkloadFeatureApplIDs(ids...)
	return wu
}

// RemoveWorkloadFeatureAppls removes "workload_feature_appls" edges to WorkloadFeatureAppl entities.
func (wu *WorkloadUpdate) RemoveWorkloadFeatureAppls(w ...*WorkloadFeatureAppl) *WorkloadUpdate {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wu.RemoveWorkloadFeatureApplIDs(ids...)
}

// ClearWorkloadItems clears all "workload_items" edges to the WorkloadItem entity.
func (wu *WorkloadUpdate) ClearWorkloadItems() *WorkloadUpdate {
	wu.mutation.ClearWorkloadItems()
	return wu
}

// RemoveWorkloadItemIDs removes the "workload_items" edge to WorkloadItem entities by IDs.
func (wu *WorkloadUpdate) RemoveWorkloadItemIDs(ids ...int) *WorkloadUpdate {
	wu.mutation.RemoveWorkloadItemIDs(ids...)
	return wu
}

// RemoveWorkloadItems removes "workload_items" edges to WorkloadItem entities.
func (wu *WorkloadUpdate) RemoveWorkloadItems(w ...*WorkloadItem) *WorkloadUpdate {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wu.RemoveWorkloadItemIDs(ids...)
}

// ClearWorkloadStatuses clears all "workload_statuses" edges to the WorkloadStatus entity.
func (wu *WorkloadUpdate) ClearWorkloadStatuses() *WorkloadUpdate {
	wu.mutation.ClearWorkloadStatuses()
	return wu
}

// RemoveWorkloadStatusIDs removes the "workload_statuses" edge to WorkloadStatus entities by IDs.
func (wu *WorkloadUpdate) RemoveWorkloadStatusIDs(ids ...int) *WorkloadUpdate {
	wu.mutation.RemoveWorkloadStatusIDs(ids...)
	return wu
}

// RemoveWorkloadStatuses removes "workload_statuses" edges to WorkloadStatus entities.
func (wu *WorkloadUpdate) RemoveWorkloadStatuses(w ...*WorkloadStatus) *WorkloadUpdate {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wu.RemoveWorkloadStatusIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (wu *WorkloadUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	wu.defaults()
	if len(wu.hooks) == 0 {
		affected, err = wu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*WorkloadMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			wu.mutation = mutation
			affected, err = wu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(wu.hooks) - 1; i >= 0; i-- {
			mut = wu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, wu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (wu *WorkloadUpdate) SaveX(ctx context.Context) int {
	affected, err := wu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (wu *WorkloadUpdate) Exec(ctx context.Context) error {
	_, err := wu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (wu *WorkloadUpdate) ExecX(ctx context.Context) {
	if err := wu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (wu *WorkloadUpdate) defaults() {
	if _, ok := wu.mutation.UpdateTime(); !ok {
		v := workload.UpdateDefaultUpdateTime()
		wu.mutation.SetUpdateTime(v)
	}
}

func (wu *WorkloadUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   workload.Table,
			Columns: workload.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: workload.FieldID,
			},
		},
	}
	if ps := wu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := wu.mutation.UpdateTime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: workload.FieldUpdateTime,
		})
	}
	if value, ok := wu.mutation.StatusID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldStatusID,
		})
	}
	if value, ok := wu.mutation.AddedStatusID(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldStatusID,
		})
	}
	if wu.mutation.StatusIDCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: workload.FieldStatusID,
		})
	}
	if value, ok := wu.mutation.WorkloadName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldWorkloadName,
		})
	}
	if wu.mutation.WorkloadNameCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldWorkloadName,
		})
	}
	if value, ok := wu.mutation.Description(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldDescription,
		})
	}
	if wu.mutation.DescriptionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldDescription,
		})
	}
	if value, ok := wu.mutation.LongDescription(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldLongDescription,
		})
	}
	if wu.mutation.LongDescriptionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldLongDescription,
		})
	}
	if value, ok := wu.mutation.Comments(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldComments,
		})
	}
	if wu.mutation.CommentsCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldComments,
		})
	}
	if value, ok := wu.mutation.WorkloadSize(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldWorkloadSize,
		})
	}
	if value, ok := wu.mutation.AddedWorkloadSize(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldWorkloadSize,
		})
	}
	if wu.mutation.WorkloadSizeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: workload.FieldWorkloadSize,
		})
	}
	if value, ok := wu.mutation.WorkloadDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: workload.FieldWorkloadDate,
		})
	}
	if wu.mutation.WorkloadDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: workload.FieldWorkloadDate,
		})
	}
	if value, ok := wu.mutation.AnotherDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: workload.FieldAnotherDate,
		})
	}
	if wu.mutation.AnotherDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: workload.FieldAnotherDate,
		})
	}
	if value, ok := wu.mutation.AnotherText(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldAnotherText,
		})
	}
	if wu.mutation.AnotherTextCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldAnotherText,
		})
	}
	if wu.mutation.WorkloadTypeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   workload.WorkloadTypeTable,
			Columns: []string{workload.WorkloadTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadtype.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.WorkloadTypeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   workload.WorkloadTypeTable,
			Columns: []string{workload.WorkloadTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadtype.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if wu.mutation.WorkloadFeatureApplsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadFeatureApplsTable,
			Columns: []string{workload.WorkloadFeatureApplsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadfeatureappl.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.RemovedWorkloadFeatureApplsIDs(); len(nodes) > 0 && !wu.mutation.WorkloadFeatureApplsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadFeatureApplsTable,
			Columns: []string{workload.WorkloadFeatureApplsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadfeatureappl.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.WorkloadFeatureApplsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadFeatureApplsTable,
			Columns: []string{workload.WorkloadFeatureApplsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadfeatureappl.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if wu.mutation.WorkloadItemsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadItemsTable,
			Columns: []string{workload.WorkloadItemsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloaditem.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.RemovedWorkloadItemsIDs(); len(nodes) > 0 && !wu.mutation.WorkloadItemsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadItemsTable,
			Columns: []string{workload.WorkloadItemsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloaditem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.WorkloadItemsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadItemsTable,
			Columns: []string{workload.WorkloadItemsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloaditem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if wu.mutation.WorkloadStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadStatusesTable,
			Columns: []string{workload.WorkloadStatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadstatus.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.RemovedWorkloadStatusesIDs(); len(nodes) > 0 && !wu.mutation.WorkloadStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadStatusesTable,
			Columns: []string{workload.WorkloadStatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadstatus.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wu.mutation.WorkloadStatusesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadStatusesTable,
			Columns: []string{workload.WorkloadStatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadstatus.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, wu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{workload.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// WorkloadUpdateOne is the builder for updating a single Workload entity.
type WorkloadUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *WorkloadMutation
}

// SetStatusID sets the "status_id" field.
func (wuo *WorkloadUpdateOne) SetStatusID(i int) *WorkloadUpdateOne {
	wuo.mutation.ResetStatusID()
	wuo.mutation.SetStatusID(i)
	return wuo
}

// SetNillableStatusID sets the "status_id" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableStatusID(i *int) *WorkloadUpdateOne {
	if i != nil {
		wuo.SetStatusID(*i)
	}
	return wuo
}

// AddStatusID adds i to the "status_id" field.
func (wuo *WorkloadUpdateOne) AddStatusID(i int) *WorkloadUpdateOne {
	wuo.mutation.AddStatusID(i)
	return wuo
}

// ClearStatusID clears the value of the "status_id" field.
func (wuo *WorkloadUpdateOne) ClearStatusID() *WorkloadUpdateOne {
	wuo.mutation.ClearStatusID()
	return wuo
}

// SetWorkloadName sets the "workload_name" field.
func (wuo *WorkloadUpdateOne) SetWorkloadName(s string) *WorkloadUpdateOne {
	wuo.mutation.SetWorkloadName(s)
	return wuo
}

// SetNillableWorkloadName sets the "workload_name" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableWorkloadName(s *string) *WorkloadUpdateOne {
	if s != nil {
		wuo.SetWorkloadName(*s)
	}
	return wuo
}

// ClearWorkloadName clears the value of the "workload_name" field.
func (wuo *WorkloadUpdateOne) ClearWorkloadName() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadName()
	return wuo
}

// SetDescription sets the "description" field.
func (wuo *WorkloadUpdateOne) SetDescription(s string) *WorkloadUpdateOne {
	wuo.mutation.SetDescription(s)
	return wuo
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableDescription(s *string) *WorkloadUpdateOne {
	if s != nil {
		wuo.SetDescription(*s)
	}
	return wuo
}

// ClearDescription clears the value of the "description" field.
func (wuo *WorkloadUpdateOne) ClearDescription() *WorkloadUpdateOne {
	wuo.mutation.ClearDescription()
	return wuo
}

// SetLongDescription sets the "long_description" field.
func (wuo *WorkloadUpdateOne) SetLongDescription(s string) *WorkloadUpdateOne {
	wuo.mutation.SetLongDescription(s)
	return wuo
}

// SetNillableLongDescription sets the "long_description" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableLongDescription(s *string) *WorkloadUpdateOne {
	if s != nil {
		wuo.SetLongDescription(*s)
	}
	return wuo
}

// ClearLongDescription clears the value of the "long_description" field.
func (wuo *WorkloadUpdateOne) ClearLongDescription() *WorkloadUpdateOne {
	wuo.mutation.ClearLongDescription()
	return wuo
}

// SetComments sets the "comments" field.
func (wuo *WorkloadUpdateOne) SetComments(s string) *WorkloadUpdateOne {
	wuo.mutation.SetComments(s)
	return wuo
}

// SetNillableComments sets the "comments" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableComments(s *string) *WorkloadUpdateOne {
	if s != nil {
		wuo.SetComments(*s)
	}
	return wuo
}

// ClearComments clears the value of the "comments" field.
func (wuo *WorkloadUpdateOne) ClearComments() *WorkloadUpdateOne {
	wuo.mutation.ClearComments()
	return wuo
}

// SetWorkloadSize sets the "workload_size" field.
func (wuo *WorkloadUpdateOne) SetWorkloadSize(i int) *WorkloadUpdateOne {
	wuo.mutation.ResetWorkloadSize()
	wuo.mutation.SetWorkloadSize(i)
	return wuo
}

// SetNillableWorkloadSize sets the "workload_size" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableWorkloadSize(i *int) *WorkloadUpdateOne {
	if i != nil {
		wuo.SetWorkloadSize(*i)
	}
	return wuo
}

// AddWorkloadSize adds i to the "workload_size" field.
func (wuo *WorkloadUpdateOne) AddWorkloadSize(i int) *WorkloadUpdateOne {
	wuo.mutation.AddWorkloadSize(i)
	return wuo
}

// ClearWorkloadSize clears the value of the "workload_size" field.
func (wuo *WorkloadUpdateOne) ClearWorkloadSize() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadSize()
	return wuo
}

// SetWorkloadDate sets the "workload_date" field.
func (wuo *WorkloadUpdateOne) SetWorkloadDate(t time.Time) *WorkloadUpdateOne {
	wuo.mutation.SetWorkloadDate(t)
	return wuo
}

// SetNillableWorkloadDate sets the "workload_date" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableWorkloadDate(t *time.Time) *WorkloadUpdateOne {
	if t != nil {
		wuo.SetWorkloadDate(*t)
	}
	return wuo
}

// ClearWorkloadDate clears the value of the "workload_date" field.
func (wuo *WorkloadUpdateOne) ClearWorkloadDate() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadDate()
	return wuo
}

// SetAnotherDate sets the "another_date" field.
func (wuo *WorkloadUpdateOne) SetAnotherDate(t time.Time) *WorkloadUpdateOne {
	wuo.mutation.SetAnotherDate(t)
	return wuo
}

// SetNillableAnotherDate sets the "another_date" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableAnotherDate(t *time.Time) *WorkloadUpdateOne {
	if t != nil {
		wuo.SetAnotherDate(*t)
	}
	return wuo
}

// ClearAnotherDate clears the value of the "another_date" field.
func (wuo *WorkloadUpdateOne) ClearAnotherDate() *WorkloadUpdateOne {
	wuo.mutation.ClearAnotherDate()
	return wuo
}

// SetAnotherText sets the "another_text" field.
func (wuo *WorkloadUpdateOne) SetAnotherText(s string) *WorkloadUpdateOne {
	wuo.mutation.SetAnotherText(s)
	return wuo
}

// SetNillableAnotherText sets the "another_text" field if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableAnotherText(s *string) *WorkloadUpdateOne {
	if s != nil {
		wuo.SetAnotherText(*s)
	}
	return wuo
}

// ClearAnotherText clears the value of the "another_text" field.
func (wuo *WorkloadUpdateOne) ClearAnotherText() *WorkloadUpdateOne {
	wuo.mutation.ClearAnotherText()
	return wuo
}

// SetWorkloadTypeID sets the "workload_type" edge to the WorkloadType entity by ID.
func (wuo *WorkloadUpdateOne) SetWorkloadTypeID(id int) *WorkloadUpdateOne {
	wuo.mutation.SetWorkloadTypeID(id)
	return wuo
}

// SetNillableWorkloadTypeID sets the "workload_type" edge to the WorkloadType entity by ID if the given value is not nil.
func (wuo *WorkloadUpdateOne) SetNillableWorkloadTypeID(id *int) *WorkloadUpdateOne {
	if id != nil {
		wuo = wuo.SetWorkloadTypeID(*id)
	}
	return wuo
}

// SetWorkloadType sets the "workload_type" edge to the WorkloadType entity.
func (wuo *WorkloadUpdateOne) SetWorkloadType(w *WorkloadType) *WorkloadUpdateOne {
	return wuo.SetWorkloadTypeID(w.ID)
}

// AddWorkloadFeatureApplIDs adds the "workload_feature_appls" edge to the WorkloadFeatureAppl entity by IDs.
func (wuo *WorkloadUpdateOne) AddWorkloadFeatureApplIDs(ids ...int) *WorkloadUpdateOne {
	wuo.mutation.AddWorkloadFeatureApplIDs(ids...)
	return wuo
}

// AddWorkloadFeatureAppls adds the "workload_feature_appls" edges to the WorkloadFeatureAppl entity.
func (wuo *WorkloadUpdateOne) AddWorkloadFeatureAppls(w ...*WorkloadFeatureAppl) *WorkloadUpdateOne {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wuo.AddWorkloadFeatureApplIDs(ids...)
}

// AddWorkloadItemIDs adds the "workload_items" edge to the WorkloadItem entity by IDs.
func (wuo *WorkloadUpdateOne) AddWorkloadItemIDs(ids ...int) *WorkloadUpdateOne {
	wuo.mutation.AddWorkloadItemIDs(ids...)
	return wuo
}

// AddWorkloadItems adds the "workload_items" edges to the WorkloadItem entity.
func (wuo *WorkloadUpdateOne) AddWorkloadItems(w ...*WorkloadItem) *WorkloadUpdateOne {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wuo.AddWorkloadItemIDs(ids...)
}

// AddWorkloadStatusIDs adds the "workload_statuses" edge to the WorkloadStatus entity by IDs.
func (wuo *WorkloadUpdateOne) AddWorkloadStatusIDs(ids ...int) *WorkloadUpdateOne {
	wuo.mutation.AddWorkloadStatusIDs(ids...)
	return wuo
}

// AddWorkloadStatuses adds the "workload_statuses" edges to the WorkloadStatus entity.
func (wuo *WorkloadUpdateOne) AddWorkloadStatuses(w ...*WorkloadStatus) *WorkloadUpdateOne {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wuo.AddWorkloadStatusIDs(ids...)
}

// Mutation returns the WorkloadMutation object of the builder.
func (wuo *WorkloadUpdateOne) Mutation() *WorkloadMutation {
	return wuo.mutation
}

// ClearWorkloadType clears the "workload_type" edge to the WorkloadType entity.
func (wuo *WorkloadUpdateOne) ClearWorkloadType() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadType()
	return wuo
}

// ClearWorkloadFeatureAppls clears all "workload_feature_appls" edges to the WorkloadFeatureAppl entity.
func (wuo *WorkloadUpdateOne) ClearWorkloadFeatureAppls() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadFeatureAppls()
	return wuo
}

// RemoveWorkloadFeatureApplIDs removes the "workload_feature_appls" edge to WorkloadFeatureAppl entities by IDs.
func (wuo *WorkloadUpdateOne) RemoveWorkloadFeatureApplIDs(ids ...int) *WorkloadUpdateOne {
	wuo.mutation.RemoveWorkloadFeatureApplIDs(ids...)
	return wuo
}

// RemoveWorkloadFeatureAppls removes "workload_feature_appls" edges to WorkloadFeatureAppl entities.
func (wuo *WorkloadUpdateOne) RemoveWorkloadFeatureAppls(w ...*WorkloadFeatureAppl) *WorkloadUpdateOne {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wuo.RemoveWorkloadFeatureApplIDs(ids...)
}

// ClearWorkloadItems clears all "workload_items" edges to the WorkloadItem entity.
func (wuo *WorkloadUpdateOne) ClearWorkloadItems() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadItems()
	return wuo
}

// RemoveWorkloadItemIDs removes the "workload_items" edge to WorkloadItem entities by IDs.
func (wuo *WorkloadUpdateOne) RemoveWorkloadItemIDs(ids ...int) *WorkloadUpdateOne {
	wuo.mutation.RemoveWorkloadItemIDs(ids...)
	return wuo
}

// RemoveWorkloadItems removes "workload_items" edges to WorkloadItem entities.
func (wuo *WorkloadUpdateOne) RemoveWorkloadItems(w ...*WorkloadItem) *WorkloadUpdateOne {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wuo.RemoveWorkloadItemIDs(ids...)
}

// ClearWorkloadStatuses clears all "workload_statuses" edges to the WorkloadStatus entity.
func (wuo *WorkloadUpdateOne) ClearWorkloadStatuses() *WorkloadUpdateOne {
	wuo.mutation.ClearWorkloadStatuses()
	return wuo
}

// RemoveWorkloadStatusIDs removes the "workload_statuses" edge to WorkloadStatus entities by IDs.
func (wuo *WorkloadUpdateOne) RemoveWorkloadStatusIDs(ids ...int) *WorkloadUpdateOne {
	wuo.mutation.RemoveWorkloadStatusIDs(ids...)
	return wuo
}

// RemoveWorkloadStatuses removes "workload_statuses" edges to WorkloadStatus entities.
func (wuo *WorkloadUpdateOne) RemoveWorkloadStatuses(w ...*WorkloadStatus) *WorkloadUpdateOne {
	ids := make([]int, len(w))
	for i := range w {
		ids[i] = w[i].ID
	}
	return wuo.RemoveWorkloadStatusIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (wuo *WorkloadUpdateOne) Select(field string, fields ...string) *WorkloadUpdateOne {
	wuo.fields = append([]string{field}, fields...)
	return wuo
}

// Save executes the query and returns the updated Workload entity.
func (wuo *WorkloadUpdateOne) Save(ctx context.Context) (*Workload, error) {
	var (
		err  error
		node *Workload
	)
	wuo.defaults()
	if len(wuo.hooks) == 0 {
		node, err = wuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*WorkloadMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			wuo.mutation = mutation
			node, err = wuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(wuo.hooks) - 1; i >= 0; i-- {
			mut = wuo.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, wuo.mutation); err != nil {
			return nil, err
		}
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (wuo *WorkloadUpdateOne) SaveX(ctx context.Context) *Workload {
	node, err := wuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (wuo *WorkloadUpdateOne) Exec(ctx context.Context) error {
	_, err := wuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (wuo *WorkloadUpdateOne) ExecX(ctx context.Context) {
	if err := wuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (wuo *WorkloadUpdateOne) defaults() {
	if _, ok := wuo.mutation.UpdateTime(); !ok {
		v := workload.UpdateDefaultUpdateTime()
		wuo.mutation.SetUpdateTime(v)
	}
}

func (wuo *WorkloadUpdateOne) sqlSave(ctx context.Context) (_node *Workload, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   workload.Table,
			Columns: workload.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: workload.FieldID,
			},
		},
	}
	id, ok := wuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "ID", err: fmt.Errorf("missing Workload.ID for update")}
	}
	_spec.Node.ID.Value = id
	if fields := wuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, workload.FieldID)
		for _, f := range fields {
			if !workload.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != workload.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := wuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := wuo.mutation.UpdateTime(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: workload.FieldUpdateTime,
		})
	}
	if value, ok := wuo.mutation.StatusID(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldStatusID,
		})
	}
	if value, ok := wuo.mutation.AddedStatusID(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldStatusID,
		})
	}
	if wuo.mutation.StatusIDCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: workload.FieldStatusID,
		})
	}
	if value, ok := wuo.mutation.WorkloadName(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldWorkloadName,
		})
	}
	if wuo.mutation.WorkloadNameCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldWorkloadName,
		})
	}
	if value, ok := wuo.mutation.Description(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldDescription,
		})
	}
	if wuo.mutation.DescriptionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldDescription,
		})
	}
	if value, ok := wuo.mutation.LongDescription(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldLongDescription,
		})
	}
	if wuo.mutation.LongDescriptionCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldLongDescription,
		})
	}
	if value, ok := wuo.mutation.Comments(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldComments,
		})
	}
	if wuo.mutation.CommentsCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldComments,
		})
	}
	if value, ok := wuo.mutation.WorkloadSize(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldWorkloadSize,
		})
	}
	if value, ok := wuo.mutation.AddedWorkloadSize(); ok {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  value,
			Column: workload.FieldWorkloadSize,
		})
	}
	if wuo.mutation.WorkloadSizeCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: workload.FieldWorkloadSize,
		})
	}
	if value, ok := wuo.mutation.WorkloadDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: workload.FieldWorkloadDate,
		})
	}
	if wuo.mutation.WorkloadDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: workload.FieldWorkloadDate,
		})
	}
	if value, ok := wuo.mutation.AnotherDate(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  value,
			Column: workload.FieldAnotherDate,
		})
	}
	if wuo.mutation.AnotherDateCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: workload.FieldAnotherDate,
		})
	}
	if value, ok := wuo.mutation.AnotherText(); ok {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  value,
			Column: workload.FieldAnotherText,
		})
	}
	if wuo.mutation.AnotherTextCleared() {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Column: workload.FieldAnotherText,
		})
	}
	if wuo.mutation.WorkloadTypeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   workload.WorkloadTypeTable,
			Columns: []string{workload.WorkloadTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadtype.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.WorkloadTypeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   workload.WorkloadTypeTable,
			Columns: []string{workload.WorkloadTypeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadtype.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if wuo.mutation.WorkloadFeatureApplsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadFeatureApplsTable,
			Columns: []string{workload.WorkloadFeatureApplsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadfeatureappl.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.RemovedWorkloadFeatureApplsIDs(); len(nodes) > 0 && !wuo.mutation.WorkloadFeatureApplsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadFeatureApplsTable,
			Columns: []string{workload.WorkloadFeatureApplsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadfeatureappl.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.WorkloadFeatureApplsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadFeatureApplsTable,
			Columns: []string{workload.WorkloadFeatureApplsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadfeatureappl.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if wuo.mutation.WorkloadItemsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadItemsTable,
			Columns: []string{workload.WorkloadItemsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloaditem.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.RemovedWorkloadItemsIDs(); len(nodes) > 0 && !wuo.mutation.WorkloadItemsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadItemsTable,
			Columns: []string{workload.WorkloadItemsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloaditem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.WorkloadItemsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadItemsTable,
			Columns: []string{workload.WorkloadItemsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloaditem.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if wuo.mutation.WorkloadStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadStatusesTable,
			Columns: []string{workload.WorkloadStatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadstatus.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.RemovedWorkloadStatusesIDs(); len(nodes) > 0 && !wuo.mutation.WorkloadStatusesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadStatusesTable,
			Columns: []string{workload.WorkloadStatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadstatus.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := wuo.mutation.WorkloadStatusesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   workload.WorkloadStatusesTable,
			Columns: []string{workload.WorkloadStatusesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: workloadstatus.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Workload{config: wuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, wuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{workload.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return _node, nil
}
